(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  This mixin provides an 'ajax' method that can be used to perform ajax requests that
  respect Discourse paths and the run loop.
**/

var _trackView = false;

Discourse.Ajax = Em.Mixin.create({

  viewTrackingRequired: function() {
    _trackView = true;
  },

  /**
    Our own $.ajax method. Makes sure the .then method executes in an Ember runloop
    for performance reasons. Also automatically adjusts the URL to support installs
    in subfolders.

    @method ajax
  **/
  ajax: function() {
    var url, args;
    var ajax;

    if (arguments.length === 1) {
      if (typeof arguments[0] === "string") {
        url = arguments[0];
        args = {};
      } else {
        args = arguments[0];
        url = args.url;
        delete args.url;
      }
    } else if (arguments.length === 2) {
      url = arguments[0];
      args = arguments[1];
    }

    if (args.success || args.error) {
      throw "Discourse.ajax should use promises";
    }

    var performAjax = function(resolve, reject) {

      args.headers = args.headers || {};

      if (_trackView && (!args.type || args.type === "GET")) {
        _trackView = false;
        // DON'T CHANGE: rack is prepending "HTTP_" in the header's name
        args.headers['Discourse-Track-View'] = "true";
      }

      args.success = function(data, textStatus, xhr) {
        if (xhr.getResponseHeader('Discourse-Readonly')) {
          Ember.run(function() {
            Discourse.Site.currentProp('isReadOnly', true);
          });
        }

        Ember.run(null, resolve, data);
      };

      args.error = function(xhr, textStatus, errorThrown) {
        // note: for bad CSRF we don't loop an extra request right away.
        //  this allows us to eliminate the possibility of having a loop.
        if (xhr.status === 403 && xhr.responseText === "['BAD CSRF']") {
          Discourse.Session.current().set('csrfToken', null);
        }

        // If it's a parsererror, don't reject
        if (xhr.status === 200) return args.success(xhr);

        // Fill in some extra info
        xhr.jqTextStatus = textStatus;
        xhr.requestedUrl = url;

        Ember.run(null, reject, {
          jqXHR: xhr,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
      };

      // We default to JSON on GET. If we don't, sometimes if the server doesn't return the proper header
      // it will not be parsed as an object.
      if (!args.type) args.type = 'GET';
      if (!args.dataType && args.type.toUpperCase() === 'GET') args.dataType = 'json';

      if (args.dataType === "script") {
        args.headers['Discourse-Script'] = true;
      }

      if (args.type === 'GET' && args.cache !== true) {
        args.cache = false;
      }

      ajax = $.ajax(Discourse.getURL(url), args);
    };

    var promise;

    // For cached pages we strip out CSRF tokens, need to round trip to server prior to sending the
    //  request (bypass for GET, not needed)
    if(args.type && args.type.toUpperCase() !== 'GET' && !Discourse.Session.currentProp('csrfToken')){
      promise = new Ember.RSVP.Promise(function(resolve, reject){
        ajax = $.ajax(Discourse.getURL('/session/csrf'), {cache: false})
           .success(function(result){
              Discourse.Session.currentProp('csrfToken', result.csrf);
              performAjax(resolve, reject);
           });
      });
    } else {
      promise = new Ember.RSVP.Promise(performAjax);
    }

    promise.abort = function(){
      if (ajax) {
        ajax.abort();
      }
    };

    return promise;
  }

});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/*global Favcount:true*/

var DiscourseResolver = require('discourse/ember/resolver').default;

// Allow us to import Ember
define('ember', ['exports'], function(__exports__) {
  __exports__.default = Ember;
});

window.Discourse = Ember.Application.createWithMixins(Discourse.Ajax, {
  rootElement: '#main',
  _docTitle: document.title,

  getURL: function(url) {
    if (!url) return url;

    // if it's a non relative URL, return it.
    if (url !== '/' && !/^\/[^\/]/.test(url)) return url;

    if (url.indexOf(Discourse.BaseUri) !== -1) return url;
    if (url[0] !== "/") url = "/" + url;

    return Discourse.BaseUri + url;
  },

  getURLWithCDN: function(url) {
    url = this.getURL(url);
    // only relative urls
    if (Discourse.CDN && /^\/[^\/]/.test(url)) {
      url = Discourse.CDN + url;
    } else if (Discourse.S3CDN) {
      url = url.replace(Discourse.S3BaseUrl, Discourse.S3CDN);
    }
    return url;
  },

  Resolver: DiscourseResolver,

  _titleChanged: function() {
    var title = this.get('_docTitle') || Discourse.SiteSettings.title;

    // if we change this we can trigger changes on document.title
    // only set if changed.
    if($('title').text() !== title) {
      $('title').text(title);
    }

    var notifyCount = this.get('notifyCount');
    if (notifyCount > 0 && !Discourse.User.currentProp('dynamic_favicon')) {
      title = "(" + notifyCount + ") " + title;
    }

    document.title = title;
  }.observes('_docTitle', 'hasFocus', 'notifyCount'),

  faviconChanged: function() {
    if(Discourse.User.currentProp('dynamic_favicon')) {
      var url = Discourse.SiteSettings.favicon_url;
      if (/^http/.test(url)) {
        url = Discourse.getURL("/favicon/proxied?" + encodeURIComponent(url));
      }
      new Favcount(url).set(
        this.get('notifyCount')
      );
    }
  }.observes('notifyCount'),

  // The classes of buttons to show on a post
  postButtons: function() {
    return Discourse.SiteSettings.post_menu.split("|").map(function(i) {
      return i.replace(/\+/, '').capitalize();
    });
  }.property(),

  notifyTitle: function(count) {
    this.set('notifyCount', count);
  },

  notifyBackgroundCountIncrement: function() {
    if (!this.get('hasFocus')) {
      this.set('backgroundNotify', true);
      this.set('notifyCount', (this.get('notifyCount') || 0) + 1);
    }
  },

  resetBackgroundNotifyCount: function() {
    if (this.get('hasFocus') && this.get('backgroundNotify')) {
      this.set('notifyCount', 0);
    }
    this.set('backgroundNotify', false);
  }.observes('hasFocus'),

  authenticationComplete: function(options) {
    // TODO, how to dispatch this to the controller without the container?
    var loginController = Discourse.__container__.lookup('controller:login');
    return loginController.authenticationComplete(options);
  },

  /**
    Start up the Discourse application by running all the initializers we've defined.

    @method start
  **/
  start: function() {

    $('noscript').remove();

    Ember.keys(requirejs._eak_seen).forEach(function(key) {
      if (/\/pre\-initializers\//.test(key)) {
        var module = require(key, null, null, true);
        if (!module) { throw new Error(key + ' must export an initializer.'); }
        Discourse.initializer(module.default);
      }
    });

    Ember.keys(requirejs._eak_seen).forEach(function(key) {
      if (/\/initializers\//.test(key)) {
        var module = require(key, null, null, true);
        if (!module) { throw new Error(key + ' must export an initializer.'); }

        var init = module.default;
        var oldInitialize = init.initialize;
        init.initialize = function(app) {
          oldInitialize.call(this, app.container, Discourse);
        };

        Discourse.instanceInitializer(init);
      }
    });

  },

  requiresRefresh: function(){
    var desired = Discourse.get("desiredAssetVersion");
    return desired && Discourse.get("currentAssetVersion") !== desired;
  }.property("currentAssetVersion", "desiredAssetVersion"),


  assetVersion: Ember.computed({
    get: function() {
      return this.get("currentAssetVersion");
    },
    set: function(key, val) {
      if(val) {
        if (this.get("currentAssetVersion")) {
          this.set("desiredAssetVersion", val);
        } else {
          this.set("currentAssetVersion", val);
        }
      }
      return this.get("currentAssetVersion");
    }
  })
});

function proxyDep(propName, moduleFunc, msg) {
  if (Discourse.hasOwnProperty(propName)) { return; }
  Object.defineProperty(Discourse, propName, {
    get: function() {
      msg = msg || "import the module";
      Ember.warn("DEPRECATION: `Discourse." + propName + "` is deprecated, " + msg + ".");
      return moduleFunc();
    }
  });
}

proxyDep('computed', function() { return require('discourse/lib/computed'); });
proxyDep('Formatter', function() { return require('discourse/lib/formatter'); });
proxyDep('PageTracker', function() { return require('discourse/lib/page-tracker').default; });
proxyDep('URL', function() { return require('discourse/lib/url').default; });
proxyDep('Quote', function() { return require('discourse/lib/quote').default; });
proxyDep('debounce', function() { return require('discourse/lib/debounce').default; });
proxyDep('View', function() { return Ember.View; }, "Use `Ember.View` instead");


// IIFE Wrapped Content Ends

 })(this);define("ember-addons/utils/extract-value", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = extractValue;

    function extractValue(desc) {
      return desc.value || typeof desc.initializer === 'function' && desc.initializer();
    }
  });define("ember-addons/utils/handle-descriptor", 
  ["ember","./extract-value","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";


    __exports__["default"] = handleDescriptor;

    var Ember = __dependency1__["default"];
    var extractValue = __dependency2__["default"];

    var computed = Ember.computed;
    var get = Ember.get;

    function handleDescriptor(target, key, desc) {
      var params = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

      return {
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        writeable: desc.writeable,
        initializer: function () {
          var computedDescriptor = undefined;

          if (desc.writable) {
            var val = extractValue(desc);
            if (typeof val === 'object') {
              var value = {};
              if (val.get) {
                value.get = callUserSuppliedGet(params, val.get);
              }
              if (val.set) {
                value.set = callUserSuppliedSet(params, val.set);
              }
              computedDescriptor = value;
            } else {
              computedDescriptor = callUserSuppliedGet(params, val);
            }
          } else {
            throw new Error('ember-computed-decorators does not support using getters and setters');
          }

          return computed.apply(null, params.concat(computedDescriptor));
        }
      };
    }

    function niceAttr(attr) {
      var parts = attr.split('.');
      var i = undefined;

      for (i = 0; i < parts.length; i++) {
        if (parts[i] === '@each' || parts[i] === '[]' || parts[i].indexOf('{') !== -1) {
          break;
        }
      }

      return parts.slice(0, i).join('.');
    }

    function callUserSuppliedGet(params, func) {
      params = params.map(niceAttr);
      return function () {
        var _this = this;

        var paramValues = params.map(function (p) {
          return get(_this, p);
        });

        return func.apply(this, paramValues);
      };
    }

    function callUserSuppliedSet(params, func) {
      params = params.map(niceAttr);
      return function (key, value) {
        var _this2 = this;

        var paramValues = params.map(function (p) {
          return get(_this2, p);
        });
        paramValues.unshift(value);

        return func.apply(this, paramValues);
      };
    }
  });define("ember-addons/utils/is-descriptor", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = isDescriptor;

    function isDescriptor(item) {
      return item && typeof item === 'object' && 'writable' in item && 'enumerable' in item && 'configurable' in item;
    }
  });define("ember-addons/decorator-alias", 
  ["./utils/extract-value","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = decoratorAlias;
    var extractValue = __dependency1__["default"];
    function decoratorAlias(fn, errorMessage) {
      return function () {
        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        // determine if user called as @computed('blah', 'blah') or @computed
        if (params.length === 0) {
          throw new Error(errorMessage);
        } else {
          return function (target, key, desc) {
            return {
              enumerable: desc.enumerable,
              configurable: desc.configurable,
              writable: desc.writable,
              initializer: function () {
                var value = extractValue(desc);
                return fn.apply(null, params.concat(value));
              }
            };
          };
        }
      };
    }
  });define("ember-addons/macro-alias", 
  ["./utils/is-descriptor","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = macroAlias;

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

    var isDescriptor = __dependency1__["default"];

    function handleDescriptor(target, property, desc, fn) {
      var params = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];

      return {
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        writable: desc.writable,
        initializer: function () {
          return fn.apply(undefined, _toConsumableArray(params));
        }
      };
    }
    function macroAlias(fn) {
      return function () {
        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        if (isDescriptor(params[params.length - 1])) {
          return handleDescriptor.apply(undefined, params.concat([fn]));
        } else {
          return function (target, property, desc) {
            return handleDescriptor(target, property, desc, fn, params);
          };
        }
      };
    }
  });define("ember-addons/ember-computed-decorators", 
  ["./utils/handle-descriptor","./utils/is-descriptor","./utils/extract-value","./decorator-alias","./macro-alias","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var _slice = Array.prototype.slice;

    __exports__["default"] = computedDecorator;

    __exports__.readOnly = readOnly;
    var handleDescriptor = __dependency1__["default"];
    var isDescriptor = __dependency2__["default"];
    var extractValue = __dependency3__["default"];

    var decoratorAlias = __dependency4__["default"];

    var macroAlias = __dependency5__["default"];

    function computedDecorator() {
      for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }

      // determine if user called as @computed('blah', 'blah') or @computed
      if (isDescriptor(params[params.length - 1])) {
        return handleDescriptor.apply(undefined, arguments);
      } else {
        return function () /* target, key, desc */{
          return handleDescriptor.apply(undefined, _slice.call(arguments).concat([params]));
        };
      }
    }

    function readOnly(target, name, desc) {
      return {
        writable: false,
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        initializer: function () {
          var value = extractValue(desc);
          return value.readOnly();
        }
      };
    }

    var on = decoratorAlias(Ember.on, 'Can not `on` without event names');
    __exports__.on = on;
    var observes = decoratorAlias(Ember.observer, 'Can not `observe` without property names');__exports__.observes = observes;
    var alias = macroAlias(Ember.computed.alias);
    __exports__.alias = alias;
    var and = macroAlias(Ember.computed.and);
    __exports__.and = and;
    var bool = macroAlias(Ember.computed.bool);
    __exports__.bool = bool;
    var collect = macroAlias(Ember.computed.collect);
    __exports__.collect = collect;
    var empty = macroAlias(Ember.computed.empty);
    __exports__.empty = empty;
    var equal = macroAlias(Ember.computed.equal);
    __exports__.equal = equal;
    var filter = macroAlias(Ember.computed.filter);
    __exports__.filter = filter;
    var filterBy = macroAlias(Ember.computed.filterBy);
    __exports__.filterBy = filterBy;
    var gt = macroAlias(Ember.computed.gt);
    __exports__.gt = gt;
    var gte = macroAlias(Ember.computed.gte);
    __exports__.gte = gte;
    var lt = macroAlias(Ember.computed.lt);
    __exports__.lt = lt;
    var lte = macroAlias(Ember.computed.lte);
    __exports__.lte = lte;
    var map = macroAlias(Ember.computed.map);
    __exports__.map = map;
    var mapBy = macroAlias(Ember.computed.mapBy);
    __exports__.mapBy = mapBy;
    var match = macroAlias(Ember.computed.match);
    __exports__.match = match;
    var max = macroAlias(Ember.computed.max);
    __exports__.max = max;
    var min = macroAlias(Ember.computed.min);
    __exports__.min = min;
    var none = macroAlias(Ember.computed.none);
    __exports__.none = none;
    var not = macroAlias(Ember.computed.not);
    __exports__.not = not;
    var notEmpty = macroAlias(Ember.computed.notEmpty);
    __exports__.notEmpty = notEmpty;
    var oneWay = macroAlias(Ember.computed.oneWay);
    __exports__.oneWay = oneWay;
    var or = macroAlias(Ember.computed.or);
    __exports__.or = or;
    var readOnly = macroAlias(Ember.computed.readOnly);
    __exports__.readOnly = readOnly;
    var reads = macroAlias(Ember.computed.reads);
    __exports__.reads = reads;
    var setDiff = macroAlias(Ember.computed.setDiff);
    __exports__.setDiff = setDiff;
    var sort = macroAlias(Ember.computed.sort);
    __exports__.sort = sort;
    var sum = macroAlias(Ember.computed.sum);
    __exports__.sum = sum;
    var union = macroAlias(Ember.computed.union);
    __exports__.union = union;
    var uniq = macroAlias(Ember.computed.uniq);
    __exports__.uniq = uniq;
  });define("discourse/lib/hash", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.hashString = hashString;
    /*eslint no-bitwise:0 */

    // Note: before changing this be aware the same algo is used server side for avatars.

    function hashString(str) {
      var hash = 0;
      for (var i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }
  });define("discourse/lib/stale-result", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var StaleResult = function () {
      this.hasResults = false;
    };

    StaleResult.prototype.setResults = function (results) {
      if (results) {
        this.results = results;
        this.hasResults = true;
      }
    };

    __exports__["default"] = StaleResult;
  });define("discourse/lib/load-script", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = loadScript;
    /* global assetPath */

    var _loaded = {};
    var _loading = {};

    function loadWithTag(path, cb) {
      var head = document.getElementsByTagName('head')[0];

      var s = document.createElement('script');
      s.src = path;
      if (Ember.Test) {
        Ember.Test.pendingAjaxRequests++;
      }
      head.appendChild(s);

      s.onload = s.onreadystatechange = function (_, abort) {
        if (Ember.Test) {
          Ember.Test.pendingAjaxRequests--;
        }
        if (abort || !s.readyState || s.readyState === "loaded" || s.readyState === "complete") {
          s = s.onload = s.onreadystatechange = null;
          if (!abort) {
            Ember.run(null, cb);
          }
        }
      };
    }
    function loadScript(url, opts) {
      opts = opts || {};

      return new Ember.RSVP.Promise(function (resolve) {
        url = Discourse.getURL(assetPath && assetPath(url) || url);

        // If we already loaded this url
        if (_loaded[url]) {
          return resolve();
        }
        if (_loading[url]) {
          return _loading[url].then(resolve);
        }

        var done;
        _loading[url] = new Ember.RSVP.Promise(function (_done) {
          done = _done;
        });

        _loading[url].then(function () {
          delete _loading[url];
        });

        var cb = function () {
          _loaded[url] = true;
          done();
          resolve();
        };

        var cdnUrl = url;

        // Scripts should always load from CDN
        if (Discourse.CDN && url[0] === "/" && url[1] !== "/") {
          cdnUrl = Discourse.CDN.replace(/\/$/, "") + url;
        }

        // Some javascript depends on the path of where it is loaded (ace editor)
        // to dynamically load more JS. In that case, add the `scriptTag: true`
        // option.
        if (opts.scriptTag) {
          loadWithTag(cdnUrl, cb);
        } else {
          Discourse.ajax({ url: cdnUrl, dataType: "script", cache: true }).then(cb);
        }
      });
    }
  });define("discourse/lib/notification-levels", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      WATCHING: 3,
      TRACKING: 2,
      REGULAR: 1,
      MUTED: 0
    };
  });define("discourse/lib/app-events", 
  ["exports"],
  function(__exports__) {
    "use strict";

    var id = 1;
    function newKey() {
      return "_view_app_event_" + id++;
    }

    function createViewListener(eventName, cb) {
      var extension = {};
      extension[newKey()] = (function () {
        this.appEvents.on(eventName, this, cb);
      }).on('didInsertElement');

      extension[newKey()] = (function () {
        this.appEvents.off(eventName, this, cb);
      }).on('willDestroyElement');

      return extension;
    }

    function listenForViewEvent(viewClass, eventName, cb) {
      viewClass.reopen(createViewListener(eventName, cb));
    }

    __exports__.listenForViewEvent = listenForViewEvent;
    __exports__.createViewListener = createViewListener;
    __exports__["default"] = Ember.Object.extend(Ember.Evented);
  });define("discourse/lib/url", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /*global LockOn:true*/

    var _jumpScheduled = false;
    var rewrites = [];

    var DiscourseURL = Ember.Object.createWithMixins({

      // Used for matching a topic
      TOPIC_REGEXP: /\/t\/([^\/]+)\/(\d+)\/?(\d+)?/,

      isJumpScheduled: function () {
        return _jumpScheduled;
      },

      /**
        Jumps to a particular post in the stream
      **/
      jumpToPost: function (postNumber, opts) {
        var holderId = '.post-cloak[data-post-number=' + postNumber + ']';
        var offset = function () {

          var $header = $('header');
          var $title = $('#topic-title');
          var windowHeight = $(window).height() - $title.height();
          var expectedOffset = $title.height() - $header.find('.contents').height() + windowHeight / 5;

          return $header.outerHeight(true) + (expectedOffset < 0 ? 0 : expectedOffset);
        };

        Em.run.schedule('afterRender', function () {
          if (postNumber === 1) {
            $(window).scrollTop(0);
            return;
          }

          var lockon = new LockOn(holderId, { offsetCalculator: offset });
          var holder = $(holderId);

          if (holder.length > 0 && opts && opts.skipIfOnScreen) {

            // if we are on screen skip
            var elementTop = lockon.elementTop(),
                scrollTop = $(window).scrollTop(),
                windowHeight = $(window).height() - offset(),
                height = holder.height();

            if (elementTop > scrollTop && elementTop + height < scrollTop + windowHeight) {
              return;
            }
          }

          lockon.lock();
        });
      },

      /**
        Browser aware replaceState. Will only be invoked if the browser supports it.
         @method replaceState
        @param {String} path The path we are replacing our history state with.
      **/
      replaceState: function (path) {
        if (window.history && window.history.pushState && window.history.replaceState && !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]|WebApps\/.+CFNetwork)/) && window.location.pathname !== path) {

          // Always use replaceState in the next runloop to prevent weird routes changing
          // while URLs are loading. For example, while a topic loads it sets `currentPost`
          // which triggers a replaceState even though the topic hasn't fully loaded yet!
          Em.run.next(function () {
            var location = DiscourseURL.get('router.location');
            if (location && location.replaceURL) {
              location.replaceURL(path);
            }
          });
        }
      },

      // Scroll to the same page, different anchor
      scrollToId: function (id) {
        if (Em.isEmpty(id)) {
          return;
        }

        _jumpScheduled = true;
        Em.run.schedule('afterRender', function () {
          var $elem = $(id);
          if ($elem.length === 0) {
            $elem = $("[name='" + id.replace('#', '') + "']");
          }
          if ($elem.length > 0) {
            $('html,body').scrollTop($elem.offset().top - $('header').height() - 15);
            _jumpScheduled = false;
          }
        });
      },

      /**
        Our custom routeTo method is used to intelligently overwrite default routing
        behavior.
         It contains the logic necessary to route within a topic using replaceState to
        keep the history intact.
      **/
      routeTo: function (path, opts) {
        if (Em.isEmpty(path)) {
          return;
        }

        if (Discourse.get('requiresRefresh')) {
          document.location.href = Discourse.getURL(path);
          return;
        }

        // Protocol relative URLs
        if (path.indexOf('//') === 0) {
          document.location = path;
          return;
        }

        // Scroll to the same page, different anchor
        if (path.indexOf('#') === 0) {
          this.scrollToId(path);
          this.replaceState(path);
          return;
        }

        var oldPath = window.location.pathname;
        path = path.replace(/(https?\:)?\/\/[^\/]+/, '');

        // handle prefixes
        if (path.match(/^\//)) {
          var rootURL = Discourse.BaseUri === undefined ? "/" : Discourse.BaseUri;
          rootURL = rootURL.replace(/\/$/, '');
          path = path.replace(rootURL, '');
        }

        // Rewrite /my/* urls
        if (path.indexOf('/my/') === 0) {
          var currentUser = Discourse.User.current();
          if (currentUser) {
            path = path.replace('/my/', '/users/' + currentUser.get('username_lower') + "/");
          } else {
            document.location.href = "/404";
            return;
          }
        }

        rewrites.forEach(function (rw) {
          path = path.replace(rw.regexp, rw.replacement);
        });

        if (this.navigatedToPost(oldPath, path)) {
          return;
        }
        // Schedule a DOM cleanup event
        Em.run.scheduleOnce('afterRender', Discourse.Route, 'cleanDOM');

        // TODO: Extract into rules we can inject into the URL handler
        if (this.navigatedToHome(oldPath, path)) {
          return;
        }

        if (oldPath === path) {
          // If navigating to the same path send an app event. Views can watch it
          // and tell their controllers to refresh
          this.appEvents.trigger('url:refresh');
        }

        return this.handleURL(path, opts);
      },

      rewrite: function (regexp, replacement) {
        rewrites.push({ regexp: regexp, replacement: replacement });
      },

      redirectTo: function (url) {
        window.location = Discourse.getURL(url);
      },

      /**
       * Determines whether a URL is internal or not
       *
       * @method isInternal
       * @param {String} url
      **/
      isInternal: function (url) {
        if (url && url.length) {
          if (url.indexOf('#') === 0) {
            return true;
          }
          if (url.indexOf('/') === 0) {
            return true;
          }
          if (url.indexOf(this.origin()) === 0) {
            return true;
          }
          if (url.replace(/^http/, 'https').indexOf(this.origin()) === 0) {
            return true;
          }
          if (url.replace(/^https/, 'http').indexOf(this.origin()) === 0) {
            return true;
          }
        }
        return false;
      },

      /**
        @private
         If the URL is in the topic form, /t/something/:topic_id/:post_number
        then we want to apply some special logic. If the post_number changes within the
        same topic, use replaceState and instruct our controller to load more posts.
         @method navigatedToPost
        @param {String} oldPath the previous path we were on
        @param {String} path the path we're navigating to
      **/
      navigatedToPost: function (oldPath, path) {
        var _this = this;

        var newMatches = this.TOPIC_REGEXP.exec(path);
        var newTopicId = newMatches ? newMatches[2] : null;

        if (newTopicId) {
          var oldMatches = this.TOPIC_REGEXP.exec(oldPath);
          var oldTopicId = oldMatches ? oldMatches[2] : null;

          // If the topic_id is the same
          if (oldTopicId === newTopicId) {
            var _ret = (function () {
              DiscourseURL.replaceState(path);

              var container = Discourse.__container__;
              var topicController = container.lookup('controller:topic');
              var opts = {};
              var postStream = topicController.get('model.postStream');

              if (newMatches[3]) {
                opts.nearPost = newMatches[3];
              }
              if (path.match(/last$/)) {
                opts.nearPost = topicController.get('model.highest_post_number');
              }
              var closest = opts.nearPost || 1;

              postStream.refresh(opts).then(function () {
                topicController.setProperties({
                  'model.currentPost': closest,
                  enteredAt: new Date().getTime().toString()
                });

                var closestPost = postStream.closestPostForPostNumber(closest);
                var progress = postStream.progressIndexOfPost(closestPost);
                var progressController = container.lookup('controller:topic-progress');

                progressController.set('progressPosition', progress);
                _this.appEvents.trigger('post:highlight', closest);
              }).then(function () {
                DiscourseURL.jumpToPost(closest, { skipIfOnScreen: true });
              });

              // Abort routing, we have replaced our state.
              return {
                v: true
              };
            })();

            if (typeof _ret === 'object') return _ret.v;
          }
        }

        return false;
      },

      /**
        @private
         Handle the custom case of routing to the root path from itself.
         @param {String} oldPath the previous path we were on
        @param {String} path the path we're navigating to
      **/
      navigatedToHome: function (oldPath, path) {
        var homepage = Discourse.Utilities.defaultHomepage();

        if (window.history && window.history.pushState && (path === "/" || path === "/" + homepage) && (oldPath === "/" || oldPath === "/" + homepage)) {
          this.appEvents.trigger('url:refresh');
          return true;
        }

        return false;
      },

      // This has been extracted so it can be tested.
      origin: function () {
        return window.location.origin + (Discourse.BaseUri === "/" ? '' : Discourse.BaseUri);
      },

      /**
        @private
         Get a handle on the application's router. Note that currently it uses `__container__` which is not
        advised but there is no other way to access the router.
         @property router
      **/
      router: (function () {
        return Discourse.__container__.lookup('router:main');
      }).property().volatile(),

      // Get a controller. Note that currently it uses `__container__` which is not
      // advised but there is no other way to access the router.
      controllerFor: function (name) {
        return Discourse.__container__.lookup('controller:' + name);
      },

      /**
        Be wary of looking up the router. In this case, we have links in our
        HTML, say form compiled markdown posts, that need to be routed.
      **/
      handleURL: function (path, opts) {
        opts = opts || {};

        var router = this.get('router');

        if (opts.replaceURL) {
          this.replaceState(path);
        } else {
          router.router.updateURL(path);
        }

        var split = path.split('#');
        var elementId = undefined;

        if (split.length === 2) {
          path = split[0];
          elementId = split[1];
        }

        var transition = router.handleURL(path);
        transition._discourse_intercepted = true;
        transition.promise.then(function () {
          if (elementId) {

            _jumpScheduled = true;
            Em.run.next('afterRender', function () {
              var offset = $('#' + elementId).offset();
              if (offset && offset.top) {
                $('html, body').scrollTop(offset.top - $('header').height() - 10);
                _jumpScheduled = false;
              }
            });
          }
        });
      }

    });

    __exports__["default"] = DiscourseURL;
  });define("discourse/lib/debounce", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Debounce a Javascript function. This means if it's called many times in a time limit it
      should only be executed once (at the end of the limit counted from the last call made).
      Original function will be called with the context and arguments from the last call made.
    **/

    __exports__["default"] = function (func, wait) {
      var self = undefined,
          args = undefined;
      var later = function () {
        func.apply(self, args);
      };

      return function () {
        self = this;
        args = arguments;

        Ember.run.debounce(null, later, wait);
      };
    }
  });define("discourse/lib/quote", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {

      REGEXP: /\[quote=([^\]]*)\]((?:[\s\S](?!\[quote=[^\]]*\]))*?)\[\/quote\]/im,

      // Build the BBCode quote around the selected text
      build: function (post, contents, opts) {
        var contents_hashed, result, sansQuotes, stripped, stripped_hashed, tmp;
        var full = opts && opts["full"];
        var raw = opts && opts["raw"];

        if (!post) {
          return "";
        }

        if (!contents) contents = "";

        sansQuotes = contents.replace(this.REGEXP, '').trim();
        if (sansQuotes.length === 0) {
          return "";
        }

        // Escape the content of the quote
        sansQuotes = sansQuotes.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        result = "[quote=\"" + post.get('username') + ", post:" + post.get('post_number') + ", topic:" + post.get('topic_id');

        /* Strip the HTML from cooked */
        tmp = document.createElement('div');
        tmp.innerHTML = post.get('cooked');
        stripped = tmp.textContent || tmp.innerText || "";

        /*
          Let's remove any non alphanumeric characters as a kind of hash. Yes it's
          not accurate but it should work almost every time we need it to. It would be unlikely
          that the user would quote another post that matches in exactly this way.
        */
        stripped_hashed = stripped.replace(/[^a-zA-Z0-9]/g, '');
        contents_hashed = contents.replace(/[^a-zA-Z0-9]/g, '');

        /* If the quote is the full message, attribute it as such */
        if (full || stripped_hashed === contents_hashed) result += ", full:true";
        result += "\"]\n" + (raw ? contents : sansQuotes) + "\n[/quote]\n\n";

        return result;
      }

    };
  });define("discourse/lib/key-value-store", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // A simple key value store that uses LocalStorage
    var safeLocalStorage = undefined;

    try {
      safeLocalStorage = localStorage;
      if (localStorage["disableLocalStorage"] === "true") {
        safeLocalStorage = null;
      } else {
        // makes sure we can write to the local storage
        safeLocalStorage["safeLocalStorage"] = true;
      }
    } catch (e) {
      // cookies disabled, we don't care
      safeLocalStorage = null;
    }

    var KeyValueStore = function (ctx) {
      this.context = ctx;
    };

    KeyValueStore.prototype = {
      abandonLocal: function () {
        if (!safeLocalStorage) {
          return;
        }

        var i = safeLocalStorage.length - 1;
        while (i >= 0) {
          var k = safeLocalStorage.key(i);
          if (k.substring(0, this.context.length) === this.context) {
            safeLocalStorage.removeItem(k);
          }
          i--;
        }
        return true;
      },

      remove: function (key) {
        if (!safeLocalStorage) {
          return;
        }
        return safeLocalStorage.removeItem(this.context + key);
      },

      set: function (opts) {
        if (!safeLocalStorage) {
          return false;
        }
        safeLocalStorage[this.context + opts.key] = opts.value;
      },

      setObject: function (opts) {
        this.set({ key: opts.key, value: JSON.stringify(opts.value) });
      },

      get: function (key) {
        if (!safeLocalStorage) {
          return null;
        }
        return safeLocalStorage[this.context + key];
      },

      getInt: function (key, def) {
        if (!def) {
          def = 0;
        }
        if (!safeLocalStorage) {
          return def;
        }
        var result = parseInt(this.get(key));
        if (!isFinite(result)) {
          return def;
        }
        return result;
      },

      getObject: function (key) {
        if (!safeLocalStorage) {
          return null;
        }
        try {
          return JSON.parse(safeLocalStorage[this.context + key]);
        } catch (e) {}
      }
    };

    // API compatibility with `localStorage`
    KeyValueStore.prototype.getItem = KeyValueStore.prototype.get;
    KeyValueStore.prototype.removeItem = KeyValueStore.prototype.remove;
    KeyValueStore.prototype.setItem = function (key, value) {
      this.set({ key: key, value: value });
    };

    __exports__["default"] = KeyValueStore;
  });define("discourse/helpers/i18n", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('i18n', function (key, params) {
      return I18n.t(key, params);
    });

    registerUnbound('replace-emoji', function (text) {
      return new Handlebars.SafeString(Discourse.Emoji.unescape(text));
    });
  });define("discourse/helpers/fa-icon", 
  ["discourse/helpers/register-unbound","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    function iconClasses(icon, params) {
      var classes = "fa fa-" + icon;
      if (params.modifier) {
        classes += " fa-" + params.modifier;
      }
      if (params['class']) {
        classes += ' ' + params['class'];
      }
      return classes;
    }

    function iconHTML(icon, params) {
      params = params || {};

      var html = "<i class='" + iconClasses(icon, params) + "'";
      if (params.label) {
        html += " aria-hidden='true'";
      }
      html += "></i>";
      if (params.label) {
        html += "<span class='sr-only'>" + I18n.t(params.label) + "</span>";
      }
      return html;
    }

    Ember.Handlebars.helper('fa-icon-bound', function (value, options) {
      return new Handlebars.SafeString(iconHTML(value, options));
    });

    registerUnbound('fa-icon', function (icon, params) {
      return new Handlebars.SafeString(iconHTML(icon, params));
    });

    __exports__.iconHTML = iconHTML;
  });define("discourse/helpers/register-unbound", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = registerUnbound;
    var get = Discourse.EmberCompatHandlebars.get;

    function resolveParams(ctx, options) {
      var params = {};
      var hash = options.hash;

      if (hash) {
        if (options.hashTypes) {
          Ember.keys(hash).forEach(function (k) {
            var type = options.hashTypes[k];
            if (type === "STRING") {
              params[k] = hash[k];
            } else if (type === "ID") {
              params[k] = get(ctx, hash[k], options);
            }
          });
        } else {
          params = hash;
        }
      }
      return params;
    }
    function registerUnbound(name, fn) {
      var func = function (property, options) {
        if (options.types && options.types[0] === "ID") {
          property = get(this, property, options);
        }

        return fn.call(this, property, resolveParams(this, options));
      };

      Handlebars.registerHelper(name, func);
      Ember.Handlebars.registerHelper(name, func);
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

// keep IIF for simpler testing

// EmberCompatHandlebars is a mechanism for quickly rendering templates which is Ember aware
// templates are highly compatible with Ember so you don't need to worry about calling "get"
// and computed properties function, additionally it uses stringParams like Ember does

(function(){

  // compat with ie8 in case this gets picked up elsewhere
  var objectCreate = Object.create || function(parent) {
    function F() {}
    F.prototype = parent;
    return new F();
  };


  var RawHandlebars = Handlebars.create();

  RawHandlebars.helper = function() {};
  RawHandlebars.helpers = objectCreate(Handlebars.helpers);

  RawHandlebars.helpers.get = function(context, options){
    var firstContext =  options.contexts[0];
    var val = firstContext[context];

    if (val && val.isDescriptor) { return Em.get(firstContext, context); }
    val = val === undefined ? Em.get(firstContext, context): val;
    return val;
  };

  // adds compatability so this works with stringParams
  var stringCompatHelper = function(fn){

    var old = RawHandlebars.helpers[fn];
    RawHandlebars.helpers[fn] = function(context,options){
      return old.apply(this, [
          RawHandlebars.helpers.get(context,options),
          options
      ]);
    };
  };

  // #each .. in support
  RawHandlebars.registerHelper('each', function(localName,inKeyword,contextName,options){
    var list = Em.get(this, contextName);
    var output = [];
    var innerContext = Object.create(this);
    for (var i=0; i<list.length; i++) {
      innerContext[localName] = list[i];
      output.push(options.fn(innerContext));
    }
    return output.join('');
  });

  stringCompatHelper("if");
  stringCompatHelper("unless");
  stringCompatHelper("with");


  if (Handlebars.Compiler) {
    RawHandlebars.Compiler = function() {};
    RawHandlebars.Compiler.prototype = objectCreate(Handlebars.Compiler.prototype);
    RawHandlebars.Compiler.prototype.compiler = RawHandlebars.Compiler;

    RawHandlebars.JavaScriptCompiler = function() {};

    RawHandlebars.JavaScriptCompiler.prototype = objectCreate(Handlebars.JavaScriptCompiler.prototype);
    RawHandlebars.JavaScriptCompiler.prototype.compiler = RawHandlebars.JavaScriptCompiler;
    RawHandlebars.JavaScriptCompiler.prototype.namespace = "Discourse.EmberCompatHandlebars";


    RawHandlebars.Compiler.prototype.mustache = function(mustache) {
      if ( !(mustache.params.length || mustache.hash)) {

        var id = new Handlebars.AST.IdNode([{ part: 'get' }]);
        mustache = new Handlebars.AST.MustacheNode([id].concat([mustache.id]), mustache.hash, mustache.escaped);
      }

      return Handlebars.Compiler.prototype.mustache.call(this, mustache);
    };

    RawHandlebars.precompile = function(value, asObject) {
      var ast = Handlebars.parse(value);

      var options = {
        knownHelpers: {
          get: true
        },
        data: true,
        stringParams: true
      };

      asObject = asObject === undefined ? true : asObject;

      var environment = new RawHandlebars.Compiler().compile(ast, options);
      return new RawHandlebars.JavaScriptCompiler().compile(environment, options, undefined, asObject);
    };


    RawHandlebars.compile = function(string) {
      var ast = Handlebars.parse(string);
      // this forces us to rewrite helpers
      var options = {  data: true, stringParams: true };
      var environment = new RawHandlebars.Compiler().compile(ast, options);
      var templateSpec = new RawHandlebars.JavaScriptCompiler().compile(environment, options, undefined, true);

      var template = RawHandlebars.template(templateSpec);
      template.isMethod = false;

      return template;
    };
  }

  RawHandlebars.get = function(ctx, property, options){
    if (options.types && options.data.view) {
      return options.data.view.getStream(property).value();
    } else {
      return Ember.get(ctx, property);
    }
  };

  Discourse.EmberCompatHandlebars = RawHandlebars;

})();


// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/computed", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.propertyEqual = propertyEqual;
    __exports__.propertyNotEqual = propertyNotEqual;
    __exports__.propertyGreaterThan = propertyGreaterThan;
    __exports__.propertyLessThan = propertyLessThan;
    __exports__.i18n = i18n;
    __exports__.fmt = fmt;
    __exports__.url = url;
    __exports__.endWith = endWith;
    __exports__.setting = setting;
    /**
      Returns whether two properties are equal to each other.

      @method propertyEqual
      @params {String} p1 the first property
      @params {String} p2 the second property
      @return {Function} computedProperty function
    **/

    function propertyEqual(p1, p2) {
      return Em.computed(function () {
        return this.get(p1) === this.get(p2);
      }).property(p1, p2);
    }

    /**
      Returns whether two properties are not equal to each other.

      @method propertyNotEqual
      @params {String} p1 the first property
      @params {String} p2 the second property
      @return {Function} computedProperty function
    **/

    function propertyNotEqual(p1, p2) {
      return Em.computed(function () {
        return this.get(p1) !== this.get(p2);
      }).property(p1, p2);
    }

    function propertyGreaterThan(p1, p2) {
      return Ember.computed(function () {
        return this.get(p1) > this.get(p2);
      }).property(p1, p2);
    }

    function propertyLessThan(p1, p2) {
      return Ember.computed(function () {
        return this.get(p1) < this.get(p2);
      }).property(p1, p2);
    }

    /**
      Returns i18n version of a string based on a property.

      @method i18n
      @params {String} properties* to format
      @params {String} format the i18n format string
      @return {Function} computedProperty function
    **/

    function i18n() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return I18n.t(format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        })));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Uses an Ember String `fmt` call to format a string. See:
      http://emberjs.com/api/classes/Em.String.html#method_fmt

      @method fmt
      @params {String} properties* to format
      @params {String} format the format string
      @return {Function} computedProperty function
    **/

    function fmt() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        }));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Creates a URL using Discourse.getURL. It takes a fmt string just like
      fmt does.

      @method url
      @params {String} properties* to format
      @params {String} format the format string for the URL
      @return {Function} computedProperty function returning a URL
    **/

    function url() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return Discourse.getURL(format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        })));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Returns whether properties end with a string

      @method endWith
      @params {String} properties* to check
      @params {String} substring the substring
      @return {Function} computedProperty function
    **/

    function endWith() {
      var args = Array.prototype.slice.call(arguments, 0);
      var substring = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return _.all(args.map(function (a) {
          return self.get(a);
        }), function (s) {
          var position = s.length - substring.length,
              lastIndex = s.lastIndexOf(substring);
          return lastIndex !== -1 && lastIndex === position;
        });
      });
      return computed.property.apply(computed, args);
    }

    /**
      Creates a property from a SiteSetting. In the future the plan is for them to
      be able to update when changed.

      @method setting
      @param {String} name of site setting
    **/

    function setting(name) {
      return Em.computed(function () {
        return Discourse.SiteSettings[name];
      }).property();
    }
  });define("discourse/lib/formatter", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.shortDate = shortDate;
    __exports__.toTitleCase = toTitleCase;
    __exports__.longDate = longDate;
    __exports__.longDateNoYear = longDateNoYear;
    __exports__.updateRelativeAge = updateRelativeAge;
    __exports__.autoUpdatingRelativeAge = autoUpdatingRelativeAge;
    __exports__.relativeAge = relativeAge;
    __exports__.number = number;
    /* global BreakString:true */

    /*
    * memoize.js
    * by @philogb and @addyosmani
    * with further optimizations by @mathias
    * and @DmitryBaranovsk
    * perf tests: http://bit.ly/q3zpG3
    * Released under an MIT license.
    *
    * modified with cap by Sam
    */

    function cappedMemoize(fn, max) {
      fn.maxMemoize = max;
      fn.memoizeLength = 0;

      return function () {
        var args = Array.prototype.slice.call(arguments);
        var hash = "";
        var i = args.length;
        var currentArg = null;
        while (i--) {
          currentArg = args[i];
          hash += currentArg === new Object(currentArg) ? JSON.stringify(currentArg) : currentArg;
          if (!fn.memoize) {
            fn.memoize = {};
          }
        }
        if (hash in fn.memoize) {
          return fn.memoize[hash];
        } else {
          fn.memoizeLength++;
          if (fn.memoizeLength > max) {
            fn.memoizeLength = 0;
            fn.memoize = {};
          }
          var result = fn.apply(this, args);
          fn.memoize[hash] = result;
          return result;
        }
      };
    }

    var breakUp = cappedMemoize(function (str, hint) {
      return new BreakString(str).break(hint);
    }, 100);
    __exports__.breakUp = breakUp;

    function shortDate(date) {
      return moment(date).format(I18n.t("dates.medium.date_year"));
    }

    function shortDateNoYear(date) {
      return moment(date).format(I18n.t("dates.tiny.date_month"));
    }

    function tinyDateYear(date) {
      return moment(date).format(I18n.t("dates.tiny.date_year"));
    }

    // http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
    // TODO: locale support ?

    function toTitleCase(str) {
      return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    }

    function longDate(dt) {
      if (!dt) return;
      return moment(dt).longDate();
    }

    // suppress year, if current year

    function longDateNoYear(dt) {
      if (!dt) return;

      if (new Date().getFullYear() !== dt.getFullYear()) {
        return moment(dt).format(I18n.t("dates.long_date_with_year"));
      } else {
        return moment(dt).format(I18n.t("dates.long_date_without_year"));
      }
    }

    function updateRelativeAge(elems) {
      // jQuery .each
      elems.each(function () {
        var $this = $(this);
        $this.html(relativeAge(new Date($this.data('time')), { format: $this.data('format'), wrapInSpan: false }));
      });
    }

    function autoUpdatingRelativeAge(date, options) {
      if (!date) return "";
      if (+date === +new Date(0)) return "";

      options = options || {};
      var format = options.format || "tiny";

      var append = "";
      if (format === 'medium') {
        append = " date";
        if (options.leaveAgo) {
          format = 'medium-with-ago';
        }
        options.wrapInSpan = false;
      }

      var relAge = relativeAge(date, options);

      if (format === 'tiny' && relativeAgeTinyShowsYear(relAge)) {
        append += " with-year";
      }

      if (options.title) {
        append += "' title='" + longDate(date);
      }

      return "<span class='relative-date" + append + "' data-time='" + date.getTime() + "' data-format='" + format + "'>" + relAge + "</span>";
    }

    function relativeAgeTiny(date) {
      var format = "tiny";
      var distance = Math.round((new Date() - date) / 1000);
      var distanceInMinutes = Math.round(distance / 60.0);

      var formatted = undefined;
      var t = function (key, opts) {
        return I18n.t("dates." + format + "." + key, opts);
      };

      switch (true) {

        case distanceInMinutes < 1:
          formatted = t("less_than_x_minutes", { count: 1 });
          break;
        case distanceInMinutes >= 1 && distanceInMinutes <= 44:
          formatted = t("x_minutes", { count: distanceInMinutes });
          break;
        case distanceInMinutes >= 45 && distanceInMinutes <= 89:
          formatted = t("about_x_hours", { count: 1 });
          break;
        case distanceInMinutes >= 90 && distanceInMinutes <= 1409:
          formatted = t("about_x_hours", { count: Math.round(distanceInMinutes / 60.0) });
          break;
        case Discourse.SiteSettings.relative_date_duration === 0 && distanceInMinutes <= 525599:
          formatted = shortDateNoYear(date);
          break;
        case distanceInMinutes >= 1410 && distanceInMinutes <= 2519:
          formatted = t("x_days", { count: 1 });
          break;
        case distanceInMinutes >= 2520 && distanceInMinutes <= (Discourse.SiteSettings.relative_date_duration || 14) * 1440:
          formatted = t("x_days", { count: Math.round(distanceInMinutes / 1440.0) });
          break;
        default:
          if (date.getFullYear() === new Date().getFullYear()) {
            formatted = shortDateNoYear(date);
          } else {
            formatted = tinyDateYear(date);
          }
          break;
      }

      return formatted;
    }

    /*
     * Returns true if the given tiny date string includes the year.
     * Useful for checking if the string isn't so tiny.
     */
    function relativeAgeTinyShowsYear(relativeAgeString) {
      return relativeAgeString.match(/'[\d]{2}$/);
    }

    function relativeAgeMediumSpan(distance, leaveAgo) {
      var formatted = undefined;
      var distanceInMinutes = Math.round(distance / 60.0);

      var t = function (key, opts) {
        return I18n.t("dates.medium" + (leaveAgo ? "_with_ago" : "") + "." + key, opts);
      };

      switch (true) {
        case distanceInMinutes >= 1 && distanceInMinutes <= 55:
          formatted = t("x_minutes", { count: distanceInMinutes });
          break;
        case distanceInMinutes >= 56 && distanceInMinutes <= 89:
          formatted = t("x_hours", { count: 1 });
          break;
        case distanceInMinutes >= 90 && distanceInMinutes <= 1409:
          formatted = t("x_hours", { count: Math.round(distanceInMinutes / 60.0) });
          break;
        case distanceInMinutes >= 1410 && distanceInMinutes <= 2159:
          formatted = t("x_days", { count: 1 });
          break;
        case distanceInMinutes >= 2160:
          formatted = t("x_days", { count: Math.round((distanceInMinutes - 720.0) / 1440.0) });
          break;
      }
      return formatted || '&mdash';
    }

    function relativeAgeMedium(date, options) {
      var wrapInSpan = options.wrapInSpan !== false;
      var leaveAgo = options.leaveAgo;
      var distance = Math.round((new Date() - date) / 1000);

      if (!date) {
        return "&mdash;";
      }

      var fullReadable = longDate(date);
      var fiveDaysAgo = 432000;
      var oneMinuteAgo = 60;

      var displayDate = "";
      if (distance < oneMinuteAgo) {
        displayDate = I18n.t("now");
      } else if (distance > fiveDaysAgo) {
        if (new Date().getFullYear() !== date.getFullYear()) {
          displayDate = shortDate(date);
        } else {
          displayDate = shortDateNoYear(date);
        }
      } else {
        displayDate = relativeAgeMediumSpan(distance, leaveAgo);
      }
      if (wrapInSpan) {
        return "<span class='date' title='" + fullReadable + "'>" + displayDate + "</span>";
      } else {
        return displayDate;
      }
    }

    // mostly lifted from rails with a few amendments

    function relativeAge(date, options) {
      options = options || {};
      var format = options.format || "tiny";

      if (format === "tiny") {
        return relativeAgeTiny(date, options);
      } else if (format === "medium") {
        return relativeAgeMedium(date, options);
      } else if (format === 'medium-with-ago') {
        return relativeAgeMedium(date, _.extend(options, { format: 'medium', leaveAgo: true }));
      }

      return "UNKNOWN FORMAT";
    }

    function number(val) {
      var formattedNumber = undefined;

      val = parseInt(val, 10);
      if (isNaN(val)) val = 0;

      if (val > 999999) {
        formattedNumber = I18n.toNumber(val / 1000000, { precision: 1 });
        return I18n.t("number.short.millions", { number: formattedNumber });
      }
      if (val > 999) {
        formattedNumber = I18n.toNumber(val / 1000, { precision: 1 });
        return I18n.t("number.short.thousands", { number: formattedNumber });
      }
      return val.toString();
    }
  });define("discourse/lib/eyeline", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Track visible elemnts on the screen.
    var Eyeline = function Eyeline(selector) {
      this.selector = selector;
    };

    Eyeline.prototype.update = function () {
      if (Ember.testing) {
        return;
      }

      var docViewTop = $(window).scrollTop(),
          windowHeight = $(window).height(),
          docViewBottom = docViewTop + windowHeight,
          $elements = $(this.selector),
          bottomOffset = $elements.last().offset(),
          self = this;

      var atBottom = false;
      if (bottomOffset) {
        atBottom = bottomOffset.top <= docViewBottom && bottomOffset.top >= docViewTop;
      }

      return $elements.each(function (i, elem) {
        var $elem = $(elem),
            elemTop = $elem.offset().top,
            elemBottom = elemTop + $elem.height();

        var markSeen = false;

        // Make sure the element is visible
        if (!$elem.is(':visible')) return true;

        // It's seen if...
        // ...the element is vertically within the top and botom
        if (elemTop <= docViewBottom && elemTop >= docViewTop) markSeen = true;

        // ...the element top is above the top and the bottom is below the bottom (large elements)
        if (elemTop <= docViewTop && elemBottom >= docViewBottom) markSeen = true;

        // ...we're at the bottom and the bottom of the element is visible (large bottom elements)
        if (atBottom && elemBottom >= docViewTop) markSeen = true;

        if (!markSeen) return true;

        // If you hit the bottom we mark all the elements as seen. Otherwise, just the first one
        if (!atBottom) {
          self.trigger('saw', { detail: $elem });
          if (i === 0) {
            self.trigger('sawTop', { detail: $elem });
          }
          return false;
        }
        if (i === 0) {
          self.trigger('sawTop', { detail: $elem });
        }
        if (i === $elements.length - 1) {
          return self.trigger('sawBottom', { detail: $elem });
        }
      });
    };

    //  Call this when we know aren't loading any more elements. Mark the rest as seen
    Eyeline.prototype.flushRest = function () {
      if (Ember.testing) {
        return;
      }
      var self = this;
      $(this.selector).each(function (i, elem) {
        return self.trigger('saw', { detail: $(elem) });
      });
    };

    RSVP.EventTarget.mixin(Eyeline.prototype);

    __exports__["default"] = Eyeline;
  });define("discourse/mixins/scrolling", 
  ["discourse/lib/debounce","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];

    /**
      This object provides the DOM methods we need for our Mixin to bind to scrolling
      methods in the browser. By removing them from the Mixin we can test them
      easier.
    **/
    var ScrollingDOMMethods = {
      bindOnScroll: function (onScrollMethod, name) {
        name = name || 'default';
        $(document).bind('touchmove.discourse-' + name, onScrollMethod);
        $(window).bind('scroll.discourse-' + name, onScrollMethod);
      },

      unbindOnScroll: function (name) {
        name = name || 'default';
        $(window).unbind('scroll.discourse-' + name);
        $(document).unbind('touchmove.discourse-' + name);
      },

      screenNotFull: function () {
        return $(window).height() > $("#main").height();
      }
    };

    var Scrolling = Ember.Mixin.create({

      // Begin watching for scroll events. By default they will be called at max every 100ms.
      // call with {debounce: N} for a diff time
      bindScrolling: function (opts) {
        var _this = this;

        opts = opts || { debounce: 100 };

        // So we can not call the scrolled event while transitioning
        var router = Discourse.__container__.lookup('router:main').router;

        var onScrollMethod = function () {
          if (router.activeTransition) {
            return;
          }
          return Ember.run.scheduleOnce('afterRender', _this, 'scrolled');
        };

        if (opts.debounce) {
          onScrollMethod = debounce(onScrollMethod, opts.debounce);
        }

        ScrollingDOMMethods.bindOnScroll(onScrollMethod, opts.name);
      },

      screenNotFull: function () {
        return ScrollingDOMMethods.screenNotFull();
      },

      unbindScrolling: function (name) {
        ScrollingDOMMethods.unbindOnScroll(name);
      }
    });

    __exports__.ScrollingDOMMethods = ScrollingDOMMethods;
    __exports__["default"] = Scrolling;
  });

Discourse.Scrolling = require('discourse/mixins/scrolling').default;
define("discourse/models/model", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Model = Ember.Object.extend();

    Model.reopenClass({
      extractByKey: function (collection, klass) {
        var retval = {};
        if (Ember.isEmpty(collection)) {
          return retval;
        }

        collection.forEach(function (item) {
          retval[item.id] = klass.create(item);
        });
        return retval;
      }
    });

    __exports__["default"] = Model;
  });

Discourse.Model = require('discourse/models/model').default;
define("discourse/models/rest", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var RestModel = Ember.Object.extend({
      isNew: Ember.computed.equal('__state', 'new'),
      isCreated: Ember.computed.equal('__state', 'created'),
      isSaving: false,

      afterUpdate: Ember.K,

      update: function (props) {
        var _this = this;

        if (this.get('isSaving')) {
          return Ember.RSVP.reject();
        }

        props = props || this.updateProperties();

        var type = this.get('__type'),
            store = this.get('store');

        var self = this;
        self.set('isSaving', true);
        return store.update(type, this.get('id'), props).then(function (res) {
          var payload = self.__munge(res.payload || res.responseJson);

          if (payload.success === "OK") {
            Ember.warn("An update call should return the updated attributes");
            res = props;
          }

          self.setProperties(payload);
          self.afterUpdate(res);
          return res;
        }).finally(function () {
          return _this.set('isSaving', false);
        });
      },

      _saveNew: function (props) {
        var _this2 = this;

        if (this.get('isSaving')) {
          return Ember.RSVP.reject();
        }

        props = props || this.createProperties();

        var type = this.get('__type'),
            store = this.get('store'),
            adapter = store.adapterFor(type);

        var self = this;
        self.set('isSaving', true);
        return adapter.createRecord(store, type, props).then(function (res) {
          if (!res) {
            throw "Received no data back from createRecord";
          }

          // We can get a response back without properties, for example
          // when a post is queued.
          if (res.payload) {
            self.setProperties(self.__munge(res.payload));
            self.set('__state', 'created');
          }

          res.target = self;
          return res;
        }).finally(function () {
          return _this2.set('isSaving', false);
        });
      },

      createProperties: function () {
        throw "You must overwrite `createProperties()` before saving a record";
      },

      save: function (props) {
        return this.get('isNew') ? this._saveNew(props) : this.update(props);
      },

      destroyRecord: function () {
        var type = this.get('__type');
        return this.store.destroyRecord(type, this);
      }
    });

    RestModel.reopenClass({

      // Overwrite and JSON will be passed through here before `create` and `update`
      munge: function (json) {
        return json;
      },

      create: function (args) {
        args = args || {};
        if (!args.store) {
          var container = Discourse.__container__;
          // Ember.warn('Use `store.createRecord` to create records instead of `.create()`');
          args.store = container.lookup('store:main');
        }

        args.__munge = this.munge;
        return this._super(this.munge(args, args.store));
      }
    });

    __exports__["default"] = RestModel;
  });define("discourse/models/badge-grouping", 
  ["ember-addons/ember-computed-decorators","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var RestModel = __dependency2__["default"];

    __exports__["default"] = RestModel.extend(_createDecoratedObject([{
      key: 'i18nNameKey',
      decorators: [computed('name')],
      value: function () {
        return this.get('name').toLowerCase().replace(/\s/g, '_');
      }
    }, {
      key: 'displayName',
      decorators: [computed],
      value: function () {
        var i18nKey = 'badges.badge_grouping.' + this.get('i18nNameKey') + '.name';
        return I18n.t(i18nKey, { defaultValue: this.get('name') });
      }
    }]));
  });define("discourse/models/badge", 
  ["discourse/models/badge-grouping","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var BadgeGrouping = __dependency1__["default"];
    var RestModel = __dependency2__["default"];

    var Badge = RestModel.extend({

      newBadge: Em.computed.none('id'),

      /**
        @private
         The name key to use for fetching i18n translations.
         @property i18nNameKey
        @type {String}
      **/
      i18nNameKey: (function () {
        return this.get('name').toLowerCase().replace(/\s/g, '_');
      }).property('name'),

      /**
        The display name of this badge. Attempts to use a translation and falls back to
        the actual name.
         @property displayName
        @type {String}
      **/
      displayName: (function () {
        var i18nKey = "badges.badge." + this.get('i18nNameKey') + ".name";
        return I18n.t(i18nKey, { defaultValue: this.get('name') });
      }).property('name', 'i18nNameKey'),

      /**
        The i18n translated description for this badge. Returns the null if no
        translation exists.
         @property translatedDescription
        @type {String}
      **/
      translatedDescription: (function () {
        var i18nKey = "badges.badge." + this.get('i18nNameKey') + ".description";
        var translation = I18n.t(i18nKey);
        if (translation.indexOf(i18nKey) !== -1) {
          translation = null;
        }
        return translation;
      }).property('i18nNameKey'),

      displayDescription: (function () {
        // we support html in description but in most places do not need it
        return this.get('displayDescriptionHtml').replace(/<[^>]*>/g, "");
      }).property('displayDescriptionHtml'),

      /**
        Display-friendly description string. Returns either a translation or the
        original description string.
         @property displayDescription
        @type {String}
      **/
      displayDescriptionHtml: (function () {
        var translated = this.get('translatedDescription');
        return (translated === null ? this.get('description') : translated) || "";
      }).property('description', 'translatedDescription'),

      /**
        Update this badge with the response returned by the server on save.
         @method updateFromJson
        @param {Object} json The JSON response returned by the server
      **/
      updateFromJson: function (json) {
        var self = this;
        if (json.badge) {
          Object.keys(json.badge).forEach(function (key) {
            self.set(key, json.badge[key]);
          });
        }
        if (json.badge_types) {
          json.badge_types.forEach(function (badgeType) {
            if (badgeType.id === self.get('badge_type_id')) {
              self.set('badge_type', Object.create(badgeType));
            }
          });
        }
      },

      badgeTypeClassName: (function () {
        var type = this.get('badge_type.name') || "";
        return "badge-type-" + type.toLowerCase();
      }).property('badge_type.name'),

      /**
        Save and update the badge from the server's response.
         @method save
        @returns {Promise} A promise that resolves to the updated `Badge`
      **/
      save: function (data) {
        var url = "/admin/badges",
            requestType = "POST";
        var self = this;

        if (this.get('id')) {
          // We are updating an existing badge.
          url += "/" + this.get('id');
          requestType = "PUT";
        }

        return Discourse.ajax(url, {
          type: requestType,
          data: data
        }).then(function (json) {
          self.updateFromJson(json);
          return self;
        }).catch(function (error) {
          throw error;
        });
      },

      /**
        Destroy the badge.
         @method destroy
        @returns {Promise} A promise that resolves to the server response
      **/
      destroy: function () {
        if (this.get('newBadge')) return Ember.RSVP.resolve();
        return Discourse.ajax("/admin/badges/" + this.get('id'), {
          type: "DELETE"
        });
      }
    });

    Badge.reopenClass({
      /**
        Create `Badge` instances from the server JSON response.
         @method createFromJson
        @param {Object} json The JSON returned by the server
        @returns Array or instance of `Badge` depending on the input JSON
      **/
      createFromJson: function (json) {
        // Create BadgeType objects.
        var badgeTypes = {};
        if ('badge_types' in json) {
          json.badge_types.forEach(function (badgeTypeJson) {
            badgeTypes[badgeTypeJson.id] = Ember.Object.create(badgeTypeJson);
          });
        }

        var badgeGroupings = {};
        if ('badge_groupings' in json) {
          json.badge_groupings.forEach(function (badgeGroupingJson) {
            badgeGroupings[badgeGroupingJson.id] = BadgeGrouping.create(badgeGroupingJson);
          });
        }

        // Create Badge objects.
        var badges = [];
        if ("badge" in json) {
          badges = [json.badge];
        } else {
          badges = json.badges;
        }
        badges = badges.map(function (badgeJson) {
          var badge = Badge.create(badgeJson);
          badge.set('badge_type', badgeTypes[badge.get('badge_type_id')]);
          badge.set('badge_grouping', badgeGroupings[badge.get('badge_grouping_id')]);
          return badge;
        });

        if ("badge" in json) {
          return badges[0];
        } else {
          return badges;
        }
      },

      /**
        Find all `Badge` instances that have been defined.
         @method findAll
        @returns {Promise} a promise that resolves to an array of `Badge`
      **/
      findAll: function (opts) {
        var listable = "";
        if (opts && opts.onlyListable) {
          listable = "?only_listable=true";
        }
        return Discourse.ajax('/badges.json' + listable).then(function (badgesJson) {
          return Badge.createFromJson(badgesJson);
        });
      },

      /**
        Returns a `Badge` that has the given ID.
         @method findById
        @param {Number} id ID of the badge
        @returns {Promise} a promise that resolves to a `Badge`
      **/
      findById: function (id) {
        return Discourse.ajax("/badges/" + id).then(function (badgeJson) {
          return Badge.createFromJson(badgeJson);
        });
      }
    });

    __exports__["default"] = Badge;
  });define("discourse/models/permission-type", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var PermissionType = Discourse.Model.extend({
      description: (function () {
        var key = "";

        switch (this.get("id")) {
          case 1:
            key = "full";
            break;
          case 2:
            key = "create_post";
            break;
          case 3:
            key = "readonly";
            break;
        }
        return I18n.t("permission_types." + key);
      }).property("id")
    });

    PermissionType.FULL = 1;
    PermissionType.CREATE_POST = 2;
    PermissionType.READONLY = 3;

    __exports__["default"] = PermissionType;
  });define("discourse/models/user-action-group", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      A data model representing a group of UserActions
    **/

    __exports__["default"] = Discourse.Model.extend({
      push: function (item) {
        if (!this.items) {
          this.items = [];
        }
        return this.items.push(item);
      }
    });
  });define("discourse/models/category", 
  ["discourse/models/rest","ember-addons/ember-computed-decorators","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var on = __dependency2__.on;
    var PermissionType = __dependency3__["default"];

    var Category = RestModel.extend(_createDecoratedObject([{
      key: 'setupGroupsAndPermissions',
      decorators: [on('init')],
      value: function () {
        var availableGroups = this.get('available_groups');
        if (!availableGroups) {
          return;
        }
        this.set("availableGroups", availableGroups);

        var groupPermissions = this.get('group_permissions');
        if (groupPermissions) {
          this.set('permissions', groupPermissions.map(function (elem) {
            availableGroups.removeObject(elem.group_name);
            return {
              group_name: elem.group_name,
              permission: PermissionType.create({ id: elem.permission_type })
            };
          }));
        }
      }
    }, {
      key: 'availablePermissions',
      initializer: function () {
        return (function () {
          return [PermissionType.create({ id: PermissionType.FULL }), PermissionType.create({ id: PermissionType.CREATE_POST }), PermissionType.create({ id: PermissionType.READONLY })];
        }).property();
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return (function () {
          return { type: 'category', id: this.get('id'), category: this };
        }).property('id');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          return Discourse.getURL("/c/") + Category.slugFor(this);
        }).property('name');
      }
    }, {
      key: 'fullSlug',
      initializer: function () {
        return (function () {
          return this.get("url").slice(3).replace("/", "-");
        }).property("url");
      }
    }, {
      key: 'nameLower',
      initializer: function () {
        return (function () {
          return this.get('name').toLowerCase();
        }).property('name');
      }
    }, {
      key: 'unreadUrl',
      initializer: function () {
        return (function () {
          return this.get('url') + '/l/unread';
        }).property('url');
      }
    }, {
      key: 'newUrl',
      initializer: function () {
        return (function () {
          return this.get('url') + '/l/new';
        }).property('url');
      }
    }, {
      key: 'style',
      initializer: function () {
        return (function () {
          return "background-color: #" + this.get('category.color') + "; color: #" + this.get('category.text_color') + ";";
        }).property('color', 'text_color');
      }
    }, {
      key: 'moreTopics',
      initializer: function () {
        return (function () {
          return this.get('topic_count') > Discourse.SiteSettings.category_featured_topics;
        }).property('topic_count');
      }
    }, {
      key: 'save',
      initializer: function () {
        return function () {
          var url = "/categories";
          if (this.get('id')) {
            url = "/categories/" + this.get('id');
          }

          return Discourse.ajax(url, {
            data: {
              name: this.get('name'),
              slug: this.get('slug'),
              color: this.get('color'),
              text_color: this.get('text_color'),
              secure: this.get('secure'),
              permissions: this.get('permissionsForUpdate'),
              auto_close_hours: this.get('auto_close_hours'),
              auto_close_based_on_last_post: this.get("auto_close_based_on_last_post"),
              position: this.get('position'),
              email_in: this.get('email_in'),
              email_in_allow_strangers: this.get('email_in_allow_strangers'),
              parent_category_id: this.get('parent_category_id'),
              logo_url: this.get('logo_url'),
              background_url: this.get('background_url'),
              allow_badges: this.get('allow_badges'),
              custom_fields: this.get('custom_fields'),
              topic_template: this.get('topic_template'),
              suppress_from_homepage: this.get('suppress_from_homepage'),
              contains_messages: this.get("contains_messages")
            },
            type: this.get('id') ? 'PUT' : 'POST'
          });
        };
      }
    }, {
      key: 'permissionsForUpdate',
      initializer: function () {
        return (function () {
          var rval = {};
          _.each(this.get("permissions"), function (p) {
            rval[p.group_name] = p.permission.id;
          });
          return rval;
        }).property("permissions");
      }
    }, {
      key: 'destroy',
      initializer: function () {
        return function () {
          return Discourse.ajax("/categories/" + (this.get('id') || this.get('slug')), { type: 'DELETE' });
        };
      }
    }, {
      key: 'addPermission',
      initializer: function () {
        return function (permission) {
          this.get("permissions").addObject(permission);
          this.get("availableGroups").removeObject(permission.group_name);
        };
      }
    }, {
      key: 'removePermission',
      initializer: function () {
        return function (permission) {
          this.get("permissions").removeObject(permission);
          this.get("availableGroups").addObject(permission.group_name);
        };
      }
    }, {
      key: 'permissions',
      initializer: function () {
        return (function () {
          return Em.A([{ group_name: "everyone", permission: PermissionType.create({ id: 1 }) }, { group_name: "admins", permission: PermissionType.create({ id: 2 }) }, { group_name: "crap", permission: PermissionType.create({ id: 3 }) }]);
        }).property();
      }
    }, {
      key: 'latestTopic',
      initializer: function () {
        return (function () {
          var topics = this.get('topics');
          if (topics && topics.length) {
            return topics[0];
          }
        }).property("topics");
      }
    }, {
      key: 'featuredTopics',
      initializer: function () {
        return (function () {
          var topics = this.get('topics');
          if (topics && topics.length) {
            return topics.slice(0, Discourse.SiteSettings.category_featured_topics || 2);
          }
        }).property('topics');
      }
    }, {
      key: 'unreadTopics',
      initializer: function () {
        return (function () {
          return this.topicTrackingState.countUnread(this.get('id'));
        }).property('topicTrackingState.messageCount');
      }
    }, {
      key: 'newTopics',
      initializer: function () {
        return (function () {
          return this.topicTrackingState.countNew(this.get('id'));
        }).property('topicTrackingState.messageCount');
      }
    }, {
      key: 'topicStatsTitle',
      initializer: function () {
        return (function () {
          var string = I18n.t('categories.topic_stats');
          _.each(this.get('topicCountStats'), function (stat) {
            string += ' ' + I18n.t('categories.topic_stat_sentence', { count: stat.value, unit: stat.unit });
          }, this);
          return string;
        }).property('post_count');
      }
    }, {
      key: 'postStatsTitle',
      initializer: function () {
        return (function () {
          var string = I18n.t('categories.post_stats');
          _.each(this.get('postCountStats'), function (stat) {
            string += ' ' + I18n.t('categories.post_stat_sentence', { count: stat.value, unit: stat.unit });
          }, this);
          return string;
        }).property('post_count');
      }
    }, {
      key: 'topicCountStats',
      initializer: function () {
        return (function () {
          return this.countStats('topics');
        }).property('topics_year', 'topics_month', 'topics_week', 'topics_day');
      }
    }, {
      key: 'setNotification',
      initializer: function () {
        return function (notification_level) {
          var url = "/category/" + this.get('id') + "/notifications";
          this.set('notification_level', notification_level);
          return Discourse.ajax(url, {
            data: {
              notification_level: notification_level
            },
            type: 'POST'
          });
        };
      }
    }, {
      key: 'postCountStats',
      initializer: function () {
        return (function () {
          return this.countStats('posts');
        }).property('posts_year', 'posts_month', 'posts_week', 'posts_day');
      }
    }, {
      key: 'countStats',
      initializer: function () {
        return function (prefix) {
          var stats = [],
              val;
          _.each(['day', 'week', 'month', 'year'], function (unit) {
            val = this.get(prefix + '_' + unit);
            if (val > 0) stats.pushObject({ value: val, unit: I18n.t(unit) });
            if (stats.length === 2) return false;
          }, this);
          return stats;
        };
      }
    }, {
      key: 'isUncategorizedCategory',
      initializer: function () {
        return (function () {
          return this.get('id') === Discourse.Site.currentProp("uncategorized_category_id");
        }).property('id');
      }
    }]));

    var _uncategorized;

    Category.reopenClass({

      findUncategorized: function () {
        _uncategorized = _uncategorized || Category.list().findBy('id', Discourse.Site.currentProp('uncategorized_category_id'));
        return _uncategorized;
      },

      slugFor: function (category) {
        if (!category) return "";

        var parentCategory = Em.get(category, 'parentCategory');
        var result = "";

        if (parentCategory) {
          result = Category.slugFor(parentCategory) + "/";
        }

        var id = Em.get(category, 'id'),
            slug = Em.get(category, 'slug');

        return !slug || slug.trim().length === 0 ? '' + result + id + '-category' : result + slug;
      },

      list: function () {
        return Discourse.SiteSettings.fixed_category_positions ? Discourse.Site.currentProp('categories') : Discourse.Site.currentProp('sortedCategories');
      },

      listByActivity: function () {
        return Discourse.Site.currentProp('sortedCategories');
      },

      idMap: function () {
        return Discourse.Site.currentProp('categoriesById');
      },

      findSingleBySlug: function (slug) {
        return Category.list().find(function (c) {
          return Category.slugFor(c) === slug;
        });
      },

      findById: function (id) {
        if (!id) {
          return;
        }
        return Category.idMap()[id];
      },

      findByIds: function (ids) {
        var categories = [];
        _.each(ids, function (id) {
          var found = Category.findById(id);
          if (found) {
            categories.push(found);
          }
        });
        return categories;
      },

      findBySlug: function (slug, parentSlug) {
        var categories = Category.list();
        var category = undefined;

        if (parentSlug) {
          var _ret = (function () {
            var parentCategory = Category.findSingleBySlug(parentSlug);
            if (parentCategory) {
              if (slug === 'none') {
                return {
                  v: parentCategory
                };
              }

              category = categories.find(function (item) {
                return item && item.get('parentCategory') === parentCategory && Category.slugFor(item) === parentSlug + "/" + slug;
              });
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        } else {
          category = Category.findSingleBySlug(slug);

          // If we have a parent category, we need to enforce it
          if (category && category.get('parentCategory')) return;
        }

        // In case the slug didn't work, try to find it by id instead.
        if (!category) {
          category = categories.findBy('id', parseInt(slug, 10));
        }

        return category;
      },

      reloadById: function (id) {
        return Discourse.ajax('/c/' + id + '/show.json');
      }
    });

    __exports__["default"] = Category;
  });

Discourse.Category = require('discourse/models/category').default;
define("discourse/lib/ajax-error", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.extractError = extractError;
    __exports__.throwAjaxError = throwAjaxError;
    __exports__.popupAjaxError = popupAjaxError;

    function extractError(error, defaultMessage) {
      if (error instanceof Error) {
        Ember.Logger.error(error.stack);
      }

      if (typeof error === "string") {
        Ember.Logger.error(error);
      }

      if (error.jqXHR) {
        error = error.jqXHR;
      }

      var parsedError = undefined,
          parsedJSON = undefined;

      if (error.responseJSON) {
        parsedJSON = error.responseJSON;
      }

      if (!parsedJSON && error.responseText) {
        try {
          parsedJSON = $.parseJSON(error.responseText);
        } catch (ex) {
          // in case the JSON doesn't parse
          Ember.Logger.error(ex.stack);
        }
      }

      if (parsedJSON) {
        if (parsedJSON.errors && parsedJSON.errors.length > 0) {
          parsedError = parsedJSON.errors.join("<br>");
        } else if (parsedJSON.error) {
          parsedError = parsedJSON.error;
        } else if (parsedJSON.failed) {
          parsedError = parsedJSON.message;
        }
      }

      if (!parsedError) {
        if (error.status && error.status >= 400) {
          parsedError = error.status + " " + error.statusText;
        }
      }

      return parsedError || defaultMessage || I18n.t('generic_error');
    }

    function throwAjaxError(undoCallback) {
      return function (error) {
        // If we provided an `undo` callback
        if (undoCallback) {
          undoCallback(error);
        }
        throw extractError(error);
      };
    }

    function popupAjaxError(error) {
      bootbox.alert(extractError(error));
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Contains methods to help us with markdown formatting.

  @class Markdown
  @namespace Discourse
  @module Discourse
**/

/**
 * An object mapping from HTML tag names to an object mapping the valid
 * attributes on that tag to an array of permitted values.
 *
 * The permitted values can be strings or regexes.
 *
 * The pseduo-attribute 'data-*' can be used to validate any data-foo
 * attributes without any specified validations.
 *
 * Code can insert into this map by calling Discourse.Markdown.whiteListTag().
 *
 * Example:
 *
 * <pre><code>
 * {
 *   a: {
 *     href: ['*'],
 *     data-mention-id: [/^\d+$/],
 *     ...
 *   },
 *   code: {
 *     class: ['ada', 'haskell', 'c', 'cpp', ... ]
 *   },
 *   ...
 * }
 * </code></pre>
 *
 * @private
 */

var _validTags = {};
/**
 * Classes valid on all elements. Map from class name to 'true'.
 * @private
 */
var _validClasses = {};
var _validIframes = [];
var _decoratedCaja = false;

function validateAttribute(tagName, attribName, value) {
  var tag = _validTags[tagName];

  // Handle classes
  if (attribName === "class") {
    if (_validClasses[value]) { return value; }
  }

  if (attribName.indexOf('data-') === 0) {
    // data-* catch-all validators
    if (tag && tag['data-*'] && !tag[attribName]) {
      var permitted = tag['data-*'];
      if (permitted && (
            permitted.indexOf(value) !== -1 ||
            permitted.indexOf('*') !== -1 ||
            ((permitted instanceof RegExp) && permitted.test(value)))
        ) { return value; }
    }
  }

  if (tag) {
    var attrs = tag[attribName];
    if (attrs && (attrs.indexOf(value) !== -1 ||
                  attrs.indexOf('*') !== -1) ||
                  _.any(attrs, function(r) { return (r instanceof RegExp) && r.test(value); })
        ) { return value; }
  }

  // return undefined;
}

function anchorRegexp(regex) {
  if (/^\^.*\$$/.test(regex.source)) {
    return regex; // already anchored
  }

  var flags = "";
  if (regex.global) {
    if (typeof console !== 'undefined') {
      console.warn("attribute validation regex should not be global");
    }
  }

  if (regex.ignoreCase) { flags += "i"; }
  if (regex.multiline) { flags += "m"; }
  if (regex.sticky) { throw "Invalid attribute validation regex - cannot be sticky"; }

  return new RegExp("^" + regex.source + "$", flags);
}

Discourse.Markdown = {

  /**
    Add to the attribute whitelist for a certain HTML tag.

    @param {String} tagName tag to whitelist the attr for
    @param {String} attribName attr to whitelist for the tag
    @param {String | RegExp} [value] whitelisted value for the attribute
  **/
  whiteListTag: function(tagName, attribName, value) {
    if (value instanceof RegExp) {
      value = anchorRegexp(value);
    }
    _validTags[tagName] = _validTags[tagName] || {};
    _validTags[tagName][attribName] = _validTags[tagName][attribName] || [];
    _validTags[tagName][attribName].push(value || '*');
  },

  /**
    Whitelists more classes for sanitization.

    @param {...String} var_args Classes to whitelist
    @method whiteListClass
  **/
  whiteListClass: function() {
    var args = Array.prototype.slice.call(arguments);
    args.forEach(function (a) { _validClasses[a] = true; });
  },

  /**
    Whitelists iframes for sanitization

    @method whiteListIframe
    @param {Regexp} regexp The regexp to whitelist.
  **/
  whiteListIframe: function(regexp) {
    _validIframes.push(regexp);
  },

  /**
    Convert a raw string to a cooked markdown string.

    @method cook
    @param {String} raw the raw string we want to apply markdown to
    @param {Object} opts the options for the rendering
    @return {String} the cooked markdown string
  **/
  cook: function(raw, opts) {
    if (!opts) opts = {};

    // Make sure we've got a string
    if (!raw || raw.length === 0) return "";

    return this.markdownConverter(opts).makeHtml(raw);
  },

  /**
    Checks to see if a URL is allowed in the cooked content

    @method urlAllowed
    @param {String} uri Url to check
    @param {Number} effect ignored
    @param {Number} ltype ignored
    @param {Object} hints an object with hints, used to check if this url is from an iframe
    @return {String} url to insert in the cooked content
  **/
  urlAllowed: function (uri, effect, ltype, hints) {
    var url = typeof(uri) === "string" ? uri : uri.toString();

    // escape single quotes
    url = url.replace(/'/g, "%27");

    // whitelist some iframe only
    if (hints && hints.XML_TAG === "iframe" && hints.XML_ATTR === "src") {
      for (var i = 0, length = _validIframes.length; i < length; i++) {
        if(_validIframes[i].test(url)) { return url; }
      }
      return;
    }

    // absolute urls
    if(/^(https?:)?\/\/[\w\.\-]+/i.test(url)) { return url; }
    // relative urls
    if(/^\/[\w\.\-]+/i.test(url)) { return url; }
    // anchors
    if(/^#[\w\.\-]+/i.test(url)) { return url; }
    // mailtos
    if(/^mailto:[\w\.\-@]+/i.test(url)) { return url; }
  },

  /**
    Sanitize text using the sanitizer

    @method sanitize
    @param {String} text The text to sanitize
    @return {String} text The sanitized text
  **/
  sanitize: function(text) {
    if (!window.html_sanitize || !text) return "";

    // Allow things like <3 and <_<
    text = text.replace(/<([^A-Za-z\/\!]|$)/g, "&lt;$1");

    // The first time, let's add some more whitelisted tags
    if (!_decoratedCaja) {

      // Add anything whitelisted to the list of elements if it's not in there already.
      var elements = window.html4.ELEMENTS;
      Object.keys(_validTags).forEach(function(t) {
        if (!elements[t]) {
          elements[t] = 0;
        }
      });

      _decoratedCaja = true;
    }

    return window.html_sanitize(text, Discourse.Markdown.urlAllowed, validateAttribute);
  },

  /**
    Creates a Markdown.Converter that we we can use for formatting

    @method markdownConverter
    @param {Object} opts the converting options
  **/
  markdownConverter: function(opts) {
    if (!opts) opts = {};

    return {
      makeHtml: function(text) {
        text = Discourse.Dialect.cook(text, opts);
        return !text ? "" : text;
      }
    };
  }

};

RSVP.EventTarget.mixin(Discourse.Markdown);

Discourse.Markdown.whiteListTag('a', 'class', 'attachment');
Discourse.Markdown.whiteListTag('a', 'class', 'onebox');
Discourse.Markdown.whiteListTag('a', 'class', 'mention');
Discourse.Markdown.whiteListTag('a', 'class', 'mention-group');

Discourse.Markdown.whiteListTag('a', 'target', '_blank');
Discourse.Markdown.whiteListTag('a', 'rel', 'nofollow');
Discourse.Markdown.whiteListTag('a', 'data-bbcode');
Discourse.Markdown.whiteListTag('a', 'name');

Discourse.Markdown.whiteListTag('img', 'src', /^data:image.*$/i);

Discourse.Markdown.whiteListTag('div', 'class', 'title');
Discourse.Markdown.whiteListTag('div', 'class', 'quote-controls');

Discourse.Markdown.whiteListTag('span', 'class', 'mention');
Discourse.Markdown.whiteListTag('aside', 'class', 'quote');
Discourse.Markdown.whiteListTag('aside', 'data-*');

Discourse.Markdown.whiteListTag('span', 'bbcode-b');
Discourse.Markdown.whiteListTag('span', 'bbcode-i');
Discourse.Markdown.whiteListTag('span', 'bbcode-u');
Discourse.Markdown.whiteListTag('span', 'bbcode-s');

// used for pinned topics
Discourse.Markdown.whiteListTag('span', 'class', 'excerpt');

Discourse.Markdown.whiteListIframe(/^(https?:)?\/\/www\.google\.com\/maps\/embed\?.+/i);
Discourse.Markdown.whiteListIframe(/^(https?:)?\/\/www\.openstreetmap\.org\/export\/embed.html\?.+/i);


// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/search", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.translateResults = translateResults;

    function translateResults(results, opts) {

      var User = require('discourse/models/user').default;
      var Category = require('discourse/models/category').default;
      var Post = require('discourse/models/post').default;
      var Topic = require('discourse/models/topic').default;

      if (!opts) opts = {};

      // Topics might not be included
      if (!results.topics) {
        results.topics = [];
      }
      if (!results.users) {
        results.users = [];
      }
      if (!results.posts) {
        results.posts = [];
      }
      if (!results.categories) {
        results.categories = [];
      }

      var topicMap = {};
      results.topics = results.topics.map(function (topic) {
        topic = Topic.create(topic);
        topicMap[topic.id] = topic;
        return topic;
      });

      results.posts = results.posts.map(function (post) {
        post = Post.create(post);
        post.set('topic', topicMap[post.topic_id]);
        return post;
      });

      results.users = results.users.map(function (user) {
        user = User.create(user);
        return user;
      });

      results.categories = results.categories.map(function (category) {
        return Category.list().findProperty('id', category.id);
      }).compact();

      var r = results.grouped_search_result;
      results.resultTypes = [];

      // TODO: consider refactoring front end to take a better structure
      [['topic', 'posts'], ['user', 'users'], ['category', 'categories']].forEach(function (pair) {
        var type = pair[0],
            name = pair[1];
        if (results[name].length > 0) {
          var result = {
            results: results[name],
            componentName: "search-result-" + (opts.searchContext && opts.searchContext.type === 'topic' && type === 'topic' ? 'post' : type),
            type: type,
            more: r['more_' + name]
          };

          if (result.more && name === "posts" && opts.fullSearchUrl) {
            result.more = false;
            result.moreUrl = opts.fullSearchUrl;
          }

          results.resultTypes.push(result);
        }
      });

      var noResults = !!(results.topics.length === 0 && results.posts.length === 0 && results.users.length === 0 && results.categories.length === 0);

      return noResults ? null : Em.Object.create(results);
    }

    function searchForTerm(term, opts) {
      if (!opts) opts = {};

      // Only include the data we have
      var data = { term: term, include_blurbs: 'true' };
      if (opts.typeFilter) data.type_filter = opts.typeFilter;
      if (opts.searchForId) data.search_for_id = true;

      if (opts.searchContext) {
        data.search_context = {
          type: opts.searchContext.type,
          id: opts.searchContext.id
        };
      }

      var promise = Discourse.ajax('/search/query', { data: data });

      promise.then(function (results) {
        return translateResults(results, opts);
      });

      return promise;
    }

    var searchContextDescription = function (type, name) {
      if (type) {
        switch (type) {
          case 'topic':
            return I18n.t('search.context.topic');
          case 'user':
            return I18n.t('search.context.user', { username: name });
          case 'category':
            return I18n.t('search.context.category', { category: name });
          case 'private_messages':
            return I18n.t('search.context.private_messages');
        }
      }
    };

    var getSearchKey = function (args) {
      return args.q + "|" + (args.searchContext && args.searchContext.type || "") + "|" + (args.searchContext && args.searchContext.id || "");
    };

    var isValidSearchTerm = function (searchTerm) {
      if (searchTerm) {
        return searchTerm.trim().length >= Discourse.SiteSettings.min_search_term_length;
      } else {
        return false;
      }
    };

    __exports__.searchForTerm = searchForTerm;
    __exports__.searchContextDescription = searchContextDescription;
    __exports__.getSearchKey = getSearchKey;
    __exports__.isValidSearchTerm = isValidSearchTerm;
  });define("discourse/lib/user-search", 
  ["discourse/lib/autocomplete","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = userSearch;
    var CANCELLED_STATUS = __dependency1__.CANCELLED_STATUS;

    var cache = {},
        cacheTopicId,
        cacheTime,
        currentTerm,
        oldSearch;

    function performSearch(term, topicId, includeGroups, includeMentionableGroups, allowedUsers, resultsFn) {
      var cached = cache[term];
      if (cached) {
        resultsFn(cached);
        return;
      }

      // need to be able to cancel this
      oldSearch = $.ajax(Discourse.getURL('/users/search/users'), {
        data: { term: term,
          topic_id: topicId,
          include_groups: includeGroups,
          include_mentionable_groups: includeMentionableGroups,
          topic_allowed_users: allowedUsers }
      });

      var returnVal = CANCELLED_STATUS;

      oldSearch.then(function (r) {
        cache[term] = r;
        cacheTime = new Date();
        // If there is a newer search term, return null
        if (term === currentTerm) {
          returnVal = r;
        }
      }).always(function () {
        oldSearch = null;
        resultsFn(returnVal);
      });
    }

    var debouncedSearch = _.debounce(performSearch, 300);

    function organizeResults(r, options) {
      if (r === CANCELLED_STATUS) {
        return r;
      }

      var exclude = options.exclude || [],
          limit = options.limit || 5,
          users = [],
          groups = [],
          results = [];

      if (r.users) {
        r.users.every(function (u) {
          if (exclude.indexOf(u.username) === -1) {
            users.push(u);
            results.push(u);
          }
          return results.length <= limit;
        });
      }

      if (r.groups) {
        r.groups.every(function (g) {
          if (results.length > limit) return false;
          if (exclude.indexOf(g.name) === -1) {
            groups.push(g);
            results.push(g);
          }
          return true;
        });
      }

      results.users = users;
      results.groups = groups;
      return results;
    }
    function userSearch(options) {
      var term = options.term || "",
          includeGroups = options.includeGroups,
          includeMentionableGroups = options.includeMentionableGroups,
          allowedUsers = options.allowedUsers,
          topicId = options.topicId;

      if (oldSearch) {
        oldSearch.abort();
        oldSearch = null;
      }

      currentTerm = term;

      return new Ember.RSVP.Promise(function (resolve) {
        // TODO site setting for allowed regex in username
        if (term.match(/[^a-zA-Z0-9_\.\-]/)) {
          resolve([]);
          return;
        }
        if (new Date() - cacheTime > 30000 || cacheTopicId !== topicId) {
          cache = {};
        }

        cacheTopicId = topicId;

        var clearPromise = setTimeout(function () {
          resolve(CANCELLED_STATUS);
        }, 5000);

        debouncedSearch(term, topicId, includeGroups, includeMentionableGroups, allowedUsers, function (r) {
          clearTimeout(clearPromise);
          resolve(organizeResults(r, options));
        });
      });
    }
  });define("discourse/lib/export-csv", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.exportUserArchive = exportUserArchive;
    __exports__.exportEntity = exportEntity;
    function exportEntityByType(type, entity, args) {
      return Discourse.ajax("/export_csv/export_entity.json", {
        method: 'POST',
        data: { entity_type: type, entity: entity, args: args }
      });
    }

    function exportUserArchive() {
      return exportEntityByType('user', 'user_archive').then(function () {
        bootbox.alert(I18n.t("admin.export_csv.success"));
      }).catch(function () {
        bootbox.alert(I18n.t("admin.export_csv.rate_limit_error"));
      });
    }

    function exportEntity(entity, args) {
      return exportEntityByType('admin', entity, args);
    }
  });define("discourse/lib/autocomplete", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      This is a jQuery plugin to support autocompleting values in our text fields.

      @module $.fn.autocomplete
    **/

    var CANCELLED_STATUS = "__CANCELLED";

    __exports__.CANCELLED_STATUS = CANCELLED_STATUS;
    var allowedLettersRegex = /[\s\t\[\{\(\/]/;

    var keys = {
      backSpace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      esc: 27,
      space: 32,
      leftWindows: 91,
      rightWindows: 92,
      pageUp: 33,
      pageDown: 34,
      end: 35,
      home: 36,
      leftArrow: 37,
      upArrow: 38,
      rightArrow: 39,
      downArrow: 40,
      insert: 45,
      deleteKey: 46,
      zero: 48,
      a: 65,
      z: 90
    };

    var inputTimeout = undefined;

    __exports__["default"] = function (options) {
      var autocompletePlugin = this;

      if (this.length === 0) return;

      if (options === 'destroy') {
        Ember.run.cancel(inputTimeout);

        $(this).off('keypress.autocomplete').off('keydown.autocomplete').off('paste.autocomplete');

        return;
      }

      if (options && options.cancel && this.data("closeAutocomplete")) {
        this.data("closeAutocomplete")();
        return this;
      }

      if (this.length !== 1) {
        alert("only supporting one matcher at the moment");
      }

      var disabled = options && options.disabled;
      var wrap = null;
      var autocompleteOptions = null;
      var selectedOption = null;
      var completeStart = null;
      var completeEnd = null;
      var me = this;
      var div = null;

      // input is handled differently
      var isInput = this[0].tagName === "INPUT";
      var inputSelectedItems = [];

      var closeAutocomplete = function () {
        if (div) {
          div.hide().remove();
        }
        div = null;
        completeStart = null;
        autocompleteOptions = null;
      };

      var addInputSelectedItem = function (item) {
        var transformed,
            transformedItem = item;

        if (options.transformComplete) {
          transformedItem = options.transformComplete(transformedItem);
        }
        // dump what we have in single mode, just in case
        if (options.single) {
          inputSelectedItems = [];
        }
        transformed = _.isArray(transformedItem) ? transformedItem : [transformedItem || item];

        var divs = transformed.map(function (itm) {
          var d = $("<div class='item'><span>" + itm + "<a class='remove' href><i class='fa fa-times'></i></a></span></div>");
          var prev = me.parent().find('.item:last');
          if (prev.length === 0) {
            me.parent().prepend(d);
          } else {
            prev.after(d);
          }
          inputSelectedItems.push(itm);
          return d[0];
        });

        if (options.onChangeItems) {
          options.onChangeItems(inputSelectedItems);
        }

        $(divs).find('a').click(function () {
          closeAutocomplete();
          inputSelectedItems.splice($.inArray(transformedItem, inputSelectedItems), 1);
          $(this).parent().parent().remove();
          if (options.single) {
            me.show();
          }
          if (options.onChangeItems) {
            options.onChangeItems(inputSelectedItems);
          }
          return false;
        });
      };

      var completeTerm = function (term) {
        if (term) {
          if (isInput) {
            me.val("");
            if (options.single) {
              me.hide();
            }
            addInputSelectedItem(term);
          } else {
            if (options.transformComplete) {
              term = options.transformComplete(term);
            }

            if (term) {
              var text = me.val();
              text = text.substring(0, completeStart) + (options.key || "") + term + ' ' + text.substring(completeEnd + 1, text.length);
              me.val(text);
              Discourse.Utilities.setCaretPosition(me[0], completeStart + 1 + term.length);
            }
          }
        }
        closeAutocomplete();
      };

      if (isInput) {
        var width = this.width();
        wrap = this.wrap("<div class='ac-wrap clearfix" + (disabled ? " disabled" : "") + "'/>").parent();
        wrap.width(width);
        if (options.single) {
          this.css("width", "100%");
        } else {
          this.width(150);
        }
        this.attr('name', this.attr('name') + "-renamed");
        var vals = this.val().split(",");
        _.each(vals, function (x) {
          if (x !== "") {
            if (options.reverseTransform) {
              x = options.reverseTransform(x);
            }
            addInputSelectedItem(x);
          }
        });
        if (options.items) {
          _.each(options.items, function (item) {
            addInputSelectedItem(item);
          });
        }
        this.val("");
        completeStart = 0;
        wrap.click(function () {
          autocompletePlugin.focus();
          return true;
        });
      }

      var markSelected = function () {
        var links = div.find('li a');
        links.removeClass('selected');
        return $(links[selectedOption]).addClass('selected');
      };

      var renderAutocomplete = function () {
        if (div) {
          div.hide().remove();
        }
        if (autocompleteOptions.length === 0) return;

        div = $(options.template({ options: autocompleteOptions }));

        var ul = div.find('ul');
        selectedOption = 0;
        markSelected();
        ul.find('li').click(function () {
          selectedOption = ul.find('li').index(this);
          completeTerm(autocompleteOptions[selectedOption]);
          return false;
        });
        var pos = null;
        var vOffset = 0;
        var hOffset = 0;
        if (isInput) {
          pos = {
            left: 0,
            top: 0
          };
          vOffset = -32;
          hOffset = 0;
        } else {
          pos = me.caretPosition({
            pos: completeStart,
            key: options.key
          });
          hOffset = 27;
        }
        div.css({
          left: "-1000px"
        });

        me.parent().append(div);

        if (!isInput) {
          vOffset = div.height();
        }

        if (Discourse.Mobile.mobileView && !isInput) {
          div.css('width', 'auto');

          if (me.height() / 2 >= pos.top) {
            vOffset = -23;
          }
          if (me.width() / 2 <= pos.left) {
            hOffset = -div.width();
          }
        }

        var mePos = me.position();
        var borderTop = parseInt(me.css('border-top-width'), 10) || 0;
        div.css({
          position: 'absolute',
          top: mePos.top + pos.top - vOffset + borderTop + 'px',
          left: mePos.left + pos.left + hOffset + 'px'
        });
      };

      var updateAutoComplete = function (r) {

        if (completeStart === null) return;

        if (r && r.then && typeof r.then === "function") {
          if (div) {
            div.hide().remove();
          }
          r.then(updateAutoComplete);
          return;
        }

        // Allow an update method to cancel. This allows us to debounce
        // promises without leaking
        if (r === CANCELLED_STATUS) {
          return;
        }

        autocompleteOptions = r;
        if (!r || r.length === 0) {
          closeAutocomplete();
        } else {
          renderAutocomplete();
        }
      };

      // chain to allow multiples
      var oldClose = me.data("closeAutocomplete");
      me.data("closeAutocomplete", function () {
        if (oldClose) {
          oldClose();
        }
        closeAutocomplete();
      });

      $(this).on('paste.autocomplete', function () {
        _.delay(function () {
          me.trigger("keydown");
        }, 50);
      });

      $(this).on('keypress.autocomplete', function (e) {
        var caretPosition, term;

        // keep hunting backwards till you hit a the @ key
        if (options.key && e.which === options.key.charCodeAt(0)) {
          caretPosition = Discourse.Utilities.caretPosition(me[0]);
          var prevChar = me.val().charAt(caretPosition - 1);
          if (!prevChar || allowedLettersRegex.test(prevChar)) {
            completeStart = completeEnd = caretPosition;
            updateAutoComplete(options.dataSource(""));
          }
        } else if (completeStart !== null && e.charCode !== 0) {
          caretPosition = Discourse.Utilities.caretPosition(me[0]);
          term = me.val().substring(completeStart + (options.key ? 1 : 0), caretPosition);
          term += String.fromCharCode(e.charCode);
          updateAutoComplete(options.dataSource(term));
        }
      });

      $(this).on('keydown.autocomplete', function (e) {
        var c, caretPosition, i, initial, prev, prevIsGood, stopFound, term, total, userToComplete;

        if (e.ctrlKey || e.altKey || e.metaKey) {
          return true;
        }

        if (options.allowAny) {
          // saves us wiring up a change event as well, keypress is while its pressed

          Ember.run.cancel(inputTimeout);
          inputTimeout = Ember.run.later(function () {
            if (inputSelectedItems.length === 0) {
              inputSelectedItems.push("");
            }

            if (_.isString(inputSelectedItems[0]) && me.val().length > 0) {
              inputSelectedItems.pop();
              inputSelectedItems.push(me.val());
              if (options.onChangeItems) {
                options.onChangeItems(inputSelectedItems);
              }
            }
          }, 50);
        }

        if (!options.key) {
          completeStart = 0;
        }
        if (e.which === keys.shift) return;
        if (completeStart === null && e.which === keys.backSpace && options.key) {
          c = Discourse.Utilities.caretPosition(me[0]);
          c -= 1;
          initial = c;
          prevIsGood = true;
          while (prevIsGood && c >= 0) {
            c -= 1;
            prev = me[0].value[c];
            stopFound = prev === options.key;
            if (stopFound) {
              prev = me[0].value[c - 1];
              if (!prev || allowedLettersRegex.test(prev)) {
                completeStart = c;
                caretPosition = completeEnd = initial;
                term = me[0].value.substring(c + 1, initial);
                updateAutoComplete(options.dataSource(term));
                return true;
              }
            }
            prevIsGood = /[a-zA-Z\.]/.test(prev);
          }
        }

        // ESC
        if (e.which === keys.esc) {
          if (div !== null) {
            closeAutocomplete();
            return false;
          }
          return true;
        }

        if (completeStart !== null) {
          caretPosition = Discourse.Utilities.caretPosition(me[0]);

          // If we've backspaced past the beginning, cancel unless no key
          if (caretPosition <= completeStart && options.key) {
            closeAutocomplete();
            return false;
          }

          // Keyboard codes! So 80's.
          switch (e.which) {
            case keys.enter:
            case keys.rightArrow:
            case keys.tab:
              if (!autocompleteOptions) return true;
              if (selectedOption >= 0 && (userToComplete = autocompleteOptions[selectedOption])) {
                completeTerm(userToComplete);
              } else {
                // We're cancelling it, really.
                return true;
              }
              e.stopImmediatePropagation();
              return false;
            case keys.upArrow:
              selectedOption = selectedOption - 1;
              if (selectedOption < 0) {
                selectedOption = 0;
              }
              markSelected();
              return false;
            case keys.downArrow:
              total = autocompleteOptions.length;
              selectedOption = selectedOption + 1;
              if (selectedOption >= total) {
                selectedOption = total - 1;
              }
              if (selectedOption < 0) {
                selectedOption = 0;
              }
              markSelected();
              return false;
            case keys.backSpace:
              completeEnd = caretPosition;
              caretPosition--;

              if (caretPosition < 0) {
                closeAutocomplete();
                if (isInput) {
                  i = wrap.find('a:last');
                  if (i) {
                    i.click();
                  }
                }
                return true;
              }

              term = me.val().substring(completeStart + (options.key ? 1 : 0), caretPosition);

              updateAutoComplete(options.dataSource(term));
              return true;
            default:
              completeEnd = caretPosition;
              return true;
          }
        }
      });

      return this;
    }
  });define("discourse/lib/after-transition", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      CSS transitions are a PITA, often we need to queue some js after a transition, this helper ensures
      it happens after the transition.

      SO: http://stackoverflow.com/questions/9943435/css3-animation-end-techniques
    **/

    var dummy = document.createElement("div"),
        eventNameHash = {
      webkit: "webkitTransitionEnd",
      Moz: "transitionend",
      O: "oTransitionEnd",
      ms: "MSTransitionEnd"
    };

    var transitionEnd = (function () {
      var retValue;
      retValue = "transitionend";
      Object.keys(eventNameHash).some(function (vendor) {
        if (vendor + "TransitionProperty" in dummy.style) {
          retValue = eventNameHash[vendor];
          return true;
        }
      });
      return retValue;
    })();

    __exports__["default"] = function (element, callback) {
      return $(element).on(transitionEnd, callback);
    }
  });define("discourse/lib/safari-hacks", 
  ["exports"],
  function(__exports__) {
    "use strict";
    function applicable() {
      // IE has no DOMNodeInserted so can not get this hack despite saying it is like iPhone
      // This will apply hack on all iDevices
      return navigator.userAgent.match(/(iPad|iPhone|iPod)/g) && navigator.userAgent.match(/Safari/g) && !navigator.userAgent.match(/Trident/g);
    }

    // per http://stackoverflow.com/questions/29001977/safari-in-ios8-is-scrolling-screen-when-fixed-elements-get-focus/29064810
    function positioningWorkaround($fixedElement) {
      if (!applicable()) {
        return;
      }

      var fixedElement = $fixedElement[0];

      var done = false;
      var originalScrollTop = 0;

      var blurredNow = function (evt) {
        if (!done && _.include($(document.activeElement).parents(), fixedElement)) {
          // something in focus so skip
          return;
        }

        done = true;

        $('#main-outlet').show();
        $('header').show();

        fixedElement.style.position = '';
        fixedElement.style.top = '';
        fixedElement.style.height = '';

        $(window).scrollTop(originalScrollTop);

        if (evt) {
          evt.target.removeEventListener('blur', blurred);
        }

        $('body').removeData('disable-cloaked-view');
      };

      var blurred = _.debounce(blurredNow, 250);

      var positioningHack = function (evt) {

        var self = this;
        done = false;

        // we need this, otherwise changing focus means we never clear
        self.addEventListener('blur', blurred);

        if (fixedElement.style.top === '0px') {
          if (this !== document.activeElement) {
            evt.preventDefault();
            self.focus();
          }
          return;
        }

        originalScrollTop = $(window).scrollTop();

        // take care of body

        $('body').data('disable-cloaked-view', true);
        $('#main-outlet').hide();
        $('header').hide();

        $(window).scrollTop(0);

        fixedElement.style.top = '0px';

        fixedElement.style.height = parseInt(window.innerHeight * 0.6) + "px";

        // I used to do this, but it seems like we don't need to with position
        // fixed
        // setTimeout(()=>$(window).scrollTop(0),500);

        evt.preventDefault();
        self.focus();
      };

      function attachTouchStart(elem, fn) {
        if (!$(elem).data('listening')) {
          elem.addEventListener('touchstart', fn);
          $(elem).data('listening', true);
        }
      }

      var checkForInputs = _.debounce(function () {
        $fixedElement.find('button,a:not(.mobile-file-upload)').each(function (idx, elem) {
          if ($(elem).parents('.autocomplete').length > 0) {
            return;
          }

          attachTouchStart(this, function (evt) {
            done = true;
            $(document.activeElement).blur();
            evt.preventDefault();
            $(this).click();
          });
        });
        $fixedElement.find('input[type=text],textarea').each(function () {
          attachTouchStart(this, positioningHack);
        });
      }, 100);

      fixedElement.addEventListener('DOMNodeInserted', checkForInputs);
    }

    __exports__["default"] = positioningWorkaround;
  });define("discourse/adapters/email-template", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      basePath: function () {
        return "/admin/customize/";
      }
    });
  });define("discourse/adapters/notification", 
  ["discourse/adapters/rest","discourse/mixins/stale-local-storage","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];
    var StaleLocalStorage = __dependency2__["default"];

    __exports__["default"] = RestAdapter.extend(StaleLocalStorage);
  });define("discourse/adapters/post", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];
    var Result = __dependency1__.Result;

    __exports__["default"] = RestAdapter.extend({

      find: function (store, type, findArgs) {
        return this._super(store, type, findArgs).then(function (result) {
          return { post: result };
        });
      },

      createRecord: function (store, type, args) {
        var typeField = Ember.String.underscore(type);
        args.nested_post = true;
        return Discourse.ajax(this.pathFor(store, type), { method: 'POST', data: args }).then(function (json) {
          return new Result(json[typeField], json);
        });
      }

    });
  });define("discourse/adapters/rest", 
  ["discourse/lib/stale-result","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.Result = Result;
    var StaleResult = __dependency1__["default"];
    var ADMIN_MODELS = ['plugin', 'site-customization', 'embeddable-host'];

    function Result(payload, responseJson) {
      this.payload = payload;
      this.responseJson = responseJson;
      this.target = null;
    }

    var ajax = Discourse.ajax;

    // We use this to make sure 404s are caught
    function rethrow(error) {
      if (error.status === 404) {
        throw "404: " + error.responseText;
      }
      throw error;
    }

    __exports__["default"] = Ember.Object.extend({

      basePath: function (store, type) {
        if (ADMIN_MODELS.indexOf(type.replace('_', '-')) !== -1) {
          return "/admin/";
        }
        return "/";
      },

      appendQueryParams: function (path, findArgs) {
        if (findArgs) {
          if (typeof findArgs === "object") {
            var queryString = Object.keys(findArgs).reject(function (k) {
              return !findArgs[k];
            }).map(function (k) {
              return k + "=" + encodeURIComponent(findArgs[k]);
            });

            if (queryString.length) {
              return path + "?" + queryString.join('&');
            }
          } else {
            // It's serializable as a string if not an object
            return path + "/" + findArgs;
          }
        }
        return path;
      },

      pathFor: function (store, type, findArgs) {
        var path = this.basePath(store, type, findArgs) + Ember.String.underscore(store.pluralize(type));
        return this.appendQueryParams(path, findArgs);
      },

      findAll: function (store, type) {
        return ajax(this.pathFor(store, type)).catch(rethrow);
      },

      find: function (store, type, findArgs) {
        return ajax(this.pathFor(store, type, findArgs)).catch(rethrow);
      },

      findStale: function () {
        return new StaleResult();
      },

      update: function (store, type, id, attrs) {
        var data = {};
        var typeField = Ember.String.underscore(type);
        data[typeField] = attrs;
        return ajax(this.pathFor(store, type, id), { method: 'PUT', data: data }).then(function (json) {
          return new Result(json[typeField], json);
        });
      },

      createRecord: function (store, type, attrs) {
        var data = {};
        var typeField = Ember.String.underscore(type);
        data[typeField] = attrs;
        return ajax(this.pathFor(store, type), { method: 'POST', data: data }).then(function (json) {
          return new Result(json[typeField], json);
        });
      },

      destroyRecord: function (store, type, record) {
        return ajax(this.pathFor(store, type, record.get('id')), { method: 'DELETE' });
      }

    });
  });define("discourse/adapters/topic-list", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.finderFor = finderFor;
    var RestAdapter = __dependency1__["default"];

    function finderFor(filter, params) {
      return function () {
        var url = Discourse.getURL("/") + filter + ".json";

        if (params) {
          (function () {
            var keys = Object.keys(params),
                encoded = [];

            keys.forEach(function (p) {
              var value = encodeURI(params[p]);
              if (typeof value !== 'undefined') {
                encoded.push(p + "=" + value);
              }
            });

            if (encoded.length > 0) {
              url += "?" + encoded.join('&');
            }
          })();
        }
        return Discourse.ajax(url);
      };
    }

    __exports__["default"] = RestAdapter.extend({

      find: function (store, type, findArgs) {
        var filter = findArgs.filter;
        var params = findArgs.params;

        return PreloadStore.getAndRemove("topic_list_" + filter, finderFor(filter, params)).then(function (result) {
          result.filter = filter;
          result.params = params;
          return result;
        });
      }
    });
  });define("discourse/adapters/topic", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      find: function (store, type, findArgs) {
        if (findArgs.similar) {
          return Discourse.ajax("/topics/similar_to", { data: findArgs.similar });
        } else {
          return this._super(store, type, findArgs);
        }
      }
    });
  });define("discourse/models/result-set", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayProxy.extend({
      loading: false,
      loadingMore: false,
      totalRows: 0,
      refreshing: false,

      content: null,
      loadMoreUrl: null,
      refreshUrl: null,
      findArgs: null,
      store: null,
      __type: null,

      canLoadMore: (function () {
        return this.get('length') < this.get('totalRows');
      }).property('totalRows', 'length'),

      loadMore: function () {
        var _this = this;

        var loadMoreUrl = this.get('loadMoreUrl');
        if (!loadMoreUrl) {
          return;
        }

        var totalRows = this.get('totalRows');
        if (this.get('length') < totalRows && !this.get('loadingMore')) {
          var _ret = (function () {
            _this.set('loadingMore', true);

            var self = _this;
            return {
              v: _this.store.appendResults(_this, _this.get('__type'), loadMoreUrl).finally(function () {
                self.set('loadingMore', false);
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }

        return Ember.RSVP.resolve();
      },

      refresh: function () {
        if (this.get('refreshing')) {
          return;
        }

        var refreshUrl = this.get('refreshUrl');
        if (!refreshUrl) {
          return;
        }

        var self = this;
        this.set('refreshing', true);
        return this.store.refreshResults(this, this.get('__type'), refreshUrl).finally(function () {
          self.set('refreshing', false);
        });
      }
    });
  });define("discourse/models/store", 
  ["discourse/models/rest","discourse/models/result-set","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var ResultSet = __dependency2__["default"];

    var _identityMap = undefined;

    // You should only call this if you're a test scaffold
    function flushMap() {
      _identityMap = {};
    }

    function storeMap(type, id, obj) {
      if (!id) {
        return;
      }

      _identityMap[type] = _identityMap[type] || {};
      _identityMap[type][id] = obj;
    }

    function fromMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        return byType[id];
      }
    }

    function removeMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        delete byType[id];
      }
    }

    function findAndRemoveMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        var result = byType[id];
        delete byType[id];
        return result;
      }
    }

    flushMap();

    __exports__["default"] = Ember.Object.extend({
      _plurals: {},
      pluralize: function (thing) {
        return this._plurals[thing] || thing + "s";
      },

      addPluralization: function (thing, plural) {
        this._plurals[thing] = plural;
      },

      findAll: function (type) {
        var self = this;
        return this.adapterFor(type).findAll(this, type).then(function (result) {
          return self._resultSet(type, result);
        });
      },

      // Mostly for legacy, things like TopicList without ResultSets
      findFiltered: function (type, findArgs) {
        var self = this;
        return this.adapterFor(type).find(this, type, findArgs).then(function (result) {
          return self._build(type, result);
        });
      },

      _hydrateFindResults: function (result, type, findArgs) {
        if (typeof findArgs === "object") {
          return this._resultSet(type, result, findArgs);
        } else {
          return this._hydrate(type, result[Ember.String.underscore(type)], result);
        }
      },

      // See if the store can find stale data. We sometimes prefer to show stale data and
      // refresh it in the background.
      findStale: function (type, findArgs, opts) {
        var _this = this;

        var stale = this.adapterFor(type).findStale(this, type, findArgs, opts);
        if (stale.hasResults) {
          stale.results = this._hydrateFindResults(stale.results, type, findArgs);
        }
        stale.refresh = function () {
          return _this.find(type, findArgs, opts);
        };
        return stale;
      },

      find: function (type, findArgs, opts) {
        var _this2 = this;

        return this.adapterFor(type).find(this, type, findArgs, opts).then(function (result) {
          return _this2._hydrateFindResults(result, type, findArgs, opts);
        });
      },

      refreshResults: function (resultSet, type, url) {
        var self = this;
        return Discourse.ajax(url).then(function (result) {
          var typeName = Ember.String.underscore(self.pluralize(type));
          var content = result[typeName].map(function (obj) {
            return self._hydrate(type, obj, result);
          });
          resultSet.set('content', content);
        });
      },

      appendResults: function (resultSet, type, url) {
        var self = this;

        return Discourse.ajax(url).then(function (result) {
          var typeName = Ember.String.underscore(self.pluralize(type)),
              totalRows = result["total_rows_" + typeName] || result.get('totalRows'),
              loadMoreUrl = result["load_more_" + typeName],
              content = result[typeName].map(function (obj) {
            return self._hydrate(type, obj, result);
          });

          resultSet.setProperties({ totalRows: totalRows, loadMoreUrl: loadMoreUrl });
          resultSet.get('content').pushObjects(content);

          // If we've loaded them all, clear the load more URL
          if (resultSet.get('length') >= totalRows) {
            resultSet.set('loadMoreUrl', null);
          }
        });
      },

      update: function (type, id, attrs) {
        return this.adapterFor(type).update(this, type, id, attrs, function (result) {
          if (result && result[type] && result[type].id) {
            var oldRecord = findAndRemoveMap(type, id);
            storeMap(type, result[type].id, oldRecord);
          }
          return result;
        });
      },

      createRecord: function (type, attrs) {
        attrs = attrs || {};
        return !!attrs.id ? this._hydrate(type, attrs) : this._build(type, attrs);
      },

      destroyRecord: function (type, record) {
        // If the record is new, don't perform an Ajax call
        if (record.get('isNew')) {
          removeMap(type, record.get('id'));
          return Ember.RSVP.Promise.resolve(true);
        }

        return this.adapterFor(type).destroyRecord(this, type, record).then(function (result) {
          removeMap(type, record.get('id'));
          return result;
        });
      },

      _resultSet: function (type, result, findArgs) {
        var _this3 = this;

        var typeName = Ember.String.underscore(this.pluralize(type));
        var content = result[typeName].map(function (obj) {
          return _this3._hydrate(type, obj, result);
        });

        var createArgs = {
          content: content,
          findArgs: findArgs,
          totalRows: result["total_rows_" + typeName] || content.length,
          loadMoreUrl: result["load_more_" + typeName],
          refreshUrl: result['refresh_' + typeName],
          store: this,
          __type: type
        };

        if (result.extras) {
          createArgs.extras = result.extras;
        }

        return ResultSet.create(createArgs);
      },

      _build: function (type, obj) {
        obj.store = this;
        obj.__type = type;
        obj.__state = obj.id ? "created" : "new";

        // TODO: Have injections be automatic
        obj.topicTrackingState = this.container.lookup('topic-tracking-state:main');
        obj.keyValueStore = this.container.lookup('key-value-store:main');

        var klass = this.container.lookupFactory('model:' + type) || RestModel;
        var model = klass.create(obj);

        storeMap(type, obj.id, model);
        return model;
      },

      adapterFor: function (type) {
        return this.container.lookup('adapter:' + type) || this.container.lookup('adapter:rest');
      },

      _lookupSubType: function (subType, type, id, root) {
        var _this4 = this;

        // cheat: we know we already have categories in memory
        // TODO: topics do their own resolving of `category_id`
        // to category. That should either respect this or be
        // removed.
        if (subType === 'category' && type !== 'topic') {
          return Discourse.Category.findById(id);
        }

        var pluralType = this.pluralize(subType);
        var collection = root[this.pluralize(subType)];
        if (collection) {
          var _ret = (function () {
            var hashedProp = "__hashed_" + pluralType;
            var hashedCollection = root[hashedProp];
            if (!hashedCollection) {
              hashedCollection = {};
              collection.forEach(function (it) {
                hashedCollection[it.id] = it;
              });
              root[hashedProp] = hashedCollection;
            }

            var found = hashedCollection[id];
            if (found) {
              var hydrated = _this4._hydrate(subType, found, root);
              hashedCollection[id] = hydrated;
              return {
                v: hydrated
              };
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      },

      _hydrateEmbedded: function (type, obj, root) {
        var self = this;
        Object.keys(obj).forEach(function (k) {
          var m = /(.+)\_id(s?)$/.exec(k);
          if (m) {
            (function () {
              var subType = m[1];

              if (m[2]) {
                var hydrated = obj[k].map(function (id) {
                  return self._lookupSubType(subType, type, id, root);
                });
                obj[self.pluralize(subType)] = hydrated || [];
                delete obj[k];
              } else {
                var hydrated = self._lookupSubType(subType, type, obj[k], root);
                if (hydrated) {
                  obj[subType] = hydrated;
                  delete obj[k];
                }
              }
            })();
          }
        });
      },

      _hydrate: function (type, obj, root) {
        if (!obj) {
          throw "Can't hydrate " + type + " of `null`";
        }
        if (!obj.id) {
          throw "Can't hydrate " + type + " without an `id`";
        }

        root = root || obj;

        // Experimental: If serialized with a certain option we'll wire up embedded objects
        // automatically.
        if (root.__rest_serializer === "1") {
          this._hydrateEmbedded(type, obj, root);
        }

        var existing = fromMap(type, obj.id);
        if (existing === obj) {
          return existing;
        }

        if (existing) {
          delete obj.id;
          var klass = this.container.lookupFactory('model:' + type) || RestModel;
          existing.setProperties(klass.munge(obj));
          return existing;
        }

        return this._build(type, obj);
      }
    });

    __exports__.flushMap = flushMap;
  });define("discourse/models/post-action-type", 
  ["discourse/models/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];

    var PostActionType = RestModel.extend({
      notCustomFlag: Em.computed.not('is_custom_flag')
    });

    var MAX_MESSAGE_LENGTH = 500;

    __exports__.MAX_MESSAGE_LENGTH = MAX_MESSAGE_LENGTH;
    __exports__["default"] = PostActionType;
  });define("discourse/models/action-summary", 
  ["discourse/models/rest","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var popupAjaxError = __dependency2__.popupAjaxError;

    __exports__["default"] = RestModel.extend({

      // Description for the action
      description: (function () {
        var action = this.get('actionType.name_key');
        if (this.get('acted')) {
          if (this.get('count') <= 1) {
            return I18n.t('post.actions.by_you.' + action);
          } else {
            return I18n.t('post.actions.by_you_and_others.' + action, { count: this.get('count') - 1 });
          }
        } else {
          return I18n.t('post.actions.by_others.' + action, { count: this.get('count') });
        }
      }).property('count', 'acted', 'actionType'),

      canToggle: (function () {
        return this.get('can_undo') || this.get('can_act');
      }).property('can_undo', 'can_act'),

      // Remove it
      removeAction: function () {
        this.setProperties({
          acted: false,
          count: this.get('count') - 1,
          can_act: true,
          can_undo: false
        });
      },

      toggle: function (post) {
        if (!this.get('acted')) {
          this.act(post);
          return true;
        } else {
          this.undo(post);
          return false;
        }
      },

      // Perform this action
      act: function (post, opts) {

        if (!opts) opts = {};

        var action = this.get('actionType.name_key');

        // Mark it as acted
        this.setProperties({
          acted: true,
          count: this.get('count') + 1,
          can_act: false,
          can_undo: true
        });

        if (action === 'notify_moderators' || action === 'notify_user') {
          this.set('can_undo', false);
          this.set('can_defer_flags', false);
        }

        // Create our post action
        var self = this;
        return Discourse.ajax("/post_actions", {
          type: 'POST',
          data: {
            id: this.get('flagTopic') ? this.get('flagTopic.id') : post.get('id'),
            post_action_type_id: this.get('id'),
            message: opts.message,
            take_action: opts.takeAction,
            flag_topic: this.get('flagTopic') ? true : false
          }
        }).then(function (result) {
          if (!self.get('flagTopic')) {
            return post.updateActionsSummary(result);
          }
        }).catch(function (error) {
          popupAjaxError(error);
          self.removeAction(post);
        });
      },

      // Undo this action
      undo: function (post) {
        this.removeAction(post);

        // Remove our post action
        return Discourse.ajax("/post_actions/" + post.get('id'), {
          type: 'DELETE',
          data: {
            post_action_type_id: this.get('id')
          }
        }).then(function (result) {
          return post.updateActionsSummary(result);
        });
      },

      deferFlags: function (post) {
        var self = this;
        return Discourse.ajax("/post_actions/defer_flags", {
          type: "POST",
          data: {
            post_action_type_id: this.get("id"),
            id: post.get('id')
          }
        }).then(function () {
          self.set("count", 0);
        });
      },

      loadUsers: function (post) {
        return this.store.find('post-action-user', {
          id: post.get('id'),
          post_action_type_id: this.get('id')
        });
      }
    });
  });define("discourse/models/post", 
  ["discourse/models/rest","discourse/lib/ajax-error","discourse/models/action-summary","discourse/lib/computed","discourse/lib/quote","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var popupAjaxError = __dependency2__.popupAjaxError;
    var ActionSummary = __dependency3__["default"];
    var url = __dependency4__.url;
    var propertyEqual = __dependency4__.propertyEqual;
    var Quote = __dependency5__["default"];
    var computed = __dependency6__["default"];

    var Post = RestModel.extend(_createDecoratedObject([{
      key: 'init',
      value: function () {
        this.set('replyHistory', []);
      }
    }, {
      key: 'siteSettings',
      decorators: [computed()],
      value: function () {
        // TODO: Remove this once one instantiate all `Discourse.Post` models via the store.
        return Discourse.SiteSettings;
      }
    }, {
      key: 'shareUrl',
      initializer: function () {
        return (function () {
          var user = Discourse.User.current();
          var userSuffix = user ? '?u=' + user.get('username_lower') : '';

          if (this.get('firstPost')) {
            return this.get('topic.url') + userSuffix;
          } else {
            return this.get('url') + userSuffix;
          }
        }).property('url');
      }
    }, {
      key: 'new_user',
      initializer: function () {
        return Em.computed.equal('trust_level', 0);
      }
    }, {
      key: 'firstPost',
      initializer: function () {
        return Em.computed.equal('post_number', 1);
      }
    }, {
      key: 'deletedViaTopic',

      // Posts can show up as deleted if the topic is deleted
      initializer: function () {
        return Em.computed.and('firstPost', 'topic.deleted_at');
      }
    }, {
      key: 'deleted',
      initializer: function () {
        return Em.computed.or('deleted_at', 'deletedViaTopic');
      }
    }, {
      key: 'notDeleted',
      initializer: function () {
        return Em.computed.not('deleted');
      }
    }, {
      key: 'userDeleted',
      initializer: function () {
        return Em.computed.empty('user_id');
      }
    }, {
      key: 'hasTimeGap',
      initializer: function () {
        return (function () {
          return (this.get('daysSincePrevious') || 0) > Discourse.SiteSettings.show_time_gap_days;
        }).property('daysSincePrevious');
      }
    }, {
      key: 'showName',
      initializer: function () {
        return (function () {
          var name = this.get('name');
          return name && name !== this.get('username') && Discourse.SiteSettings.display_name_on_posts;
        }).property('name', 'username');
      }
    }, {
      key: 'postDeletedBy',
      initializer: function () {
        return (function () {
          if (this.get('firstPost')) {
            return this.get('topic.deleted_by');
          }
          return this.get('deleted_by');
        }).property('firstPost', 'deleted_by', 'topic.deleted_by');
      }
    }, {
      key: 'postDeletedAt',
      initializer: function () {
        return (function () {
          if (this.get('firstPost')) {
            return this.get('topic.deleted_at');
          }
          return this.get('deleted_at');
        }).property('firstPost', 'deleted_at', 'topic.deleted_at');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          return Discourse.Utilities.postUrl(this.get('topic.slug') || this.get('topic_slug'), this.get('topic_id'), this.get('post_number'));
        }).property('post_number', 'topic_id', 'topic.slug');
      }
    }, {
      key: 'urlWithNumber',
      decorators: [computed('post_number', 'url')],
      value: function (postNumber, postUrl) {
        return postNumber === 1 ? postUrl + "/1" : postUrl;
      }
    }, {
      key: 'usernameUrl',
      initializer: function () {
        return url('username', '/users/%@');
      }
    }, {
      key: 'showUserReplyTab',
      initializer: function () {
        return (function () {
          return this.get('reply_to_user') && (!Discourse.SiteSettings.suppress_reply_directly_above || this.get('reply_to_post_number') < this.get('post_number') - 1);
        }).property('reply_to_user', 'reply_to_post_number', 'post_number');
      }
    }, {
      key: 'topicOwner',
      initializer: function () {
        return propertyEqual('topic.details.created_by.id', 'user_id');
      }
    }, {
      key: 'hasHistory',
      initializer: function () {
        return Em.computed.gt('version', 1);
      }
    }, {
      key: 'canViewRawEmail',
      initializer: function () {
        return (function () {
          return this.get("user_id") === Discourse.User.currentProp("id") || Discourse.User.currentProp('staff');
        }).property("user_id");
      }
    }, {
      key: 'updatePostField',
      value: function (field, value) {
        var _this = this;

        var data = {};
        data[field] = value;

        Discourse.ajax('/posts/' + this.get('id') + '/' + field, { type: 'PUT', data: data }).then(function () {
          _this.set(field, value);
          _this.incrementProperty("version");
        }).catch(popupAjaxError);
      }
    }, {
      key: 'internalLinks',
      initializer: function () {
        return (function () {
          if (Ember.isEmpty(this.get('link_counts'))) return null;
          return this.get('link_counts').filterProperty('internal').filterProperty('title');
        }).property('link_counts.@each.internal');
      }
    }, {
      key: 'editCount',

      // Edits are the version - 1, so version 2 = 1 edit
      initializer: function () {
        return (function () {
          return this.get('version') - 1;
        }).property('version');
      }
    }, {
      key: 'flagsAvailable',
      initializer: function () {
        return (function () {
          var post = this;
          return Discourse.Site.currentProp('flagTypes').filter(function (item) {
            return post.get("actionByName." + item.get('name_key') + ".can_act");
          });
        }).property('actions_summary.@each.can_act');
      }
    }, {
      key: 'actionsWithoutLikes',
      initializer: function () {
        return (function () {
          if (!!Ember.isEmpty(this.get('actions_summary'))) return null;

          return this.get('actions_summary').filter(function (i) {
            if (i.get('count') === 0) return false;
            if (i.get('actionType.name_key') === 'like') {
              return false;
            }
            if (i.get('users') && i.get('users').length > 0) return true;
            return !i.get('hidden');
          });
        }).property('actions_summary.@each.users', 'actions_summary.@each.count');
      }
    }, {
      key: 'afterUpdate',
      value: function (res) {
        if (res.category) {
          Discourse.Site.current().updateCategory(res.category);
        }
      }
    }, {
      key: 'updateProperties',
      value: function () {
        return {
          post: { raw: this.get('raw'), edit_reason: this.get('editReason') },
          image_sizes: this.get('imageSizes')
        };
      }
    }, {
      key: 'createProperties',
      value: function () {
        // composer only used once, defer the dependency
        var Composer = require('discourse/models/composer').default;
        var data = this.getProperties(Composer.serializedFieldsForCreate());
        data.reply_to_post_number = this.get('reply_to_post_number');
        data.image_sizes = this.get('imageSizes');

        var metaData = this.get('metaData');

        // Put the metaData into the request
        if (metaData) {
          data.meta_data = {};
          Ember.keys(metaData).forEach(function (key) {
            data.meta_data[key] = metaData.get(key);
          });
        }

        return data;
      }
    }, {
      key: 'expand',

      // Expands the first post's content, if embedded and shortened.
      value: function () {
        var self = this;
        return Discourse.ajax("/posts/" + this.get('id') + "/expand-embed").then(function (post) {
          self.set('cooked', "<section class='expanded-embed'>" + post.cooked + "</section>");
        });
      }
    }, {
      key: 'recover',

      // Recover a deleted post
      value: function () {
        var post = this,
            initProperties = post.getProperties('deleted_at', 'deleted_by', 'user_deleted', 'can_delete');

        post.setProperties({
          deleted_at: null,
          deleted_by: null,
          user_deleted: false,
          can_delete: false
        });

        return Discourse.ajax("/posts/" + this.get('id') + "/recover", { type: 'PUT', cache: false }).then(function (data) {
          post.setProperties({
            cooked: data.cooked,
            raw: data.raw,
            user_deleted: false,
            can_delete: true,
            version: data.version
          });
        }).catch(function (error) {
          popupAjaxError(error);
          post.setProperties(initProperties);
        });
      }
    }, {
      key: 'setDeletedState',

      /**
        Changes the state of the post to be deleted. Does not call the server, that should be
        done elsewhere.
      **/
      value: function (deletedBy) {
        this.set('oldCooked', this.get('cooked'));

        // Moderators can delete posts. Users can only trigger a deleted at message, unless delete_removed_posts_after is 0.
        if (deletedBy.get('staff') || Discourse.SiteSettings.delete_removed_posts_after === 0) {
          this.setProperties({
            deleted_at: new Date(),
            deleted_by: deletedBy,
            can_delete: false
          });
        } else {
          this.setProperties({
            cooked: Discourse.Markdown.cook(I18n.t("post.deleted_by_author", { count: Discourse.SiteSettings.delete_removed_posts_after })),
            can_delete: false,
            version: this.get('version') + 1,
            can_recover: true,
            can_edit: false,
            user_deleted: true
          });
        }
      }
    }, {
      key: 'undoDeleteState',

      /**
        Changes the state of the post to NOT be deleted. Does not call the server.
        This can only be called after setDeletedState was called, but the delete
        failed on the server.
      **/
      value: function () {
        if (this.get('oldCooked')) {
          this.setProperties({
            deleted_at: null,
            deleted_by: null,
            cooked: this.get('oldCooked'),
            version: this.get('version') - 1,
            can_recover: false,
            can_delete: true,
            user_deleted: false
          });
        }
      }
    }, {
      key: 'destroy',
      value: function (deletedBy) {
        this.setDeletedState(deletedBy);
        return Discourse.ajax("/posts/" + this.get('id'), {
          data: { context: window.location.pathname },
          type: 'DELETE'
        });
      }
    }, {
      key: 'updateFromPost',

      /**
        Updates a post from another's attributes. This will normally happen when a post is loading but
        is already found in an identity map.
      **/
      value: function (otherPost) {
        var self = this;
        Object.keys(otherPost).forEach(function (key) {
          var value = otherPost[key],
              oldValue = self[key];

          if (key === "replyHistory") {
            return;
          }

          if (!value) {
            value = null;
          }
          if (!oldValue) {
            oldValue = null;
          }

          var skip = false;
          if (typeof value !== "function" && oldValue !== value) {
            // wishing for an identity map
            if (key === "reply_to_user" && value && oldValue) {
              skip = value.username === oldValue.username || Em.get(value, "username") === Em.get(oldValue, "username");
            }

            if (!skip) {
              self.set(key, value);
            }
          }
        });
      }
    }, {
      key: 'loadReplies',

      // Load replies to this post
      value: function () {
        if (this.get('loadingReplies')) {
          return;
        }

        this.set('loadingReplies', true);
        this.set('replies', []);

        var self = this;
        return Discourse.ajax("/posts/" + this.get('id') + "/replies").then(function (loaded) {
          var replies = self.get('replies');
          _.each(loaded, function (reply) {
            var post = Discourse.Post.create(reply);
            post.set('topic', self.get('topic'));
            replies.pushObject(post);
          });
        })['finally'](function () {
          self.set('loadingReplies', false);
        });
      }
    }, {
      key: 'showRepliesBelow',

      // Whether to show replies directly below
      initializer: function () {
        return (function () {
          var replyCount = this.get('reply_count');

          // We don't show replies if there aren't any
          if (replyCount === 0) return false;

          // Always show replies if the setting `suppress_reply_directly_below` is false.
          if (!Discourse.SiteSettings.suppress_reply_directly_below) return true;

          // Always show replies if there's more than one
          if (replyCount > 1) return true;

          // If we have *exactly* one reply, we have to consider if it's directly below us
          var topic = this.get('topic');
          return !topic.isReplyDirectlyBelow(this);
        }).property('reply_count');
      }
    }, {
      key: 'expandHidden',
      value: function () {
        var self = this;
        return Discourse.ajax("/posts/" + this.get('id') + "/cooked.json").then(function (result) {
          self.setProperties({
            cooked: result.cooked,
            cooked_hidden: false
          });
        });
      }
    }, {
      key: 'rebake',
      value: function () {
        return Discourse.ajax("/posts/" + this.get("id") + "/rebake", { type: "PUT" });
      }
    }, {
      key: 'unhide',
      value: function () {
        return Discourse.ajax("/posts/" + this.get("id") + "/unhide", { type: "PUT" });
      }
    }, {
      key: 'toggleBookmark',
      value: function () {
        var self = this;
        var bookmarkedTopic = undefined;

        this.toggleProperty("bookmarked");

        if (this.get("bookmarked") && !this.get("topic.bookmarked")) {
          this.set("topic.bookmarked", true);
          bookmarkedTopic = true;
        }

        // need to wait to hear back from server (stuff may not be loaded)

        return Discourse.Post.updateBookmark(this.get('id'), this.get('bookmarked')).then(function (result) {
          self.set("topic.bookmarked", result.topic_bookmarked);
        }).catch(function (e) {
          self.toggleProperty("bookmarked");
          if (bookmarkedTopic) {
            self.set("topic.bookmarked", false);
          }
          throw e;
        });
      }
    }, {
      key: 'updateActionsSummary',
      value: function (json) {
        if (json && json.id === this.get('id')) {
          json = Post.munge(json);
          this.set('actions_summary', json.actions_summary);
        }
      }
    }]));

    Post.reopenClass({

      munge: function (json) {
        if (json.actions_summary) {
          (function () {
            var lookup = Em.Object.create();

            // this area should be optimized, it is creating way too many objects per post
            json.actions_summary = json.actions_summary.map(function (a) {
              a.actionType = Discourse.Site.current().postActionTypeById(a.id);
              a.count = a.count || 0;
              var actionSummary = ActionSummary.create(a);
              lookup[a.actionType.name_key] = actionSummary;

              if (a.actionType.name_key === "like") {
                json.likeAction = actionSummary;
              }
              return actionSummary;
            });

            json.actionByName = lookup;
          })();
        }

        if (json && json.reply_to_user) {
          json.reply_to_user = Discourse.User.create(json.reply_to_user);
        }
        return json;
      },

      updateBookmark: function (postId, bookmarked) {
        return Discourse.ajax("/posts/" + postId + "/bookmark", {
          type: 'PUT',
          data: { bookmarked: bookmarked }
        });
      },

      deleteMany: function (selectedPosts, selectedReplies) {
        return Discourse.ajax("/posts/destroy_many", {
          type: 'DELETE',
          data: {
            post_ids: selectedPosts.map(function (p) {
              return p.get('id');
            }),
            reply_post_ids: selectedReplies.map(function (p) {
              return p.get('id');
            })
          }
        });
      },

      loadRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + ".json").then(function (result) {
          return Ember.Object.create(result);
        });
      },

      hideRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + "/hide", { type: 'PUT' });
      },

      showRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + "/show", { type: 'PUT' });
      },

      loadQuote: function (postId) {
        return Discourse.ajax("/posts/" + postId + ".json").then(function (result) {
          var post = Discourse.Post.create(result);
          return Quote.build(post, post.get('raw'), { raw: true, full: true });
        });
      },

      loadRawEmail: function (postId) {
        return Discourse.ajax("/posts/" + postId + "/raw-email").then(function (result) {
          return result.raw_email;
        });
      }

    });

    __exports__["default"] = Post;

    // Don't drop the /1
  });

Discourse.Post = require('discourse/models/post').default;
define("discourse/lib/posts-with-placeholders", 
  ["discourse/views/cloaked","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var Placeholder = __dependency1__.Placeholder;
    var computed = __dependency2__.default;

    __exports__["default"] = Ember.Object.extend(Ember.Array, _createDecoratedObject([{
      key: 'posts',
      initializer: function () {
        return null;
      }
    }, {
      key: '_appendingIds',
      initializer: function () {
        return null;
      }
    }, {
      key: 'init',
      value: function () {
        this._appendingIds = {};
      }
    }, {
      key: 'length',
      decorators: [computed],
      value: function () {
        return this.get('posts.length') + Object.keys(this._appendingIds || {}).length;
      }
    }, {
      key: '_changeArray',
      value: function (cb, offset, removed, inserted) {
        this.arrayContentWillChange(offset, removed, inserted);
        cb();
        this.arrayContentDidChange(offset, removed, inserted);
        this.propertyDidChange('length');
      }
    }, {
      key: 'clear',
      value: function (cb) {
        this._changeArray(cb, 0, this.get('posts.length'), 0);
      }
    }, {
      key: 'appendPost',
      value: function (cb) {
        this._changeArray(cb, this.get('posts.length'), 0, 1);
      }
    }, {
      key: 'removePost',
      value: function (cb) {
        this._changeArray(cb, this.get('posts.length') - 1, 1, 0);
      }
    }, {
      key: 'appending',
      value: function (postIds) {
        var _this = this;

        this._changeArray(function () {
          var appendingIds = _this._appendingIds;
          postIds.forEach(function (pid) {
            return appendingIds[pid] = true;
          });
        }, this.get('length'), 0, postIds.length);
      }
    }, {
      key: 'finishedAppending',
      value: function (postIds) {
        var _this2 = this;

        this._changeArray(function () {
          var appendingIds = _this2._appendingIds;
          postIds.forEach(function (pid) {
            return delete appendingIds[pid];
          });
        }, this.get('posts.length') - postIds.length, postIds.length, postIds.length);
      }
    }, {
      key: 'finishedPrepending',
      value: function (postIds) {
        this._changeArray(Ember.K, 0, 0, postIds.length);
      }
    }, {
      key: 'objectAt',
      value: function (index) {
        var posts = this.get('posts');
        return index < posts.length ? posts[index] : new Placeholder('post-placeholder');
      }
    }]));
  });define("discourse/models/post-stream", 
  ["discourse/lib/url","discourse/models/rest","discourse/lib/posts-with-placeholders","ember-addons/ember-computed-decorators","discourse/models/topic","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var DiscourseURL = __dependency1__["default"];
    var RestModel = __dependency2__["default"];
    var PostsWithPlaceholders = __dependency3__["default"];
    var computed = __dependency4__.default;
    var loadTopicView = __dependency5__.loadTopicView;

    function calcDayDiff(p1, p2) {
      if (!p1) {
        return;
      }

      var date = p1.get('created_at');
      if (date && p2) {
        var lastDate = p2.get('created_at');
        if (lastDate) {
          var delta = new Date(date).getTime() - new Date(lastDate).getTime();
          var days = Math.round(delta / (1000 * 60 * 60 * 24));

          p1.set('daysSincePrevious', days);
        }
      }
    }

    __exports__["default"] = RestModel.extend(_createDecoratedObject([{
      key: '_identityMap',
      initializer: function () {
        return null;
      }
    }, {
      key: 'posts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'stream',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFilters',
      initializer: function () {
        return null;
      }
    }, {
      key: 'summary',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loaded',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingAbove',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingBelow',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingFilter',
      initializer: function () {
        return null;
      }
    }, {
      key: 'stagingPost',
      initializer: function () {
        return null;
      }
    }, {
      key: 'postsWithPlaceholders',
      initializer: function () {
        return null;
      }
    }, {
      key: 'init',
      value: function () {
        this._identityMap = {};
        var posts = [];
        var postsWithPlaceholders = PostsWithPlaceholders.create({ posts: posts, store: this.store });

        this.setProperties({
          posts: posts,
          postsWithPlaceholders: postsWithPlaceholders,
          stream: [],
          userFilters: [],
          summary: false,
          loaded: false,
          loadingAbove: false,
          loadingBelow: false,
          loadingFilter: false,
          stagingPost: false
        });
      }
    }, {
      key: 'loading',
      initializer: function () {
        return Ember.computed.or('loadingAbove', 'loadingBelow', 'loadingFilter', 'stagingPost');
      }
    }, {
      key: 'notLoading',
      initializer: function () {
        return Ember.computed.not('loading');
      }
    }, {
      key: 'filteredPostsCount',
      initializer: function () {
        return Ember.computed.alias("stream.length");
      }
    }, {
      key: 'hasPosts',
      decorators: [computed('posts.@each')],
      value: function () {
        return this.get('posts.length') > 0;
      }
    }, {
      key: 'hasLoadedData',
      decorators: [computed('hasPosts', 'filteredPostsCount')],
      value: function (hasPosts, filteredPostsCount) {
        return hasPosts && filteredPostsCount > 0;
      }
    }, {
      key: 'canAppendMore',
      initializer: function () {
        return Ember.computed.and('notLoading', 'hasPosts', 'lastPostNotLoaded');
      }
    }, {
      key: 'canPrependMore',
      initializer: function () {
        return Ember.computed.and('notLoading', 'hasPosts', 'firstPostNotLoaded');
      }
    }, {
      key: 'firstPostPresent',
      decorators: [computed('hasLoadedData', 'firstPostId', 'posts.@each')],
      value: function (hasLoadedData, firstPostId) {
        if (!hasLoadedData) {
          return false;
        }
        return !!this.get('posts').findProperty('id', firstPostId);
      }
    }, {
      key: 'firstPostNotLoaded',
      initializer: function () {
        return Ember.computed.not('firstPostPresent');
      }
    }, {
      key: 'firstPostId',
      initializer: function () {
        return Ember.computed.alias('stream.firstObject');
      }
    }, {
      key: 'lastPostId',
      initializer: function () {
        return Ember.computed.alias('stream.lastObject');
      }
    }, {
      key: 'loadedAllPosts',
      decorators: [computed('hasLoadedData', 'lastPostId', 'posts.@each.id')],
      value: function (hasLoadedData, lastPostId) {
        if (!hasLoadedData) {
          return false;
        }
        if (lastPostId === -1) {
          return true;
        }

        return !!this.get('posts').findProperty('id', lastPostId);
      }
    }, {
      key: 'lastPostNotLoaded',
      initializer: function () {
        return Ember.computed.not('loadedAllPosts');
      }
    }, {
      key: 'streamFilters',
      decorators: [computed('summary', 'show_deleted', 'userFilters.[]')],
      value: function (summary, showDeleted) {
        var result = {};
        if (summary) {
          result.filter = "summary";
        }
        if (showDeleted) {
          result.show_deleted = true;
        }

        var userFilters = this.get('userFilters');
        if (!Ember.isEmpty(userFilters)) {
          result.username_filters = userFilters.join(",");
        }

        return result;
      }
    }, {
      key: 'hasNoFilters',
      decorators: [computed('streamFilters.[]', 'topic.posts_count', 'posts.length')],
      value: function () {
        var streamFilters = this.get('streamFilters');
        return !(streamFilters && (streamFilters.filter === 'summary' || streamFilters.username_filters));
      }
    }, {
      key: 'previousWindow',
      decorators: [computed('posts.@each', 'stream.@each')],
      value: function () {
        // If we can't find the last post loaded, bail
        var firstPost = _.first(this.get('posts'));
        if (!firstPost) {
          return [];
        }

        // Find the index of the last post loaded, if not found, bail
        var stream = this.get('stream');
        var firstIndex = this.indexOf(firstPost);
        if (firstIndex === -1) {
          return [];
        }

        var startIndex = firstIndex - this.get('topic.chunk_size');
        if (startIndex < 0) {
          startIndex = 0;
        }
        return stream.slice(startIndex, firstIndex);
      }
    }, {
      key: 'nextWindow',
      decorators: [computed('posts.lastObject', 'stream.@each')],
      value: function (lastLoadedPost) {
        // If we can't find the last post loaded, bail
        if (!lastLoadedPost) {
          return [];
        }

        // Find the index of the last post loaded, if not found, bail
        var stream = this.get('stream');
        var lastIndex = this.indexOf(lastLoadedPost);
        if (lastIndex === -1) {
          return [];
        }
        if (lastIndex + 1 >= this.get('highest_post_number')) {
          return [];
        }

        // find our window of posts
        return stream.slice(lastIndex + 1, lastIndex + this.get('topic.chunk_size') + 1);
      }
    }, {
      key: 'cancelFilter',
      value: function () {
        this.set('summary', false);
        this.set('show_deleted', false);
        this.get('userFilters').clear();
      }
    }, {
      key: 'toggleSummary',
      value: function () {
        var _this = this;

        this.get('userFilters').clear();
        this.toggleProperty('summary');

        return this.refresh().then(function () {
          if (_this.get('summary')) {
            _this.jumpToSecondVisible();
          }
        });
      }
    }, {
      key: 'toggleDeleted',
      value: function () {
        this.toggleProperty('show_deleted');
        return this.refresh();
      }
    }, {
      key: 'jumpToSecondVisible',
      value: function () {
        var posts = this.get('posts');
        if (posts.length > 1) {
          var secondPostNum = posts[1].get('post_number');
          DiscourseURL.jumpToPost(secondPostNum);
        }
      }
    }, {
      key: 'toggleParticipant',

      // Filter the stream to a particular user.
      value: function (username) {
        var _this2 = this;

        var userFilters = this.get('userFilters');
        this.set('summary', false);
        this.set('show_deleted', true);

        var jump = false;
        if (userFilters.contains(username)) {
          userFilters.removeObject(username);
        } else {
          userFilters.addObject(username);
          jump = true;
        }
        return this.refresh().then(function () {
          if (jump) {
            _this2.jumpToSecondVisible();
          }
        });
      }
    }, {
      key: 'refresh',

      /**
        Loads a new set of posts into the stream. If you provide a `nearPost` option and the post
        is already loaded, it will simply scroll there and load nothing.
      **/
      value: function (opts) {
        var _this3 = this;

        opts = opts || {};
        opts.nearPost = parseInt(opts.nearPost, 10);

        var topic = this.get('topic');

        // Do we already have the post in our list of posts? Jump there.
        if (opts.forceLoad) {
          this.set('loaded', false);
        } else {
          var postWeWant = this.get('posts').findProperty('post_number', opts.nearPost);
          if (postWeWant) {
            return Ember.RSVP.resolve();
          }
        }

        // TODO: if we have all the posts in the filter, don't go to the server for them.
        this.set('loadingFilter', true);

        opts = _.merge(opts, this.get('streamFilters'));

        // Request a topicView
        return loadTopicView(topic, opts).then(function (json) {
          _this3.updateFromJson(json.post_stream);
          _this3.setProperties({ loadingFilter: false, loaded: true });
        }).catch(function (result) {
          _this3.errorLoading(result);
          throw result;
        });
      }
    }, {
      key: 'collapsePosts',
      value: function (from, to) {
        var posts = this.get('posts');
        var remove = posts.filter(function (post) {
          var postNumber = post.get('post_number');
          return postNumber >= from && postNumber <= to;
        });

        posts.removeObjects(remove);

        // make gap
        this.set('gaps', this.get('gaps') || { before: {}, after: {} });
        var before = this.get('gaps.before');
        var post = posts.find(function (p) {
          return p.get('post_number') > to;
        });

        before[post.get('id')] = remove.map(function (p) {
          return p.get('id');
        });
        post.set('hasGap', true);

        this.get('stream').enumerableContentDidChange();
      }
    }, {
      key: 'fillGapBefore',

      // Fill in a gap of posts before a particular post
      value: function (post, gap) {
        var _this4 = this;

        var postId = post.get('id'),
            stream = this.get('stream'),
            idx = stream.indexOf(postId),
            currentPosts = this.get('posts');

        if (idx !== -1) {
          var _ret = (function () {
            // Insert the gap at the appropriate place
            stream.splice.apply(stream, [idx, 0].concat(gap));

            var postIdx = currentPosts.indexOf(post);
            var origIdx = postIdx;
            if (postIdx !== -1) {
              return {
                v: _this4.findPostsByIds(gap).then(function (posts) {
                  posts.forEach(function (p) {
                    var stored = _this4.storePost(p);
                    if (!currentPosts.contains(stored)) {
                      currentPosts.insertAt(postIdx++, stored);
                    }
                  });

                  delete _this4.get('gaps.before')[postId];
                  _this4.get('stream').enumerableContentDidChange();
                  _this4.get('postsWithPlaceholders').arrayContentDidChange(origIdx, 0, posts.length);
                  post.set('hasGap', false);
                })
              };
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
        return Ember.RSVP.resolve();
      }
    }, {
      key: 'fillGapAfter',

      // Fill in a gap of posts after a particular post
      value: function (post, gap) {
        var _this5 = this;

        var postId = post.get('id'),
            stream = this.get('stream'),
            idx = stream.indexOf(postId);

        if (idx !== -1) {
          stream.pushObjects(gap);
          return this.appendMore().then(function () {
            _this5.get('stream').enumerableContentDidChange();
          });
        }
        return Ember.RSVP.resolve();
      }
    }, {
      key: 'appendMore',

      // Appends the next window of posts to the stream. Call it when scrolling downwards.
      value: function () {
        var _this6 = this;

        // Make sure we can append more posts
        if (!this.get('canAppendMore')) {
          return Ember.RSVP.resolve();
        }

        var postIds = this.get('nextWindow');
        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve();
        }

        this.set('loadingBelow', true);
        var postsWithPlaceholders = this.get('postsWithPlaceholders');
        postsWithPlaceholders.appending(postIds);
        return this.findPostsByIds(postIds).then(function (posts) {
          posts.forEach(function (p) {
            return _this6.appendPost(p);
          });
          return posts;
        }).finally(function () {
          postsWithPlaceholders.finishedAppending(postIds);
          _this6.set('loadingBelow', false);
        });
      }
    }, {
      key: 'prependMore',

      // Prepend the previous window of posts to the stream. Call it when scrolling upwards.
      value: function () {
        var _this7 = this;

        // Make sure we can append more posts
        if (!this.get('canPrependMore')) {
          return Ember.RSVP.resolve();
        }

        var postIds = this.get('previousWindow');
        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve();
        }

        this.set('loadingAbove', true);
        return this.findPostsByIds(postIds.reverse()).then(function (posts) {
          posts.forEach(function (p) {
            return _this7.prependPost(p);
          });
        }).finally(function () {
          var postsWithPlaceholders = _this7.get('postsWithPlaceholders');
          postsWithPlaceholders.finishedPrepending(postIds);
          _this7.set('loadingAbove', false);
        });
      }
    }, {
      key: 'stagePost',

      /**
        Stage a post for insertion in the stream. It should be rendered right away under the
        assumption that the post will succeed. We can then `commitPost` when it succeeds or
        `undoPost` when it fails.
      **/
      value: function (post, user) {
        // We can't stage two posts simultaneously
        if (this.get('stagingPost')) {
          return "alreadyStaging";
        }

        this.set('stagingPost', true);

        var topic = this.get('topic');
        topic.setProperties({
          posts_count: (topic.get('posts_count') || 0) + 1,
          last_posted_at: new Date(),
          'details.last_poster': user,
          highest_post_number: (topic.get('highest_post_number') || 0) + 1
        });

        post.setProperties({
          post_number: topic.get('highest_post_number'),
          topic: topic,
          created_at: new Date(),
          id: -1
        });

        // If we're at the end of the stream, add the post
        if (this.get('loadedAllPosts')) {
          this.appendPost(post);
          this.get('stream').addObject(post.get('id'));
          return "staged";
        }

        return "offScreen";
      }
    }, {
      key: 'commitPost',

      // Commit the post we staged. Call this after a save succeeds.
      value: function (post) {

        if (this.get('topic.id') === post.get('topic_id')) {
          if (this.get('loadedAllPosts')) {
            this.appendPost(post);
            this.get('stream').addObject(post.get('id'));
          }
        }

        this.get('stream').removeObject(-1);
        this._identityMap[-1] = null;
        this.set('stagingPost', false);
      }
    }, {
      key: 'undoPost',

      /**
        Undo a post we've staged in the stream. Remove it from being rendered and revert the
        state we changed.
      **/
      value: function (post) {
        var _this8 = this;

        this.get('stream').removeObject(-1);
        this.get('postsWithPlaceholders').removePost(function () {
          return _this8.posts.removeObject(post);
        });
        this._identityMap[-1] = null;

        var topic = this.get('topic');
        this.set('stagingPost', false);

        topic.setProperties({
          highest_post_number: (topic.get('highest_post_number') || 0) - 1,
          posts_count: (topic.get('posts_count') || 0) - 1
        });

        // TODO unfudge reply count on parent post
      }
    }, {
      key: 'prependPost',
      value: function (post) {
        var stored = this.storePost(post);
        if (stored) {
          var posts = this.get('posts');
          calcDayDiff(posts.get('firstObject'), stored);
          posts.unshiftObject(stored);
        }

        return post;
      }
    }, {
      key: 'appendPost',
      value: function (post) {
        var _this9 = this;

        var stored = this.storePost(post);
        if (stored) {
          (function () {
            var posts = _this9.get('posts');

            calcDayDiff(stored, _this9.get('lastAppended'));
            if (!posts.contains(stored)) {
              if (!_this9.get('loadingBelow')) {
                _this9.get('postsWithPlaceholders').appendPost(function () {
                  return posts.pushObject(stored);
                });
              } else {
                posts.pushObject(stored);
              }
            }

            if (stored.get('id') !== -1) {
              _this9.set('lastAppended', stored);
            }
          })();
        }
        return post;
      }
    }, {
      key: 'removePosts',
      value: function (posts) {
        if (Ember.isEmpty(posts)) {
          return;
        }

        var postIds = posts.map(function (p) {
          return p.get('id');
        });
        var identityMap = this._identityMap;

        this.get('stream').removeObjects(postIds);
        this.get('posts').removeObjects(posts);
        postIds.forEach(function (id) {
          return delete identityMap[id];
        });
      }
    }, {
      key: 'findLoadedPost',

      // Returns a post from the identity map if it's been inserted.
      value: function (id) {
        return this._identityMap[id];
      }
    }, {
      key: 'loadPost',
      value: function (postId) {
        var _this10 = this;

        var url = "/posts/" + postId;
        var store = this.store;

        return Discourse.ajax(url).then(function (p) {
          return _this10.storePost(store.createRecord('post', p));
        });
      }
    }, {
      key: 'triggerNewPostInStream',

      /**
        Finds and adds a post to the stream by id. Typically this would happen if we receive a message
        from the message bus indicating there's a new post. We'll only insert it if we currently
        have no filters.
      **/
      value: function (postId) {
        var _this11 = this;

        if (!postId) {
          return;
        }

        // We only trigger if there are no filters active
        if (!this.get('hasNoFilters')) {
          return;
        }

        var loadedAllPosts = this.get('loadedAllPosts');

        if (this.get('stream').indexOf(postId) === -1) {
          this.get('stream').addObject(postId);
          if (loadedAllPosts) {
            this.set('loadingLastPost', true);
            this.findPostsByIds([postId]).then(function (posts) {
              posts.forEach(function (p) {
                return _this11.appendPost(p);
              });
            }).finally(function () {
              _this11.set('loadingLastPost', false);
            });
          }
        }
      }
    }, {
      key: 'triggerRecoveredPost',
      value: function (postId) {
        var _this12 = this;

        var existing = this._identityMap[postId];

        if (existing) {
          this.triggerChangedPost(postId, new Date());
        } else {
          (function () {
            // need to insert into stream
            var url = "/posts/" + postId;
            var store = _this12.store;
            Discourse.ajax(url).then(function (p) {
              var post = store.createRecord('post', p);
              var stream = _this12.get("stream");
              var posts = _this12.get("posts");
              _this12.storePost(post);

              // we need to zip this into the stream
              var index = 0;
              stream.forEach(function (pid) {
                if (pid < p.id) {
                  index += 1;
                }
              });

              stream.insertAt(index, p.id);

              index = 0;
              posts.forEach(function (_post) {
                if (_post.id < p.id) {
                  index += 1;
                }
              });

              if (index < posts.length) {
                posts.insertAt(index, post);
              } else {
                if (post.post_number < posts[posts.length - 1].post_number + 5) {
                  _this12.appendMore();
                }
              }
            });
          })();
        }
      }
    }, {
      key: 'triggerDeletedPost',
      value: function (postId) {
        var _this13 = this;

        var existing = this._identityMap[postId];

        if (existing) {
          (function () {
            var url = "/posts/" + postId;
            var store = _this13.store;

            Discourse.ajax(url).then(function (p) {
              _this13.storePost(store.createRecord('post', p));
            }).catch(function () {
              _this13.removePosts([existing]);
            });
          })();
        }
      }
    }, {
      key: 'triggerChangedPost',
      value: function (postId, updatedAt) {
        var _this14 = this;

        if (!postId) {
          return;
        }

        var existing = this._identityMap[postId];
        if (existing && existing.updated_at !== updatedAt) {
          (function () {
            var url = "/posts/" + postId;
            var store = _this14.store;
            Discourse.ajax(url).then(function (p) {
              return _this14.storePost(store.createRecord('post', p));
            });
          })();
        }
      }
    }, {
      key: 'findReplyHistory',

      // Returns the "thread" of posts in the history of a post.
      value: function (post) {
        var _this15 = this;

        var url = '/posts/' + post.get('id') + '/reply-history.json?max_replies=' + Discourse.SiteSettings.max_reply_history;
        var store = this.store;
        return Discourse.ajax(url).then(function (result) {
          return result.map(function (p) {
            return _this15.storePost(store.createRecord('post', p));
          });
        }).then(function (replyHistory) {
          post.set('replyHistory', replyHistory);
        });
      }
    }, {
      key: 'closestPostForPostNumber',

      /**
        Returns the closest post given a postNumber that may not exist in the stream.
        For example, if the user asks for a post that's deleted or otherwise outside the range.
        This allows us to set the progress bar with the correct number.
      **/
      value: function (postNumber) {
        if (!this.get('hasPosts')) {
          return;
        }

        var closest = null;
        this.get('posts').forEach(function (p) {
          if (!closest) {
            closest = p;
            return;
          }

          if (Math.abs(postNumber - p.get('post_number')) < Math.abs(closest.get('post_number') - postNumber)) {
            closest = p;
          }
        });

        return closest;
      }
    }, {
      key: 'progressIndexOfPost',

      // Get the index of a post in the stream. (Use this for the topic progress bar.)
      value: function (post) {
        return this.progressIndexOfPostId(post.get('id'));
      }
    }, {
      key: 'progressIndexOfPostId',

      // Get the index in the stream of a post id. (Use this for the topic progress bar.)
      value: function (postId) {
        return this.get('stream').indexOf(postId) + 1;
      }
    }, {
      key: 'closestPostNumberFor',

      /**
        Returns the closest post number given a postNumber that may not exist in the stream.
        For example, if the user asks for a post that's deleted or otherwise outside the range.
        This allows us to set the progress bar with the correct number.
      **/
      value: function (postNumber) {
        if (!this.get('hasPosts')) {
          return;
        }

        var closest = null;
        this.get('posts').forEach(function (p) {
          if (closest === postNumber) {
            return;
          }
          if (!closest) {
            closest = p.get('post_number');
          }

          if (Math.abs(postNumber - p.get('post_number')) < Math.abs(closest - postNumber)) {
            closest = p.get('post_number');
          }
        });

        return closest;
      }
    }, {
      key: 'findPostIdForPostNumber',

      // Find a postId for a postNumber, respecting gaps
      value: function (postNumber) {
        var stream = this.get('stream'),
            beforeLookup = this.get('gaps.before'),
            streamLength = stream.length;

        var sum = 1;
        for (var i = 0; i < streamLength; i++) {
          var pid = stream[i];

          // See if there are posts before this post
          if (beforeLookup) {
            var before = beforeLookup[pid];
            if (before) {
              for (var j = 0; j < before.length; j++) {
                if (sum === postNumber) {
                  return pid;
                }
                sum++;
              }
            }
          }

          if (sum === postNumber) {
            return pid;
          }
          sum++;
        }
      }
    }, {
      key: 'updateFromJson',
      value: function (postStreamData) {
        var _this16 = this;

        var posts = this.get('posts');

        var postsWithPlaceholders = this.get('postsWithPlaceholders');
        postsWithPlaceholders.clear(function () {
          return posts.clear();
        });

        this.set('gaps', null);
        if (postStreamData) {
          (function () {
            // Load posts if present
            var store = _this16.store;
            postStreamData.posts.forEach(function (p) {
              return _this16.appendPost(store.createRecord('post', p));
            });
            delete postStreamData.posts;

            // Update our attributes
            _this16.setProperties(postStreamData);
          })();
        }
      }
    }, {
      key: 'storePost',

      /**
        Stores a post in our identity map, and sets up the references it needs to
        find associated objects like the topic. It might return a different reference
        than you supplied if the post has already been loaded.
      **/
      value: function (post) {
        // Calling `Ember.get(undefined)` raises an error
        if (!post) {
          return;
        }

        var postId = Ember.get(post, 'id');
        if (postId) {
          var existing = this._identityMap[post.get('id')];

          // Update the `highest_post_number` if this post is higher.
          var postNumber = post.get('post_number');
          if (postNumber && postNumber > (this.get('topic.highest_post_number') || 0)) {
            this.set('topic.highest_post_number', postNumber);
          }

          if (existing) {
            // If the post is in the identity map, update it and return the old reference.
            existing.updateFromPost(post);
            return existing;
          }

          post.set('topic', this.get('topic'));
          this._identityMap[post.get('id')] = post;
        }
        return post;
      }
    }, {
      key: 'findPostsByIds',
      value: function (postIds) {
        var identityMap = this._identityMap;
        var unloaded = postIds.filter(function (p) {
          return !identityMap[p];
        });

        // Load our unloaded posts by id
        return this.loadIntoIdentityMap(unloaded).then(function () {
          return postIds.map(function (p) {
            return identityMap[p];
          }).compact();
        });
      }
    }, {
      key: 'loadIntoIdentityMap',
      value: function (postIds) {
        var _this17 = this;

        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve([]);
        }

        var url = "/t/" + this.get('topic.id') + "/posts.json";
        var data = { post_ids: postIds };
        var store = this.store;
        return Discourse.ajax(url, { data: data }).then(function (result) {
          var posts = Ember.get(result, "post_stream.posts");
          if (posts) {
            posts.forEach(function (p) {
              return _this17.storePost(store.createRecord('post', p));
            });
          }
        });
      }
    }, {
      key: 'indexOf',
      value: function (post) {
        return this.get('stream').indexOf(post.get('id'));
      }
    }, {
      key: 'errorLoading',

      // Handles an error loading a topic based on a HTTP status code. Updates
      // the text to the correct values.
      value: function (result) {
        var status = result.jqXHR.status;

        var topic = this.get('topic');
        this.set('loadingFilter', false);
        topic.set('errorLoading', true);

        // If the result was 404 the post is not found
        if (status === 404) {
          topic.set('notFoundHtml', result.jqXHR.responseText);
          return;
        }

        // If the result is 403 it means invalid access
        if (status === 403) {
          topic.set('noRetry', true);
          if (Discourse.User.current()) {
            topic.set('message', I18n.t('topic.invalid_access.description'));
          } else {
            topic.set('message', I18n.t('topic.invalid_access.login_required'));
          }
          return;
        }

        // Otherwise supply a generic error message
        topic.set('message', I18n.t('topic.server_error.description'));
      }
    }]));

    /**
      Returns a JS Object of current stream filter options. It should match the query
      params for the stream.
    **/

    /**
      Returns the window of posts above the current set in the stream, bound to the top of the stream.
      This is the collection we'll ask for when scrolling upwards.
    **/

    /**
      Returns the window of posts below the current set in the stream, bound by the bottom of the
      stream. This is the collection we use when scrolling downwards.
    **/
  });define("discourse/models/topic-details", 
  ["discourse/models/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /**
      A model representing a Topic's details that aren't always present, such as a list of participants.
      When showing topics in lists and such this information should not be required.
    **/

    var RestModel = __dependency1__["default"];

    var TopicDetails = RestModel.extend({
      loaded: false,

      updateFromJson: function (details) {
        var _this = this;

        var topic = this.get('topic');

        if (details.allowed_users) {
          details.allowed_users = details.allowed_users.map(function (u) {
            return Discourse.User.create(u);
          });
        }

        if (details.suggested_topics) {
          (function () {
            var store = _this.store;
            details.suggested_topics = details.suggested_topics.map(function (st) {
              return store.createRecord('topic', st);
            });
          })();
        }

        if (details.participants) {
          details.participants = details.participants.map(function (p) {
            p.topic = topic;
            return Ember.Object.create(p);
          });
        }

        this.setProperties(details);
        this.set('loaded', true);
      },

      fewParticipants: (function () {
        if (!!Ember.isEmpty(this.get('participants'))) return null;
        return this.get('participants').slice(0, 3);
      }).property('participants'),

      notificationReasonText: (function () {
        var level = this.get('notification_level');
        if (typeof level !== 'number') {
          level = 1;
        }

        var localeString = "topic.notifications.reasons." + level;
        if (typeof this.get('notifications_reason_id') === 'number') {
          var tmp = localeString + "_" + this.get('notifications_reason_id');
          // some sane protection for missing translations of edge cases
          if (I18n.lookup(tmp)) {
            localeString = tmp;
          }
        }
        return I18n.t(localeString, { username: Discourse.User.currentProp('username_lower') });
      }).property('notification_level', 'notifications_reason_id'),

      updateNotifications: function (v) {
        this.set('notification_level', v);
        this.set('notifications_reason_id', null);
        return Discourse.ajax("/t/" + this.get('topic.id') + "/notifications", {
          type: 'POST',
          data: { notification_level: v }
        });
      },

      removeAllowedUser: function (user) {
        var users = this.get('allowed_users'),
            username = user.get('username');

        Discourse.ajax("/t/" + this.get('topic.id') + "/remove-allowed-user", {
          type: 'PUT',
          data: { username: username }
        }).then(function () {
          users.removeObject(users.findProperty('username', username));
        });
      }
    });

    __exports__["default"] = TopicDetails;
  });define("discourse/models/topic", 
  ["discourse/models/store","discourse/models/rest","discourse/lib/computed","discourse/lib/formatter","ember-addons/ember-computed-decorators","discourse/models/action-summary","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    __exports__.loadTopicView = loadTopicView;
    __exports__.movePosts = movePosts;
    __exports__.mergeTopic = mergeTopic;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var flushMap = __dependency1__.flushMap;
    var RestModel = __dependency2__["default"];
    var propertyEqual = __dependency3__.propertyEqual;
    var longDate = __dependency4__.longDate;
    var computed = __dependency5__["default"];
    var ActionSummary = __dependency6__["default"];

    function loadTopicView(topic, args) {
      var topicId = topic.get('id');
      var data = _.merge({}, args);
      var url = Discourse.getURL("/t/") + topicId;
      var jsonUrl = (data.nearPost ? url + '/' + data.nearPost : url) + '.json';

      delete data.nearPost;
      delete data.__type;
      delete data.store;

      return PreloadStore.getAndRemove('topic_' + topicId, function () {
        return Discourse.ajax(jsonUrl, { data: data });
      }).then(function (json) {
        topic.updateFromJson(json);
        return json;
      });
    }

    var Topic = RestModel.extend(_createDecoratedObject([{
      key: 'message',
      initializer: function () {
        return null;
      }
    }, {
      key: 'errorLoading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'creator',
      decorators: [computed('posters.firstObject')],
      value: function (poster) {
        return poster && poster.user;
      }
    }, {
      key: 'lastPoster',
      decorators: [computed('posters.@each')],
      value: function (posters) {
        if (posters && posters.length > 0) {
          var latest = posters.filter(function (p) {
            return p.extras && p.extras.indexOf("latest") >= 0;
          })[0];
          return latest.user;
        } else {
          return this.get("creator");
        }
      }
    }, {
      key: 'fancyTitle',
      decorators: [computed('fancy_title')],
      value: function (title) {
        title = title || "";
        title = Discourse.Emoji.unescape(title);
        return Discourse.CensoredWords.censor(title);
      }
    }, {
      key: 'bumpedAt',

      // returns createdAt if there's no bumped date
      initializer: function () {
        return (function () {
          var bumpedAt = this.get('bumped_at');
          if (bumpedAt) {
            return new Date(bumpedAt);
          } else {
            return this.get('createdAt');
          }
        }).property('bumped_at', 'createdAt');
      }
    }, {
      key: 'bumpedAtTitle',
      initializer: function () {
        return (function () {
          return I18n.t('first_post') + ": " + longDate(this.get('createdAt')) + "\n" + I18n.t('last_post') + ": " + longDate(this.get('bumpedAt'));
        }).property('bumpedAt');
      }
    }, {
      key: 'createdAt',
      initializer: function () {
        return (function () {
          return new Date(this.get('created_at'));
        }).property('created_at');
      }
    }, {
      key: 'postStream',
      initializer: function () {
        return (function () {
          return this.store.createRecord('postStream', { id: this.get('id'), topic: this });
        }).property();
      }
    }, {
      key: 'replyCount',
      initializer: function () {
        return (function () {
          return this.get('posts_count') - 1;
        }).property('posts_count');
      }
    }, {
      key: 'details',
      initializer: function () {
        return (function () {
          return this.store.createRecord('topicDetails', { id: this.get('id'), topic: this });
        }).property();
      }
    }, {
      key: 'invisible',
      initializer: function () {
        return Em.computed.not('visible');
      }
    }, {
      key: 'deleted',
      initializer: function () {
        return Em.computed.notEmpty('deleted_at');
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return (function () {
          return { type: 'topic', id: this.get('id') };
        }).property('id');
      }
    }, {
      key: '_categoryIdChanged',
      initializer: function () {
        return (function () {
          this.set('category', Discourse.Category.findById(this.get('category_id')));
        }).observes('category_id').on('init');
      }
    }, {
      key: '_categoryNameChanged',
      initializer: function () {
        return (function () {
          var categoryName = this.get('categoryName');
          var category = undefined;
          if (categoryName) {
            category = Discourse.Category.list().findProperty('name', categoryName);
          }
          this.set('category', category);
        }).observes('categoryName');
      }
    }, {
      key: 'categoryClass',
      initializer: function () {
        return (function () {
          return 'category-' + this.get('category.fullSlug');
        }).property('category.fullSlug');
      }
    }, {
      key: 'shareUrl',
      initializer: function () {
        return (function () {
          var user = Discourse.User.current();
          return this.get('url') + (user ? '?u=' + user.get('username_lower') : '');
        }).property('url');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          var slug = this.get('slug') || '';
          if (slug.trim().length === 0) {
            slug = "topic";
          }
          return Discourse.getURL("/t/") + slug + "/" + this.get('id');
        }).property('id', 'slug');
      }
    }, {
      key: 'urlForPostNumber',

      // Helper to build a Url with a post number
      value: function (postNumber) {
        var url = this.get('url');
        if (postNumber && postNumber > 0) {
          url += "/" + postNumber;
        }
        return url;
      }
    }, {
      key: 'totalUnread',
      initializer: function () {
        return (function () {
          var count = (this.get('unread') || 0) + (this.get('new_posts') || 0);
          return count > 0 ? count : null;
        }).property('new_posts', 'unread');
      }
    }, {
      key: 'lastReadUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(this.get('last_read_post_number'));
        }).property('url', 'last_read_post_number');
      }
    }, {
      key: 'lastUnreadUrl',
      initializer: function () {
        return (function () {
          var postNumber = Math.min(this.get('last_read_post_number') + 1, this.get('highest_post_number'));
          return this.urlForPostNumber(postNumber);
        }).property('url', 'last_read_post_number', 'highest_post_number');
      }
    }, {
      key: 'lastPostUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(this.get('highest_post_number'));
        }).property('url', 'highest_post_number');
      }
    }, {
      key: 'firstPostUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(1);
        }).property('url');
      }
    }, {
      key: 'summaryUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(1) + (this.get('has_summary') ? "?filter=summary" : "");
        }).property('url');
      }
    }, {
      key: 'lastPosterUrl',
      initializer: function () {
        return (function () {
          return Discourse.getURL("/users/") + this.get("last_poster.username");
        }).property('last_poster');
      }
    }, {
      key: 'displayNewPosts',

      // The amount of new posts to display. It might be different than what the server
      // tells us if we are still asynchronously flushing our "recently read" data.
      // So take what the browser has seen into consideration.
      initializer: function () {
        return (function () {
          var highestSeen = Discourse.Session.currentProp('highestSeenByTopic')[this.get('id')];
          if (highestSeen) {
            var delta = highestSeen - this.get('last_read_post_number');
            if (delta > 0) {
              var result = this.get('new_posts') - delta;
              if (result < 0) {
                result = 0;
              }
              return result;
            }
          }
          return this.get('new_posts');
        }).property('new_posts', 'id');
      }
    }, {
      key: 'viewsHeat',
      initializer: function () {
        return (function () {
          var v = this.get('views');
          if (v >= Discourse.SiteSettings.topic_views_heat_high) return 'heatmap-high';
          if (v >= Discourse.SiteSettings.topic_views_heat_medium) return 'heatmap-med';
          if (v >= Discourse.SiteSettings.topic_views_heat_low) return 'heatmap-low';
          return null;
        }).property('views');
      }
    }, {
      key: 'archetypeObject',
      initializer: function () {
        return (function () {
          return Discourse.Site.currentProp('archetypes').findProperty('id', this.get('archetype'));
        }).property('archetype');
      }
    }, {
      key: 'isPrivateMessage',
      initializer: function () {
        return Em.computed.equal('archetype', 'private_message');
      }
    }, {
      key: 'isBanner',
      initializer: function () {
        return Em.computed.equal('archetype', 'banner');
      }
    }, {
      key: 'toggleStatus',
      value: function (property) {
        this.toggleProperty(property);
        this.saveStatus(property, !!this.get(property));
      }
    }, {
      key: 'saveStatus',
      value: function (property, value, until) {
        if (property === 'closed') {
          this.incrementProperty('posts_count');

          if (value === true) {
            this.set('details.auto_close_at', null);
          }
        }
        return Discourse.ajax(this.get('url') + "/status", {
          type: 'PUT',
          data: {
            status: property,
            enabled: !!value,
            until: until
          }
        });
      }
    }, {
      key: 'makeBanner',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id') + '/make-banner', { type: 'PUT' }).then(function () {
          self.set('archetype', 'banner');
        });
      }
    }, {
      key: 'removeBanner',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id') + '/remove-banner', { type: 'PUT' }).then(function () {
          self.set('archetype', 'regular');
        });
      }
    }, {
      key: 'estimatedReadingTime',
      initializer: function () {
        return (function () {
          var wordCount = this.get('word_count');
          if (!wordCount) return;

          // Avg for 500 words per minute when you account for skimming
          return Math.floor(wordCount / 500.0);
        }).property('word_count');
      }
    }, {
      key: 'toggleBookmark',
      value: function () {
        if (this.get("bookmarking")) {
          return;
        }
        this.set("bookmarking", true);

        var self = this,
            stream = this.get('postStream'),
            posts = Em.get(stream, 'posts'),
            firstPost = posts && posts[0] && posts[0].get('post_number') === 1 && posts[0],
            bookmark = !this.get('bookmarked'),
            path = bookmark ? '/bookmark' : '/remove_bookmarks';

        var toggleBookmarkOnServer = function () {
          return Discourse.ajax('/t/' + self.get('id') + path, {
            type: 'PUT'
          }).then(function () {
            self.toggleProperty('bookmarked');
            if (bookmark && firstPost) {
              firstPost.set('bookmarked', true);
            }
            if (!bookmark && posts) {
              posts.forEach(function (post) {
                return post.get('bookmarked') && post.set('bookmarked', false);
              });
            }
          }).catch(function (error) {
            var showGenericError = true;
            if (error && error.responseText) {
              try {
                bootbox.alert($.parseJSON(error.responseText).errors);
                showGenericError = false;
              } catch (e) {}
            }

            if (showGenericError) {
              bootbox.alert(I18n.t('generic_error'));
            }

            throw error;
          }).finally(function () {
            self.set("bookmarking", false);
          });
        };

        var unbookmarkedPosts = [];
        if (!bookmark && posts) {
          posts.forEach(function (post) {
            return post.get('bookmarked') && unbookmarkedPosts.push(post);
          });
        }

        if (unbookmarkedPosts.length > 1) {
          return bootbox.confirm(I18n.t("bookmarks.confirm_clear"), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
            if (confirmed) {
              return toggleBookmarkOnServer();
            }
          });
        } else {
          return toggleBookmarkOnServer();
        }
      }
    }, {
      key: 'createInvite',
      value: function (emailOrUsername, groupNames) {
        return Discourse.ajax("/t/" + this.get('id') + "/invite", {
          type: 'POST',
          data: { user: emailOrUsername, group_names: groupNames }
        });
      }
    }, {
      key: 'generateInviteLink',
      initializer: function () {
        return function (email, groupNames, topicId) {
          return Discourse.ajax('/invites/link', {
            type: 'POST',
            data: { email: email, group_names: groupNames, topic_id: topicId }
          });
        };
      }
    }, {
      key: 'destroy',

      // Delete this topic
      value: function (deleted_by) {
        this.setProperties({
          deleted_at: new Date(),
          deleted_by: deleted_by,
          'details.can_delete': false,
          'details.can_recover': true
        });
        return Discourse.ajax("/t/" + this.get('id'), {
          data: { context: window.location.pathname },
          type: 'DELETE'
        });
      }
    }, {
      key: 'recover',

      // Recover this topic if deleted
      value: function () {
        this.setProperties({
          deleted_at: null,
          deleted_by: null,
          'details.can_delete': true,
          'details.can_recover': false
        });
        return Discourse.ajax("/t/" + this.get('id') + "/recover", { type: 'PUT' });
      }
    }, {
      key: 'updateFromJson',

      // Update our attributes from a JSON result
      value: function (json) {
        var _this = this;

        this.get('details').updateFromJson(json.details);

        var keys = Object.keys(json);
        keys.removeObject('details');
        keys.removeObject('post_stream');

        keys.forEach(function (key) {
          return _this.set(key, json[key]);
        });
      }
    }, {
      key: 'reload',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id'), { type: 'GET' }).then(function (topic_json) {
          self.updateFromJson(topic_json);
        });
      }
    }, {
      key: 'isPinnedUncategorized',
      initializer: function () {
        return (function () {
          return this.get('pinned') && this.get('category.isUncategorizedCategory');
        }).property('pinned', 'category.isUncategorizedCategory');
      }
    }, {
      key: 'clearPin',
      value: function () {
        var topic = this;

        // Clear the pin optimistically from the object
        topic.set('pinned', false);
        topic.set('unpinned', true);

        Discourse.ajax("/t/" + this.get('id') + "/clear-pin", {
          type: 'PUT'
        }).then(null, function () {
          // On error, put the pin back
          topic.set('pinned', true);
          topic.set('unpinned', false);
        });
      }
    }, {
      key: 'togglePinnedForUser',
      value: function () {
        if (this.get('pinned')) {
          this.clearPin();
        } else {
          this.rePin();
        }
      }
    }, {
      key: 'rePin',
      value: function () {
        var topic = this;

        // Clear the pin optimistically from the object
        topic.set('pinned', true);
        topic.set('unpinned', false);

        Discourse.ajax("/t/" + this.get('id') + "/re-pin", {
          type: 'PUT'
        }).then(null, function () {
          // On error, put the pin back
          topic.set('pinned', true);
          topic.set('unpinned', false);
        });
      }
    }, {
      key: 'isReplyDirectlyBelow',

      // Is the reply to a post directly below it?
      value: function (post) {
        var posts = this.get('postStream.posts');
        var postNumber = post.get('post_number');
        if (!posts) return;

        var postBelow = posts[posts.indexOf(post) + 1];

        // If the post directly below's reply_to_post_number is our post number or we are quoted,
        // it's considered directly below.
        //
        // TODO: we don't carry information about quoting, this leaves this code fairly fragile
        //  instead we should start shipping quote meta data with posts, but this will add at least
        //  1 query to the topics page
        //
        return postBelow && (postBelow.get('reply_to_post_number') === postNumber || postBelow.get('cooked').indexOf('data-post="' + postNumber + '"') >= 0);
      }
    }, {
      key: 'hasExcerpt',
      initializer: function () {
        return Em.computed.notEmpty('excerpt');
      }
    }, {
      key: 'excerptTruncated',
      initializer: function () {
        return (function () {
          var e = this.get('excerpt');
          return e && e.substr(e.length - 8, 8) === '&hellip;';
        }).property('excerpt');
      }
    }, {
      key: 'readLastPost',
      initializer: function () {
        return propertyEqual('last_read_post_number', 'highest_post_number');
      }
    }, {
      key: 'canClearPin',
      initializer: function () {
        return Em.computed.and('pinned', 'readLastPost');
      }
    }]));

    Topic.reopenClass({
      NotificationLevel: {
        WATCHING: 3,
        TRACKING: 2,
        REGULAR: 1,
        MUTED: 0
      },

      createActionSummary: function (result) {
        if (result.actions_summary) {
          (function () {
            var lookup = Em.Object.create();
            result.actions_summary = result.actions_summary.map(function (a) {
              a.post = result;
              a.actionType = Discourse.Site.current().postActionTypeById(a.id);
              var actionSummary = ActionSummary.create(a);
              lookup.set(a.actionType.get('name_key'), actionSummary);
              return actionSummary;
            });
            result.set('actionByName', lookup);
          })();
        }
      },

      update: function (topic, props) {
        props = JSON.parse(JSON.stringify(props)) || {};

        // We support `category_id` and `categoryId` for compatibility
        if (typeof props.categoryId !== "undefined") {
          props.category_id = props.categoryId;
          delete props.categoryId;
        }

        // Make sure we never change the category for private messages
        if (topic.get("isPrivateMessage")) {
          delete props.category_id;
        }

        // Annoyingly, empty arrays are not sent across the wire. This
        // allows us to make a distinction between arrays that were not
        // sent and arrays that we specifically want to be empty.
        Object.keys(props).forEach(function (k) {
          var v = props[k];
          if (v instanceof Array && v.length === 0) {
            props[k + '_empty_array'] = true;
          }
        });

        return Discourse.ajax(topic.get('url'), { type: 'PUT', data: props }).then(function (result) {
          // The title can be cleaned up server side
          props.title = result.basic_topic.title;
          props.fancy_title = result.basic_topic.fancy_title;
          topic.setProperties(props);
        });
      },

      create: function () {
        var result = this._super.apply(this, arguments);
        this.createActionSummary(result);
        return result;
      },

      // Load a topic, but accepts a set of filters
      find: function (topicId, opts) {
        var url = Discourse.getURL("/t/") + topicId;
        if (opts.nearPost) {
          url += "/" + opts.nearPost;
        }

        var data = {};
        if (opts.postsAfter) {
          data.posts_after = opts.postsAfter;
        }
        if (opts.postsBefore) {
          data.posts_before = opts.postsBefore;
        }
        if (opts.trackVisit) {
          data.track_visit = true;
        }

        // Add username filters if we have them
        if (opts.userFilters && opts.userFilters.length > 0) {
          data.username_filters = [];
          opts.userFilters.forEach(function (username) {
            data.username_filters.push(username);
          });
          data.show_deleted = true;
        }

        // Add the summary of filter if we have it
        if (opts.summary === true) {
          data.summary = true;
        }

        // Check the preload store. If not, load it via JSON
        return Discourse.ajax(url + ".json", { data: data });
      },

      changeOwners: function (topicId, opts) {
        var promise = Discourse.ajax("/t/" + topicId + "/change-owner", {
          type: 'POST',
          data: opts
        }).then(function (result) {
          if (result.success) return result;
          promise.reject(new Error("error changing ownership of posts"));
        });
        return promise;
      },

      changeTimestamp: function (topicId, timestamp) {
        var promise = Discourse.ajax("/t/" + topicId + '/change-timestamp', {
          type: 'PUT',
          data: { timestamp: timestamp }
        }).then(function (result) {
          if (result.success) return result;
          promise.reject(new Error("error updating timestamp of topic"));
        });
        return promise;
      },

      bulkOperation: function (topics, operation) {
        return Discourse.ajax("/topics/bulk", {
          type: 'PUT',
          data: {
            topic_ids: topics.map(function (t) {
              return t.get('id');
            }),
            operation: operation
          }
        });
      },

      bulkOperationByFilter: function (filter, operation, categoryId) {
        var data = { filter: filter, operation: operation };
        if (categoryId) data['category_id'] = categoryId;
        return Discourse.ajax("/topics/bulk", {
          type: 'PUT',
          data: data
        });
      },

      resetNew: function () {
        return Discourse.ajax("/topics/reset-new", { type: 'PUT' });
      },

      idForSlug: function (slug) {
        return Discourse.ajax("/t/id_for/" + slug);
      }
    });

    function moveResult(result) {
      if (result.success) {
        // We should be hesitant to flush the map but moving ids is one rare case
        flushMap();
        return result;
      }
      throw "error moving posts topic";
    }

    function movePosts(topicId, data) {
      return Discourse.ajax("/t/" + topicId + "/move-posts", { type: 'POST', data: data }).then(moveResult);
    }

    function mergeTopic(topicId, destinationTopicId) {
      return Discourse.ajax("/t/" + topicId + "/merge-topic", {
        type: 'POST',
        data: { destination_topic_id: destinationTopicId }
      }).then(moveResult);
    }

    __exports__["default"] = Topic;
  });

Discourse.Topic = require('discourse/models/topic').default;
define("discourse/models/user-action", 
  ["discourse/models/rest","discourse/lib/computed","ember-addons/ember-computed-decorators","discourse/models/user-action-group","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var url = __dependency2__.url;
    var on = __dependency3__.on;
    var computed = __dependency3__["default"];
    var UserActionGroup = __dependency4__["default"];

    var UserActionTypes = {
      likes_given: 1,
      likes_received: 2,
      bookmarks: 3,
      topics: 4,
      posts: 5,
      replies: 6,
      mentions: 7,
      quotes: 9,
      edits: 11,
      messages_sent: 12,
      messages_received: 13,
      pending: 14
    };
    var InvertedActionTypes = {};

    _.each(UserActionTypes, function (k, v) {
      InvertedActionTypes[k] = v;
    });

    var UserAction = RestModel.extend(_createDecoratedObject([{
      key: '_attachCategory',
      decorators: [on("init")],
      value: function () {
        var categoryId = this.get('category_id');
        if (categoryId) {
          this.set('category', Discourse.Category.findById(categoryId));
        }
      }
    }, {
      key: 'descriptionKey',
      decorators: [computed("action_type")],
      value: function (action) {
        if (action === null || UserAction.TO_SHOW.indexOf(action) >= 0) {
          if (this.get('isPM')) {
            return this.get('sameUser') ? 'sent_by_you' : 'sent_by_user';
          } else {
            return this.get('sameUser') ? 'posted_by_you' : 'posted_by_user';
          }
        }

        if (this.get('topicType')) {
          return this.get('sameUser') ? 'you_posted_topic' : 'user_posted_topic';
        }

        if (this.get('postReplyType')) {
          if (this.get('reply_to_post_number')) {
            return this.get('sameUser') ? 'you_replied_to_post' : 'user_replied_to_post';
          } else {
            return this.get('sameUser') ? 'you_replied_to_topic' : 'user_replied_to_topic';
          }
        }

        if (this.get('mentionType')) {
          if (this.get('sameUser')) {
            return 'you_mentioned_user';
          } else {
            return this.get('targetUser') ? 'user_mentioned_you' : 'user_mentioned_user';
          }
        }
      }
    }, {
      key: 'sameUser',
      decorators: [computed("username")],
      value: function (username) {
        return username === Discourse.User.currentProp('username');
      }
    }, {
      key: 'targetUser',
      decorators: [computed("target_username")],
      value: function (targetUsername) {
        return targetUsername === Discourse.User.currentProp('username');
      }
    }, {
      key: 'presentName',
      initializer: function () {
        return Em.computed.any('name', 'username');
      }
    }, {
      key: 'targetDisplayName',
      initializer: function () {
        return Em.computed.any('target_name', 'target_username');
      }
    }, {
      key: 'actingDisplayName',
      initializer: function () {
        return Em.computed.any('acting_name', 'acting_username');
      }
    }, {
      key: 'targetUserUrl',
      initializer: function () {
        return url('target_username', '/users/%@');
      }
    }, {
      key: 'usernameLower',
      decorators: [computed("username")],
      value: function (username) {
        return username.toLowerCase();
      }
    }, {
      key: 'userUrl',
      initializer: function () {
        return url('usernameLower', '/users/%@');
      }
    }, {
      key: 'postUrl',
      decorators: [computed()],
      value: function () {
        return Discourse.Utilities.postUrl(this.get('slug'), this.get('topic_id'), this.get('post_number'));
      }
    }, {
      key: 'replyUrl',
      decorators: [computed()],
      value: function () {
        return Discourse.Utilities.postUrl(this.get('slug'), this.get('topic_id'), this.get('reply_to_post_number'));
      }
    }, {
      key: 'replyType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.replies);
      }
    }, {
      key: 'postType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.posts);
      }
    }, {
      key: 'topicType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.topics);
      }
    }, {
      key: 'bookmarkType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.bookmarks);
      }
    }, {
      key: 'messageSentType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.messages_sent);
      }
    }, {
      key: 'messageReceivedType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.messages_received);
      }
    }, {
      key: 'mentionType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.mentions);
      }
    }, {
      key: 'isPM',
      initializer: function () {
        return Em.computed.or('messageSentType', 'messageReceivedType');
      }
    }, {
      key: 'postReplyType',
      initializer: function () {
        return Em.computed.or('postType', 'replyType');
      }
    }, {
      key: 'removableBookmark',
      initializer: function () {
        return Em.computed.and('bookmarkType', 'sameUser');
      }
    }, {
      key: 'addChild',
      value: function (action) {
        var groups = this.get("childGroups");
        if (!groups) {
          groups = {
            likes: UserActionGroup.create({ icon: "fa fa-heart" }),
            stars: UserActionGroup.create({ icon: "fa fa-star" }),
            edits: UserActionGroup.create({ icon: "fa fa-pencil" }),
            bookmarks: UserActionGroup.create({ icon: "fa fa-bookmark" })
          };
        }
        this.set("childGroups", groups);

        var bucket = (function () {
          switch (action.action_type) {
            case UserActionTypes.likes_given:
            case UserActionTypes.likes_received:
              return "likes";
            case UserActionTypes.edits:
              return "edits";
            case UserActionTypes.bookmarks:
              return "bookmarks";
          }
        })();
        var current = groups[bucket];
        if (current) {
          current.push(action);
        }
      }
    }, {
      key: 'children',
      initializer: function () {
        return (function () {
          var g = this.get("childGroups");
          var rval = [];
          if (g) {
            rval = [g.likes, g.stars, g.edits, g.bookmarks].filter(function (i) {
              return i.get("items") && i.get("items").length > 0;
            });
          }
          return rval;
        }).property("childGroups", "childGroups.likes.items", "childGroups.likes.items.@each", "childGroups.stars.items", "childGroups.stars.items.@each", "childGroups.edits.items", "childGroups.edits.items.@each", "childGroups.bookmarks.items", "childGroups.bookmarks.items.@each");
      }
    }, {
      key: 'switchToActing',
      value: function () {
        this.setProperties({
          username: this.get('acting_username'),
          name: this.get('actingDisplayName')
        });
      }
    }]));

    UserAction.reopenClass({
      collapseStream: function (stream) {
        var uniq = {};
        var collapsed = [];
        var pos = 0;

        stream.forEach(function (item) {
          var key = "" + item.topic_id + "-" + item.post_number;
          var found = uniq[key];
          if (found === void 0) {

            var current = undefined;
            if (UserAction.TO_COLLAPSE.indexOf(item.action_type) >= 0) {
              current = UserAction.create(item);
              item.switchToActing();
              current.addChild(item);
            } else {
              current = item;
            }
            uniq[key] = pos;
            collapsed[pos] = current;
            pos += 1;
          } else {
            if (UserAction.TO_COLLAPSE.indexOf(item.action_type) >= 0) {
              item.switchToActing();
              collapsed[found].addChild(item);
            } else {
              collapsed[found].setProperties(item.getProperties('action_type', 'description'));
            }
          }
        });
        return collapsed;
      },

      TYPES: UserActionTypes,
      TYPES_INVERTED: InvertedActionTypes,

      TO_COLLAPSE: [UserActionTypes.likes_given, UserActionTypes.likes_received, UserActionTypes.edits, UserActionTypes.bookmarks],

      TO_SHOW: [UserActionTypes.likes_given, UserActionTypes.likes_received, UserActionTypes.edits, UserActionTypes.bookmarks, UserActionTypes.messages_sent, UserActionTypes.messages_received]

    });

    __exports__["default"] = UserAction;
  });

Discourse.UserAction = require('discourse/models/user-action').default;
define("discourse/models/draft", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Draft = Discourse.Model.extend();

    Draft.reopenClass({

      clear: function (key, sequence) {
        return Discourse.ajax("/draft.json", {
          type: 'DELETE',
          data: {
            draft_key: key,
            sequence: sequence
          }
        });
      },

      get: function (key) {
        return Discourse.ajax('/draft.json', {
          data: { draft_key: key },
          dataType: 'json'
        });
      },

      getLocal: function (key, current) {
        // TODO: implement this
        return current;
      },

      save: function (key, sequence, data) {
        data = typeof data === "string" ? data : JSON.stringify(data);
        return Discourse.ajax("/draft.json", {
          type: 'POST',
          data: {
            draft_key: key,
            data: data,
            sequence: sequence
          }
        });
      }

    });

    __exports__["default"] = Draft;
  });define("discourse/models/composer", 
  ["discourse/models/rest","discourse/models/topic","discourse/lib/ajax-error","discourse/lib/quote","discourse/models/draft","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var Topic = __dependency2__["default"];
    var throwAjaxError = __dependency3__.throwAjaxError;
    var Quote = __dependency4__["default"];
    var Draft = __dependency5__["default"];
    var computed = __dependency6__["default"];

    var CLOSED = 'closed',
        SAVING = 'saving',
        OPEN = 'open',
        DRAFT = 'draft',

    // The actions the composer can take
    CREATE_TOPIC = 'createTopic',
        PRIVATE_MESSAGE = 'privateMessage',
        REPLY = 'reply',
        EDIT = 'edit',
        REPLY_AS_NEW_TOPIC_KEY = "reply_as_new_topic",

    // When creating, these fields are moved into the post model from the composer model
    _create_serializer = {
      raw: 'reply',
      title: 'title',
      category: 'categoryId',
      topic_id: 'topic.id',
      is_warning: 'isWarning',
      whisper: 'whisper',
      archetype: 'archetypeId',
      target_usernames: 'targetUsernames',
      typing_duration_msecs: 'typingTime',
      composer_open_duration_msecs: 'composerTime'
    },
        _edit_topic_serializer = {
      title: 'topic.title',
      categoryId: 'topic.category.id'
    };

    var Composer = RestModel.extend(_createDecoratedObject([{
      key: '_categoryId',
      initializer: function () {
        return null;
      }
    }, {
      key: 'archetypes',
      initializer: function () {
        return (function () {
          return this.site.get('archetypes');
        }).property();
      }
    }, {
      key: 'categoryId',
      decorators: [computed],
      initializer: function () {
        return {
          get: function () {
            return this._categoryId;
          },

          // We wrap categoryId this way so we can fire `applyTopicTemplate` with
          // the previous value as well as the new value
          set: function (categoryId) {
            var oldCategoryId = this._categoryId;

            if (Ember.isEmpty(categoryId)) {
              categoryId = null;
            }
            this._categoryId = categoryId;

            if (oldCategoryId !== categoryId) {
              this.applyTopicTemplate(oldCategoryId, categoryId);
            }
            return categoryId;
          }
        };
      }
    }, {
      key: 'creatingTopic',
      initializer: function () {
        return Em.computed.equal('action', CREATE_TOPIC);
      }
    }, {
      key: 'creatingPrivateMessage',
      initializer: function () {
        return Em.computed.equal('action', PRIVATE_MESSAGE);
      }
    }, {
      key: 'notCreatingPrivateMessage',
      initializer: function () {
        return Em.computed.not('creatingPrivateMessage');
      }
    }, {
      key: 'showCategoryChooser',
      decorators: [computed("privateMessage", "archetype.hasOptions", "categoryId")],
      value: function (isPrivateMessage, hasOptions, categoryId) {
        var manyCategories = Discourse.Category.list().length > 1;
        var category = Discourse.Category.findById(categoryId);
        var containsMessages = category && category.get("contains_messages");
        return !isPrivateMessage && !containsMessages && (hasOptions || manyCategories);
      }
    }, {
      key: 'privateMessage',
      initializer: function () {
        return (function () {
          return this.get('creatingPrivateMessage') || this.get('topic.archetype') === 'private_message';
        }).property('creatingPrivateMessage', 'topic');
      }
    }, {
      key: 'topicFirstPost',
      initializer: function () {
        return Em.computed.or('creatingTopic', 'editingFirstPost');
      }
    }, {
      key: 'editingPost',
      initializer: function () {
        return Em.computed.equal('action', EDIT);
      }
    }, {
      key: 'replyingToTopic',
      initializer: function () {
        return Em.computed.equal('action', REPLY);
      }
    }, {
      key: 'viewOpen',
      initializer: function () {
        return Em.computed.equal('composeState', OPEN);
      }
    }, {
      key: 'viewDraft',
      initializer: function () {
        return Em.computed.equal('composeState', DRAFT);
      }
    }, {
      key: 'composeStateChanged',
      initializer: function () {
        return (function () {
          var oldOpen = this.get('composerOpened');

          if (this.get('composeState') === OPEN) {
            this.set('composerOpened', oldOpen || new Date());
          } else {
            if (oldOpen) {
              var oldTotal = this.get('composerTotalOpened') || 0;
              this.set('composerTotalOpened', oldTotal + (new Date() - oldOpen));
            }
            this.set('composerOpened', null);
          }
        }).observes('composeState');
      }
    }, {
      key: 'composerTime',
      initializer: function () {
        return (function () {
          var total = this.get('composerTotalOpened') || 0;

          var oldOpen = this.get('composerOpened');
          if (oldOpen) {
            total += new Date() - oldOpen;
          }

          return total;
        }).property().volatile();
      }
    }, {
      key: 'archetype',
      initializer: function () {
        return (function () {
          return this.get('archetypes').findProperty('id', this.get('archetypeId'));
        }).property('archetypeId');
      }
    }, {
      key: 'archetypeChanged',
      initializer: function () {
        return (function () {
          return this.set('metaData', Em.Object.create());
        }).observes('archetype');
      }
    }, {
      key: 'typing',

      // view detected user is typing
      initializer: function () {
        return _.throttle(function () {
          var typingTime = this.get("typingTime") || 0;
          this.set("typingTime", typingTime + 100);
        }, 100, { leading: false, trailing: true });
      }
    }, {
      key: 'editingFirstPost',
      initializer: function () {
        return Em.computed.and('editingPost', 'post.firstPost');
      }
    }, {
      key: 'canEditTitle',
      initializer: function () {
        return Em.computed.or('creatingTopic', 'creatingPrivateMessage', 'editingFirstPost');
      }
    }, {
      key: 'canCategorize',
      initializer: function () {
        return Em.computed.and('canEditTitle', 'notCreatingPrivateMessage');
      }
    }, {
      key: 'actionTitle',

      // Determine the appropriate title for this action
      initializer: function () {
        return (function () {
          var topic = this.get('topic');

          var postLink = undefined,
              topicLink = undefined,
              usernameLink = undefined;
          if (topic) {
            var postNumber = this.get('post.post_number');
            postLink = "<a href='" + topic.get('url') + "/" + postNumber + "'>" + I18n.t("post.post_number", { number: postNumber }) + "</a>";
            topicLink = "<a href='" + topic.get('url') + "'> " + Discourse.Utilities.escapeExpression(topic.get('title')) + "</a>";
            usernameLink = "<a href='" + topic.get('url') + "/" + postNumber + "'>" + this.get('post.username') + "</a>";
          }

          var postDescription = undefined;
          var post = this.get('post');

          if (post) {
            postDescription = I18n.t('post.' + this.get('action'), {
              link: postLink,
              replyAvatar: Discourse.Utilities.tinyAvatar(post.get('avatar_template')),
              username: this.get('post.username'),
              usernameLink: usernameLink
            });

            if (!Discourse.Mobile.mobileView) {
              var replyUsername = post.get('reply_to_user.username');
              var replyAvatarTemplate = post.get('reply_to_user.avatar_template');
              if (replyUsername && replyAvatarTemplate && this.get('action') === EDIT) {
                postDescription += " <i class='fa fa-mail-forward reply-to-glyph'></i> " + Discourse.Utilities.tinyAvatar(replyAvatarTemplate) + " " + replyUsername;
              }
            }
          }

          switch (this.get('action')) {
            case PRIVATE_MESSAGE:
              return I18n.t('topic.private_message');
            case CREATE_TOPIC:
              return I18n.t('topic.create_long');
            case REPLY:
            case EDIT:
              if (postDescription) return postDescription;
              if (topic) return I18n.t('post.reply_topic', { link: topicLink });
          }
        }).property('action', 'post', 'topic', 'topic.title');
      }
    }, {
      key: 'cantSubmitPost',

      // whether to disable the post button
      initializer: function () {
        return (function () {

          // can't submit while loading
          if (this.get('loading')) return true;

          // title is required when
          //  - creating a new topic/private message
          //  - editing the 1st post
          if (this.get('canEditTitle') && !this.get('titleLengthValid')) return true;

          // reply is always required
          if (this.get('missingReplyCharacters') > 0) return true;

          if (this.get("privateMessage")) {
            // need at least one user when sending a PM
            return this.get('targetUsernames') && (this.get('targetUsernames').trim() + ',').indexOf(',') === 0;
          } else {
            // has a category? (when needed)
            return this.get('canCategorize') && !this.siteSettings.allow_uncategorized_topics && !this.get('categoryId') && !this.user.get('admin');
          }
        }).property('loading', 'canEditTitle', 'titleLength', 'targetUsernames', 'replyLength', 'categoryId', 'missingReplyCharacters');
      }
    }, {
      key: 'titleLengthValid',
      initializer: function () {
        return (function () {
          if (this.user.get('admin') && this.get('post.static_doc') && this.get('titleLength') > 0) return true;
          if (this.get('titleLength') < this.get('minimumTitleLength')) return false;
          return this.get('titleLength') <= this.siteSettings.max_topic_title_length;
        }).property('minimumTitleLength', 'titleLength', 'post.static_doc');
      }
    }, {
      key: 'saveIcon',

      // The icon for the save button
      initializer: function () {
        return (function () {
          switch (this.get('action')) {
            case EDIT:
              return '<i class="fa fa-pencil"></i>';
            case REPLY:
              return '<i class="fa fa-reply"></i>';
            case CREATE_TOPIC:
              return '<i class="fa fa-plus"></i>';
            case PRIVATE_MESSAGE:
              return '<i class="fa fa-envelope"></i>';
          }
        }).property('action');
      }
    }, {
      key: 'saveText',

      // The text for the save button
      initializer: function () {
        return (function () {
          switch (this.get('action')) {
            case EDIT:
              return I18n.t('composer.save_edit');
            case REPLY:
              return I18n.t('composer.reply');
            case CREATE_TOPIC:
              return I18n.t('composer.create_topic');
            case PRIVATE_MESSAGE:
              return I18n.t('composer.create_pm');
          }
        }).property('action');
      }
    }, {
      key: 'hasMetaData',
      initializer: function () {
        return (function () {
          var metaData = this.get('metaData');
          return metaData ? Em.isEmpty(Em.keys(this.get('metaData'))) : false;
        }).property('metaData');
      }
    }, {
      key: 'replyDirty',

      /**
        Did the user make changes to the reply?
         @property replyDirty
      **/
      initializer: function () {
        return (function () {
          return this.get('reply') !== this.get('originalText');
        }).property('reply', 'originalText');
      }
    }, {
      key: 'missingTitleCharacters',

      /**
        Number of missing characters in the title until valid.
         @property missingTitleCharacters
      **/
      initializer: function () {
        return (function () {
          return this.get('minimumTitleLength') - this.get('titleLength');
        }).property('minimumTitleLength', 'titleLength');
      }
    }, {
      key: 'minimumTitleLength',

      /**
        Minimum number of characters for a title to be valid.
         @property minimumTitleLength
      **/
      initializer: function () {
        return (function () {
          if (this.get('privateMessage')) {
            return this.siteSettings.min_private_message_title_length;
          } else {
            return this.siteSettings.min_topic_title_length;
          }
        }).property('privateMessage');
      }
    }, {
      key: 'missingReplyCharacters',
      initializer: function () {
        return (function () {
          var postType = this.get('post.post_type');
          if (postType === this.site.get('post_types.small_action')) {
            return 0;
          }
          return this.get('minimumPostLength') - this.get('replyLength');
        }).property('minimumPostLength', 'replyLength');
      }
    }, {
      key: 'minimumPostLength',

      /**
        Minimum number of characters for a post body to be valid.
         @property minimumPostLength
      **/
      initializer: function () {
        return (function () {
          if (this.get('privateMessage')) {
            return this.siteSettings.min_private_message_post_length;
          } else if (this.get('topicFirstPost')) {
            // first post (topic body)
            return this.siteSettings.min_first_post_length;
          } else {
            return this.siteSettings.min_post_length;
          }
        }).property('privateMessage', 'topicFirstPost');
      }
    }, {
      key: 'titleLength',

      /**
        Computes the length of the title minus non-significant whitespaces
         @property titleLength
      **/
      initializer: function () {
        return (function () {
          var title = this.get('title') || "";
          return title.replace(/\s+/img, " ").trim().length;
        }).property('title');
      }
    }, {
      key: 'replyLength',

      /**
        Computes the length of the reply minus the quote(s) and non-significant whitespaces
         @property replyLength
      **/
      initializer: function () {
        return (function () {
          var reply = this.get('reply') || "";
          while (Quote.REGEXP.test(reply)) {
            reply = reply.replace(Quote.REGEXP, "");
          }
          return reply.replace(/\s+/img, " ").trim().length;
        }).property('reply');
      }
    }, {
      key: '_setupComposer',
      initializer: function () {
        return (function () {
          this.set('archetypeId', this.site.get('default_archetype'));
        }).on('init');
      }
    }, {
      key: 'appendText',

      /**
        Append text to the current reply
         @method appendText
        @param {String} text the text to append
      **/
      value: function (text, position, opts) {
        var reply = this.get('reply') || '';
        position = typeof position === "number" ? position : reply.length;

        var before = reply.slice(0, position) || '';
        var after = reply.slice(position) || '';

        var stripped = undefined,
            i = undefined;
        if (opts && opts.block) {
          if (before.trim() !== "") {
            stripped = before.replace(/\r/g, "");
            for (i = 0; i < 2; i++) {
              if (stripped[stripped.length - 1 - i] !== "\n") {
                before += "\n";
                position++;
              }
            }
          }
          if (after.trim() !== "") {
            stripped = after.replace(/\r/g, "");
            for (i = 0; i < 2; i++) {
              if (stripped[i] !== "\n") {
                after = "\n" + after;
              }
            }
          }
        }

        if (opts && opts.space) {
          if (before.length > 0 && !before[before.length - 1].match(/\s/)) {
            before = before + " ";
          }
          if (after.length > 0 && !after[0].match(/\s/)) {
            after = " " + after;
          }
        }

        this.set('reply', before + text + after);

        return before.length + text.length;
      }
    }, {
      key: 'applyTopicTemplate',
      value: function (oldCategoryId, categoryId) {
        if (this.get('action') !== CREATE_TOPIC) {
          return;
        }
        var reply = this.get('reply');

        // If the user didn't change the template, clear it
        if (oldCategoryId) {
          var oldCat = this.site.categories.findProperty('id', oldCategoryId);
          if (oldCat && oldCat.get('topic_template') === reply) {
            reply = "";
          }
        }

        if (!Ember.isEmpty(reply)) {
          return;
        }
        var category = this.site.categories.findProperty('id', categoryId);
        if (category) {
          this.set('reply', category.get('topic_template') || "");
        }
      }
    }, {
      key: 'open',

      /*
         Open a composer
          opts:
           action   - The action we're performing: edit, reply or createTopic
           post     - The post we're replying to, if present
           topic    - The topic we're replying to, if present
           quote    - If we're opening a reply from a quote, the quote we're making
      */
      value: function (opts) {
        if (!opts) opts = {};
        this.set('loading', false);

        var replyBlank = Em.isEmpty(this.get("reply"));

        var composer = this;
        if (!replyBlank && ((opts.reply || opts.action === EDIT) && this.get('replyDirty'))) {
          return;
        }

        if (opts.action === REPLY && this.get('action') === EDIT) this.set('reply', '');
        if (!opts.draftKey) throw 'draft key is required';
        if (opts.draftSequence === null) throw 'draft sequence is required';

        this.setProperties({
          draftKey: opts.draftKey,
          draftSequence: opts.draftSequence,
          composeState: opts.composerState || OPEN,
          action: opts.action,
          topic: opts.topic,
          targetUsernames: opts.usernames,
          composerTotalOpened: opts.composerTime,
          typingTime: opts.typingTime
        });

        if (opts.post) {
          this.set('post', opts.post);

          this.set('whisper', opts.post.get('post_type') === this.site.get('post_types.whisper'));
          if (!this.get('topic')) {
            this.set('topic', opts.post.get('topic'));
          }
        } else {
          this.set('post', null);
        }

        this.setProperties({
          archetypeId: opts.archetypeId || this.site.get('default_archetype'),
          metaData: opts.metaData ? Em.Object.create(opts.metaData) : null,
          reply: opts.reply || this.get("reply") || ""
        });

        // We set the category id separately for topic templates on opening of composer
        this.set('categoryId', opts.categoryId || this.get('topic.category.id'));

        if (!this.get('categoryId') && this.get('creatingTopic')) {
          var categories = Discourse.Category.list();
          if (categories.length === 1) {
            this.set('categoryId', categories[0].get('id'));
          }
        }

        if (opts.postId) {
          this.set('loading', true);
          this.store.find('post', opts.postId).then(function (post) {
            composer.set('post', post);
            composer.set('loading', false);
          });
        }

        // If we are editing a post, load it.
        if (opts.action === EDIT && opts.post) {

          var topicProps = this.serialize(_edit_topic_serializer);
          topicProps.loading = true;

          this.setProperties(topicProps);

          this.store.find('post', opts.post.get('id')).then(function (post) {
            composer.setProperties({
              reply: post.get('raw'),
              originalText: post.get('raw'),
              loading: false
            });
          });
        } else if (opts.action === REPLY && opts.quote) {
          this.setProperties({
            reply: opts.quote,
            originalText: opts.quote
          });
        }
        if (opts.title) {
          this.set('title', opts.title);
        }
        this.set('originalText', opts.draft ? '' : this.get('reply'));

        return false;
      }
    }, {
      key: 'save',
      value: function (opts) {
        if (!this.get('cantSubmitPost')) {
          return this.get('editingPost') ? this.editPost(opts) : this.createPost(opts);
        }
      }
    }, {
      key: 'clearState',

      /**
        Clear any state we have in preparation for a new composition.
         @method clearState
      **/
      value: function () {
        this.setProperties({
          originalText: null,
          reply: null,
          post: null,
          title: null,
          editReason: null,
          stagedPost: false,
          typingTime: 0,
          composerOpened: null,
          composerTotalOpened: 0
        });
      }
    }, {
      key: 'editPost',

      // When you edit a post
      value: function (opts) {
        var post = this.get('post'),
            oldCooked = post.get('cooked'),
            self = this;

        var promise = undefined;

        // Update the title if we've changed it, otherwise consider it a
        // successful resolved promise
        if (this.get('title') && post.get('post_number') === 1 && this.get('topic.details.can_edit')) {
          var topicProps = this.getProperties(Object.keys(_edit_topic_serializer));

          promise = Topic.update(this.get('topic'), topicProps);
        } else {
          promise = Ember.RSVP.resolve();
        }

        var props = {
          raw: this.get('reply'),
          edit_reason: opts.editReason,
          image_sizes: opts.imageSizes,
          cooked: this.getCookedHtml()
        };

        this.set('composeState', CLOSED);

        var rollback = throwAjaxError(function () {
          post.set('cooked', oldCooked);
          self.set('composeState', OPEN);
        });

        return promise.then(function () {
          return post.save(props).then(function (result) {
            self.clearState();
            return result;
          }).catch(function (error) {
            throw error;
          });
        }).catch(rollback);
      }
    }, {
      key: 'serialize',
      value: function (serializer, dest) {
        var _this = this;

        dest = dest || {};
        Object.keys(serializer).forEach(function (f) {
          var val = _this.get(serializer[f]);
          if (typeof val !== 'undefined') {
            Ember.set(dest, f, val);
          }
        });
        return dest;
      }
    }, {
      key: 'createPost',

      // Create a new Post
      value: function (opts) {
        var post = this.get('post'),
            topic = this.get('topic'),
            user = this.user,
            postStream = this.get('topic.postStream');

        var addedToStream = false;

        var postTypes = this.site.get('post_types');
        var postType = this.get('whisper') ? postTypes.whisper : postTypes.regular;

        // Build the post object
        var createdPost = this.store.createRecord('post', {
          imageSizes: opts.imageSizes,
          cooked: this.getCookedHtml(),
          reply_count: 0,
          name: user.get('name'),
          display_username: user.get('name'),
          username: user.get('username'),
          user_id: user.get('id'),
          user_title: user.get('title'),
          avatar_template: user.get('avatar_template'),
          user_custom_fields: user.get('custom_fields'),
          post_type: postType,
          actions_summary: [],
          moderator: user.get('moderator'),
          admin: user.get('admin'),
          yours: true,
          read: true,
          wiki: false,
          typingTime: this.get('typingTime'),
          composerTime: this.get('composerTime')
        });

        this.serialize(_create_serializer, createdPost);

        if (post) {
          createdPost.setProperties({
            reply_to_post_number: post.get('post_number'),
            reply_to_user: {
              username: post.get('username'),
              avatar_template: post.get('avatar_template')
            }
          });
        }

        var state = null;

        // If we're in a topic, we can append the post instantly.
        if (postStream) {
          // If it's in reply to another post, increase the reply count
          if (post) {
            post.set('reply_count', (post.get('reply_count') || 0) + 1);
            post.set('replies', []);
          }

          // We do not stage posts in mobile view, we do not have the "cooked"
          // Furthermore calculating cooked is very complicated, especially since
          // we would need to handle oneboxes and other bits that are not even in the
          // engine, staging will just cause a blank post to render
          if (!_.isEmpty(createdPost.get('cooked'))) {
            state = postStream.stagePost(createdPost, user);
            if (state === "alreadyStaging") {
              return;
            }
          }
        }

        var composer = this;
        composer.set('composeState', SAVING);
        composer.set("stagedPost", state === "staged" && createdPost);

        return createdPost.save().then(function (result) {
          var saving = true;

          if (result.responseJson.action === "enqueued") {
            if (postStream) {
              postStream.undoPost(createdPost);
            }
            return result;
          }

          if (topic) {
            // It's no longer a new post
            topic.set('draft_sequence', result.target.draft_sequence);
            postStream.commitPost(createdPost);
            addedToStream = true;
          } else {
            // We created a new topic, let's show it.
            composer.set('composeState', CLOSED);
            saving = false;

            // Update topic_count for the category
            var category = composer.site.get('categories').find(function (x) {
              return x.get('id') === (parseInt(createdPost.get('category'), 10) || 1);
            });
            if (category) category.incrementProperty('topic_count');
            Discourse.notifyPropertyChange('globalNotice');
          }

          composer.clearState();
          composer.set('createdPost', createdPost);

          if (addedToStream) {
            composer.set('composeState', CLOSED);
          } else if (saving) {
            composer.set('composeState', SAVING);
          }

          return result;
        }).catch(throwAjaxError(function () {
          if (postStream) {
            postStream.undoPost(createdPost);
          }
          Ember.run.next(function () {
            return composer.set('composeState', OPEN);
          });
        }));
      }
    }, {
      key: 'getCookedHtml',
      value: function () {
        return $('#reply-control .d-editor-preview').html().replace(/<span class="marker"><\/span>/g, '');
      }
    }, {
      key: 'saveDraft',
      value: function () {
        // Do not save when drafts are disabled
        if (this.get('disableDrafts')) return;
        // Do not save when there is no reply
        if (!this.get('reply')) return;
        // Do not save when the reply's length is too small
        if (this.get('replyLength') < this.siteSettings.min_post_length) return;

        var data = {
          reply: this.get('reply'),
          action: this.get('action'),
          title: this.get('title'),
          categoryId: this.get('categoryId'),
          postId: this.get('post.id'),
          archetypeId: this.get('archetypeId'),
          metaData: this.get('metaData'),
          usernames: this.get('targetUsernames'),
          composerTime: this.get('composerTime'),
          typingTime: this.get('typingTime')
        };

        this.set('draftStatus', I18n.t('composer.saving_draft_tip'));

        var composer = this;

        if (this._clearingStatus) {
          Em.run.cancel(this._clearingStatus);
          this._clearingStatus = null;
        }

        // try to save the draft
        return Draft.save(this.get('draftKey'), this.get('draftSequence'), data).then(function () {
          composer.set('draftStatus', I18n.t('composer.saved_draft_tip'));
        }).catch(function () {
          composer.set('draftStatus', I18n.t('composer.drafts_offline'));
        });
      }
    }, {
      key: 'dataChanged',
      initializer: function () {
        return (function () {
          var draftStatus = this.get('draftStatus');
          var self = this;

          if (draftStatus && !this._clearingStatus) {

            this._clearingStatus = Em.run.later(this, function () {
              self.set('draftStatus', null);
              self._clearingStatus = null;
            }, 1000);
          }
        }).observes('title', 'reply');
      }
    }]));

    Composer.reopenClass({

      // TODO: Replace with injection
      create: function (args) {
        args = args || {};
        args.user = args.user || Discourse.User.current();
        args.site = args.site || Discourse.Site.current();
        args.siteSettings = args.siteSettings || Discourse.SiteSettings;
        return this._super(args);
      },

      serializeToTopic: function (fieldName, property) {
        if (!property) {
          property = fieldName;
        }
        _edit_topic_serializer[fieldName] = property;
      },

      serializeOnCreate: function (fieldName, property) {
        if (!property) {
          property = fieldName;
        }
        _create_serializer[fieldName] = property;
      },

      serializedFieldsForCreate: function () {
        return Object.keys(_create_serializer);
      },

      // The status the compose view can have
      CLOSED: CLOSED,
      SAVING: SAVING,
      OPEN: OPEN,
      DRAFT: DRAFT,

      // The actions the composer can take
      CREATE_TOPIC: CREATE_TOPIC,
      PRIVATE_MESSAGE: PRIVATE_MESSAGE,
      REPLY: REPLY,
      EDIT: EDIT,

      // Draft key
      REPLY_AS_NEW_TOPIC_KEY: REPLY_AS_NEW_TOPIC_KEY
    });

    __exports__["default"] = Composer;
  });define("discourse/mixins/add-archetype-class", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Mix this in to a view that has a `archetype` property to automatically
    // add it to the body as the view is entered / left / model is changed.
    // This is used for keeping the `body` style in sync for the background image.
    __exports__["default"] = {
      _init: (function () {
        this.get('archetype');
      }).on('init'),

      _cleanUp: function () {
        $('body').removeClass(function (_, css) {
          return (css.match(/\barchetype-\S+/g) || []).join(' ');
        });
      },

      _archetypeChanged: (function () {
        var archetype = this.get('archetype');
        this._cleanUp();

        if (archetype) {
          $('body').addClass('archetype-' + archetype);
        }
      }).observes('archetype'),

      _willDestroyElement: (function () {
        this._cleanUp();
      }).on('willDestroyElement')
    };
  });

Discourse.AddArchetypeClass = require('discourse/mixins/add-archetype-class').default;
define("discourse/mixins/add-category-class", 
  ["ember","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // Mix this in to a view that has a `categoryFullSlug` property to automatically
    // add it to the body as the view is entered / left / model is changed.
    // This is used for keeping the `body` style in sync for the background image.

    var Ember = __dependency1__["default"];
    var on = Ember.on;
    var observer = Ember.observer;

    __exports__["default"] = {
      _categoryChanged: on("didInsertElement", observer("categoryFullSlug", function () {
        var categoryFullSlug = this.get("categoryFullSlug");

        this._removeClass();

        if (categoryFullSlug) {
          $("body").addClass("category-" + categoryFullSlug);
        }
      })),

      _leave: on("willDestroyElement", function () {
        this.removeObserver("categoryFullSlug");
        this._removeClass();
      }),

      _removeClass: function () {
        $("body").removeClass(function (_, css) {
          return (css.match(/\bcategory-\S+/g) || []).join(" ");
        });
      }
    };
  });

Discourse.AddCategoryClass = require('discourse/mixins/add-category-class').default;
define("discourse/mixins/badge-select-controller", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({
      saving: false,
      saved: false,

      selectableUserBadges: (function () {
        var items = this.get('filteredList');
        items = _.uniq(items, false, function (e) {
          return e.get('badge.name');
        });
        items.unshiftObject(Em.Object.create({
          badge: Badge.create({ name: I18n.t('badges.none') })
        }));
        return items;
      }).property('filteredList'),

      savingStatus: (function () {
        if (this.get('saving')) {
          return I18n.t('saving');
        } else {
          return I18n.t('save');
        }
      }).property('saving'),

      selectedUserBadge: (function () {
        var selectedUserBadgeId = parseInt(this.get('selectedUserBadgeId'));
        var selectedUserBadge = null;
        this.get('selectableUserBadges').forEach(function (userBadge) {
          if (userBadge.get('id') === selectedUserBadgeId) {
            selectedUserBadge = userBadge;
          }
        });
        return selectedUserBadge;
      }).property('selectedUserBadgeId'),

      disableSave: Em.computed.alias('saving')
    });
  });

Discourse.BadgeSelectController = require('discourse/mixins/badge-select-controller').default;
define("discourse/mixins/buffered-content", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.bufferedProperty = bufferedProperty;
    /* global BufferedProxy: true */

    function bufferedProperty(property) {
      var mixin = {
        buffered: (function () {
          return Em.ObjectProxy.extend(BufferedProxy).create({
            content: this.get(property)
          });
        }).property(property),

        rollbackBuffer: function () {
          this.get('buffered').discardBufferedChanges();
        },

        commitBuffer: function () {
          this.get('buffered').applyBufferedChanges();
        }
      };

      // It's a good idea to null out fields when declaring objects
      mixin.property = null;

      return Ember.Mixin.create(mixin);
    }

    __exports__["default"] = bufferedProperty('content');
  });

Discourse.BufferedContent = require('discourse/mixins/buffered-content').default;
define("discourse/mixins/bulk-topic-selection", 
  ["discourse/lib/notification-levels","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationLevels = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({
      bulkSelectEnabled: false,
      selected: null,

      canBulkSelect: Em.computed.alias('currentUser.staff'),

      resetSelected: (function () {
        this.set('selected', []);
      }).on('init'),

      actions: {
        toggleBulkSelect: function () {
          this.toggleProperty('bulkSelectEnabled');
          this.get('selected').clear();
        },

        dismissRead: function (operationType) {
          var self = this,
              selected = this.get('selected');

          var operation = undefined;
          if (operationType === "posts") {
            operation = { type: 'dismiss_posts' };
          } else {
            operation = { type: 'change_notification_level',
              notification_level_id: NotificationLevels.REGULAR };
          }

          var promise = undefined;
          if (selected.length > 0) {
            promise = Discourse.Topic.bulkOperation(selected, operation);
          } else {
            promise = Discourse.Topic.bulkOperationByFilter('unread', operation, this.get('category.id'));
          }
          promise.then(function (result) {
            if (result && result.topic_ids) {
              (function () {
                var tracker = self.topicTrackingState;
                result.topic_ids.forEach(function (t) {
                  tracker.removeTopic(t);
                });
                tracker.incrementMessageCount();
              })();
            }
            self.send('closeModal');
            self.send('refresh');
          });
        }
      }
    });
  });

Discourse.BulkTopicSelection = require('discourse/mixins/bulk-topic-selection').default;
define("discourse/mixins/can-check-emails", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var setting = __dependency1__.setting;

    __exports__["default"] = Ember.Mixin.create({
      isOwnEmail: propertyEqual("model.id", "currentUser.id"),
      showEmailOnProfile: setting("show_email_on_profile"),
      canStaffCheckEmails: Em.computed.and("showEmailOnProfile", "currentUser.staff"),
      canAdminCheckEmails: Em.computed.alias("currentUser.admin"),
      canCheckEmails: Em.computed.or("isOwnEmail", "canStaffCheckEmails", "canAdminCheckEmails")
    });
  });

Discourse.CanCheckEmails = require('discourse/mixins/can-check-emails').default;
define("discourse/mixins/cleans-up", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Include this mixin if you want to be notified when the dom should be
    // cleaned (usually on route change.)
    __exports__["default"] = Ember.Mixin.create({
      _initializeChooser: (function () {
        this.appEvents.on('dom:clean', this, "cleanUp");
      }).on('didInsertElement'),

      _clearChooser: (function () {
        this.appEvents.off('dom:clean', this, "cleanUp");
      }).on('willDestroyElement')
    });
  });

Discourse.CleansUp = require('discourse/mixins/cleans-up').default;
define("discourse/mixins/load-more", 
  ["discourse/lib/eyeline","discourse/mixins/scrolling","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var Eyeline = __dependency1__["default"];
    var Scrolling = __dependency2__["default"];
    var on = __dependency3__.on;

    //  Provides the ability to load more items for a view which is scrolled to the bottom.
    __exports__["default"] = Ember.Mixin.create(Ember.ViewTargetActionSupport, Scrolling, _createDecoratedObject([{
      key: 'scrolled',
      value: function () {
        var eyeline = this.get('eyeline');
        if (eyeline) {
          eyeline.update();
        }
      }
    }, {
      key: 'loadMoreUnlessFull',
      value: function () {
        if (this.screenNotFull()) {
          this.send("loadMore");
        }
      }
    }, {
      key: '_bindEyeline',
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        var eyeline = new Eyeline(this.get('eyelineSelector') + ":last");
        this.set('eyeline', eyeline);
        eyeline.on('sawBottom', function () {
          return _this.send('loadMore');
        });
        this.bindScrolling();
      }
    }, {
      key: '_removeEyeline',
      decorators: [on("willDestroyElement")],
      value: function () {
        this.unbindScrolling();
      }
    }]));
  });

Discourse.LoadMore = require('discourse/mixins/load-more').default;
define("discourse/mixins/modal-functionality", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({
      flashMessage: null,

      needs: ['modal'],

      flash: function (message, messageClass) {
        this.set('flashMessage', Em.Object.create({ message: message, messageClass: messageClass }));
      }
    });
  });

Discourse.ModalFunctionality = require('discourse/mixins/modal-functionality').default;
define("discourse/mixins/open-composer", 
  ["discourse/models/composer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // This mixin allows a route to open the composer
    var Composer = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({

      openComposer: function (controller) {
        this.controllerFor('composer').open({
          categoryId: controller.get('category.id'),
          action: Composer.CREATE_TOPIC,
          draftKey: controller.get('model.draft_key'),
          draftSequence: controller.get('model.draft_sequence')
        });
      },

      openComposerWithTopicParams: function (controller, topicTitle, topicBody, topicCategoryId, topicCategory) {
        this.controllerFor('composer').open({
          action: Composer.CREATE_TOPIC,
          topicTitle: topicTitle,
          topicBody: topicBody,
          topicCategoryId: topicCategoryId,
          topicCategory: topicCategory,
          draftKey: controller.get('model.draft_key'),
          draftSequence: controller.get('model.draft_sequence')
        });
      },

      openComposerWithMessageParams: function (usernames, topicTitle, topicBody) {
        this.controllerFor('composer').open({
          action: Composer.PRIVATE_MESSAGE,
          usernames: usernames,
          topicTitle: topicTitle,
          topicBody: topicBody,
          archetypeId: 'private_message',
          draftKey: 'new_private_message'
        });
      }

    });
  });

Discourse.OpenComposer = require('discourse/mixins/open-composer').default;
define("discourse/mixins/scroll-top", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    function scrollTop() {
      if (DiscourseURL.isJumpScheduled()) {
        return;
      }
      Ember.run.schedule('afterRender', function () {
        $(document).scrollTop(0);
      });
    }

    __exports__["default"] = Ember.Mixin.create({
      _scrollTop: scrollTop.on('didInsertElement')
    });

    __exports__.scrollTop = scrollTop;
  });

Discourse.ScrollTop = require('discourse/mixins/scroll-top').default;
define("discourse/mixins/selected-posts-count", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({

      selectedPostsCount: (function () {
        if (this.get('allPostsSelected')) {
          return this.get('model.posts_count') || this.get('topic.posts_count') || this.get('posts_count');
        }

        var sum = this.get('selectedPosts.length') || 0;
        if (this.get('selectedReplies')) {
          this.get('selectedReplies').forEach(function (p) {
            sum += p.get('reply_count') || 0;
          });
        }

        return sum;
      }).property('selectedPosts.length', 'allPostsSelected', 'selectedReplies.length'),

      // The username that owns every selected post, or undefined if no selection or if ownership is mixed.
      selectedPostsUsername: (function () {
        // Don't proceed if replies are selected or usernames are mixed
        // Changing ownership in those cases normally doesn't make sense
        if (this.get('selectedReplies') && this.get('selectedReplies').length > 0) {
          return undefined;
        }
        if (this.get('selectedPosts').length <= 0) {
          return undefined;
        }

        var selectedPosts = this.get('selectedPosts'),
            username = selectedPosts[0].username;

        if (selectedPosts.every(function (post) {
          return post.username === username;
        })) {
          return username;
        } else {
          return undefined;
        }
      }).property('selectedPosts.length', 'selectedReplies.length')
    });
  });

Discourse.SelectedPostsCount = require('discourse/mixins/selected-posts-count').default;
define("discourse/mixins/singleton", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      This mixin allows a class to return a singleton, as well as a method to quickly
      read/write attributes on the singleton.


      Example usage:

      ```javascript

        // Define your class and apply the Mixin
        User = Ember.Object.extend({});
        User.reopenClass(Singleton);

        // Retrieve the current instance:
        var instance = User.current();

      ```

      Commonly you want to read or write a property on the singleton. There's a
      helper method which is a little nicer than `.current().get()`:

      ```javascript

        // Sets the age to 34
        User.currentProp('age', 34);

        console.log(User.currentProp('age')); // 34

      ```

      If you want to customize how the singleton is created, redefine the `createCurrent`
      method:

      ```javascript

        // Define your class and apply the Mixin
        Foot = Ember.Object.extend({});
        Foot.reopenClass(Singleton, {
          createCurrent: function() {
            return Foot.create({toes: 5});
          }
        });

        console.log(Foot.currentProp('toes')); // 5

      ```
    **/

    var Singleton = Ember.Mixin.create({

      current: function () {
        if (!this._current) {
          this._current = this.createCurrent();
        }
        return this._current;
      },

      /**
        How the singleton instance is created. This can be overridden
        with logic for creating (or even returning null) your instance.
         By default it just calls `create` with an empty object.
      **/
      createCurrent: function () {
        return this.create({});
      },

      // Returns OR sets a property on the singleton instance.
      currentProp: function (property, value) {
        var instance = this.current();
        if (!instance) {
          return;
        }

        if (typeof value !== "undefined") {
          instance.set(property, value);
          return value;
        } else {
          return instance.get(property);
        }
      },

      resetCurrent: function (val) {
        this._current = val;
      }
    });

    __exports__["default"] = Singleton;
  });

Discourse.Singleton = require('discourse/mixins/singleton').default;
define("discourse/mixins/stale-local-storage", 
  ["discourse/lib/stale-result","discourse/lib/hash","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StaleResult = __dependency1__["default"];
    var hashString = __dependency2__.hashString;

    // Mix this in to an adapter to provide stale caching in our key value store
    __exports__["default"] = {
      storageKey: function (type, findArgs) {
        var hashedArgs = Math.abs(hashString(JSON.stringify(findArgs)));
        return type + '_' + hashedArgs;
      },

      findStale: function (store, type, findArgs, opts) {
        var staleResult = new StaleResult();
        var key = opts && opts.storageKey || this.storageKey(type, findArgs);
        try {
          var stored = this.keyValueStore.getItem(key);
          if (stored) {
            var parsed = JSON.parse(stored);
            staleResult.setResults(parsed);
          }
        } catch (e) {
          // JSON parsing error
        }
        return staleResult;
      },

      find: function (store, type, findArgs, opts) {
        var _this = this;

        var key = opts && opts.storageKey || this.storageKey(type, findArgs);

        return this._super(store, type, findArgs).then(function (results) {
          _this.keyValueStore.setItem(key, JSON.stringify(results));
          return results;
        });
      }
    };
  });

Discourse.StaleLocalStorage = require('discourse/mixins/stale-local-storage').default;
define("discourse/mixins/string-buffer", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Mixin.create({

      _watchProps: (function () {
        var _this = this;

        var args = this.get('rerenderTriggers');
        if (!Ember.isNone(args)) {
          args.forEach(function (k) {
            return _this.addObserver(k, _this.rerenderString);
          });
        }
      }).on('init'),

      render: function (buffer) {
        this.renderString(buffer);
      },

      renderString: function (buffer) {
        var template = Discourse.__container__.lookup('template:' + this.rawTemplate);
        if (template) {
          buffer.push(template(this));
        }
      },

      _rerenderString: function () {
        var $sel = this.$();
        if (!$sel) {
          return;
        }

        var buffer = [];
        this.renderString(buffer);

        $sel.html(buffer.join(''));
      },

      rerenderString: function () {
        Ember.run.once(this, '_rerenderString');
      }

    });
  });

Discourse.StringBuffer = require('discourse/mixins/string-buffer').default;
define("discourse/mixins/upload", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({
      uploading: false,
      uploadProgress: 0,

      uploadDone: function () {
        Em.warn("You should implement `uploadDone`");
      },

      _initialize: (function () {
        var _this = this;

        var $upload = this.$(),
            csrf = Discourse.Session.currentProp("csrfToken"),
            uploadUrl = Discourse.getURL(this.getWithDefault("uploadUrl", "/uploads")),
            reset = function () {
          return _this.setProperties({ uploading: false, uploadProgress: 0 });
        };

        this.messageBus.subscribe("/uploads/" + this.get("type"), function (upload) {
          if (upload && upload.url) {
            _this.uploadDone(upload);
          } else {
            Discourse.Utilities.displayErrorForUpload(upload);
          }
          reset();
        });

        $upload.fileupload({
          url: uploadUrl + ".json?client_id=" + this.messageBus.clientId + "&authenticity_token=" + encodeURIComponent(csrf),
          dataType: "json",
          dropZone: $upload,
          pasteZone: $upload
        });

        $upload.on("fileuploaddrop", function (e, data) {
          if (data.files.length > 10) {
            bootbox.alert(I18n.t("post.errors.too_many_dragged_and_dropped_files"));
            return false;
          } else {
            return true;
          }
        });

        $upload.on("fileuploadsubmit", function (e, data) {
          var isValid = Discourse.Utilities.validateUploadedFiles(data.files, true);
          var form = { type: _this.get("type") };
          if (_this.get("data")) {
            form = $.extend(form, _this.get("data"));
          }
          data.formData = form;
          _this.setProperties({ uploadProgress: 0, uploading: isValid });
          return isValid;
        });

        $upload.on("fileuploadprogressall", function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          _this.set("uploadProgress", progress);
        });

        $upload.on("fileuploadfail", function (e, data) {
          Discourse.Utilities.displayErrorForUpload(data);
          reset();
        });
      }).on("didInsertElement"),

      _destroy: (function () {
        this.messageBus.unsubscribe("/uploads/" + this.get("type"));
        var $upload = this.$();
        try {
          $upload.fileupload("destroy");
        } catch (e) {/* wasn't initialized yet */}
        $upload.off();
      }).on("willDestroyElement")
    });
  });

Discourse.Upload = require('discourse/mixins/upload').default;
define("discourse/mixins/url-refresh", 
  ["discourse/lib/app-events","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // A Mixin that a view can use to listen for 'url:refresh' when
    // it is on screen, and will send an action to the controller to
    // refresh its data.
    //
    // This is useful if you want to get around Ember's default
    // behavior of not refreshing when navigating to the same place.

    var createViewListener = __dependency1__.createViewListener;

    __exports__["default"] = createViewListener('url:refresh', function () {
      this.get('controller').send('refresh');
    });
  });

Discourse.UrlRefresh = require('discourse/mixins/url-refresh').default;
define("discourse/mixins/viewing-action-type", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      viewingActionType: function (userActionType) {
        this.controllerFor('user').set('userActionType', userActionType);
        this.controllerFor('user-activity').set('userActionType', userActionType);
      }
    };
  });

Discourse.ViewingActionType = require('discourse/mixins/viewing-action-type').default;
define("discourse/models/invite", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Invite = Discourse.Model.extend({

      rescind: function () {
        Discourse.ajax('/invites', {
          type: 'DELETE',
          data: { email: this.get('email') }
        });
        this.set('rescinded', true);
      },

      reinvite: function () {
        Discourse.ajax('/invites/reinvite', {
          type: 'POST',
          data: { email: this.get('email') }
        });
        this.set('reinvited', true);
      }

    });

    Invite.reopenClass({

      create: function () {
        var result = this._super.apply(this, arguments);
        if (result.user) {
          result.user = Discourse.User.create(result.user);
        }
        return result;
      },

      findInvitedBy: function (user, filter, search, offset) {
        if (!user) {
          return Em.RSVP.resolve();
        }

        var data = {};
        if (!Em.isNone(filter)) {
          data.filter = filter;
        }
        if (!Em.isNone(search)) {
          data.search = search;
        }
        data.offset = offset || 0;

        return Discourse.ajax("/users/" + user.get('username_lower') + "/invited.json", { data: data }).then(function (result) {
          result.invites = result.invites.map(function (i) {
            return Invite.create(i);
          });

          return Em.Object.create(result);
        });
      },

      findInvitedCount: function (user) {
        if (!user) {
          return Em.RSVP.resolve();
        }
        return Discourse.ajax("/users/" + user.get('username_lower') + "/invited_count.json").then(function (result) {
          return Em.Object.create(result.counts);
        });
      }

    });

    __exports__["default"] = Invite;
  });define("discourse/models/user-badge", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    var UserBadge = Discourse.Model.extend({
      postUrl: (function () {
        if (this.get('topic_title')) {
          return "/t/-/" + this.get('topic_id') + "/" + this.get('post_number');
        }
      }).property(), // avoid the extra bindings for now
      /**
        Revoke this badge.
         @method revoke
        @returns {Promise} a promise that resolves when the badge has been revoked.
      **/
      revoke: function () {
        return Discourse.ajax("/user_badges/" + this.get('id'), {
          type: "DELETE"
        });
      }
    });

    UserBadge.reopenClass({

      createFromJson: function (json) {
        // Create User objects.
        if (json.users === undefined) {
          json.users = [];
        }
        var users = {};
        json.users.forEach(function (userJson) {
          users[userJson.id] = Discourse.User.create(userJson);
        });

        // Create Topic objects.
        if (json.topics === undefined) {
          json.topics = [];
        }
        var topics = {};
        json.topics.forEach(function (topicJson) {
          topics[topicJson.id] = Discourse.Topic.create(topicJson);
        });

        // Create the badges.
        if (json.badges === undefined) {
          json.badges = [];
        }
        var badges = {};
        Badge.createFromJson(json).forEach(function (badge) {
          badges[badge.get('id')] = badge;
        });

        // Create UserBadge object(s).
        var userBadges = [];
        if ("user_badge" in json) {
          userBadges = [json.user_badge];
        } else {
          userBadges = json.user_badges;
        }

        userBadges = userBadges.map(function (userBadgeJson) {
          var userBadge = UserBadge.create(userBadgeJson);

          var grantedAtDate = Date.parse(userBadge.get('granted_at'));
          userBadge.set('grantedAt', grantedAtDate);

          userBadge.set('badge', badges[userBadge.get('badge_id')]);
          if (userBadge.get('user_id')) {
            userBadge.set('user', users[userBadge.get('user_id')]);
          }
          if (userBadge.get('granted_by_id')) {
            userBadge.set('granted_by', users[userBadge.get('granted_by_id')]);
          }
          if (userBadge.get('topic_id')) {
            userBadge.set('topic', topics[userBadge.get('topic_id')]);
          }
          return userBadge;
        });

        if ("user_badge" in json) {
          return userBadges[0];
        } else {
          return userBadges;
        }
      },

      /**
        Find all badges for a given username.
         @method findByUsername
        @param {String} username
        @param {Object} options
        @returns {Promise} a promise that resolves to an array of `UserBadge`.
      **/
      findByUsername: function (username, options) {
        var url = "/user-badges/" + username + ".json";
        if (options && options.grouped) {
          url += "?grouped=true";
        }
        return Discourse.ajax(url).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      },

      /**
        Find all badge grants for a given badge ID.
         @method findById
        @param {String} badgeId
        @returns {Promise} a promise that resolves to an array of `UserBadge`.
      **/
      findByBadgeId: function (badgeId, options) {
        if (!options) {
          options = {};
        }
        options.badge_id = badgeId;

        return Discourse.ajax("/user_badges.json", {
          data: options
        }).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      },

      /**
        Grant the badge having id `badgeId` to the user identified by `username`.
         @method grant
        @param {Integer} badgeId id of the badge to be granted.
        @param {String} username username of the user to be granted the badge.
        @returns {Promise} a promise that resolves to an instance of `UserBadge`.
      **/
      grant: function (badgeId, username, reason) {
        return Discourse.ajax("/user_badges", {
          type: "POST",
          data: {
            username: username,
            badge_id: badgeId,
            reason: reason
          }
        }).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      }
    });

    __exports__["default"] = UserBadge;
  });define("discourse/controllers/discovery-sortable", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Just add query params here to have them automatically passed to topic list filters.
    var queryParams = {
      order: { replace: true, refreshModel: true },
      ascending: { replace: true, refreshModel: true },
      status: { replace: true, refreshModel: true },
      state: { replace: true, refreshModel: true },
      search: { replace: true, refreshModel: true },
      max_posts: { replace: true, refreshModel: true },
      q: { replace: true, refreshModel: true }
    };

    // Basic controller options
    __exports__.queryParams = queryParams;
    var controllerOpts = {
      needs: ['discovery/topics'],
      queryParams: Ember.keys(queryParams)
    };

    // Aliases for the values
    controllerOpts.queryParams.forEach(function (p) {
      return controllerOpts[p] = Em.computed.alias('controllers.discovery/topics.' + p);
    });

    __exports__["default"] = Ember.Controller.extend(controllerOpts);
  });define("discourse/controllers/navigation/default", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['discovery', 'discovery/topics'];
      }
    }, {
      key: 'categories',
      decorators: [computed()],
      value: function () {
        return Discourse.Category.list();
      }
    }, {
      key: 'navItems',
      decorators: [computed("filterMode")],
      value: function (filterMode) {
        // we don't want to show the period in the navigation bar since it's in a dropdown
        if (filterMode.indexOf("top/") === 0) {
          filterMode = filterMode.replace("top/", "");
        }
        return Discourse.NavItem.buildList(null, { filterMode: filterMode });
      }
    }]));
  });define("discourse/views/grouped", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      _groupInit: (function () {
        this.set('context', this.get('content'));

        var templateData = this.get('templateData');
        if (templateData) {
          this.set('templateData.insideGroup', true);
        }
      }).on('init')
    });
  });

Discourse.GroupedView = require('discourse/views/grouped').default;
define("discourse/views/container", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ContainerView.extend({

      attachViewWithArgs: function (viewArgs, viewClass) {
        if (typeof viewClass === "string") {
          viewClass = this.container.lookupFactory("view:" + viewClass) || this.container.lookupFactory("component:" + viewClass);
        }

        if (!viewClass) {
          viewClass = Ember.View.extend();
        }
        this.pushObject(this.createChildView(viewClass, viewArgs));
      },

      attachViewClass: function (viewClass) {
        this.attachViewWithArgs(null, viewClass);
      }
    });
  });define("discourse/views/modal-body", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: "focusInput",
      initializer: function () {
        return true;
      }
    }, {
      key: "_setupModal",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        $('#modal-alert').hide();
        $('#discourse-modal').modal('show');

        // Focus on first element
        if (!Discourse.Mobile.mobileView && this.get('focusInput')) {
          Em.run.schedule('afterRender', function () {
            return _this.$('input:first').focus();
          });
        }

        var title = this.get('title');
        if (title) {
          this.set('controller.controllers.modal.title', title);
        }
      }
    }, {
      key: "flashMessageChanged",
      decorators: [observes("controller.flashMessage")],
      value: function () {
        var flashMessage = this.get('controller.flashMessage');
        if (flashMessage) {
          var messageClass = flashMessage.get('messageClass') || 'success';
          $('#modal-alert').hide().removeClass('alert-error', 'alert-success').addClass("alert alert-" + messageClass).html(flashMessage.get('message')).fadeIn();
        }
      }
    }]));
  });define("discourse/views/flag", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/flag',

      title: (function () {
        return this.get('controller.flagTopic') ? I18n.t('flagging_topic.title') : I18n.t('flagging.title');
      }).property('controller.flagTopic'),

      _selectRadio: function () {
        this.$("input[type='radio']").prop('checked', false);

        var nameKey = this.get('controller.selected.name_key');
        if (!nameKey) {
          return;
        }

        this.$('#radio_' + nameKey).prop('checked', 'true');
      },

      selectedChanged: (function () {
        Ember.run.next(this, this._selectRadio);
      }).observes('controller.selected.name_key'),

      // See: https://github.com/emberjs/ember.js/issues/10869
      _selectedHack: (function () {
        this.removeObserver('controller.selected.name_key');
      }).on('willDestroyElement')
    });
  });define("discourse/views/cloaked", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.Placeholder = Placeholder;

    function Placeholder(viewName) {
      this.viewName = viewName;
    }

    __exports__["default"] = Ember.View.extend({
      attributeBindings: ['style'],
      _containedView: null,
      _scheduled: null,
      isPlaceholder: null,

      init: function () {
        this._super();
        this._scheduled = false;
        this._childViews = [];
      },

      setContainedView: function (cv) {
        if (this._childViews[0]) {
          this._childViews[0].destroy();
          this._childViews[0] = cv;
        }

        this.set('isPlaceholder', cv && cv.get('content') instanceof Placeholder);

        if (cv) {
          cv.set('_parentView', this);
          cv.set('templateData', this.get('templateData'));
          this._childViews[0] = cv;
        } else {
          this._childViews.clear();
        }

        if (this._scheduled) return;
        this._scheduled = true;
        this.set('_containedView', cv);
        Ember.run.schedule('render', this, this.updateChildView);
      },

      render: function (buffer) {
        var element = buffer.element();
        var dom = buffer.dom;

        this._childViewsMorph = dom.appendMorph(element);
      },

      updateChildView: function () {
        this._scheduled = false;
        if (!this._elementCreated || this.isDestroying || this.isDestroyed) {
          return;
        }

        var childView = this._containedView;
        if (childView && !childView._elementCreated) {
          this._renderer.renderTree(childView, this, 0);
        }
      },

      /**
        Triggers the set up for rendering a view that is cloaked.
         @method uncloak
      */
      uncloak: function () {
        var state = this._state || this.state;
        if (state !== 'inDOM' && state !== 'preRender') {
          return;
        }

        if (!this._containedView) {
          var model = this.get('content');
          var container = this.get('container');

          var controller = undefined;

          // Wire up the itemController if necessary
          var controllerName = this.get('cloaksController');
          if (controllerName) {
            var controllerFullName = 'controller:' + controllerName;
            var factory = container.lookupFactory(controllerFullName);

            // let ember generate controller if needed
            if (!factory) {
              factory = Ember.generateControllerFactory(container, controllerName, model);

              // inform developer about typo
              Ember.Logger.warn('ember-cloaking: can\'t lookup controller by name "' + controllerFullName + '".');
              Ember.Logger.warn('ember-cloaking: using ' + factory.toString() + '.');
            }

            var parentController = this.get('controller');
            controller = factory.create({ model: model, parentController: parentController, target: parentController });
          }

          var createArgs = {};
          var target = controller || model;

          if (this.get('preservesContext')) {
            createArgs.content = target;
          } else {
            createArgs.context = target;
          }
          if (controller) {
            createArgs.controller = controller;
          }
          this.setProperties({ style: ''.htmlSafe(), loading: false });

          var cloaks = target && target instanceof Placeholder ? target.viewName : this.get('cloaks');
          this.setContainedView(this.createChildView(cloaks, createArgs));
        }
      },

      /**
        Removes the view from the DOM and tears down all observers.
         @method cloak
      */
      cloak: function () {
        var self = this;

        if (this._containedView && (this._state || this.state) === 'inDOM') {
          var style = ('height: ' + this.$().height() + 'px;').htmlSafe();
          this.set('style', style);
          this.$().prop('style', style);

          // We need to remove the container after the height of the element has taken
          // effect.
          Ember.run.schedule('afterRender', function () {
            self.setContainedView(null);
          });
        }
      },

      _setHeights: (function () {
        if (!this._containedView) {
          // setting default height
          // but do not touch if height already defined
          if (!this.$().height()) {
            var defaultHeight = 100;
            if (this.get('defaultHeight')) {
              defaultHeight = this.get('defaultHeight');
            }

            this.$().css('height', defaultHeight);
          }
        }
      }).on('didInsertElement')
    });
  });define("discourse/components/combo-box", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'select',
      attributeBindings: ['tabindex'],
      classNames: ['combobox'],
      valueAttribute: 'id',
      nameProperty: 'name',

      _buildData: function (o) {
        var result = "";
        if (this.resultAttributes) {
          this.resultAttributes.forEach(function (a) {
            result += "data-" + a + "=\"" + o.get(a) + "\" ";
          });
        }
        return result;
      },

      render: function (buffer) {
        var _this = this;

        var nameProperty = this.get('nameProperty');
        var none = this.get('none');

        // Add none option if required
        if (typeof none === "string") {
          buffer.push('<option value="">' + I18n.t(none) + "</option>");
        } else if (typeof none === "object") {
          buffer.push("<option value=\"\" " + this._buildData(none) + ">" + Em.get(none, nameProperty) + "</option>");
        }

        var selected = this.get('value');
        if (!Em.isNone(selected)) {
          selected = selected.toString();
        }

        if (this.get('content')) {
          (function () {
            var self = _this;
            _this.get('content').forEach(function (o) {
              var val = o[self.get('valueAttribute')];
              if (typeof val === "undefined") {
                val = o;
              }
              if (!Em.isNone(val)) {
                val = val.toString();
              }

              var selectedText = val === selected ? "selected" : "";
              var name = Ember.get(o, nameProperty) || o;
              buffer.push("<option " + selectedText + " value=\"" + val + "\" " + self._buildData(o) + ">" + Handlebars.Utils.escapeExpression(name) + "</option>");
            });
          })();
        }
      },

      valueChanged: (function () {
        var $combo = this.$(),
            val = this.get('value');

        if (val !== undefined && val !== null) {
          $combo.select2('val', val.toString());
        } else {
          $combo.select2('val', null);
        }
      }).observes('value'),

      _rerenderOnChange: (function () {
        this.rerender();
      }).observes('content.@each'),

      _initializeCombo: (function () {
        var _this2 = this;

        // Workaround for https://github.com/emberjs/ember.js/issues/9813
        // Can be removed when fixed. Without it, the wrong option is selected
        this.$('option').each(function (i, o) {
          o.selected = !!$(o).attr('selected');
        });

        // observer for item names changing (optional)
        if (this.get('nameChanges')) {
          this.addObserver('content.@each.' + this.get('nameProperty'), this.rerender);
        }

        var $elem = this.$();
        var minimumResultsForSearch = this.capabilities.isIOS ? -1 : 5;
        $elem.select2({ formatResult: this.comboTemplate, minimumResultsForSearch: minimumResultsForSearch, width: 'resolve' });

        var castInteger = this.get('castInteger');
        $elem.on("change", function (e) {
          var val = $(e.target).val();
          if (val && val.length && castInteger) {
            val = parseInt(val, 10);
          }
          _this2.set('value', val);
        });
        $elem.trigger('change');
      }).on('didInsertElement'),

      _destroyDropdown: (function () {
        this.$().select2('destroy');
      }).on('willDestroyElement')

    });
  });define("discourse/components/edit-category-panel", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.buildCategoryPanel = buildCategoryPanel;
    var EditCategoryPanel = Ember.Component.extend({
      classNameBindings: [':modal-tab', 'activeTab::invisible']
    });

    __exports__["default"] = EditCategoryPanel;

    function buildCategoryPanel(tab, extras) {
      return EditCategoryPanel.extend({
        activeTab: Ember.computed.equal('selectedTab', tab)
      }, extras || {});
    }
  });define("discourse/views/button", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(StringBuffer, {
      tagName: 'button',
      classNameBindings: [':btn', ':standard', 'dropDownToggle'],
      attributeBindings: ['title', 'data-toggle', 'data-share-url'],

      title: (function () {
        return I18n.t(this.get('helpKey') || this.get('textKey'));
      }).property('helpKey', 'textKey'),

      text: (function () {
        if (Ember.isEmpty(this.get('textKey'))) {
          return "";
        }
        return I18n.t(this.get('textKey'));
      }).property('textKey'),

      renderString: function (buffer) {
        if (this.renderIcon) {
          this.renderIcon(buffer);
        }
        buffer.push(this.get('text'));
      }
    });
  });define("discourse/components/search-result", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'ul',

      _highlightOnInsert: (function () {
        var term = this.get('controller.term');
        if (!_.isEmpty(term)) {
          this.$('.blurb').highlight(term.split(/\s+/), { className: 'search-highlight' });
          this.$('.topic-title').highlight(term.split(/\s+/), { className: 'search-highlight' });
        }
      }).on('didInsertElement')
    });
  });define("discourse/components/dropdown-button", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNameBindings: [':btn-group', 'hidden'],
      rerenderTriggers: ['text', 'longDescription'],

      _bindClick: (function () {
        var _this = this;

        // If there's a click handler, call it
        if (this.clicked) {
          (function () {
            var self = _this;
            _this.$().on('click.dropdown-button', 'ul li', function (e) {
              e.preventDefault();
              if ($(e.currentTarget).data('id') !== self.get('activeItem')) {
                self.clicked($(e.currentTarget).data('id'));
              }
              self.$('.dropdown-toggle').dropdown('toggle');
              return false;
            });
          })();
        }
      }).on('didInsertElement'),

      _unbindClick: (function () {
        this.$().off('click.dropdown-button', 'ul li');
      }).on('willDestroyElement'),

      renderString: function (buffer) {
        var _this2 = this;

        var title = this.get('title');
        if (title) {
          buffer.push("<h4 class='title'>" + title + "</h4>");
        }

        buffer.push('<button class=\'btn standard dropdown-toggle ' + this.get('buttonExtraClasses') + '\' data-toggle=\'dropdown\'>' + this.get('text') + '</button>');
        buffer.push("<ul class='dropdown-menu'>");

        var contents = this.get('dropDownContent');
        if (contents) {
          (function () {
            var self = _this2;
            contents.forEach(function (row) {
              var id = row.id,
                  className = self.get('activeItem') === id ? 'disabled' : '';

              buffer.push("<li data-id=\"" + id + "\" class=\"" + className + "\"><a href>");
              buffer.push("<span class='icon " + row.styleClasses + "'></span>");
              buffer.push("<div><span class='title'>" + row.title + "</span>");
              buffer.push("<span>" + row.description + "</span></div>");
              buffer.push("</a></li>");
            });
          })();
        }

        buffer.push("</ul>");

        var desc = this.get('longDescription');
        if (desc) {
          buffer.push("<p>");
          buffer.push(desc);
          buffer.push("</p>");
        }
      }
    });
  });define("discourse/components/notifications-button", 
  ["discourse/components/dropdown-button","discourse/lib/notification-levels","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DropdownButton = __dependency1__["default"];
    var NotificationLevels = __dependency2__["default"];

    var NotificationsButton = DropdownButton.extend({
      classNames: ['notification-options'],
      title: '',
      buttonIncludesText: true,
      activeItem: Em.computed.alias('notificationLevel'),
      i18nPrefix: '',
      i18nPostfix: '',
      watchingClasses: 'fa fa-exclamation-circle watching',
      trackingClasses: 'fa fa-circle tracking',
      mutedClasses: 'fa fa-times-circle muted',
      regularClasses: 'fa fa-circle-o regular',

      options: (function () {
        return [['WATCHING', 'watching', this.watchingClasses], ['TRACKING', 'tracking', this.trackingClasses], ['REGULAR', 'regular', this.regularClasses], ['MUTED', 'muted', this.mutedClasses]];
      }).property(),

      dropDownContent: (function () {
        var contents = [],
            prefix = this.get('i18nPrefix'),
            postfix = this.get('i18nPostfix');

        _.each(this.get('options'), function (pair) {
          if (postfix === '_pm' && pair[1] === 'regular') {
            return;
          }
          contents.push({
            id: NotificationLevels[pair[0]],
            title: I18n.t(prefix + '.' + pair[1] + postfix + '.title'),
            description: I18n.t(prefix + '.' + pair[1] + postfix + '.description'),
            styleClasses: pair[2]
          });
        });

        return contents;
      }).property(),

      text: (function () {
        var self = this,
            prefix = this.get('i18nPrefix'),
            postfix = this.get('i18nPostfix');

        var key = (function () {
          switch (this.get('notificationLevel')) {
            case NotificationLevels.WATCHING:
              return 'watching';
            case NotificationLevels.TRACKING:
              return 'tracking';
            case NotificationLevels.MUTED:
              return 'muted';
            default:
              return 'regular';
          }
        }).call(this);

        var icon = (function () {
          switch (key) {
            case 'watching':
              return '<i class="' + self.watchingClasses + '"></i>&nbsp;';
            case 'tracking':
              return '<i class="' + self.trackingClasses + '"></i>&nbsp;';
            case 'muted':
              return '<i class="' + self.mutedClasses + '"></i>&nbsp;';
            default:
              return '<i class="' + self.regularClasses + '"></i>&nbsp;';
          }
        })();
        return icon + (this.get('buttonIncludesText') ? I18n.t(prefix + '.' + key + postfix + ".title") : '') + "<span class='caret'></span>";
      }).property('notificationLevel'),

      clicked: function () /* id */{
        // sub-class needs to implement this
      }

    });

    __exports__["default"] = NotificationsButton;
    __exports__.NotificationLevels = NotificationLevels;
  });define("discourse/components/topic-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      longDescription: Em.computed.alias('topic.details.notificationReasonText'),
      hidden: Em.computed.alias('topic.deleted'),
      notificationLevel: Em.computed.alias('topic.details.notification_level'),
      i18nPrefix: 'topic.notifications',

      i18nPostfix: (function () {
        return this.get('topic.isPrivateMessage') ? '_pm' : '';
      }).property('topic.isPrivateMessage'),

      clicked: function (id) {
        this.get('topic.details').updateNotifications(id);
      }
    });
  });define("discourse/lib/link-mentions", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.linkSeenMentions = linkSeenMentions;
    __exports__.fetchUnseenMentions = fetchUnseenMentions;
    function replaceSpan($e, username, opts) {
      if (opts && opts.group) {
        var extra = "",
            extraClass = "";
        if (opts.mentionable) {
          extra = " data-name='" + username + "' data-mentionable-user-count='" + opts.mentionable.user_count + "' ";
          extraClass = " notify";
        }
        $e.replaceWith("<a href='" + Discourse.getURL("/groups/") + username + "' class='mention-group" + extraClass + "'" + extra + ">@" + username + "</a>");
      } else {
        $e.replaceWith("<a href='" + Discourse.getURL("/users/") + username.toLowerCase() + "' class='mention'>@" + username + "</a>");
      }
    }

    var found = [];
    var foundGroups = [];
    var mentionableGroups = [];
    var checked = [];

    function updateFound($mentions, usernames) {
      Ember.run.scheduleOnce('afterRender', function () {
        $mentions.each(function (i, e) {
          var $e = $(e);
          var username = usernames[i];
          if (found.indexOf(username.toLowerCase()) !== -1) {
            replaceSpan($e, username);
          } else if (foundGroups.indexOf(username) !== -1) {
            var mentionable = _(mentionableGroups).where({ name: username }).first();
            replaceSpan($e, username, { group: true, mentionable: mentionable });
          } else if (checked.indexOf(username) !== -1) {
            $e.addClass('mention-tested');
          }
        });
      });
    }

    function linkSeenMentions($elem, siteSettings) {
      var $mentions = $('span.mention:not(.mention-tested)', $elem);
      if ($mentions.length) {
        var usernames = $mentions.map(function (_, e) {
          return $(e).text().substr(1);
        });
        var unseen = _.uniq(usernames).filter(function (u) {
          return u.length >= siteSettings.min_username_length && checked.indexOf(u) === -1;
        });
        updateFound($mentions, usernames);
        return unseen;
      }

      return [];
    }

    function fetchUnseenMentions($elem, usernames) {
      return Discourse.ajax("/users/is_local_username", { data: { usernames: usernames } }).then(function (r) {
        found.push.apply(found, r.valid);
        foundGroups.push.apply(foundGroups, r.valid_groups);
        mentionableGroups.push.apply(mentionableGroups, r.mentionable_groups);
        checked.push.apply(checked, usernames);
        return r;
      });
    }
  });define("discourse/views/header", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.headerHeight = headerHeight;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'header';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['d-header', 'clearfix'];
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['editingTopic'];
      }
    }, {
      key: 'templateName',
      initializer: function () {
        return 'header';
      }
    }, {
      key: 'examineDockHeader',
      value: function () {
        var _this = this;

        // Check the dock after the current run loop. While rendering,
        // it's much slower to calculate `outlet.offset()`
        Ember.run.next(function () {
          if (_this.docAt === undefined) {
            var outlet = $('#main-outlet');
            if (!(outlet && outlet.length === 1)) return;
            _this.docAt = outlet.offset().top;
          }

          var offset = window.pageYOffset || $('html').scrollTop();
          if (offset >= _this.docAt) {
            if (!_this.dockedHeader) {
              $('body').addClass('docked');
              _this.dockedHeader = true;
            }
          } else {
            if (_this.dockedHeader) {
              $('body').removeClass('docked');
              _this.dockedHeader = false;
            }
          }
        });
      }
    }, {
      key: '_tearDown',
      decorators: [on('willDestroyElement')],
      value: function () {
        $(window).unbind('scroll.discourse-dock');
        $(document).unbind('touchmove.discourse-dock');
        this.$('a.unread-private-messages, a.unread-notifications, a[data-notifications]').off('click.notifications');
        $('body').off('keydown.header');
      }
    }, {
      key: '_setup',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        $(window).bind('scroll.discourse-dock', function () {
          return _this2.examineDockHeader();
        });
        $(document).bind('touchmove.discourse-dock', function () {
          return _this2.examineDockHeader();
        });
        this.examineDockHeader();
      }
    }]));

    function headerHeight() {
      var $header = $('header.d-header');
      var headerOffset = $header.offset();
      var headerOffsetTop = headerOffset ? headerOffset.top : 0;
      return parseInt($header.outerHeight() + headerOffsetTop - $(window).scrollTop());
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:


var discourseEscape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  '`': '&#x60;'
};
var discourseBadChars = /[&<>"'`]/g;
var discoursePossible = /[&<>"'`]/;

function discourseEscapeChar(chr) {
  return discourseEscape[chr];
}
Discourse.Utilities = {

  translateSize: function(size) {
    switch (size) {
      case 'tiny': return 20;
      case 'small': return 25;
      case 'medium': return 32;
      case 'large': return 45;
      case 'extra_large': return 60;
      case 'huge': return 120;
    }
    return size;
  },

  /**
    Allows us to supply bindings without "binding" to a helper.
  **/
  normalizeHash: function(hash, hashTypes) {
    for (var prop in hash) {
      if (hashTypes[prop] === 'ID') {
        hash[prop + 'Binding'] = hash[prop];
        delete hash[prop];
      }
    }
  },

  // Handlebars no longer allows spaces in its `escapeExpression` code which makes it
  // unsuitable for many of Discourse's uses. Use `Handlebars.Utils.escapeExpression`
  // when escaping an attribute in HTML, otherwise this one will do.
  escapeExpression: function(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof Handlebars.SafeString) {
      return string.toString();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!discoursePossible.test(string)) { return string; }
    return string.replace(discourseBadChars, discourseEscapeChar);
  },

  avatarUrl: function(template, size) {
    if (!template) { return ""; }
    var rawSize = Discourse.Utilities.getRawSize(Discourse.Utilities.translateSize(size));
    return template.replace(/\{size\}/g, rawSize);
  },

  getRawSize: function(size) {
    var pixelRatio = window.devicePixelRatio || 1;
    return size * Math.min(3, Math.max(1, Math.round(pixelRatio)));
  },

  avatarImg: function(options) {
    var size = Discourse.Utilities.translateSize(options.size);
    var url = Discourse.Utilities.avatarUrl(options.avatarTemplate, size);

    // We won't render an invalid url
    if (!url || url.length === 0) { return ""; }

    var classes = "avatar" + (options.extraClasses ? " " + options.extraClasses : "");
    var title = (options.title) ? " title='" + Handlebars.Utils.escapeExpression(options.title || "") + "'" : "";

    return "<img alt='' width='" + size + "' height='" + size + "' src='" + Discourse.getURLWithCDN(url) + "' class='" + classes + "'" + title + ">";
  },

  tinyAvatar: function(avatarTemplate, options) {
    return Discourse.Utilities.avatarImg(_.merge({avatarTemplate: avatarTemplate, size: 'tiny' }, options));
  },

  postUrl: function(slug, topicId, postNumber) {
    var url = Discourse.getURL("/t/");
    if (slug) {
      url += slug + "/";
    } else {
      url += 'topic/';
    }
    url += topicId;
    if (postNumber > 1) {
      url += "/" + postNumber;
    }
    return url;
  },

  userUrl: function(username) {
    return Discourse.getURL("/users/" + username.toLowerCase());
  },

  emailValid: function(email) {
    // see:  http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
    var re = /^[a-zA-Z0-9!#$%&'*+\/=?\^_`{|}~\-]+(?:\.[a-zA-Z0-9!#$%&'\*+\/=?\^_`{|}~\-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    return re.test(email);
  },

  selectedText: function() {
    var html = '';

    if (typeof window.getSelection !== "undefined") {
      var sel = window.getSelection();
      if (sel.rangeCount) {
        var container = document.createElement("div");
        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
          container.appendChild(sel.getRangeAt(i).cloneContents());
        }
        html = container.innerHTML;
      }
    } else if (typeof document.selection !== "undefined") {
      if (document.selection.type === "Text") {
        html = document.selection.createRange().htmlText;
      }
    }

    // Strip out any .click elements from the HTML before converting it to text
    var div = document.createElement('div');
    div.innerHTML = html;
    var $div = $(div);
    // Find all emojis and replace with its title attribute.
    $div.find('img.emoji').replaceWith(function() { return this.title; });
    $('.clicks', $div).remove();
    var text = div.textContent || div.innerText || "";

    return String(text).trim();
  },

  // Determine the position of the caret in an element
  caretPosition: function(el) {
    var r, rc, re;
    if (el.selectionStart) {
      return el.selectionStart;
    }
    if (document.selection) {
      el.focus();
      r = document.selection.createRange();
      if (!r) return 0;

      re = el.createTextRange();
      rc = re.duplicate();
      re.moveToBookmark(r.getBookmark());
      rc.setEndPoint('EndToStart', re);
      return rc.text.length;
    }
    return 0;
  },

  // Set the caret's position
  setCaretPosition: function(ctrl, pos) {
    var range;
    if (ctrl.setSelectionRange) {
      ctrl.focus();
      ctrl.setSelectionRange(pos, pos);
      return;
    }
    if (ctrl.createTextRange) {
      range = ctrl.createTextRange();
      range.collapse(true);
      range.moveEnd('character', pos);
      range.moveStart('character', pos);
      return range.select();
    }
  },

  validateUploadedFiles: function(files, bypassNewUserRestriction) {
    if (!files || files.length === 0) { return false; }

    if (files.length > 1) {
      bootbox.alert(I18n.t('post.errors.too_many_uploads'));
      return false;
    }

    var upload = files[0];

    // CHROME ONLY: if the image was pasted, sets its name to a default one
    if (typeof Blob !== "undefined" && typeof File !== "undefined") {
      if (upload instanceof Blob && !(upload instanceof File) && upload.type === "image/png") { upload.name = "blob.png"; }
    }

    var type = Discourse.Utilities.isAnImage(upload.name) ? 'image' : 'attachment';

    return Discourse.Utilities.validateUploadedFile(upload, type, bypassNewUserRestriction);
  },

  validateUploadedFile: function(file, type, bypassNewUserRestriction) {
    // check that the uploaded file is authorized
    if (!Discourse.Utilities.authorizesAllExtensions() &&
        !Discourse.Utilities.isAuthorizedUpload(file)) {
      var extensions = Discourse.Utilities.authorizedExtensions();
      bootbox.alert(I18n.t('post.errors.upload_not_authorized', { authorized_extensions: extensions }));
      return false;
    }

    if (!bypassNewUserRestriction) {
      // ensures that new users can upload a file
      if (!Discourse.User.current().isAllowedToUploadAFile(type)) {
        bootbox.alert(I18n.t('post.errors.' + type + '_upload_not_allowed_for_new_user'));
        return false;
      }
    }

    // everything went fine
    return true;
  },

  authorizesAllExtensions: function() {
    return Discourse.SiteSettings.authorized_extensions.indexOf("*") >= 0;
  },

  isAuthorizedUpload: function(file) {
    if (file && file.name) {
      var extensions = _.chain(Discourse.SiteSettings.authorized_extensions.split("|"))
                        .reject(function(extension) { return extension.indexOf("*") >= 0; })
                        .map(function(extension) { return (extension.indexOf(".") === 0 ? extension.substring(1) : extension).replace(".", "\\."); })
                        .value();
      return new RegExp("\\.(" + extensions.join("|") + ")$", "i").test(file.name);
    }
    return false;
  },

  authorizedExtensions: function() {
    return _.chain(Discourse.SiteSettings.authorized_extensions.split("|"))
            .reject(function(extension) { return extension.indexOf("*") >= 0; })
            .map(function(extension) { return extension.toLowerCase(); })
            .value()
            .join(", ");
  },

  getUploadMarkdown: function(upload) {
    if (Discourse.Utilities.isAnImage(upload.original_filename)) {
      return '<img src="' + upload.url + '" width="' + upload.width + '" height="' + upload.height + '">';
    } else {
      return '<a class="attachment" href="' + upload.url + '">' + upload.original_filename + '</a> (' + I18n.toHumanSize(upload.filesize) + ')';
    }
  },

  isAnImage: function(path) {
    return (/\.(png|jpe?g|gif|bmp|tiff?|svg|webp)$/i).test(path);
  },

  allowsImages: function() {
    return Discourse.Utilities.authorizesAllExtensions() ||
           (/(png|jpe?g|gif|bmp|tiff?|svg|webp)/i).test(Discourse.Utilities.authorizedExtensions());
  },

  allowsAttachments: function() {
    return Discourse.Utilities.authorizesAllExtensions() ||
           !(/((png|jpe?g|gif|bmp|tiff?|svg|webp)(,\s)?)+$/i).test(Discourse.Utilities.authorizedExtensions());
  },

  displayErrorForUpload: function(data) {
    // deal with meaningful errors first
    if (data.jqXHR) {
      switch (data.jqXHR.status) {
        // cancelled by the user
        case 0: return;

        // entity too large, usually returned from the web server
        case 413:
          var maxSizeKB = 10 * 1024; // 10 MB
          bootbox.alert(I18n.t('post.errors.file_too_large', { max_size_kb: maxSizeKB }));
          return;

        // the error message is provided by the server
        case 422:
          if (data.jqXHR.responseJSON.message) {
            bootbox.alert(data.jqXHR.responseJSON.message);
          } else {
            bootbox.alert(data.jqXHR.responseJSON.join("\n"));
          }
          return;
      }
    } else if (data.errors && data.errors.length > 0) {
      bootbox.alert(data.errors.join("\n"));
      return;
    }
    // otherwise, display a generic error message
    bootbox.alert(I18n.t('post.errors.upload'));
  },

  defaultHomepage: function() {
    // the homepage is the first item of the 'top_menu' site setting
    return Discourse.SiteSettings.top_menu.split("|")[0].split(",")[0];
  }

};


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/*global md5:true */
/**

  Discourse uses the Markdown.js as its main parser. `Discourse.Dialect` is the framework
  for extending it with additional formatting.

**/

var parser = window.BetterMarkdown,
    MD = parser.Markdown,
    DialectHelpers = parser.DialectHelpers,
    dialect = MD.dialects.Discourse = DialectHelpers.subclassDialect( MD.dialects.Gruber ),
    initialized = false,
    emitters = [],
    hoisted,
    preProcessors = [],
    escape = Discourse.Utilities.escapeExpression;

/**
  Initialize our dialects for processing.

  @method initializeDialects
**/
function initializeDialects() {
  MD.buildBlockOrder(dialect.block);
  var index = dialect.block.__order__.indexOf("code");
  if (index > -1) {
    dialect.block.__order__.splice(index, 1);
    dialect.block.__order__.unshift("code");
  }
  MD.buildInlinePatterns(dialect.inline);
  initialized = true;
}

/**
  Process the text nodes in the JsonML tree, calling any emitters that have
  been added.

  @method processTextNodes
  @param {Array} node the JsonML tree
  @param {Object} event the parse node event data
  @param {Function} emitter the function to call on the text node
**/
function processTextNodes(node, event, emitter) {
  if (node.length < 2) { return; }

  if (node[0] === '__RAW') {
    var hash = md5(node[1]);
    hoisted[hash] = node[1];
    node[1] = hash;
    return;
  }

  for (var j=1; j<node.length; j++) {
    var textContent = node[j];
    if (typeof textContent === "string") {
      var result = emitter(textContent, event);
      if (result) {
        if (result instanceof Array) {
          node.splice.apply(node, [j, 1].concat(result));
        } else {
          node[j] = result;
        }
      } else {
        node[j] = textContent;
      }

    }
  }
}


/**
  Parse a JSON ML tree, using registered handlers to adjust it if necessary.

  @method parseTree
  @param {Array} tree the JsonML tree to parse
  @param {Array} path the path of ancestors to the current node in the tree. Can be used for matching.
  @param {Object} insideCounts counts what tags we're inside
  @returns {Array} the parsed tree
**/
function parseTree(tree, path, insideCounts) {

  if (tree instanceof Array) {
    var event = {node: tree, path: path, dialect: dialect, insideCounts: insideCounts || {}};
    Discourse.Dialect.trigger('parseNode', event);

    for (var j=0; j<emitters.length; j++) {
      processTextNodes(tree, event, emitters[j]);
    }

    path = path || [];
    insideCounts = insideCounts || {};

    path.push(tree);

    for (var i=1; i<tree.length; i++) {
      var n = tree[i],
          tagName = n[0];

      insideCounts[tagName] = (insideCounts[tagName] || 0) + 1;

      if (n && n.length === 2 && n[0] === "p" && /^<!--([\s\S]*)-->$/.exec(n[1])) {
        // Remove paragraphs around comment-only nodes.
        tree[i] = n[1];
      } else {
        parseTree(n, path, insideCounts);
      }

      insideCounts[tagName] = insideCounts[tagName] - 1;
    }

    // If raw nodes are in paragraphs, pull them up
    if (tree.length === 2 && tree[0] === 'p' && tree[1] instanceof Array && tree[1][0] === "__RAW") {
      var text = tree[1][1];
      tree[0] = "__RAW";
      tree[1] = text;
    }

    path.pop();
  }
  return tree;
}

/**
  Returns true if there's an invalid word boundary for a match.

  @method invalidBoundary
  @param {Object} args our arguments, including whether we care about boundaries
  @param {Array} prev the previous content, if exists
  @returns {Boolean} whether there is an invalid word boundary
**/
function invalidBoundary(args, prev) {
  if (!(args.wordBoundary || args.spaceBoundary || args.spaceOrTagBoundary)) { return false; }

  var last = prev[prev.length - 1];
  if (typeof last !== "string") { return false; }

  if (args.wordBoundary && (!last.match(/\W$/))) { return true; }
  if (args.spaceBoundary && (!last.match(/\s$/))) { return true; }
  if (args.spaceOrTagBoundary && (!last.match(/(\s|\>)$/))) { return true; }
}

/**
  Returns the number of (terminated) lines in a string.

  @method countLines
  @param {string} str the string.
  @returns {Integer} number of terminated lines in str
**/
function countLines(str) {
  var index = -1, count = 0;
  while ((index = str.indexOf("\n", index + 1)) !== -1) { count++; }
  return count;
}

function hoister(t, target, replacement) {
  var regexp = new RegExp(target.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), "g");
  if (t.match(regexp)) {
    var hash = md5(target);
    t = t.replace(regexp, hash);
    hoisted[hash] = replacement;
  }
  return t;
}

function outdent(t) {
  return t.replace(/^([ ]{4}|\t)/gm, "");
}

function removeEmptyLines(t) {
  return t.replace(/^\n+/, "")
          .replace(/\s+$/, "");
}

function hideBackslashEscapedCharacters(t) {
  return t.replace(/\\\\/g, "\u1E800")
          .replace(/\\`/g, "\u1E8001");
}

function showBackslashEscapedCharacters(t) {
  return t.replace(/\u1E8001/g, "\\`")
          .replace(/\u1E800/g, "\\\\");
}

function hoistCodeBlocksAndSpans(text) {
  // replace all "\`" with a single character
  text = hideBackslashEscapedCharacters(text);

  // /!\ the order is important /!\

  // fenced code blocks (AKA GitHub code blocks)
  text = text.replace(/(^\n*|\n)```([a-z0-9\-]*)\n([\s\S]*?)\n```/g, function(_, before, language, content) {
    var hash = md5(content);
    hoisted[hash] = escape(showBackslashEscapedCharacters(removeEmptyLines(content)));
    return before + "```" + language + "\n" + hash + "\n```";
  });

  // markdown code blocks
  text = text.replace(/(^\n*|\n\n)((?:(?:[ ]{4}|\t).*\n*)+)/g, function(match, before, content, index) {
    // make sure we aren't in a list
    var previousLine = text.slice(0, index).trim().match(/.*$/);
    if (previousLine && previousLine[0].length) {
      previousLine = previousLine[0].trim();
      if (/^(?:\*|\+|-|\d+\.)\s+/.test(previousLine)) {
        return match;
      }
    }
    // we can safely hoist the code block
    var hash = md5(content);
    hoisted[hash] = escape(outdent(showBackslashEscapedCharacters(removeEmptyLines(content))));
    return before + "    " + hash + "\n";
  });

  // <pre>...</pre> code blocks
  text = text.replace(/(\s|^)<pre>([\s\S]*?)<\/pre>/ig, function(_, before, content) {
    var hash = md5(content);
    hoisted[hash] = escape(showBackslashEscapedCharacters(removeEmptyLines(content)));
    return before + "<pre>" + hash + "</pre>";
  });

  // code spans (double & single `)
  ["``", "`"].forEach(function(delimiter) {
    var regexp = new RegExp("(^|[^`])" + delimiter + "([^`\\n]+?)" + delimiter + "([^`]|$)", "g");
    text = text.replace(regexp, function(_, before, content, after) {
      var hash = md5(content);
      hoisted[hash] = escape(showBackslashEscapedCharacters(content.trim()));
      return before + delimiter + hash + delimiter + after;
    });
  });

  // replace back all weird character with "\`"
  return showBackslashEscapedCharacters(text);
}

/**
  An object used for rendering our dialects.

  @class Dialect
  @namespace Discourse
  @module Discourse
**/
Discourse.Dialect = {

  /**
    Cook text using the dialects.

    @method cook
    @param {String} text the raw text to cook
    @param {Object} opts hash of options
    @returns {String} the cooked text
  **/
  cook: function(text, opts) {
    if (!initialized) { initializeDialects(); }

    dialect.options = opts;

    // Helps us hoist out HTML
    hoisted = {};

    // pre-hoist all code-blocks/spans
    text = hoistCodeBlocksAndSpans(text);

    // pre-processors
    preProcessors.forEach(function(p) {
      text = p(text, hoister);
    });

    var tree = parser.toHTMLTree(text, 'Discourse'),
        result = parser.renderJsonML(parseTree(tree));

    if (opts.sanitize) {
      result = Discourse.Markdown.sanitize(result);
    } else if (opts.sanitizerFunction) {
      result = opts.sanitizerFunction(result);
    }

    // If we hoisted out anything, put it back
    var keys = Object.keys(hoisted);
    if (keys.length) {
      var found = true;

      var unhoist = function(key) {
        result = result.replace(new RegExp(key, "g"), function() {
          found = true;
          return hoisted[key];
        });
      };

      while(found) {
        found = false;
        keys.forEach(unhoist);
      }
    }

    return result.trim();
  },

  /**
    Adds a text pre-processor. Use only if necessary, as a dialect
    that emits JsonML is much better if possible.
  **/
  addPreProcessor: function(preProc) {
    preProcessors.push(preProc);
  },

  /**
    Registers an inline replacer function

    @method registerInline
    @param {String} start The token the replacement begins with
    @param {Function} fn The replacing function
  **/
  registerInline: function(start, fn) {
    dialect.inline[start] = fn;
  },


  /**
    The simplest kind of replacement possible. Replace a stirng token with JsonML.

    For example to replace all occurrances of :) with a smile image:

    ```javascript
      Discourse.Dialect.inlineReplace(':)', function (text) {
        return ['img', {src: '/images/smile.png'}];
      });

    ```

    @method inlineReplace
    @param {String} token The token we want to replace
    @param {Function} emitter A function that emits the JsonML for the replacement.
  **/
  inlineReplace: function(token, emitter) {
    this.registerInline(token, function(text, match, prev) {
      return [token.length, emitter.call(this, token, match, prev)];
    });
  },

  /**
    Matches inline using a regular expression. The emitter function is passed
    the matches from the regular expression.

    For example, this auto links URLs:

    ```javascript
      Discourse.Dialect.inlineRegexp({
        matcher: /((?:https?:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.])(?:[^\s()<>]+|\([^\s()<>]+\))+(?:\([^\s()<>]+\)|[^`!()\[\]{};:'".,<>?«»“”‘’\s]))/gm,
        spaceBoundary: true,
        start: 'http',

        emitter: function(matches) {
          var url = matches[1];
          return ['a', {href: url}, url];
        }
      });
    ```

    @method inlineRegexp
    @param {Object} args Our replacement options
      @param {Function} [opts.emitter] The function that will be called with the contents and regular expresison match and returns JsonML.
      @param {String} [opts.start] The starting token we want to find
      @param {String} [opts.matcher] The regular expression to match
      @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
      @param {Boolean} [opts.spaceBoundary] If true, the match must be on a space boundary
  **/
  inlineRegexp: function(args) {
    this.registerInline(args.start, function(text, match, prev) {
      if (invalidBoundary(args, prev)) { return; }

      args.matcher.lastIndex = 0;
      var m = args.matcher.exec(text);
      if (m) {
        var result = args.emitter.call(this, m);
        if (result) {
          return [m[0].length, result];
        }
      }
    });
  },

  /**
    Handles inline replacements surrounded by tokens.

    For example, to handle markdown style bold. Note we use `concat` on the array because
    the contents are JsonML too since we didn't pass `rawContents` as true. This supports
    recursive markup.

    ```javascript

      Discourse.Dialect.inlineBetween({
        between: '**',
        wordBoundary: true.
        emitter: function(contents) {
          return ['strong'].concat(contents);
        }
      });
    ```

    @method inlineBetween
    @param {Object} args Our replacement options
      @param {Function} [opts.emitter] The function that will be called with the contents and returns JsonML.
      @param {String} [opts.start] The starting token we want to find
      @param {String} [opts.stop] The ending token we want to find
      @param {String} [opts.between] A shortcut for when the `start` and `stop` are the same.
      @param {Boolean} [opts.rawContents] If true, the contents between the tokens will not be parsed.
      @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
      @param {Boolean} [opts.spaceBoundary] If true, the match must be on a space boundary
  **/
  inlineBetween: function(args) {
    var start = args.start || args.between,
        stop = args.stop || args.between,
        startLength = start.length,
        self = this;

    this.registerInline(start, function(text, match, prev) {
      if (invalidBoundary(args, prev)) { return; }

      var endPos = self.findEndPos(text, start, stop, args, startLength);
      if (endPos === -1) { return; }
      var between = text.slice(startLength, endPos);

      // If rawcontents is set, don't process inline
      if (!args.rawContents) {
        between = this.processInline(between);
      }

      var contents = args.emitter.call(this, between);
      if (contents) {
        return [endPos+stop.length, contents];
      }
    });
  },

  findEndPos: function(text, start, stop, args, offset) {
    var endPos, nextStart;
    do {
      endPos = text.indexOf(stop, offset);
      if (endPos === -1) { return -1; }
      nextStart = text.indexOf(start, offset);
      offset = endPos + stop.length;
    } while (nextStart !== -1 && nextStart < endPos);
    return endPos;
  },

  /**
    Registers a block for processing. This is more complicated than using one of
    the other helpers such as `replaceBlock` so consider using them first!

    @method registerBlock
    @param {String} name the name of the block handler
    @param {Function} handler the handler
  **/
  registerBlock: function(name, handler) {
    dialect.block[name] = handler;
  },

  /**
    Replaces a block of text between a start and stop. As opposed to inline, these
    might span multiple lines.

    Here's an example that takes the content between `[code]` ... `[/code]` and
    puts them inside a `pre` tag:

    ```javascript
      Discourse.Dialect.replaceBlock({
        start: /(\[code\])([\s\S]*)/igm,
        stop: '[/code]',
        rawContents: true,

        emitter: function(blockContents) {
          return ['p', ['pre'].concat(blockContents)];
        }
      });
    ```

    @method replaceBlock
    @param {Object} args Our replacement options
      @param {RegExp} [args.start] The starting regexp we want to find
      @param {String} [args.stop] The ending token we want to find
      @param {Boolean} [args.rawContents] True to skip recursive processing
      @param {Function} [args.emitter] The emitting function to transform the contents of the block into jsonML

  **/
  replaceBlock: function(args) {
    var fn = function(block, next) {

      var linebreaks = dialect.options.traditional_markdown_linebreaks ||
          Discourse.SiteSettings.traditional_markdown_linebreaks;
      if (linebreaks && args.skipIfTradtionalLinebreaks) { return; }

      args.start.lastIndex = 0;
      var result = [], match = (args.start).exec(block);
      if (!match) { return; }

      var lastChance = function() {
        return !next.some(function(blk) { return blk.match(args.stop); });
      };

      // shave off start tag and leading text, if any.
      var pos = args.start.lastIndex - match[0].length,
          leading = block.slice(0, pos),
          trailing = match[2] ? match[2].replace(/^\n*/, "") : "";

      if(args.withoutLeading && args.withoutLeading.test(leading)) {
        //The other leading block should be processed first! eg a code block wrapped around a code block.
        return;
      }

      // just give up if there's no stop tag in this or any next block
      args.stop.lastIndex = block.length - trailing.length;
      if (!args.stop.exec(block) && lastChance()) { return; }
      if (leading.length > 0) {
        var parsedLeading = this.processBlock(MD.mk_block(leading), []);
        if (parsedLeading && parsedLeading[0]) {
          result.push(parsedLeading[0]);
        }
      }
      if (trailing.length > 0) {
        next.unshift(MD.mk_block(trailing, block.trailing,
          block.lineNumber + countLines(leading) + (match[2] ? match[2].length : 0) - trailing.length));
      }

      // go through the available blocks to find the matching stop tag.
      var contentBlocks = [], nesting = 0, actualEndPos = -1, currentBlock;
      blockloop:
      while (currentBlock = next.shift()) {
        // collect all the start and stop tags in the current block
        args.start.lastIndex = 0;
        var startPos = [], m;
        while (m = (args.start).exec(currentBlock)) {
          startPos.push(args.start.lastIndex - m[0].length);
          args.start.lastIndex = args.start.lastIndex - (m[2] ? m[2].length : 0);
        }
        args.stop.lastIndex = 0;
        var endPos = [];
        while (m = (args.stop).exec(currentBlock)) {
          endPos.push(args.stop.lastIndex - m[0].length);
        }

        // go through the available end tags:
        var ep = 0, sp = 0; // array indices
        while (ep < endPos.length) {
          if (sp < startPos.length && startPos[sp] < endPos[ep]) {
            // there's an end tag, but there's also another start tag first. we need to go deeper.
            sp++; nesting++;
          } else if (nesting > 0) {
            // found an end tag, but we must go up a level first.
            ep++; nesting--;
          } else {
            // found an end tag and we're at the top: done! -- or: start tag and end tag are
            // identical, (i.e. startPos[sp] == endPos[ep]), so we don't do nesting at all.
            actualEndPos = endPos[ep];
            break blockloop;
          }
        }

        if (lastChance()) {
          // when lastChance() becomes true the first time, currentBlock contains the last
          // end tag available in the input blocks but it's not on the right nesting level
          // or we would have terminated the loop already. the only thing we can do is to
          // treat the last available end tag as tho it were matched with our start tag
          // and let the emitter figure out how to render the garbage inside.
          actualEndPos = endPos[endPos.length - 1];
          break;
        }

        // any left-over start tags still increase the nesting level
        nesting += startPos.length - sp;
        contentBlocks.push(currentBlock);
      }

      var stopLen = currentBlock.match(args.stop)[0].length,
          before = currentBlock.slice(0, actualEndPos).replace(/\n*$/, ""),
          after = currentBlock.slice(actualEndPos + stopLen).replace(/^\n*/, "");
      if (before.length > 0) contentBlocks.push(MD.mk_block(before, "", currentBlock.lineNumber));
      if (after.length > 0) next.unshift(MD.mk_block(after, currentBlock.trailing, currentBlock.lineNumber + countLines(before)));

      var emitterResult = args.emitter.call(this, contentBlocks, match, dialect.options);
      if (emitterResult) { result.push(emitterResult); }
      return result;
    };

    if (args.priority) {
      fn.priority = args.priority;
    }

    this.registerBlock(args.start.toString(), fn);
  },

  /**
    After the parser has been executed, post process any text nodes in the HTML document.
    This is useful if you want to apply a transformation to the text.

    If you are generating HTML from the text, it is preferable to use the replacer
    functions and do it in the parsing part of the pipeline. This function is best for
    simple transformations or transformations that have to happen after all earlier
    processing is done.

    For example, to convert all text to upper case:

    ```javascript

      Discourse.Dialect.postProcessText(function (text) {
        return text.toUpperCase();
      });

    ```

    @method postProcessText
    @param {Function} emitter The function to call with the text. It returns JsonML to modify the tree.
  **/
  postProcessText: function(emitter) {
    emitters.push(emitter);
  },

  /**
    After the parser has been executed, change the contents of a HTML tag.

    Let's say you want to replace the contents of all code tags to prepend
    "EVIL TROUT HACKED YOUR CODE!":

    ```javascript
      Discourse.Dialect.postProcessTag('code', function (contents) {
        return "EVIL TROUT HACKED YOUR CODE!\n\n" + contents;
      });
    ```

    @method postProcessTag
    @param {String} tag The HTML tag you want to match on
    @param {Function} emitter The function to call with the text. It returns JsonML to modify the tree.
  **/
  postProcessTag: function(tag, emitter) {
    Discourse.Dialect.on('parseNode', function (event) {
      var node = event.node;
      if (node[0] === tag) {
        node[node.length-1] = emitter(node[node.length-1]);
      }
    });
  }

};

RSVP.EventTarget.mixin(Discourse.Dialect);




// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

// TODO @robin to move this whole thing to es6
Discourse.Emoji = {};
// bump up this number to expire all emojis
Discourse.Emoji.ImageVersion = "0"

var emoji = ["smile", "smiley", "grinning", "blush", "relaxed", "wink", "heart_eyes", "kissing_heart", "kissing_closed_eyes", "kissing", "kissing_smiling_eyes", "stuck_out_tongue_winking_eye", "stuck_out_tongue_closed_eyes", "stuck_out_tongue", "flushed", "grin", "pensive", "relieved", "unamused", "disappointed", "persevere", "cry", "joy", "sob", "sleepy", "disappointed_relieved", "cold_sweat", "sweat_smile", "sweat", "weary", "tired_face", "fearful", "scream", "angry", "rage", "triumph", "confounded", "laughing", "yum", "mask", "sunglasses", "sleeping", "dizzy_face", "astonished", "worried", "frowning", "anguished", "smiling_imp", "imp", "open_mouth", "grimacing", "neutral_face", "confused", "hushed", "no_mouth", "innocent", "smirk", "expressionless", "man_with_gua_pi_mao", "man_with_turban", "cop", "construction_worker", "guardsman", "baby", "boy", "girl", "man", "woman", "older_man", "older_woman", "person_with_blond_hair", "angel", "princess", "smiley_cat", "smile_cat", "heart_eyes_cat", "kissing_cat", "smirk_cat", "scream_cat", "crying_cat_face", "joy_cat", "pouting_cat", "japanese_ogre", "japanese_goblin", "see_no_evil", "hear_no_evil", "speak_no_evil", "skull", "alien", "hankey", "fire", "sparkles", "star2", "dizzy", "boom", "anger", "sweat_drops", "droplet", "zzz", "dash", "ear", "eyes", "nose", "tongue", "lips", "+1", "-1", "ok_hand", "facepunch", "fist", "v", "wave", "hand", "open_hands", "point_up_2", "point_down", "point_right", "point_left", "raised_hands", "pray", "point_up", "clap", "muscle", "walking", "runner", "dancer", "couple", "family", "two_men_holding_hands", "two_women_holding_hands", "couplekiss", "couple_with_heart", "dancers", "ok_woman", "no_good", "information_desk_person", "raising_hand", "massage", "haircut", "nail_care", "bride_with_veil", "person_with_pouting_face", "person_frowning", "bow", "tophat", "crown", "womans_hat", "athletic_shoe", "mans_shoe", "sandal", "high_heel", "boot", "shirt", "necktie", "womans_clothes", "dress", "running_shirt_with_sash", "jeans", "kimono", "bikini", "briefcase", "handbag", "pouch", "purse", "eyeglasses", "ribbon", "closed_umbrella", "lipstick", "yellow_heart", "blue_heart", "purple_heart", "green_heart", "heart", "broken_heart", "heartpulse", "heartbeat", "two_hearts", "sparkling_heart", "revolving_hearts", "cupid", "love_letter", "kiss", "ring", "gem", "bust_in_silhouette", "busts_in_silhouette", "speech_balloon", "footprints", "thought_balloon", "dog", "wolf", "cat", "mouse", "hamster", "rabbit", "frog", "tiger", "koala", "bear", "pig", "pig_nose", "cow", "boar", "monkey_face", "monkey", "horse", "sheep", "elephant", "panda_face", "penguin", "bird", "baby_chick", "hatched_chick", "hatching_chick", "chicken", "snake", "turtle", "bug", "bee", "ant", "beetle", "snail", "octopus", "shell", "tropical_fish", "fish", "dolphin", "whale", "whale2", "cow2", "ram", "rat", "water_buffalo", "tiger2", "rabbit2", "dragon", "racehorse", "goat", "rooster", "dog2", "pig2", "mouse2", "ox", "dragon_face", "blowfish", "crocodile", "camel", "dromedary_camel", "leopard", "cat2", "poodle", "feet", "bouquet", "cherry_blossom", "tulip", "four_leaf_clover", "rose", "sunflower", "hibiscus", "maple_leaf", "leaves", "fallen_leaf", "herb", "ear_of_rice", "mushroom", "cactus", "palm_tree", "evergreen_tree", "deciduous_tree", "chestnut", "seedling", "blossom", "globe_with_meridians", "sun_with_face", "full_moon_with_face", "new_moon_with_face", "new_moon", "waxing_crescent_moon", "first_quarter_moon", "moon", "full_moon", "waning_gibbous_moon", "last_quarter_moon", "waning_crescent_moon", "last_quarter_moon_with_face", "first_quarter_moon_with_face", "crescent_moon", "earth_africa", "earth_americas", "earth_asia", "volcano", "milky_way", "stars", "star", "sunny", "partly_sunny", "cloud", "zap", "umbrella", "snowflake", "snowman", "cyclone", "foggy", "rainbow", "ocean", "bamboo", "gift_heart", "dolls", "school_satchel", "mortar_board", "flags", "fireworks", "sparkler", "wind_chime", "rice_scene", "jack_o_lantern", "ghost", "santa", "christmas_tree", "gift", "tanabata_tree", "tada", "confetti_ball", "balloon", "crossed_flags", "crystal_ball", "movie_camera", "camera", "video_camera", "vhs", "cd", "dvd", "minidisc", "floppy_disk", "computer", "iphone", "phone", "telephone_receiver", "pager", "fax", "satellite", "tv", "radio", "loud_sound", "sound", "speaker", "mute", "bell", "no_bell", "loudspeaker", "mega", "hourglass_flowing_sand", "hourglass", "alarm_clock", "watch", "unlock", "lock", "lock_with_ink_pen", "closed_lock_with_key", "key", "mag_right", "bulb", "flashlight", "high_brightness", "low_brightness", "electric_plug", "battery", "mag", "bathtub", "bath", "shower", "toilet", "wrench", "nut_and_bolt", "hammer", "door", "smoking", "bomb", "gun", "hocho", "pill", "syringe", "moneybag", "yen", "dollar", "pound", "euro", "credit_card", "money_with_wings", "calling", "e-mail", "inbox_tray", "outbox_tray", "email", "envelope_with_arrow", "incoming_envelope", "postal_horn", "mailbox", "mailbox_closed", "mailbox_with_mail", "mailbox_with_no_mail", "postbox", "package", "memo", "page_facing_up", "page_with_curl", "bookmark_tabs", "bar_chart", "chart_with_upwards_trend", "chart_with_downwards_trend", "scroll", "clipboard", "date", "calendar", "card_index", "file_folder", "open_file_folder", "scissors", "pushpin", "paperclip", "black_nib", "pencil2", "straight_ruler", "triangular_ruler", "closed_book", "green_book", "blue_book", "orange_book", "notebook", "notebook_with_decorative_cover", "ledger", "books", "book", "bookmark", "name_badge", "microscope", "telescope", "newspaper", "art", "clapper", "microphone", "headphones", "musical_score", "musical_note", "notes", "musical_keyboard", "violin", "trumpet", "saxophone", "guitar", "space_invader", "video_game", "black_joker", "flower_playing_cards", "mahjong", "game_die", "dart", "football", "basketball", "soccer", "baseball", "tennis", "8ball", "rugby_football", "bowling", "golf", "mountain_bicyclist", "bicyclist", "checkered_flag", "horse_racing", "trophy", "ski", "snowboarder", "swimmer", "surfer", "fishing_pole_and_fish", "coffee", "tea", "sake", "baby_bottle", "beer", "beers", "cocktail", "tropical_drink", "wine_glass", "fork_and_knife", "pizza", "hamburger", "fries", "poultry_leg", "meat_on_bone", "spaghetti", "curry", "fried_shrimp", "bento", "sushi", "fish_cake", "rice_ball", "rice_cracker", "rice", "ramen", "stew", "oden", "dango", "egg", "bread", "doughnut", "custard", "icecream", "ice_cream", "shaved_ice", "birthday", "cake", "cookie", "chocolate_bar", "candy", "lollipop", "honey_pot", "apple", "green_apple", "tangerine", "lemon", "cherries", "grapes", "watermelon", "strawberry", "peach", "melon", "banana", "pear", "pineapple", "sweet_potato", "eggplant", "tomato", "corn", "house", "house_with_garden", "school", "office", "post_office", "hospital", "bank", "convenience_store", "love_hotel", "hotel", "wedding", "church", "department_store", "european_post_office", "city_sunrise", "city_sunset", "japanese_castle", "european_castle", "tent", "factory", "tokyo_tower", "japan", "mount_fuji", "sunrise_over_mountains", "sunrise", "night_with_stars", "statue_of_liberty", "bridge_at_night", "carousel_horse", "ferris_wheel", "fountain", "roller_coaster", "ship", "boat", "speedboat", "rowboat", "anchor", "rocket", "airplane", "seat", "helicopter", "steam_locomotive", "tram", "station", "mountain_railway", "train2", "bullettrain_side", "bullettrain_front", "light_rail", "metro", "monorail", "train", "railway_car", "trolleybus", "bus", "oncoming_bus", "blue_car", "oncoming_automobile", "car", "taxi", "oncoming_taxi", "articulated_lorry", "truck", "rotating_light", "police_car", "oncoming_police_car", "fire_engine", "ambulance", "minibus", "bike", "aerial_tramway", "suspension_railway", "mountain_cableway", "tractor", "barber", "busstop", "ticket", "vertical_traffic_light", "traffic_light", "warning", "construction", "beginner", "fuelpump", "izakaya_lantern", "slot_machine", "hotsprings", "moyai", "circus_tent", "performing_arts", "round_pushpin", "triangular_flag_on_post", "jp", "kr", "de", "cn", "us", "fr", "es", "it", "ru", "gb", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "zero", "keycap_ten", "1234", "hash", "symbols", "arrow_up", "arrow_down", "arrow_left", "arrow_right", "capital_abcd", "abcd", "abc", "arrow_upper_right", "arrow_upper_left", "arrow_lower_right", "arrow_lower_left", "left_right_arrow", "arrow_up_down", "arrows_counterclockwise", "arrow_backward", "arrow_forward", "arrow_up_small", "arrow_down_small", "leftwards_arrow_with_hook", "arrow_right_hook", "information_source", "rewind", "fast_forward", "arrow_double_up", "arrow_double_down", "arrow_heading_down", "arrow_heading_up", "ok", "twisted_rightwards_arrows", "repeat", "repeat_one", "new", "up", "cool", "free", "ng", "signal_strength", "cinema", "koko", "u6307", "u7a7a", "u6e80", "u5408", "u7981", "ideograph_advantage", "u5272", "u55b6", "u6709", "u7121", "restroom", "mens", "womens", "baby_symbol", "wc", "potable_water", "put_litter_in_its_place", "parking", "wheelchair", "no_smoking", "u6708", "u7533", "sa", "m", "passport_control", "baggage_claim", "left_luggage", "customs", "accept", "secret", "congratulations", "cl", "sos", "id", "no_entry_sign", "underage", "no_mobile_phones", "do_not_litter", "non-potable_water", "no_bicycles", "no_pedestrians", "children_crossing", "no_entry", "eight_spoked_asterisk", "sparkle", "negative_squared_cross_mark", "white_check_mark", "eight_pointed_black_star", "heart_decoration", "vs", "vibration_mode", "mobile_phone_off", "a", "b", "ab", "o2", "diamond_shape_with_a_dot_inside", "loop", "recycle", "aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpius", "sagittarius", "capricorn", "aquarius", "pisces", "ophiuchus", "six_pointed_star", "atm", "chart", "heavy_dollar_sign", "currency_exchange", "copyright", "registered", "tm", "x", "bangbang", "interrobang", "exclamation", "question", "grey_exclamation", "grey_question", "o", "top", "end", "back", "on", "soon", "arrows_clockwise", "clock12", "clock1230", "clock1", "clock130", "clock2", "clock230", "clock3", "clock330", "clock4", "clock430", "clock5", "clock530", "clock6", "clock7", "clock8", "clock9", "clock10", "clock11", "clock630", "clock730", "clock830", "clock930", "clock1030", "clock1130", "heavy_multiplication_x", "heavy_plus_sign", "heavy_minus_sign", "heavy_division_sign", "spades", "hearts", "clubs", "diamonds", "white_flower", "100", "heavy_check_mark", "ballot_box_with_check", "radio_button", "link", "curly_loop", "wavy_dash", "part_alternation_mark", "trident", "black_medium_square", "white_medium_square", "black_medium_small_square", "white_medium_small_square", "black_small_square", "white_small_square", "small_red_triangle", "black_square_button", "white_square_button", "black_circle", "white_circle", "red_circle", "large_blue_circle", "small_red_triangle_down", "white_large_square", "black_large_square", "large_orange_diamond", "large_blue_diamond", "small_orange_diamond", "small_blue_diamond"];
var aliases = {"laughing":["satisfied"], "hankey":["poop", "shit"], "boom":["collision"], "+1":["thumbsup"], "-1":["thumbsdown"], "facepunch":["punch"], "hand":["raised_hand"], "runner":["running"], "mans_shoe":["shoe"], "shirt":["tshirt"], "bee":["honeybee"], "dolphin":["flipper"], "feet":["paw_prints"], "moon":["waxing_gibbous_moon"], "phone":["telephone"], "hocho":["knife"], "email":["envelope"], "memo":["pencil"], "book":["open_book"], "boat":["sailboat"], "car":["red_car"], "izakaya_lantern":["lantern"], "gb":["uk"], "exclamation":["heavy_exclamation_mark"]};

var extendedEmoji = {};
Discourse.Dialect.registerEmoji = function(code, url) {
  code = code.toLowerCase();
  extendedEmoji[code] = url;
};

// This method is used by PrettyText to reset custom emojis in multisites
Discourse.Dialect.resetEmojis = function() {
  extendedEmoji = {};
};

var customEmojiCallbacks = [];
Discourse.Emoji.addCustomEmojis = function(cb) {
  customEmojiCallbacks.push(cb);
};

Discourse.Emoji.applyCustomEmojis = function() {
  var self = this;
  _.each(customEmojiCallbacks, function(cb) { cb.apply(self); });
};

Discourse.Emoji.list = function(){
  var list = emoji.slice(0);
  _.each(extendedEmoji, function(v,k){ list.push(k); });
  return list;
};


var emojiHash = {};
// add all default emojis
emoji.forEach(function(code){ emojiHash[code] = true; });
// and their aliases
for (var name in aliases) {
  aliases[name].forEach(function(alias) {
    emojiHash[alias] = true;
  });
}

Discourse.Emoji.unescape = function(string) {
  //this can be further improved by supporting matches of emoticons that don't begin with a colon
  if (Discourse.SiteSettings.enable_emoji && string.indexOf(":") >= 0) {
    string = string.replace(/\B:[^\s:]+:?\B/g, function(m) {
      var isEmoticon = !!Discourse.Emoji.translations[m],
            emoji = isEmoticon ? Discourse.Emoji.translations[m] : m.slice(1, m.length - 1),
            hasEndingColon = m.lastIndexOf(":") === m.length - 1,
            url = Discourse.Emoji.urlFor(emoji);
      return url && (isEmoticon || hasEndingColon) ? "<img src='" + url + "' title='" + emoji + "' alt='" + emoji + "' class='emoji'>" : m;
    });
  }

  return string;
};

Discourse.Emoji.urlFor = urlFor = function(code) {
  var url, set = Discourse.SiteSettings.emoji_set;

  code = code.toLowerCase();

  if(extendedEmoji.hasOwnProperty(code)) {
    url = extendedEmoji[code];
  }

  if(!url && emojiHash.hasOwnProperty(code)) {
    url = Discourse.getURL('/images/emoji/' + set + '/' + code + '.png');
  }

  if(url && url[0] !== 'h' && Discourse.CDN) {
    url = Discourse.CDN + url;
  }

  if(url){
    url = url + "?v=" + Discourse.Emoji.ImageVersion;
  }

  return url;
};

Discourse.Emoji.exists = function(code){
  code = code.toLowerCase();
  return !!(extendedEmoji.hasOwnProperty(code) || emojiHash.hasOwnProperty(code));
};

function imageFor(code) {
  code = code.toLowerCase();
  var url = urlFor(code);
  if (url) {
    var code = ':' + code + ':';
    return ['img', { href: url, title: code, 'class': 'emoji', alt: code }];
  }
}

// Also support default emotions
var translations = {
  ':)'   : 'smile',
  ':-)'  : 'smile',
  ':('   : 'frowning',
  ':-('  : 'frowning',
  ';)'   : 'wink',
  ';-)'  : 'wink',
  ':\'(' : 'cry',
  ':\'-(': 'cry',
  ':-\'(': 'cry',
  ':p'   : 'stuck_out_tongue',
  ':P'   : 'stuck_out_tongue',
  ':-P'  : 'stuck_out_tongue',
  ':O'   : 'open_mouth',
  ':-O'  : 'open_mouth',
  ':D'   : 'smiley',
  ':-D'  : 'smiley',
  ':|'   : 'expressionless',
  ':-|'  : 'expressionless',
  ':/'   : 'confused',
  '8-)'  : 'sunglasses',
  ";P"   : 'stuck_out_tongue_winking_eye',
  ";-P"  : 'stuck_out_tongue_winking_eye',
  ":$"   : 'blush',
  ":-$"  : 'blush'
};

Discourse.Emoji.translations = translations;

function checkPrev(prev) {
  if (prev && prev.length) {
    var lastToken = prev[prev.length-1];
    if (lastToken && lastToken.charAt) {
      var lastChar = lastToken.charAt(lastToken.length-1);
      if (!/\W/.test(lastChar)) return false;
    }
  }
  return true;
}

var translationsWithColon = {};
Object.keys(translations).forEach(function (t) {
  if (t[0] === ':') {
    translationsWithColon[t] = translations[t];
  } else {
    var replacement = translations[t];
    Discourse.Dialect.inlineReplace(t, function (token, match, prev) {
      if (!Discourse.SiteSettings.enable_emoji) { return token; }
      return checkPrev(prev) ? imageFor(replacement) : token;
    });
  }
});

function escapeRegExp(s) {
  return s.replace(/[-/\\^$*+?.()|[\]{}]/gi, '\\$&');
}

var translationColonRegexp = new RegExp(Object.keys(translationsWithColon).map(function (t) {
                                           return "(" + escapeRegExp(t) + ")";
                                         }).join("|"));

Discourse.Dialect.registerInline(':', function(text, match, prev) {
  if (!Discourse.SiteSettings.enable_emoji) { return; }

  var endPos = text.indexOf(':', 1),
      firstSpace = text.search(/\s/),
      contents;

  if (!checkPrev(prev)) { return; }

  // If there is no trailing colon, check our translations that begin with colons
  if (endPos === -1 || (firstSpace !== -1 && endPos > firstSpace)) {
    translationColonRegexp.lastIndex = 0;
    var m = translationColonRegexp.exec(text);
    if (m && m[0] && text.indexOf(m[0]) === 0) {
      // Check outer edge
      var lastChar = text.charAt(m[0].length);
      if (lastChar && !/\s/.test(lastChar)) return;
      contents = imageFor(translationsWithColon[m[0]]);
      if (contents) {
        return [m[0].length, contents];
      }
    }
    return;
  }

  // Simple find and replace from our array
  var between = text.slice(1, endPos);
  contents = imageFor(between);
  if (contents) {
    return [endPos+1, contents];
  }
});


var toSearch;
Discourse.Emoji.search = function(term, options) {
  var maxResults = (options && options["maxResults"]) || -1;
  if (maxResults === 0) { return []; }

  toSearch = toSearch || _.union(_.keys(emojiHash), _.keys(extendedEmoji)).sort();

  var i, results = [];

  var done = function() {
    return maxResults > 0 && results.length >= maxResults;
  }

  for (i=0; i < toSearch.length; i++) {
    if (toSearch[i].indexOf(term) === 0) {
      results.push(toSearch[i]);
      if(done()) { break; }
    }
  }

  if(!done()){
    for (i=0; i < toSearch.length; i++) {
      if (toSearch[i].indexOf(term) > 0) {
        results.push(toSearch[i]);
        if(done()) { break; }
      }
    }
  }

  return results;
};

Discourse.Markdown.whiteListTag('img', 'class', 'emoji');


// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/emoji/emoji-groups", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // note that these categories are copied from Slack
    // be careful, there are ~20 differences in synonyms, e.g. :boom: vs. :collision:
    // a few Emoji are actually missing from the Slack categories as well (?), and were added
    var groups = [{
      name: "people",
      fullname: "People",
      tabicon: "grinning",
      icons: ["grinning", "grin", "joy", "smiley", "smile", "sweat_smile", "laughing", "innocent", "smiling_imp", "imp", "wink", "blush", "relaxed", "yum", "relieved", "heart_eyes", "sunglasses", "smirk", "neutral_face", "expressionless", "unamused", "sweat", "pensive", "confused", "confounded", "kissing", "kissing_heart", "kissing_smiling_eyes", "kissing_closed_eyes", "stuck_out_tongue", "stuck_out_tongue_winking_eye", "stuck_out_tongue_closed_eyes", "disappointed", "worried", "angry", "rage", "cry", "persevere", "triumph", "disappointed_relieved", "frowning", "anguished", "fearful", "weary", "sleepy", "tired_face", "grimacing", "sob", "open_mouth", "hushed", "cold_sweat", "scream", "astonished", "flushed", "sleeping", "dizzy_face", "no_mouth", "mask", "smile_cat", "joy_cat", "smiley_cat", "heart_eyes_cat", "smirk_cat", "kissing_cat", "pouting_cat", "crying_cat_face", "scream_cat", "footprints", "bust_in_silhouette", "busts_in_silhouette", "baby", "boy", "girl", "man", "woman", "family", "couple", "two_men_holding_hands", "two_women_holding_hands", "dancers", "bride_with_veil", "person_with_blond_hair", "man_with_gua_pi_mao", "man_with_turban", "older_man", "older_woman", "cop", "construction_worker", "princess", "guardsman", "angel", "santa", "ghost", "japanese_ogre", "japanese_goblin", "hankey", "skull", "alien", "space_invader", "bow", "information_desk_person", "no_good", "ok_woman", "raising_hand", "person_with_pouting_face", "person_frowning", "massage", "haircut", "couple_with_heart", "couplekiss", "raised_hands", "clap", "hand", "ear", "eyes", "nose", "lips", "kiss", "tongue", "nail_care", "wave", "+1", "-1", "point_up", "point_up_2", "point_down", "point_left", "point_right", "ok_hand", "v", "facepunch", "fist", "raised_hand", "muscle", "open_hands", "pray"]
    }, {
      name: "nature",
      fullname: "Nature",
      tabicon: "evergreen_tree",
      icons: ["seedling", "evergreen_tree", "deciduous_tree", "palm_tree", "cactus", "tulip", "cherry_blossom", "rose", "hibiscus", "sunflower", "blossom", "bouquet", "ear_of_rice", "herb", "four_leaf_clover", "maple_leaf", "fallen_leaf", "leaves", "mushroom", "chestnut", "rat", "mouse2", "mouse", "hamster", "ox", "water_buffalo", "cow2", "cow", "tiger2", "leopard", "tiger", "rabbit2", "rabbit", "cat2", "cat", "racehorse", "horse", "ram", "sheep", "goat", "rooster", "chicken", "baby_chick", "hatching_chick", "hatched_chick", "bird", "penguin", "elephant", "dromedary_camel", "camel", "boar", "pig2", "pig", "pig_nose", "dog2", "poodle", "dog", "wolf", "bear", "koala", "panda_face", "monkey_face", "see_no_evil", "hear_no_evil", "speak_no_evil", "monkey", "dragon", "dragon_face", "crocodile", "snake", "turtle", "frog", "whale2", "whale", "dolphin", "octopus", "fish", "tropical_fish", "blowfish", "shell", "snail", "bug", "ant", "bee", "beetle", "feet", "zap", "fire", "crescent_moon", "sunny", "partly_sunny", "cloud", "droplet", "sweat_drops", "umbrella", "dash", "snowflake", "star2", "star", "stars", "sunrise_over_mountains", "sunrise", "rainbow", "ocean", "volcano", "milky_way", "mount_fuji", "japan", "globe_with_meridians", "earth_africa", "earth_americas", "earth_asia", "new_moon", "waxing_crescent_moon", "first_quarter_moon", "moon", "full_moon", "waning_gibbous_moon", "last_quarter_moon", "waning_crescent_moon", "new_moon_with_face", "full_moon_with_face", "first_quarter_moon_with_face", "last_quarter_moon_with_face", "sun_with_face"]
    }, {
      name: "food",
      fullname: "Food & Drink",
      tabicon: "hamburger",
      icons: ["tomato", "eggplant", "corn", "sweet_potato", "grapes", "melon", "watermelon", "tangerine", "lemon", "banana", "pineapple", "apple", "green_apple", "pear", "peach", "cherries", "strawberry", "hamburger", "pizza", "meat_on_bone", "poultry_leg", "rice_cracker", "rice_ball", "rice", "curry", "ramen", "spaghetti", "bread", "fries", "dango", "oden", "sushi", "fried_shrimp", "fish_cake", "icecream", "shaved_ice", "ice_cream", "doughnut", "cookie", "chocolate_bar", "candy", "lollipop", "custard", "honey_pot", "cake", "bento", "stew", "egg", "fork_and_knife", "tea", "coffee", "sake", "wine_glass", "cocktail", "tropical_drink", "beer", "beers", "baby_bottle"]
    }, {
      name: "celebration",
      fullname: "Celebration",
      tabicon: "gift",
      icons: ["ribbon", "gift", "birthday", "jack_o_lantern", "christmas_tree", "tanabata_tree", "bamboo", "rice_scene", "fireworks", "sparkler", "tada", "confetti_ball", "balloon", "dizzy", "sparkles", "boom", "mortar_board", "crown", "dolls", "flags", "wind_chime", "crossed_flags", "izakaya_lantern", "ring", "heart", "broken_heart", "love_letter", "two_hearts", "revolving_hearts", "heartbeat", "heartpulse", "sparkling_heart", "cupid", "gift_heart", "heart_decoration", "purple_heart", "yellow_heart", "green_heart", "blue_heart"]
    }, {
      name: "activity",
      fullname: "Activities",
      tabicon: "soccer",
      icons: ["runner", "walking", "dancer", "rowboat", "swimmer", "surfer", "bath", "snowboarder", "ski", "snowman", "bicyclist", "mountain_bicyclist", "horse_racing", "tent", "fishing_pole_and_fish", "soccer", "basketball", "football", "baseball", "tennis", "rugby_football", "golf", "trophy", "running_shirt_with_sash", "checkered_flag", "musical_keyboard", "guitar", "violin", "saxophone", "trumpet", "musical_note", "notes", "musical_score", "headphones", "microphone", "performing_arts", "ticket", "tophat", "circus_tent", "clapper", "art", "dart", "8ball", "bowling", "slot_machine", "game_die", "video_game", "flower_playing_cards", "black_joker", "mahjong", "carousel_horse", "ferris_wheel", "roller_coaster"]
    }, {
      name: "travel",
      fullname: "Travel & Places",
      tabicon: "airplane",
      icons: ["train", "mountain_railway", "railway_car", "steam_locomotive", "monorail", "bullettrain_side", "bullettrain_front", "train2", "metro", "light_rail", "station", "tram", "bus", "oncoming_bus", "trolleybus", "minibus", "ambulance", "fire_engine", "police_car", "oncoming_police_car", "rotating_light", "taxi", "oncoming_taxi", "car", "oncoming_automobile", "blue_car", "truck", "articulated_lorry", "tractor", "bike", "busstop", "fuelpump", "construction", "vertical_traffic_light", "traffic_light", "rocket", "helicopter", "airplane", "seat", "anchor", "ship", "speedboat", "boat", "aerial_tramway", "mountain_cableway", "suspension_railway", "passport_control", "customs", "baggage_claim", "left_luggage", "yen", "euro", "pound", "dollar", "statue_of_liberty", "moyai", "foggy", "tokyo_tower", "fountain", "european_castle", "japanese_castle", "city_sunrise", "city_sunset", "night_with_stars", "bridge_at_night", "house", "house_with_garden", "office", "department_store", "factory", "post_office", "european_post_office", "hospital", "bank", "hotel", "love_hotel", "wedding", "church", "convenience_store", "school", "cn", "de", "es", "fr", "gb", "it", "jp", "kr", "ru", "us"]
    }, {
      name: "objects",
      fullname: "Objects & Symbols",
      tabicon: "eyeglasses",
      icons: ["watch", "iphone", "calling", "computer", "alarm_clock", "hourglass_flowing_sand", "hourglass", "camera", "video_camera", "movie_camera", "tv", "radio", "pager", "telephone_receiver", "phone", "fax", "minidisc", "floppy_disk", "cd", "dvd", "vhs", "battery", "electric_plug", "bulb", "flashlight", "satellite", "credit_card", "money_with_wings", "moneybag", "gem", "closed_umbrella", "pouch", "purse", "handbag", "briefcase", "school_satchel", "lipstick", "eyeglasses", "womans_hat", "sandal", "high_heel", "boot", "mans_shoe", "athletic_shoe", "bikini", "dress", "kimono", "womans_clothes", "shirt", "necktie", "jeans", "door", "shower", "bathtub", "toilet", "barber", "syringe", "pill", "microscope", "telescope", "crystal_ball", "wrench", "hocho", "nut_and_bolt", "hammer", "bomb", "smoking", "gun", "bookmark", "newspaper", "key", "email", "envelope_with_arrow", "incoming_envelope", "e-mail", "inbox_tray", "outbox_tray", "package", "postal_horn", "postbox", "mailbox_closed", "mailbox", "mailbox_with_mail", "mailbox_with_no_mail", "page_facing_up", "page_with_curl", "bookmark_tabs", "chart_with_upwards_trend", "chart_with_downwards_trend", "bar_chart", "date", "calendar", "low_brightness", "high_brightness", "scroll", "clipboard", "book", "notebook", "notebook_with_decorative_cover", "ledger", "closed_book", "green_book", "blue_book", "orange_book", "books", "card_index", "link", "paperclip", "pushpin", "scissors", "triangular_ruler", "round_pushpin", "straight_ruler", "triangular_flag_on_post", "file_folder", "open_file_folder", "black_nib", "pencil2", "memo", "lock_with_ink_pen", "closed_lock_with_key", "lock", "unlock", "mega", "loudspeaker", "sound", "loud_sound", "speaker", "mute", "zzz", "bell", "no_bell", "thought_balloon", "speech_balloon", "children_crossing", "mag", "mag_right", "no_entry_sign", "no_entry", "name_badge", "no_pedestrians", "do_not_litter", "no_bicycles", "non-potable_water", "no_mobile_phones", "underage", "accept", "ideograph_advantage", "white_flower", "secret", "congratulations", "u5408", "u6e80", "u7981", "u6709", "u7121", "u7533", "u55b6", "u6708", "u5272", "u7a7a", "sa", "koko", "u6307", "chart", "sparkle", "eight_spoked_asterisk", "negative_squared_cross_mark", "white_check_mark", "eight_pointed_black_star", "vibration_mode", "mobile_phone_off", "vs", "a", "b", "ab", "cl", "o2", "sos", "id", "parking", "wc", "cool", "free", "new", "ng", "ok", "up", "atm", "aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpius", "sagittarius", "capricorn", "aquarius", "pisces", "restroom", "mens", "womens", "baby_symbol", "wheelchair", "potable_water", "no_smoking", "put_litter_in_its_place", "arrow_forward", "arrow_backward", "arrow_up_small", "arrow_down_small", "fast_forward", "rewind", "arrow_double_up", "arrow_double_down", "arrow_right", "arrow_left", "arrow_up", "arrow_down", "arrow_upper_right", "arrow_lower_right", "arrow_lower_left", "arrow_upper_left", "arrow_up_down", "left_right_arrow", "arrows_counterclockwise", "arrow_right_hook", "leftwards_arrow_with_hook", "arrow_heading_up", "arrow_heading_down", "twisted_rightwards_arrows", "repeat", "repeat_one", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "keycap_ten", "1234", "hash", "abc", "abcd", "capital_abcd", "information_source", "signal_strength", "cinema", "symbols", "heavy_plus_sign", "heavy_minus_sign", "wavy_dash", "heavy_division_sign", "heavy_multiplication_x", "heavy_check_mark", "arrows_clockwise", "tm", "copyright", "registered", "currency_exchange", "heavy_dollar_sign", "curly_loop", "loop", "part_alternation_mark", "exclamation", "bangbang", "question", "grey_exclamation", "grey_question", "interrobang", "x", "o", "100", "end", "back", "on", "top", "soon", "cyclone", "m", "ophiuchus", "six_pointed_star", "beginner", "trident", "warning", "hotsprings", "recycle", "anger", "diamond_shape_with_a_dot_inside", "spades", "clubs", "hearts", "diamonds", "ballot_box_with_check", "white_circle", "black_circle", "radio_button", "red_circle", "large_blue_circle", "small_red_triangle", "small_red_triangle_down", "small_orange_diamond", "small_blue_diamond", "large_orange_diamond", "large_blue_diamond", "black_small_square", "white_small_square", "black_large_square", "white_large_square", "black_medium_square", "white_medium_square", "black_medium_small_square", "white_medium_small_square", "black_square_button", "white_square_button", "clock1", "clock2", "clock3", "clock4", "clock5", "clock6", "clock7", "clock8", "clock9", "clock10", "clock11", "clock12", "clock130", "clock230", "clock330", "clock430", "clock530", "clock630", "clock730", "clock830", "clock930", "clock1030", "clock1130", "clock1230"]
    }];

    // scrub groups
    groups.forEach(function (group) {
      group.icons = group.icons.reject(function (obj) {
        return !Discourse.Emoji.exists(obj);
      });
    });

    // export so others can modify
    Discourse.Emoji.groups = groups;

    __exports__["default"] = groups;
  });define("discourse/lib/emoji/emoji-toolbar", 
  ["discourse/lib/emoji/emoji-groups","discourse/lib/key-value-store","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var groups = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];

    var keyValueStore = new KeyValueStore("discourse_emojis_");
    var EMOJI_USAGE = "emojiUsage";

    var PER_ROW = 12;
    var PER_PAGE = 60;

    var ungroupedIcons = undefined,
        recentlyUsedIcons = undefined;

    if (!keyValueStore.getObject(EMOJI_USAGE)) {
      keyValueStore.setObject({ key: EMOJI_USAGE, value: {} });
    }

    function closeSelector() {
      $('.emoji-modal, .emoji-modal-wrapper').remove();
      $('body, textarea').off('keydown.emoji');
    }

    function initializeUngroupedIcons() {
      var groupedIcons = {};

      groups.forEach(function (group) {
        group.icons.forEach(function (icon) {
          return groupedIcons[icon] = true;
        });
      });

      ungroupedIcons = [];
      var emojis = Discourse.Emoji.list();
      emojis.forEach(function (emoji) {
        if (groupedIcons[emoji] !== true) {
          ungroupedIcons.push(emoji);
        }
      });

      if (ungroupedIcons.length) {
        groups.push({ name: 'ungrouped', icons: ungroupedIcons });
      }
    }

    function trackEmojiUsage(title) {
      var recent = keyValueStore.getObject(EMOJI_USAGE) || {};

      if (!recent[title]) {
        recent[title] = { title: title, usage: 0 };
      }
      recent[title]["usage"]++;

      keyValueStore.setObject({ key: EMOJI_USAGE, value: recent });

      // clear the cache
      recentlyUsedIcons = null;
    }

    function sortByUsage(a, b) {
      if (a.usage > b.usage) {
        return -1;
      }
      if (b.usage > a.usage) {
        return 1;
      }
      return a.title.localeCompare(b.title);
    }

    function initializeRecentlyUsedIcons() {
      recentlyUsedIcons = [];

      var usage = _.map(keyValueStore.getObject(EMOJI_USAGE)).sort(sortByUsage);
      var recent = usage.slice(0, PER_ROW);

      if (recent.length > 0) {

        recent.forEach(function (emoji) {
          return recentlyUsedIcons.push(emoji.title);
        });

        var recentGroup = groups.findProperty('name', 'recent');
        if (recentGroup) {
          recentGroup.icons = recentlyUsedIcons;
        } else {
          groups.push({ name: 'recent', icons: recentlyUsedIcons });
        }
      }
    }

    function toolbar(selected) {
      if (!ungroupedIcons) {
        initializeUngroupedIcons();
      }
      if (!recentlyUsedIcons) {
        initializeRecentlyUsedIcons();
      }

      return groups.map(function (g, i) {
        var icon = g.tabicon;
        var title = g.fullname;
        if (g.name === "recent") {
          icon = "star";
          title = "Recent";
        } else if (g.name === "ungrouped") {
          icon = g.icons[0];
          title = "Custom";
        }

        return { src: Discourse.Emoji.urlFor(icon),
          title: title,
          groupId: i,
          selected: i === selected };
      });
    }

    function bindEvents(page, offset, options) {
      $('.emoji-page a').click(function (e) {
        var title = $(e.currentTarget).attr('title');
        trackEmojiUsage(title);
        options.onSelect(title);
        closeSelector();
        return false;
      }).hover(function (e) {
        var title = $(e.currentTarget).attr('title');
        var html = "<img src='" + Discourse.Emoji.urlFor(title) + "' class='emoji'> <span>:" + title + ":<span>";
        $('.emoji-modal .info').html(html);
      }, function () {
        return $('.emoji-modal .info').html("");
      });

      $('.emoji-modal .nav .next a').click(function () {
        return render(page, offset + PER_PAGE, options);
      });
      $('.emoji-modal .nav .prev a').click(function () {
        return render(page, offset - PER_PAGE, options);
      });

      $('.emoji-modal .toolbar a').click(function () {
        var p = parseInt($(this).data('group-id'));
        render(p, 0, options);
        return false;
      });
    }

    function render(page, offset, options) {
      keyValueStore.set({ key: "emojiPage", value: page });
      keyValueStore.set({ key: "emojiOffset", value: offset });

      var toolbarItems = toolbar(page);
      var rows = [];
      var row = [];
      var icons = groups[page].icons;
      var max = offset + PER_PAGE;

      for (var i = offset; i < max; i++) {
        if (!icons[i]) {
          break;
        }
        if (row.length === PER_ROW) {
          rows.push(row);
          row = [];
        }
        row.push({ src: Discourse.Emoji.urlFor(icons[i]), title: icons[i] });
      }
      rows.push(row);

      var model = {
        toolbarItems: toolbarItems,
        rows: rows,
        prevDisabled: offset === 0,
        nextDisabled: max + 1 > icons.length
      };

      $('.emoji-modal', options.appendTo).remove();
      var template = options.container.lookup('template:emoji-toolbar.raw');
      options.appendTo.append(template(model));

      bindEvents(page, offset, options);
    }

    function showSelector(options) {
      options = options || {};
      options.appendTo = options.appendTo || $('body');

      options.appendTo.append('<div class="emoji-modal-wrapper"></div>');
      $('.emoji-modal-wrapper').click(function () {
        return closeSelector();
      });

      if (Discourse.Mobile.mobileView) PER_ROW = 9;
      var page = keyValueStore.getInt("emojiPage", 0);
      var offset = keyValueStore.getInt("emojiOffset", 0);

      render(page, offset, options);

      $('body, textarea').on('keydown.emoji', function (e) {
        if (e.which === 27) {
          closeSelector();
          return false;
        }
      });
    }

    __exports__.showSelector = showSelector;
  });define("discourse/components/d-editor", 
  ["discourse/lib/load-script","ember-addons/ember-computed-decorators","discourse/lib/emoji/emoji-toolbar","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

    __exports__.onToolbarCreate = onToolbarCreate;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    /*global Mousetrap:true */

    var loadScript = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var observes = __dependency2__.observes;
    var showSelector = __dependency3__.showSelector;

    // Our head can be a static string or a function that returns a string
    // based on input (like for numbered lists).
    function getHead(head, prev) {
      if (typeof head === "string") {
        return [head, head.length];
      } else {
        return getHead(head(prev));
      }
    }

    var OP = {
      NONE: 0,
      REMOVED: 1,
      ADDED: 2
    };

    var _createCallbacks = [];

    function Toolbar() {
      this.shortcuts = {};

      this.groups = [{ group: 'fontStyles', buttons: [] }, { group: 'insertions', buttons: [] }, { group: 'extras', buttons: [], lastGroup: true }];

      this.addButton({
        id: 'bold',
        group: 'fontStyles',
        shortcut: 'B',
        perform: function (e) {
          return e.applySurround('**', '**', 'bold_text');
        }
      });

      this.addButton({
        id: 'italic',
        group: 'fontStyles',
        shortcut: 'I',
        perform: function (e) {
          return e.applySurround('*', '*', 'italic_text');
        }
      });

      this.addButton({ id: 'link', group: 'insertions', shortcut: 'K', action: 'showLinkModal' });

      this.addButton({
        id: 'quote',
        group: 'insertions',
        icon: 'quote-right',
        shortcut: 'Shift+9',
        perform: function (e) {
          return e.applySurround('> ', '', 'code_text');
        }
      });

      this.addButton({
        id: 'code',
        group: 'insertions',
        shortcut: 'Shift+C',
        perform: function (e) {
          if (e.selected.value.indexOf("\n") !== -1) {
            e.applySurround('    ', '', 'code_text');
          } else {
            e.applySurround('`', '`', 'code_text');
          }
        }
      });

      this.addButton({
        id: 'bullet',
        group: 'extras',
        icon: 'list-ul',
        shortcut: 'Shift+8',
        title: 'composer.ulist_title',
        perform: function (e) {
          return e.applyList('* ', 'list_item');
        }
      });

      this.addButton({
        id: 'list',
        group: 'extras',
        icon: 'list-ol',
        shortcut: 'Shift+7',
        title: 'composer.olist_title',
        perform: function (e) {
          return e.applyList(function (i) {
            return !i ? "1. " : parseInt(i) + 1 + '. ';
          }, 'list_item');
        }
      });

      this.addButton({
        id: 'heading',
        group: 'extras',
        icon: 'font',
        shortcut: 'Alt+1',
        perform: function (e) {
          return e.applyList('## ', 'heading_text');
        }
      });

      this.addButton({
        id: 'rule',
        group: 'extras',
        icon: 'minus',
        shortcut: 'Alt+R',
        title: 'composer.hr_title',
        perform: function (e) {
          return e.addText("\n\n----------\n");
        }
      });
    };

    Toolbar.prototype.addButton = function (button) {
      var g = this.groups.findProperty('group', button.group);
      if (!g) {
        throw 'Couldn\'t find toolbar group ' + button.group;
      }

      var createdButton = {
        id: button.id,
        className: button.className || button.id,
        icon: button.icon || button.id,
        action: button.action || 'toolbarButton',
        perform: button.perform || Ember.K
      };

      if (button.sendAction) {
        createdButton.sendAction = button.sendAction;
      }

      var title = I18n.t(button.title || 'composer.' + button.id + '_title');
      if (button.shortcut) {
        var mac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
        var mod = mac ? 'Meta' : 'Ctrl';
        var shortcutTitle = mod + '+' + button.shortcut;

        // Mac users are used to glyphs for shortcut keys
        if (mac) {
          shortcutTitle = shortcutTitle.replace('Shift', "\u21E7").replace('Meta', "\u2318").replace('Alt', "\u2325").replace(/\+/g, '');
        } else {
          shortcutTitle = shortcutTitle.replace('Shift', I18n.t('shortcut_modifier_key.shift')).replace('Ctrl', I18n.t('shortcut_modifier_key.ctrl')).replace('Alt', I18n.t('shortcut_modifier_key.alt'));
        }

        createdButton.title = title + ' (' + shortcutTitle + ')';

        this.shortcuts[(mod + '+' + button.shortcut).toLowerCase()] = createdButton;
      } else {
        createdButton.title = title;
      }

      if (button.unshift) {
        g.buttons.unshift(createdButton);
      } else {
        g.buttons.push(createdButton);
      }
    };

    function onToolbarCreate(func) {
      _createCallbacks.push(func);
    }

    ;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['d-editor'];
      }
    }, {
      key: 'ready',
      initializer: function () {
        return false;
      }
    }, {
      key: 'insertLinkHidden',
      initializer: function () {
        return true;
      }
    }, {
      key: 'link',
      initializer: function () {
        return '';
      }
    }, {
      key: 'lastSel',
      initializer: function () {
        return null;
      }
    }, {
      key: '_mouseTrap',
      initializer: function () {
        return null;
      }
    }, {
      key: 'placeholderTranslated',
      decorators: [computed('placeholder')],
      value: function (placeholder) {
        if (placeholder) return I18n.t(placeholder);
        return null;
      }
    }, {
      key: '_startUp',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        this._applyEmojiAutocomplete();

        loadScript('defer/html-sanitizer-bundle').then(function () {
          return _this.set('ready', true);
        });

        var mouseTrap = Mousetrap(this.$('.d-editor-input')[0]);

        var shortcuts = this.get('toolbar.shortcuts');
        Ember.keys(shortcuts).forEach(function (sc) {
          var button = shortcuts[sc];
          mouseTrap.bind(sc, function () {
            _this.send(button.action, button);
            return false;
          });
        });

        // disable clicking on links in the preview
        this.$('.d-editor-preview').on('click.preview', function (e) {
          e.preventDefault();
          return false;
        });

        this.appEvents.on('composer:insert-text', function (text) {
          _this._addText(_this._getSelected(), text);
        });

        this._mouseTrap = mouseTrap;
      }
    }, {
      key: '_shutDown',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.appEvents.off('composer:insert-text');

        var mouseTrap = this._mouseTrap;
        Ember.keys(this.get('toolbar.shortcuts')).forEach(function (sc) {
          return mouseTrap.unbind(sc);
        });
        this.$('.d-editor-preview').off('click.preview');
      }
    }, {
      key: 'toolbar',
      decorators: [computed],
      value: function () {
        var toolbar = new Toolbar();
        _createCallbacks.forEach(function (cb) {
          return cb(toolbar);
        });
        this.sendAction('extraButtons', toolbar);
        return toolbar;
      }
    }, {
      key: '_updatePreview',
      value: function () {
        var _this2 = this;

        if (this._state !== "inDOM") {
          return;
        }

        var value = this.get('value');
        var markdownOptions = this.get('markdownOptions') || {};
        markdownOptions.sanitize = true;

        this.set('preview', Discourse.Dialect.cook(value || "", markdownOptions));
        Ember.run.scheduleOnce('afterRender', function () {
          if (_this2._state !== "inDOM") {
            return;
          }
          var $preview = _this2.$('.d-editor-preview');
          if ($preview.length === 0) return;

          _this2.sendAction('previewUpdated', $preview);
        });
      }
    }, {
      key: '_watchForChanges',
      decorators: [observes('ready', 'value')],
      value: function () {
        if (!this.get('ready')) {
          return;
        }
        Ember.run.debounce(this, this._updatePreview, 30);
      }
    }, {
      key: '_applyEmojiAutocomplete',
      value: function () {
        if (!this.siteSettings.enable_emoji) {
          return;
        }

        var container = this.container;
        var template = container.lookup('template:emoji-selector-autocomplete.raw');
        var self = this;

        this.$('.d-editor-input').autocomplete({
          template: template,
          key: ":",

          transformComplete: function (v) {
            if (v.code) {
              return v.code + ':';
            } else {
              showSelector({
                appendTo: self.$(),
                container: container,
                onSelect: function (title) {
                  return self._addText(self._getSelected(), title + ':');
                }
              });
              return "";
            }
          },

          dataSource: function (term) {
            return new Ember.RSVP.Promise(function (resolve) {
              var full = ':' + term;
              term = term.toLowerCase();

              if (term === "") {
                return resolve(["smile", "smiley", "wink", "sunny", "blush"]);
              }

              if (Discourse.Emoji.translations[full]) {
                return resolve([Discourse.Emoji.translations[full]]);
              }

              var options = Discourse.Emoji.search(term, { maxResults: 5 });

              return resolve(options);
            }).then(function (list) {
              return list.map(function (code) {
                return { code: code, src: Discourse.Emoji.urlFor(code) };
              });
            }).then(function (list) {
              if (list.length) {
                list.push({ label: I18n.t("composer.more_emoji") });
              }
              return list;
            });
          }
        });
      }
    }, {
      key: '_getSelected',
      value: function () {
        if (!this.get('ready')) {
          return;
        }

        var textarea = this.$('textarea.d-editor-input')[0];
        var value = textarea.value;
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;

        // Windows selects the space after a word when you double click
        while (end > start && /\s/.test(value.charAt(end - 1))) {
          end--;
        }

        var selVal = value.substring(start, end);
        var pre = value.slice(0, start);
        var post = value.slice(end);

        return { start: start, end: end, value: selVal, pre: pre, post: post };
      }
    }, {
      key: '_selectText',
      value: function (from, length) {
        var _this3 = this;

        Ember.run.scheduleOnce('afterRender', function () {
          var textarea = _this3.$('textarea.d-editor-input')[0];
          if (!_this3.capabilities.isIOS) {
            textarea.focus();
          }
          textarea.selectionStart = from;
          textarea.selectionEnd = textarea.selectionStart + length;
        });
      }
    }, {
      key: '_getMultilineContents',

      // perform the same operation over many lines of text
      value: function (lines, head, hval, hlen, tail, tlen) {
        var operation = OP.NONE;

        return lines.map(function (l) {
          if (l.length === 0) {
            return l;
          }

          if (operation !== OP.ADDED && (l.slice(0, hlen) === hval && tlen === 0 || l.slice(-tlen) === tail)) {
            operation = OP.REMOVED;
            if (tlen === 0) {
              var _result = l.slice(hlen);

              var _getHead = getHead(head, hval);

              var _getHead2 = _slicedToArray(_getHead, 2);

              hval = _getHead2[0];
              hlen = _getHead2[1];

              return _result;
            } else if (l.slice(-tlen) === tail) {
              var _result2 = l.slice(hlen, -tlen);

              var _getHead3 = getHead(head, hval);

              var _getHead32 = _slicedToArray(_getHead3, 2);

              hval = _getHead32[0];
              hlen = _getHead32[1];

              return _result2;
            }
          } else if (operation === OP.NONE) {
            operation = OP.ADDED;
          } else if (operation === OP.REMOVED) {
            return l;
          }

          var result = '' + hval + l + tail;

          var _getHead4 = getHead(head, hval);

          var _getHead42 = _slicedToArray(_getHead4, 2);

          hval = _getHead42[0];
          hlen = _getHead42[1];

          return result;
        }).join("\n");
      }
    }, {
      key: '_applySurround',
      value: function (sel, head, tail, exampleKey) {
        var pre = sel.pre;
        var post = sel.post;

        var tlen = tail.length;
        if (sel.start === sel.end) {
          if (tlen === 0) {
            return;
          }

          var _getHead5 = getHead(head);

          var _getHead52 = _slicedToArray(_getHead5, 2);

          var hval = _getHead52[0];
          var hlen = _getHead52[1];

          var example = I18n.t('composer.' + exampleKey);
          this.set('value', '' + pre + hval + example + tail + post);
          this._selectText(pre.length + hlen, example.length);
        } else {
          var lines = sel.value.split("\n");

          var _getHead6 = getHead(head);

          var _getHead62 = _slicedToArray(_getHead6, 2);

          var hval = _getHead62[0];
          var hlen = _getHead62[1];

          if (lines.length === 1 && pre.slice(-tlen) === tail && post.slice(0, hlen) === hval) {
            this.set('value', '' + pre.slice(0, -hlen) + sel.value + post.slice(tlen));
            this._selectText(sel.start - hlen, sel.value.length);
          } else {
            var contents = this._getMultilineContents(lines, head, hval, hlen, tail, tlen);

            this.set('value', '' + pre + contents + post);
            if (lines.length === 1 && tlen > 0) {
              this._selectText(sel.start + hlen, contents.length - hlen - hlen);
            } else {
              this._selectText(sel.start, contents.length);
            }
          }
        }
      }
    }, {
      key: '_applyList',
      value: function (sel, head, exampleKey) {
        if (sel.value.indexOf("\n") !== -1) {
          this._applySurround(sel, head, '', exampleKey);
        } else {
          var _getHead7 = getHead(head);

          var _getHead72 = _slicedToArray(_getHead7, 2);

          var hval = _getHead72[0];
          var hlen = _getHead72[1];

          if (sel.start === sel.end) {
            sel.value = I18n.t('composer.' + exampleKey);
          }

          var trimmedPre = sel.pre.trim();
          var number = sel.value.indexOf(hval) === 0 ? sel.value.slice(hlen) : '' + hval + sel.value;
          var preLines = trimmedPre.length ? trimmedPre + '\n\n' : "";

          var trimmedPost = sel.post.trim();
          var post = trimmedPost.length ? '\n\n' + trimmedPost : trimmedPost;

          this.set('value', '' + preLines + number + post);
          this._selectText(preLines.length, number.length);
        }
      }
    }, {
      key: '_addText',
      value: function (sel, text) {
        var _this4 = this;

        var insert = '' + sel.pre + text;
        this.set('value', '' + insert + sel.post);
        this._selectText(insert.length, 0);
        Ember.run.scheduleOnce("afterRender", function () {
          return _this4.$("textarea.d-editor-input").focus();
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toolbarButton: function (button) {
            var _this5 = this;

            var selected = this._getSelected();
            var toolbarEvent = {
              selected: selected,
              applySurround: function (head, tail, exampleKey) {
                return _this5._applySurround(selected, head, tail, exampleKey);
              },
              applyList: function (head, exampleKey) {
                return _this5._applyList(selected, head, exampleKey);
              },
              addText: function (text) {
                return _this5._addText(selected, text);
              }
            };

            if (button.sendAction) {
              return this.sendAction(button.sendAction, toolbarEvent);
            } else {
              button.perform(toolbarEvent);
            }
          },

          showLinkModal: function () {
            this._lastSel = this._getSelected();
            this.set('insertLinkHidden', false);
          },

          insertLink: function () {
            var link = this.get('link');
            var sel = this._lastSel;

            if (Ember.isEmpty(link)) {
              return;
            }
            var m = / "([^"]+)"/.exec(link);
            if (m && m.length === 2) {
              var description = m[1];
              var remaining = link.replace(m[0], '');
              this._addText(sel, '[' + description + '](' + remaining + ')');
            } else {
              if (sel.value) {
                this._addText(sel, '[' + sel.value + '](' + link + ')');
              } else {
                var desc = I18n.t('composer.link_description');
                this._addText(sel, '[' + desc + '](' + link + ')');
                this._selectText(sel.start + 1, desc.length);
              }
            }

            this.set('link', '');
          },

          emoji: function () {
            var _this6 = this;

            showSelector({
              appendTo: this.$(),
              container: this.container,
              onSelect: function (title) {
                return _this6._addText(_this6._getSelected(), ':' + title + ':');
              }
            });
          }
        };
      }
    }]));
  });define("discourse/views/composer", 
  ["discourse/lib/after-transition","discourse/lib/safari-hacks","discourse/views/header","ember-addons/ember-computed-decorators","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var afterTransition = __dependency1__["default"];
    var positioningWorkaround = __dependency2__["default"];
    var headerHeight = __dependency3__.headerHeight;
    var computed = __dependency4__.default;
    var on = __dependency4__.on;
    var observes = __dependency4__.observes;
    var Composer = __dependency5__["default"];

    var ComposerView = Ember.View.extend(_createDecoratedObject([{
      key: '_lastKeyTimeout',
      initializer: function () {
        return null;
      }
    }, {
      key: 'elementId',
      initializer: function () {
        return 'reply-control';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['composer.creatingPrivateMessage:private-message', 'composeState', 'composer.loading', 'composer.canEditTitle:edit-title', 'composer.createdPost:created-post', 'composer.creatingTopic:topic'];
      }
    }, {
      key: 'composer',
      initializer: function () {
        return Em.computed.alias('controller.model');
      }
    }, {
      key: 'composeState',
      decorators: [computed('composer.composeState')],
      value: function (composeState) {
        return composeState || Composer.CLOSED;
      }
    }, {
      key: 'movePanels',
      value: function (sizePx) {

        $('#main-outlet').css('padding-bottom', sizePx);
        $('.composer-popup').css('bottom', sizePx);

        // signal the progress bar it should move!
        this.appEvents.trigger("composer:resized");
      }
    }, {
      key: 'resize',
      decorators: [observes('composeState', 'composer.action')],
      value: function () {
        var _this = this;

        Ember.run.scheduleOnce('afterRender', function () {
          var h = $('#reply-control').height() || 0;
          _this.movePanels(h + "px");

          // Figure out the size of the fields
          var $fields = _this.$('.composer-fields');
          var fieldPos = $fields.position();
          if (fieldPos) {
            _this.$('.wmd-controls').css('top', $fields.height() + fieldPos.top + 5);
          }

          // get the submit panel height
          var submitPos = _this.$('.submit-panel').position();
          if (submitPos) {
            _this.$('.wmd-controls').css('bottom', h - submitPos.top + 7);
          }
        });
      }
    }, {
      key: 'keyUp',
      value: function () {
        var _this2 = this;

        var controller = this.get('controller');
        controller.checkReplyLength();

        this.get('composer').typing();

        var lastKeyUp = new Date();
        this._lastKeyUp = lastKeyUp;

        // One second from now, check to see if the last key was hit when
        // we recorded it. If it was, the user paused typing.
        Ember.run.cancel(this._lastKeyTimeout);
        this._lastKeyTimeout = Ember.run.later(function () {
          if (lastKeyUp !== _this2._lastKeyUp) {
            return;
          }

          // Search for similar topics if the user pauses typing
          controller.findSimilarTopics();
        }, 1000);
      }
    }, {
      key: 'keyDown',
      value: function (e) {
        if (e.which === 27) {
          this.get('controller').send('hitEsc');
          return false;
        } else if (e.which === 13 && (e.ctrlKey || e.metaKey)) {
          // CTRL+ENTER or CMD+ENTER
          this.get('controller').send('save');
          return false;
        }
      }
    }, {
      key: '_enableResizing',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this3 = this;

        var $replyControl = $('#reply-control');
        var resize = function () {
          return Ember.run(function () {
            return _this3.resize();
          });
        };

        $replyControl.DivResizer({
          resize: resize,
          maxHeight: function (winHeight) {
            return winHeight - headerHeight();
          },
          onDrag: function (sizePx) {
            return _this3.movePanels(sizePx);
          }
        });

        afterTransition($replyControl, resize);
        positioningWorkaround(this.$());
      }
    }, {
      key: 'click',
      value: function () {
        this.get('controller').send('openIfDraft');
      }
    }]));

    RSVP.EventTarget.mixin(ComposerView);
    __exports__["default"] = ComposerView;
  });define("discourse/lib/show-modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (name, opts) {
      opts = opts || {};
      var container = Discourse.__container__;

      // We use the container here because modals are like singletons
      // in Discourse. Only one can be shown with a particular state.
      var route = container.lookup('route:application');
      var modalController = route.controllerFor('modal');

      modalController.set('modalClass', null);

      var viewClass = container.lookupFactory('view:' + name);
      var controller = container.lookup('controller:' + name);
      if (viewClass) {
        route.render(name, { into: 'modal', outlet: 'modalBody' });
      } else {
        var templateName = Ember.String.dasherize(name);

        var renderArgs = { into: 'modal', outlet: 'modalBody', view: 'modal-body' };
        if (controller) {
          renderArgs.controller = name;
        }

        route.render('modal/' + templateName, renderArgs);
        if (opts.title) {
          modalController.set('title', I18n.t(opts.title));
        }
      }

      if (controller) {
        var model = opts.model;
        if (model) {
          controller.set('model', model);
        }
        if (controller.onShow) {
          controller.onShow();
        }
        controller.set('flashMessage', null);
      }

      return controller;
    };
  });define("discourse/lib/screen-track", 
  ["discourse/mixins/singleton","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // We use this class to track how long posts in a topic are on the screen.

    var Singleton = __dependency1__["default"];

    var PAUSE_UNLESS_SCROLLED = 1000 * 60 * 3,
        MAX_TRACKING_TIME = 1000 * 60 * 6,
        ANON_MAX_TOPIC_IDS = 5;

    var ScreenTrack = Ember.Object.extend({

      init: function () {
        this.reset();

        // TODO: Move `ScreenTrack` to injection and remove this
        this.set('topicTrackingState', Discourse.__container__.lookup('topic-tracking-state:main'));
      },

      start: function (topicId, topicController) {
        var _this = this;

        var currentTopicId = this.get('topicId');
        if (currentTopicId && currentTopicId !== topicId) {
          this.tick();
          this.flush();
        }

        this.reset();

        // Create an interval timer if we don't have one.
        if (!this.get('interval')) {
          (function () {
            var self = _this;
            _this.set('interval', setInterval(function () {
              self.tick();
            }, 1000));

            $(window).on('scroll.screentrack', function () {
              self.scrolled();
            });
          })();
        }

        this.set('topicId', topicId);
        this.set('topicController', topicController);
      },

      stop: function () {
        if (!this.get('topicId')) {
          // already stopped no need to "extra stop"
          return;
        }
        $(window).off('scroll.screentrack');
        this.tick();
        this.flush();
        this.reset();
        this.set('topicId', null);
        this.set('topicController', null);
        if (this.get('interval')) {
          clearInterval(this.get('interval'));
          this.set('interval', null);
        }
      },

      track: function (elementId, postNumber) {
        this.get('timings')["#" + elementId] = {
          time: 0,
          postNumber: postNumber
        };
      },

      stopTracking: function (elementId) {
        delete this.get('timings')['#' + elementId];
      },

      // Reset our timers
      reset: function () {
        this.setProperties({
          lastTick: new Date().getTime(),
          lastScrolled: new Date().getTime(),
          lastFlush: 0,
          cancelled: false,
          timings: {},
          totalTimings: {},
          topicTime: 0
        });
      },

      scrolled: function () {
        this.set('lastScrolled', new Date().getTime());
      },

      flush: function () {
        if (this.get('cancelled')) {
          return;
        }

        var newTimings = {},
            totalTimings = this.get('totalTimings'),
            self = this;

        _.each(this.get('timings'), function (timing) {
          if (!totalTimings[timing.postNumber]) totalTimings[timing.postNumber] = 0;

          if (timing.time > 0 && totalTimings[timing.postNumber] < MAX_TRACKING_TIME) {
            totalTimings[timing.postNumber] += timing.time;
            newTimings[timing.postNumber] = timing.time;
          }
          timing.time = 0;
        });

        var topicId = parseInt(this.get('topicId'), 10);
        var highestSeen = 0;

        _.each(newTimings, function (time, postNumber) {
          highestSeen = Math.max(highestSeen, parseInt(postNumber, 10));
        });

        var highestSeenByTopic = Discourse.Session.currentProp('highestSeenByTopic');
        if ((highestSeenByTopic[topicId] || 0) < highestSeen) {
          highestSeenByTopic[topicId] = highestSeen;
        }

        this.topicTrackingState.updateSeen(topicId, highestSeen);

        if (!$.isEmptyObject(newTimings)) {
          if (Discourse.User.current()) {
            Discourse.ajax('/topics/timings', {
              data: {
                timings: newTimings,
                topic_time: this.get('topicTime'),
                topic_id: topicId
              },
              cache: false,
              type: 'POST',
              headers: {
                'X-SILENCE-LOGGER': 'true'
              }
            }).then(function () {
              var controller = self.get('topicController');
              if (controller) {
                var postNumbers = Object.keys(newTimings).map(function (v) {
                  return parseInt(v, 10);
                });
                controller.readPosts(topicId, postNumbers);
              }
            });
          } else if (this.get('anonFlushCallback')) {
            // Anonymous viewer - save to localStorage
            var storage = this.get('keyValueStore');

            // Save total time
            var existingTime = storage.getInt('anon-topic-time');
            storage.setItem('anon-topic-time', existingTime + this.get('topicTime'));

            // Save unique topic IDs up to a max
            var topicIds = storage.get('anon-topic-ids');
            if (topicIds) {
              topicIds = topicIds.split(',').map(function (e) {
                return parseInt(e);
              });
            } else {
              topicIds = [];
            }
            if (topicIds.indexOf(topicId) === -1 && topicIds.length < ANON_MAX_TOPIC_IDS) {
              topicIds.push(topicId);
              storage.setItem('anon-topic-ids', topicIds.join(','));
            }

            // Inform the observer
            this.get('anonFlushCallback')();

            // No need to call controller.readPosts()
          }

          this.set('topicTime', 0);
        }
        this.set('lastFlush', 0);
      },

      tick: function () {

        // If the user hasn't scrolled the browser in a long time, stop tracking time read
        var sinceScrolled = new Date().getTime() - this.get('lastScrolled');
        if (sinceScrolled > PAUSE_UNLESS_SCROLLED) {
          return;
        }

        var diff = new Date().getTime() - this.get('lastTick');
        this.set('lastFlush', this.get('lastFlush') + diff);
        this.set('lastTick', new Date().getTime());

        var totalTimings = this.get('totalTimings'),
            timings = this.get('timings');
        var nextFlush = Discourse.SiteSettings.flush_timings_secs * 1000;

        // rush new post numbers
        var rush = _.any(_.filter(timings, function (t) {
          return t.time > 0;
        }), function (t) {
          return !totalTimings[t.postNumber];
        });

        if (this.get('lastFlush') > nextFlush || rush) {
          this.flush();
        }

        // Don't track timings if we're not in focus
        if (!Discourse.get("hasFocus")) return;

        this.set('topicTime', this.get('topicTime') + diff);
        var docViewTop = $(window).scrollTop() + $('header').height(),
            docViewBottom = docViewTop + $(window).height();

        // TODO: Eyeline has a smarter more accurate function here. It's bad to do jQuery
        // in a model like component, so we should refactor this out later.
        _.each(this.get('timings'), function (timing, id) {
          var $element = $(id);
          if ($element.length === 1) {
            var elemTop = $element.offset().top,
                elemBottom = elemTop + $element.height();

            // If part of the element is on the screen, increase the counter
            if (docViewTop <= elemTop && elemTop <= docViewBottom || docViewTop <= elemBottom && elemBottom <= docViewBottom) {
              timing.time = timing.time + diff;
            }
          }
        });
      }
    });

    ScreenTrack.reopenClass(Singleton);
    __exports__["default"] = ScreenTrack;
  });define("discourse/routes/discourse", 
  ["discourse/models/composer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.cleanDOM = cleanDOM;
    var Composer = __dependency1__["default"];

    var DiscourseRoute = Ember.Route.extend({

      // Set to true to refresh a model without a transition if a query param
      // changes
      resfreshQueryWithoutTransition: false,

      refresh: function () {
        var _this = this;

        if (!this.refreshQueryWithoutTransition) {
          return this._super();
        }

        if (!this.router.router.activeTransition) {
          (function () {
            var controller = _this.controller,
                model = controller.get('model'),
                params = _this.controller.getProperties(Object.keys(_this.queryParams));

            model.set('loading', true);
            _this.model(params).then(function (m) {
              return _this.setupController(controller, m);
            });
          })();
        }
      },

      _refreshTitleOnce: function () {
        this.send('_collectTitleTokens', []);
      },

      actions: {

        _collectTitleTokens: function (tokens) {
          // If there's a title token method, call it and get the token
          if (this.titleToken) {
            var t = this.titleToken();
            if (t && t.length) {
              if (t instanceof Array) {
                t.forEach(function (ti) {
                  tokens.push(ti);
                });
              } else {
                tokens.push(t);
              }
            }
          }
          return true;
        },

        refreshTitle: function () {
          Ember.run.once(this, this._refreshTitleOnce);
        }
      },

      redirectIfLoginRequired: function () {
        var app = this.controllerFor('application');
        if (app.get('loginRequired')) {
          this.replaceWith('login');
        }
      },

      openTopicDraft: function (model) {
        // If there's a draft, open the create topic composer
        if (model.draft) {
          var composer = this.controllerFor('composer');
          if (!composer.get('model.viewOpen')) {
            composer.open({
              action: Composer.CREATE_TOPIC,
              draft: model.draft,
              draftKey: model.draft_key,
              draftSequence: model.draft_sequence
            });
          }
        }
      },

      isPoppedState: function (transition) {
        return !transition._discourse_intercepted && !!transition.intent.url;
      }
    });

    function cleanDOM() {
      // Close mini profiler
      $('.profiler-results .profiler-result').remove();

      // Close some elements that may be open
      $('header ul.icons li').removeClass('active');
      $('[data-toggle="dropdown"]').parent().removeClass('open');
      // close the lightbox
      if ($.magnificPopup && $.magnificPopup.instance) {
        $.magnificPopup.instance.close();
        $('body').removeClass('mfp-zoom-out-cur');
      }

      // Remove any link focus
      // NOTE: the '.not("body")' is here to prevent a bug in IE10 on Win7
      // cf. https://stackoverflow.com/questions/5657371/ie9-window-loses-focus-due-to-jquery-mobile
      $(document.activeElement).not("body").not(".no-blur").blur();

      Discourse.set('notifyCount', 0);
      $('#discourse-modal').modal('hide');
      var hideDropDownFunction = $('html').data('hide-dropdown');
      if (hideDropDownFunction) {
        hideDropDownFunction();
      }

      // TODO: Avoid container lookup here
      var appEvents = Discourse.__container__.lookup('app-events:main');
      appEvents.trigger('dom:clean');
    }

    __exports__["default"] = DiscourseRoute;
  });

Discourse.Route = require('discourse/routes/discourse').default;
define("discourse/routes/build-topic-route", 
  ["discourse/lib/screen-track","discourse/controllers/discovery-sortable","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScreenTrack = __dependency1__["default"];
    var queryParams = __dependency2__.queryParams;

    // A helper to build a topic route for a filter
    function filterQueryParams(params, defaultParams) {
      var findOpts = defaultParams || {};
      if (params) {
        Ember.keys(queryParams).forEach(function (opt) {
          if (params[opt]) {
            findOpts[opt] = params[opt];
          }
        });
      }
      return findOpts;
    }

    function findTopicList(store, tracking, filter, filterParams, extras) {
      extras = extras || {};
      return new Ember.RSVP.Promise(function (resolve) {
        var session = Discourse.Session.current();

        if (extras.cached) {
          var cachedList = session.get('topicList');

          // Try to use the cached version if it exists and is greater than the topics per page
          if (cachedList && cachedList.get('filter') === filter && (cachedList.get('topics.length') || 0) > cachedList.get('per_page') && _.isEqual(cachedList.get('listParams'), filterParams)) {
            cachedList.set('loaded', true);

            if (tracking) {
              tracking.updateTopics(cachedList.get('topics'));
            }
            return resolve(cachedList);
          }
          session.set('topicList', null);
        } else {
          // Clear the cache
          session.setProperties({ topicList: null, topicListScrollPosition: null });
        }

        // Clean up any string parameters that might slip through
        filterParams = filterParams || {};
        Ember.keys(filterParams).forEach(function (k) {
          var val = filterParams[k];
          if (val === "undefined" || val === "null" || val === 'false') {
            filterParams[k] = undefined;
          }
        });

        return resolve(store.findFiltered('topicList', { filter: filter, params: filterParams || {} }));
      }).then(function (list) {
        list.set('listParams', filterParams);
        if (tracking) {
          tracking.sync(list, list.filter);
          tracking.trackIncoming(list.filter);
        }
        Discourse.Session.currentProp('topicList', list);
        return list;
      });
    }

    __exports__["default"] = function (filter, extras) {
      extras = extras || {};
      return Discourse.Route.extend({
        queryParams: queryParams,

        beforeModel: function () {
          this.controllerFor('navigation/default').set('filterMode', filter);
        },

        model: function (data, transition) {
          // attempt to stop early cause we need this to be called before .sync
          ScreenTrack.current().stop();

          var findOpts = filterQueryParams(data),
              findExtras = { cached: this.isPoppedState(transition) };

          return findTopicList(this.store, this.topicTrackingState, filter, findOpts, findExtras);
        },

        titleToken: function () {
          if (filter === Discourse.Utilities.defaultHomepage()) {
            return;
          }

          var filterText = I18n.t('filters.' + filter.replace('/', '.') + '.title');
          return I18n.t('filters.with_topics', { filter: filterText });
        },

        setupController: function (controller, model) {
          var topicOpts = {
            model: model,
            category: null,
            period: model.get('for_period') || (filter.indexOf('/') > 0 ? filter.split('/')[1] : ''),
            selected: [],
            expandGloballyPinned: true
          };

          var params = model.get('params');
          if (params && Object.keys(params).length) {
            if (params.order !== undefined) {
              topicOpts.order = params.order;
            }
            if (params.ascending !== undefined) {
              topicOpts.ascending = params.ascending;
            }
          }
          this.controllerFor('discovery/topics').setProperties(topicOpts);

          this.openTopicDraft(model);
          this.controllerFor('navigation/default').set('canCreateTopic', model.get('can_create_topic'));
        },

        resetController: function (controller, isExiting) {
          if (isExiting) {
            controller.setProperties({ order: "default", ascending: false });
          }
        },

        renderTemplate: function () {
          this.render('navigation/default', { outlet: 'navigation-bar' });
          this.render('discovery/topics', { controller: 'discovery/topics', outlet: 'list-container' });
        }
      }, extras);
    }

    __exports__.filterQueryParams = filterQueryParams;
    __exports__.findTopicList = findTopicList;
  });define("discourse/routes/restricted-user", 
  ["discourse/routes/discourse","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseRoute = __dependency1__["default"];

    // A base route that allows us to redirect when access is restricted
    __exports__["default"] = DiscourseRoute.extend({

      afterModel: function () {
        if (!this.modelFor('user').get('can_edit')) {
          this.replaceWith('userActivity');
        }
      }

    });
  });define("discourse/routes/user-topic-list", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      renderTemplate: function () {
        this.render('user-topics-list');
      },

      setupController: function (controller, model) {
        var userActionType = this.get('userActionType');
        this.controllerFor('user').set('userActionType', userActionType);
        this.controllerFor('user-activity').set('userActionType', userActionType);
        this.controllerFor('user-topics-list').setProperties({
          model: model,
          hideCategory: false,
          showParticipants: false
        });
      }
    });
  });define("discourse/routes/user-activity-stream", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      model: function () {
        return this.modelFor("user").get("stream");
      },

      afterModel: function () {
        return this.modelFor("user").get("stream").filterBy(this.get("userActionType"));
      },

      renderTemplate: function () {
        this.render("user_stream");
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.viewingActionType(this.get("userActionType"));
      },

      actions: {

        didTransition: function () {
          this.controllerFor("user-activity")._showFooter();
          return true;
        },

        removeBookmark: function (userAction) {
          var user = this.modelFor("user");
          Discourse.Post.updateBookmark(userAction.get("post_id"), false).then(function () {
            // remove the user action from the stream
            user.get("stream").remove(userAction);
            // update the counts
            user.get("stats").forEach(function (stat) {
              if (stat.get("action_type") === userAction.action_type) {
                stat.decrementProperty("count");
              }
            });
          });
        }

      }
    });
  });define("discourse/routes/topic-from-params", 
  ["discourse/lib/url","discourse/models/draft","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var Draft = __dependency2__["default"];

    // This route is used for retrieving a topic based on params
    __exports__["default"] = Discourse.Route.extend({

      // Avoid default model hook
      model: function (params) {
        return params;
      },

      setupController: function (controller, params) {
        params = params || {};
        params.track_visit = true;

        var self = this,
            topic = this.modelFor('topic'),
            postStream = topic.get('postStream'),
            topicController = this.controllerFor('topic'),
            topicProgressController = this.controllerFor('topic-progress'),
            composerController = this.controllerFor('composer');

        // I sincerely hope no topic gets this many posts
        if (params.nearPost === "last") {
          params.nearPost = 999999999;
        }

        params.forceLoad = true;

        postStream.refresh(params).then(function () {
          // TODO we are seeing errors where closest post is null and this is exploding
          // we need better handling and logging for this condition.

          // The post we requested might not exist. Let's find the closest post
          var closestPost = postStream.closestPostForPostNumber(params.nearPost || 1),
              closest = closestPost.get('post_number'),
              progress = postStream.progressIndexOfPost(closestPost);

          topicController.setProperties({
            'model.currentPost': closest,
            enteredAt: new Date().getTime().toString()
          });

          topicProgressController.setProperties({
            progressPosition: progress,
            expanded: false
          });

          // Highlight our post after the next render
          Ember.run.scheduleOnce('afterRender', function () {
            self.appEvents.trigger('post:highlight', closest);
          });
          DiscourseURL.jumpToPost(closest);

          if (!Ember.isEmpty(topic.get('draft'))) {
            composerController.open({
              draft: Draft.getLocal(topic.get('draft_key'), topic.get('draft')),
              draftKey: topic.get('draft_key'),
              draftSequence: topic.get('draft_sequence'),
              topic: topic,
              ignoreIfChanged: true
            });
          }
        }).catch(function (e) {
          Ember.warn('Could not view topic', e);
        });
      }

    });
  });define("discourse/components/text-field", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.TextField.extend(_createDecoratedObject([{
      key: 'attributeBindings',
      initializer: function () {
        return ['autocorrect', 'autocapitalize', 'autofocus', 'maxLength'];
      }
    }, {
      key: 'placeholder',
      decorators: [computed("placeholderKey")],
      value: function (placeholderKey) {
        return placeholderKey ? I18n.t(placeholderKey) : "";
      }
    }]));
  });define("discourse/components/visible", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      visibleChanged: (function () {
        this.rerender();
      }).observes("visible"),

      render: function (buffer) {
        if (this._state !== 'inDOM' && this._state !== 'preRender' && this._state !== 'inBuffer') {
          return;
        }
        if (!this.get("visible")) {
          return;
        }

        return this._super(buffer);
      }
    });
  });define("discourse/components/conditional-loading-spinner", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['containerClass', 'condition:visible'],

      containerClass: (function () {
        return this.get('size') === 'small' ? 'inline-spinner' : undefined;
      }).property('size'),

      render: function (buffer) {
        if (this.get('condition')) {
          buffer.push('<div class="spinner ' + this.get('size') + '"}}></div>');
        } else {
          return this._super(buffer);
        }
      },

      _conditionChanged: (function () {
        this.rerender();
      }).observes('condition')
    });
  });define("discourse/helpers/user-avatar", 
  ["discourse/helpers/register-unbound","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    function renderAvatar(user, options) {
      options = options || {};

      if (user) {

        var username = Em.get(user, options.usernamePath || 'username');
        var avatarTemplate = Em.get(user, options.avatarTemplatePath || 'avatar_template');

        if (!username || !avatarTemplate) {
          return '';
        }

        var title = undefined;
        if (!options.ignoreTitle) {
          // first try to get a title
          title = Em.get(user, 'title');
          // if there was no title provided
          if (!title) {
            // try to retrieve a description
            var description = Em.get(user, 'description');
            // if a description has been provided
            if (description && description.length > 0) {
              // preprend the username before the description
              title = username + " - " + description;
            }
          }
        }

        return Discourse.Utilities.avatarImg({
          size: options.imageSize,
          extraClasses: Em.get(user, 'extras') || options.extraClasses,
          title: title || username,
          avatarTemplate: avatarTemplate
        });
      } else {
        return '';
      }
    }

    registerUnbound('avatar', function (user, params) {
      return new Handlebars.SafeString(renderAvatar.call(this, user, params));
    });

    __exports__.renderAvatar = renderAvatar;
  });define("discourse/helpers/cold-age-class", 
  ["discourse/helpers/register-unbound","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    function daysSinceEpoch(dt) {
      // 1000 * 60 * 60 * 24 = days since epoch
      return dt.getTime() / 86400000;
    }

    registerUnbound('cold-age-class', function (dt, params) {
      var className = params['class'] || 'age';

      if (!dt) {
        return className;
      }

      var startDate = params.startDate || new Date();

      // Show heat on age
      var nowDays = daysSinceEpoch(startDate),
          epochDays = daysSinceEpoch(new Date(dt));

      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_high) return className + ' coldmap-high';
      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_medium) return className + ' coldmap-med';
      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_low) return className + ' coldmap-low';

      return className;
    });

    __exports__.daysSinceEpoch = daysSinceEpoch;
  });define("discourse/helpers/loading-spinner", 
  ["exports"],
  function(__exports__) {
    "use strict";
    function renderSpinner(cssClass) {
      var html = "<div class='spinner";
      if (cssClass) {
        html += ' ' + cssClass;
      }
      return html + "'></div>";
    }
    var spinnerHTML = renderSpinner();

    Ember.Handlebars.registerHelper('loading-spinner', function (params) {
      var hash = params.hash;
      return new Handlebars.SafeString(renderSpinner(hash && hash.size ? hash.size : undefined));
    });

    __exports__.spinnerHTML = spinnerHTML;
    __exports__.renderSpinner = renderSpinner;
  });define("discourse/helpers/category-link", 
  ["discourse/helpers/register-unbound","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.categoryBadgeHTML = categoryBadgeHTML;
    __exports__.categoryLinkHTML = categoryLinkHTML;
    var registerUnbound = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    var get = Em.get,
        escapeExpression = Handlebars.Utils.escapeExpression;

    function categoryStripe(color, classes) {
      var style = color ? "style='background-color: #" + color + ";'" : "";
      return "<span class='" + classes + "' " + style + "></span>";
    }

    function categoryBadgeHTML(category, opts) {
      opts = opts || {};

      if (!category || !opts.allowUncategorized && Em.get(category, 'id') === Discourse.Site.currentProp("uncategorized_category_id") && Discourse.SiteSettings.suppress_uncategorized_badge) return "";

      var description = get(category, 'description_text'),
          restricted = get(category, 'read_restricted'),
          url = Discourse.getURL("/c/") + Discourse.Category.slugFor(category),
          href = opts.link === false ? '' : url,
          tagName = opts.link === false || opts.link === "false" ? 'span' : 'a',
          extraClasses = opts.extraClasses ? ' ' + opts.extraClasses : '',
          color = get(category, 'color'),
          html = "",
          parentCat = null;

      if (!opts.hideParent) {
        parentCat = Discourse.Category.findById(get(category, 'parent_category_id'));
      }

      if (parentCat && parentCat !== category) {
        html += categoryStripe(get(parentCat, 'color'), "badge-category-parent-bg");
      }

      html += categoryStripe(color, "badge-category-bg");

      var classNames = "badge-category clear-badge";
      if (restricted) {
        classNames += " restricted";
      }

      var textColor = "#" + get(category, 'text_color');

      html += "<span" + ' style="color: ' + textColor + ';" ' + 'data-drop-close="true" class="' + classNames + '"' + (description ? 'title="' + escapeExpression(description) + '" ' : '') + ">";

      var name = escapeExpression(get(category, 'name'));
      if (restricted) {
        html += iconHTML('lock') + " " + name;
      } else {
        html += name;
      }
      html += "</span>";

      if (href) {
        href = " href='" + href + "' ";
      }

      extraClasses = Discourse.SiteSettings.category_style ? Discourse.SiteSettings.category_style + extraClasses : extraClasses;

      return "<" + tagName + " class='badge-wrapper " + extraClasses + "' " + href + ">" + html + "</" + tagName + ">";
    }

    function categoryLinkHTML(category, options) {
      var categoryOptions = {};

      // TODO: This is a compatibility layer with the old helper structure.
      // Can be removed once we migrate to `registerUnbound` fully
      if (options && options.hash) {
        options = options.hash;
      }

      if (options) {
        if (options.allowUncategorized) {
          categoryOptions.allowUncategorized = true;
        }
        if (options.link !== undefined) {
          categoryOptions.link = options.link;
        }
        if (options.extraClasses) {
          categoryOptions.extraClasses = options.extraClasses;
        }
        if (options.hideParent) {
          categoryOptions.hideParent = true;
        }
      }
      return new Handlebars.SafeString(categoryBadgeHTML(category, categoryOptions));
    }

    registerUnbound('category-link', categoryLinkHTML);
    Ember.Handlebars.helper('bound-category-link', categoryLinkHTML);
  });define("discourse/lib/export-result", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.outputExportResult = outputExportResult;

    function outputExportResult(result) {
      if (result.success) {
        bootbox.alert(I18n.t("admin.export_csv.success"));
      } else {
        bootbox.alert(I18n.t("admin.export_csv.failed"));
      }
    }
  });define("discourse/lib/binary-search", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = binarySearch;
    // The binarySearch() function is licensed under the UNLICENSE
    // https://github.com/Olical/binary-search

    // Modified for use in Discourse

    function binarySearch(list, target, keyProp) {
      var min = 0;
      var max = list.length - 1;
      var guess;
      var keyProperty = keyProp || "id";

      while (min <= max) {
        guess = Math.floor((min + max) / 2);

        if (Em.get(list[guess], keyProperty) === target) {
          return guess;
        } else {
          if (Em.get(list[guess], keyProperty) < target) {
            min = guess + 1;
          } else {
            max = guess - 1;
          }
        }
      }

      return -Math.floor((min + max) / 2);
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.CensoredWords = {
  censor: function(text) {
    var censorRegexp,
        censored = Discourse.SiteSettings.censored_words;

    if (censored && censored.length) {
      if (!censorRegexp) {
        var split = censored.split("|");
        if (split && split.length) {
          censorRegexp = new RegExp("\\b(?:" + split.map(function (t) { return "(" + t.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&') + ")"; }).join("|") + ")\\b", "ig");
        }
      }
      if (censorRegexp) {
        var m = censorRegexp.exec(text);
        while (m && m[0]) {
          var replacement = new Array(m[0].length+1).join('&#9632;');
          text = text.replace(new RegExp("\\b" + m[0] + "\\b", "ig"), replacement);
          m = censorRegexp.exec(text);
        }

      }
    }
    return text;
  }
};


// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/click-track", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = {
      trackClick: function (e) {
        // cancel click if triggered as part of selection.
        if (Discourse.Utilities.selectedText() !== "") {
          return false;
        }

        var $link = $(e.currentTarget);
        if ($link.hasClass('lightbox') || $link.hasClass('mention-group')) {
          return true;
        }

        var href = $link.attr('href') || $link.data('href'),
            $article = $link.closest('article'),
            postId = $article.data('post-id'),
            topicId = $('#topic').data('topic-id'),
            userId = $link.data('user-id');

        if (!href || href.trim().length === 0) {
          return;
        }

        if (!userId) userId = $article.data('user-id');

        var ownLink = userId && userId === Discourse.User.currentProp('id'),
            trackingUrl = Discourse.getURL("/clicks/track?url=" + encodeURIComponent(href));
        if (postId && !$link.data('ignore-post-id')) {
          trackingUrl += "&post_id=" + encodeURI(postId);
        }
        if (topicId) {
          trackingUrl += "&topic_id=" + encodeURI(topicId);
        }

        // Update badge clicks unless it's our own
        if (!ownLink) {
          var $badge = $('span.badge', $link);
          if ($badge.length === 1) {
            // don't update counts in category badge nor in oneboxes (except when we force it)
            if ($link.hasClass("track-link") || $link.closest('.badge-category,.onebox-result,.onebox-body').length === 0) {
              var html = $badge.html();
              if (/^\d+$/.test(html)) {
                $badge.html(parseInt(html, 10) + 1);
              }
            }
          }
        }

        // If they right clicked, change the destination href
        if (e.which === 3) {
          var destination = Discourse.SiteSettings.track_external_right_clicks ? trackingUrl : href;
          $link.attr('href', destination);
          return true;
        }

        // if they want to open in a new tab, do an AJAX request
        if (e.shiftKey || e.metaKey || e.ctrlKey || e.which === 2) {
          Discourse.ajax("/clicks/track", {
            data: {
              url: href,
              post_id: postId,
              topic_id: topicId,
              redirect: false
            },
            dataType: 'html'
          });
          return true;
        }

        e.preventDefault();

        // We don't track clicks on quote back buttons
        if ($link.hasClass('back') || $link.hasClass('quote-other-topic')) {
          return true;
        }

        // Remove the href, put it as a data attribute
        if (!$link.data('href')) {
          $link.addClass('no-href');
          $link.data('href', $link.attr('href'));
          $link.attr('href', null);
          // Don't route to this URL
          $link.data('auto-route', true);
        }

        // restore href
        setTimeout(function () {
          $link.removeClass('no-href');
          $link.attr('href', $link.data('href'));
          $link.data('href', null);
        }, 50);

        // warn the user if they can't download the file
        if (Discourse.SiteSettings.prevent_anons_from_downloading_files && $link.hasClass("attachment") && !Discourse.User.current()) {
          bootbox.alert(I18n.t("post.errors.attachment_download_requires_login"));
          return false;
        }

        // If we're on the same site, use the router and track via AJAX
        if (DiscourseURL.isInternal(href) && !$link.hasClass('attachment')) {
          Discourse.ajax("/clicks/track", {
            data: {
              url: href,
              post_id: postId,
              topic_id: topicId,
              redirect: false
            },
            dataType: 'html'
          });
          DiscourseURL.routeTo(href);
          return false;
        }

        // Otherwise, use a custom URL with a redirect
        if (Discourse.User.currentProp('external_links_in_new_tab')) {
          var win = window.open(trackingUrl, '_blank');
          win.focus();
        } else {
          DiscourseURL.redirectTo(trackingUrl);
        }

        return false;
      }
    };
  });define("discourse/lib/copy-text", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
     * Copy text to the clipboard. Must be called from within a user gesture (Chrome).
     */

    __exports__["default"] = function (text, element) {
      var supported = false;
      try {
        // Chrome: This only returns true within a user gesture.
        // Chrome: queryCommandEnabled() only returns true if a selection is
        //   present, so we use queryCommandSupported() instead for the fail-fast.
        if (document.queryCommandSupported('copy')) {
          supported = true;
        }
      } catch (e) {
        // Ignore
      }
      if (!supported) {
        return;
      }

      var newRange = document.createRange();
      newRange.selectNode(element);
      var selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(newRange);

      try {
        if (document.execCommand("copy")) {
          return true;
        }
      } catch (e) {
        // Ignore
      }
      return false;
    }
  });define("discourse/lib/decimal-adjust", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor

    __exports__["default"] = function (type, value, exp) {
      // If the exp is undefined or zero...
      if (typeof exp === 'undefined' || +exp === 0) {
        return Math[type](value);
      }
      value = +value;
      exp = +exp;
      // If the value is not a number or the exp is not an integer...
      if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
        return NaN;
      }
      // Shift
      value = value.toString().split('e');
      value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));
      // Shift back
      value = value.toString().split('e');
      return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
    }
  });define("discourse/lib/desktop-notifications", 
  ["discourse/lib/url","discourse/lib/page-tracker","discourse/lib/key-value-store","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var PageTracker = __dependency2__["default"];
    var KeyValueStore = __dependency3__["default"];

    var primaryTab = false;
    var liveEnabled = false;
    var havePermission = null;
    var mbClientId = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx";
    var lastAction = -1;

    var focusTrackerKey = "focus-tracker";
    var idleThresholdTime = 1000 * 10; // 10 seconds

    var context = "discourse_desktop_notifications_";
    var keyValueStore = new KeyValueStore(context);

    // Called from an initializer
    function init(messageBus) {
      liveEnabled = false;
      mbClientId = messageBus.clientId;

      if (!Discourse.User.current()) {
        return;
      }

      try {
        keyValueStore.getItem(focusTrackerKey);
      } catch (e) {
        Em.Logger.info('Discourse desktop notifications are disabled - localStorage denied.');
        return;
      }

      if (!("Notification" in window)) {
        Em.Logger.info('Discourse desktop notifications are disabled - not supported by browser');
        return;
      }

      try {
        if (Notification.permission === "granted") {
          havePermission = true;
        } else if (Notification.permission === "denied") {
          havePermission = false;
          return;
        }
      } catch (e) {
        Em.Logger.warn('Unexpected error, Notification is defined on window but not a responding correctly ' + e);
      }

      liveEnabled = true;
      try {
        // Preliminary checks passed, continue with setup
        setupNotifications();
      } catch (e) {
        Em.Logger.error(e);
      }
    }

    // This function is only called if permission was granted
    function setupNotifications() {

      window.addEventListener("storage", function (e) {
        // note: This event only fires when other tabs setItem()
        var key = e.key;
        if (key !== '' + context + focusTrackerKey) {
          return true;
        }
        primaryTab = false;
      });

      window.addEventListener("focus", function () {
        if (!primaryTab) {
          primaryTab = true;
          keyValueStore.setItem(focusTrackerKey, mbClientId);
        }
      });

      if (document && typeof document.hidden !== "undefined" && document["hidden"]) {
        primaryTab = false;
      } else {
        primaryTab = true;
        keyValueStore.setItem(focusTrackerKey, mbClientId);
      }

      if (document) {
        document.addEventListener("scroll", resetIdle);
      }
      PageTracker.on("change", resetIdle);
    }

    function resetIdle() {
      lastAction = Date.now();
    }
    function isIdle() {
      return lastAction + idleThresholdTime < Date.now();
    }

    // Call-in point from message bus
    function onNotification(data) {
      if (!liveEnabled) {
        return;
      }
      if (!primaryTab) {
        return;
      }
      if (!isIdle()) {
        return;
      }
      if (keyValueStore.getItem('notifications-disabled')) {
        return;
      }

      var notificationTitle = I18n.t(i18nKey(data.notification_type), {
        site_title: Discourse.SiteSettings.title,
        topic: data.topic_title,
        username: data.username
      });

      var notificationBody = data.excerpt;
      var notificationIcon = Discourse.SiteSettings.logo_small_url || Discourse.SiteSettings.logo_url;
      var notificationTag = "discourse-notification-" + Discourse.SiteSettings.title + "-" + data.topic_id;

      requestPermission().then(function () {
        // This shows the notification!
        var notification = new Notification(notificationTitle, {
          body: notificationBody,
          icon: notificationIcon,
          tag: notificationTag
        });

        function clickEventHandler() {
          DiscourseURL.routeTo(data.post_url);
          // Cannot delay this until the page renders
          // due to trigger-based permissions
          window.focus();
        }

        notification.addEventListener('click', clickEventHandler);
        setTimeout(function () {
          notification.close();
          notification.removeEventListener('click', clickEventHandler);
        }, 10 * 1000);
      });
    }

    // Utility function
    // Wraps Notification.requestPermission in a Promise
    function requestPermission() {
      if (havePermission === true) {
        return Ember.RSVP.resolve();
      } else if (havePermission === false) {
        return Ember.RSVP.reject();
      } else {
        return new Ember.RSVP.Promise(function (resolve, reject) {
          Notification.requestPermission(function (status) {
            if (status === "granted") {
              resolve();
            } else {
              reject();
            }
          });
        });
      }
    }

    function i18nKey(notification_type) {
      return "notifications.popup." + Discourse.Site.current().get("notificationLookup")[notification_type];
    }

    // Exported for controllers/notification.js.es6

    __exports__.init = init;
    __exports__.onNotification = onNotification;
  });define("discourse/lib/discourse-location", 
  ["discourse/views/cloaked-collection","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var CloakedCollectionView = __dependency1__["default"];

    /**
    @module Discourse
    */

    var get = Ember.get,
        set = Ember.set;
    var popstateFired = false;
    var supportsHistoryState = window.history && 'state' in window.history;

    var popstateCallbacks = [];

    /**
      `Ember.DiscourseLocation` implements the location API using the browser's
      `history.pushState` API.

      @class DiscourseLocation
      @namespace Discourse
      @extends Ember.Object
    */
    var DiscourseLocation = Ember.Object.extend({

      init: function () {
        set(this, 'location', get(this, 'location') || window.location);
        this.initState();
      },

      /**
        @private
         Used to set state on first call to setURL
         @method initState
      */
      initState: function () {
        set(this, 'history', get(this, 'history') || window.history);

        var url = this.formatURL(this.getURL());
        var loc = get(this, 'location');

        if (loc && loc.hash) {
          url += loc.hash;
        }

        this.replaceState(url);
      },

      /**
        Will be pre-pended to path upon state change
         @property rootURL
        @default '/'
      */
      rootURL: '/',

      /**
        @private
         Returns the current `location.pathname` without rootURL
         @method getURL
      */
      getURL: function () {
        var location = get(this, 'location');
        var url = location.pathname;

        url = url.replace(Discourse.BaseUri, '');

        var search = location.search || '';
        url += search;

        return url;
      },

      /**
        @private
         Uses `history.pushState` to update the url without a page reload.
         @method setURL
        @param path {String}
      */
      setURL: function (path) {
        var state = this.getState();
        path = this.formatURL(path);

        if (state && state.path !== path) {
          this.pushState(path);
        }
      },

      /**
        @private
         Uses `history.replaceState` to update the url without a page reload
        or history modification.
         @method replaceURL
        @param path {String}
      */
      replaceURL: function (path) {
        var state = this.getState();
        path = this.formatURL(path);

        if (state && state.path !== path) {
          this.replaceState(path);
        }
      },

      /**
       @private
        Get the current `history.state`
       Polyfill checks for native browser support and falls back to retrieving
       from a private _historyState constiable
        @method getState
      */
      getState: function () {
        return supportsHistoryState ? get(this, 'history').state : this._historyState;
      },

      /**
       @private
        Pushes a new state
        @method pushState
       @param path {String}
      */
      pushState: function (path) {
        var state = { path: path };

        // store state if browser doesn't support `history.state`
        if (!supportsHistoryState) {
          this._historyState = state;
        } else {
          get(this, 'history').pushState(state, null, path);
        }

        // used for webkit workaround
        this._previousURL = this.getURL();
      },

      /**
       @private
        Replaces the current state
        @method replaceState
       @param path {String}
      */
      replaceState: function (path) {
        var state = { path: path };

        // store state if browser doesn't support `history.state`
        if (!supportsHistoryState) {
          this._historyState = state;
        } else {
          get(this, 'history').replaceState(state, null, path);
        }

        // used for webkit workaround
        this._previousURL = this.getURL();
      },

      /**
        @private
         Register a callback to be invoked whenever the browser
        history changes, including using forward and back buttons.
         @method onUpdateURL
        @param callback {Function}
      */
      onUpdateURL: function (callback) {
        var guid = Ember.guidFor(this),
            self = this;

        Ember.$(window).on('popstate.ember-location-' + guid, function () {
          // Ignore initial page load popstate event in Chrome
          if (!popstateFired) {
            popstateFired = true;
            if (self.getURL() === self._previousURL) {
              return;
            }
          }
          var url = self.getURL();
          popstateCallbacks.forEach(function (cb) {
            cb(url);
          });
          callback(url);
        });
      },

      /**
        @private
         Used when using `{{action}}` helper.  The url is always appended to the rootURL.
         @method formatURL
        @param url {String}
      */
      formatURL: function (url) {
        var rootURL = get(this, 'rootURL');

        if (url !== '') {
          rootURL = rootURL.replace(/\/$/, '');

          if (rootURL.length > 0 && url.indexOf(rootURL + "/") === 0) {
            rootURL = "";
          }
        }

        return rootURL + url;
      },

      willDestroy: function () {
        var guid = Ember.guidFor(this);

        Ember.$(window).off('popstate.ember-location-' + guid);
      }

    });

    /**
      Since we're using pushState/replaceState let's add extra hooks to cloakedView to
      eject itself when the popState occurs. This results in better back button
      behavior.
    **/
    CloakedCollectionView.reopen({
      _watchForPopState: (function () {
        var self = this,
            cb = function () {
          // Sam: This is a hack, but a very important one
          // Due to the way we use replace state the back button works strangely
          //
          // If you visit a topic from the front page, scroll a bit around and then hit back
          // you notice that first the page scrolls a bit (within the topic) and then it goes back
          // this transition is jarring and adds uneeded rendering costs.
          //
          // To repro comment the hack out and wack a debugger statement here and in
          // topic_route deactivate
          $('.posts,#topic-title').hide();
          self.cleanUp();
          self.set('controller.model.postStream.loaded', false);
        };
        this.set('_callback', cb);
        popstateCallbacks.addObject(cb);
      }).on('didInsertElement'),

      _disbandWatcher: (function () {
        popstateCallbacks.removeObject(this.get('_callback'));
        this.set('_callback', null);
      }).on('willDestroyElement')
    });

    __exports__["default"] = DiscourseLocation;
  });define("discourse/lib/highlight-syntax", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = highlightSyntax;
    /*global hljs:true */

    var loadScript = __dependency1__["default"];
    function highlightSyntax($elem) {
      var selector = Discourse.SiteSettings.autohighlight_all_code ? 'pre code' : 'pre code[class]',
          path = Discourse.HighlightJSPath;

      if (!path) {
        return;
      }

      $(selector, $elem).each(function (i, e) {
        loadScript(path).then(function () {
          return hljs.highlightBlock(e);
        });
      });
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

// forked cause we may want to amend the logic a bit
/*
 * jQuery Highlight plugin
 *
 * Based on highlight v3 by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Code a little bit refactored and cleaned (in my humble opinion).
 * Most important changes:
 *  - has an option to highlight only entire words (wordsOnly - false by default),
 *  - has an option to be case sensitive (caseSensitive - false by default)
 *  - highlight element tag and class names can be specified in options
 *
 * Usage:
 *   // wrap every occurrance of text 'lorem' in content
 *   // with <span class='highlight'> (default options)
 *   $('#content').highlight('lorem');
 *
 *   // search for and highlight more terms at once
 *   // so you can save some time on traversing DOM
 *   $('#content').highlight(['lorem', 'ipsum']);
 *   $('#content').highlight('lorem ipsum');
 *
 *   // search only for entire word 'lorem'
 *   $('#content').highlight('lorem', { wordsOnly: true });
 *
 *   // don't ignore case during search of term 'lorem'
 *   $('#content').highlight('lorem', { caseSensitive: true });
 *
 *   // wrap every occurrance of term 'ipsum' in content
 *   // with <em class='important'>
 *   $('#content').highlight('ipsum', { element: 'em', className: 'important' });
 *
 *   // remove default highlight
 *   $('#content').unhighlight();
 *
 *   // remove custom highlight
 *   $('#content').unhighlight({ element: 'em', className: 'important' });
 *
 *
 * Copyright (c) 2009 Bartek Szopka
 *
 * Licensed under MIT license.
 *
 */


jQuery.extend({
    highlight: function (node, re, nodeName, className) {
        if (node.nodeType === 3) {
            var match = node.data.match(re);
            if (match) {
                var highlight = document.createElement(nodeName || 'span');
                highlight.className = className || 'highlight';
                var wordNode = node.splitText(match.index);
                wordNode.splitText(match[0].length);
                var wordClone = wordNode.cloneNode(true);
                highlight.appendChild(wordClone);
                wordNode.parentNode.replaceChild(highlight, wordNode);
                return 1; //skip added node in parent
            }
        } else if ((node.nodeType === 1 && node.childNodes) && // only element nodes that have children
                !/(script|style)/i.test(node.tagName) && // ignore script and style nodes
                !(node.tagName === nodeName.toUpperCase() && node.className === className)) { // skip if already highlighted
            for (var i = 0; i < node.childNodes.length; i++) {
                i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
            }
        }
        return 0;
    }
});

jQuery.fn.unhighlight = function (options) {
    var settings = { className: 'highlight-strong', element: 'span' };
    jQuery.extend(settings, options);

    return this.find(settings.element + "." + settings.className).each(function () {
        var parent = this.parentNode;
        parent.replaceChild(this.firstChild, this);
        parent.normalize();
    }).end();
};

jQuery.fn.highlight = function (words, options) {
    var settings = { className: 'highlight-strong', element: 'span', caseSensitive: false, wordsOnly: false };
    jQuery.extend(settings, options);

    if (words.constructor === String) {
        words = [words];
    }
    words = jQuery.grep(words, function(word){
      return word !== '';
    });
    words = jQuery.map(words, function(word) {
      return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    });
    if (words.length === 0) { return this; }

    var flag = settings.caseSensitive ? "" : "i";
    var pattern = "(" + words.join("|") + ")";
    if (settings.wordsOnly) {
        pattern = "\\b" + pattern + "\\b";
    }
    var re = new RegExp(pattern, flag);

    return this.each(function () {
        jQuery.highlight(this, re, settings.element, settings.className);
    });
};



// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/intercept-click", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";

    __exports__["default"] = interceptClick;
    var DiscourseURL = __dependency1__["default"];

    /**
      Discourse does some server side rendering of HTML, such as the `cooked` contents of
      posts. The downside of this in an Ember app is the links will not go through the router.
      This jQuery code intercepts clicks on those links and routes them properly.
    **/
    function interceptClick(e) {
      if (e.isDefaultPrevented() || e.shiftKey || e.metaKey || e.ctrlKey) {
        return;
      }

      var $currentTarget = $(e.currentTarget),
          href = $currentTarget.attr('href');

      if (!href || href === '#' || $currentTarget.attr('target') || $currentTarget.data('ember-action') || $currentTarget.data('auto-route') || $currentTarget.data('share-url') || $currentTarget.data('user-card') || $currentTarget.hasClass('mention') || !$currentTarget.hasClass('d-link') && $currentTarget.hasClass('ember-view') || $currentTarget.hasClass('lightbox') || href.indexOf("mailto:") === 0 || href.match(/^http[s]?:\/\//i) && !href.match(new RegExp("^http:\\/\\/" + window.location.hostname, "i"))) {
        return;
      }

      e.preventDefault();
      DiscourseURL.routeTo(href);
      return false;
    }
  });define("discourse/lib/is-element-in-viewport", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (element) {
          if (element instanceof jQuery) {
                element = element[0];
          }

          var $window = $(window),
              rect = element.getBoundingClientRect();

          return rect.top >= 0 && rect.left >= 0 && rect.bottom <= $window.height() && rect.right <= $window.width();
    }
  });define("discourse/lib/keyboard-shortcuts", 
  ["discourse/lib/url","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var Composer = __dependency2__["default"];

    var bindings = {
      '!': { postAction: 'showFlags' },
      '#': { handler: 'toggleProgress', anonymous: true },
      '/': { handler: 'toggleSearch', anonymous: true },
      '=': { handler: 'toggleHamburgerMenu', anonymous: true },
      '?': { handler: 'showHelpModal', anonymous: true },
      '.': { click: '.alert.alert-info.clickable', anonymous: true }, // show incoming/updated topics
      'b': { handler: 'toggleBookmark' },
      'c': { handler: 'createTopic' },
      'ctrl+f': { handler: 'showBuiltinSearch', anonymous: true },
      'command+f': { handler: 'showBuiltinSearch', anonymous: true },
      'd': { postAction: 'deletePost' },
      'e': { postAction: 'editPost' },
      'end': { handler: 'goToLastPost', anonymous: true },
      'f': { handler: 'toggleBookmarkTopic' },
      'g h': { path: '/', anonymous: true },
      'g l': { path: '/latest', anonymous: true },
      'g n': { path: '/new' },
      'g u': { path: '/unread' },
      'g c': { path: '/categories', anonymous: true },
      'g t': { path: '/top', anonymous: true },
      'g b': { path: '/bookmarks' },
      'g p': { path: '/my/activity' },
      'g m': { path: '/my/messages' },
      'home': { handler: 'goToFirstPost', anonymous: true },
      'j': { handler: 'selectDown', anonymous: true },
      'k': { handler: 'selectUp', anonymous: true },
      'l': { click: '.topic-post.selected button[data-action="like"]' },
      'm m': { click: 'div.notification-options li[data-id="0"] a' }, // mark topic as muted
      'm r': { click: 'div.notification-options li[data-id="1"] a' }, // mark topic as regular
      'm t': { click: 'div.notification-options li[data-id="2"] a' }, // mark topic as tracking
      'm w': { click: 'div.notification-options li[data-id="3"] a' }, // mark topic as watching
      'o,enter': { click: '.topic-list tr.selected a.title', anonymous: true }, // open selected topic
      'p': { handler: 'showCurrentUser' },
      'q': { handler: 'quoteReply' },
      'r': { postAction: 'replyToPost' },
      's': { click: '.topic-post.selected a.post-date', anonymous: true }, // share post
      'shift+j': { handler: 'nextSection', anonymous: true },
      'shift+k': { handler: 'prevSection', anonymous: true },
      'shift+p': { handler: 'pinUnpinTopic' },
      'shift+r': { handler: 'replyToTopic' },
      'shift+s': { click: '#topic-footer-buttons button.share', anonymous: true }, // share topic
      'shift+z shift+z': { handler: 'logout' },
      't': { postAction: 'replyAsNewTopic' },
      'u': { handler: 'goBack', anonymous: true },
      'x r': { click: '#dismiss-new,#dismiss-new-top,#dismiss-posts,#dismiss-posts-top' }, // dismiss new/posts
      'x t': { click: '#dismiss-topics,#dismiss-topics-top' } // dismiss topics
    };

    __exports__["default"] = {
      bindEvents: function (keyTrapper, container) {
        var _this = this;

        this.keyTrapper = keyTrapper;
        this.container = container;
        this._stopCallback();

        this.searchService = this.container.lookup('search-service:main');
        this.appEvents = this.container.lookup('app-events:main');
        this.currentUser = this.container.lookup('current-user:main');

        Object.keys(bindings).forEach(function (key) {
          var binding = bindings[key];
          if (!binding.anonymous && !_this.currentUser) {
            return;
          }

          if (binding.path) {
            _this._bindToPath(binding.path, key);
          } else if (binding.handler) {
            _this._bindToFunction(binding.handler, key);
          } else if (binding.postAction) {
            _this._bindToSelectedPost(binding.postAction, key);
          } else if (binding.click) {
            _this._bindToClick(binding.click, key);
          }
        });
      },

      toggleBookmark: function () {
        this.sendToSelectedPost('toggleBookmark');
        this.sendToTopicListItemView('toggleBookmark');
      },

      toggleBookmarkTopic: function () {
        var topic = this.currentTopic();
        // BIG hack, need a cleaner way
        if (topic && $('.posts-wrapper').length > 0) {
          topic.toggleBookmark();
        } else {
          this.sendToTopicListItemView('toggleBookmark');
        }
      },

      logout: function () {
        this.container.lookup('route:application').send('logout');
      },

      quoteReply: function () {
        this._replyToPost();
        // lazy but should work for now
        setTimeout(function () {
          $('.d-editor .quote').click();
        }, 500);
      },

      goToFirstPost: function () {
        this._jumpTo('jumpTop');
      },

      goToLastPost: function () {
        this._jumpTo('jumpBottom');
      },

      _jumpTo: function (direction) {
        if ($('.container.posts').length) {
          this.container.lookup('controller:topic-progress').send(direction);
        }
      },

      replyToTopic: function () {
        this._replyToPost();
      },

      selectDown: function () {
        this._moveSelection(1);
      },

      selectUp: function () {
        this._moveSelection(-1);
      },

      goBack: function () {
        history.back();
      },

      nextSection: function () {
        this._changeSection(1);
      },

      prevSection: function () {
        this._changeSection(-1);
      },

      showBuiltinSearch: function () {
        if (this.container.lookup('controller:header').get('searchVisible')) {
          this.toggleSearch();
          return true;
        }

        this.searchService.set('searchContextEnabled', false);

        var currentPath = this.container.lookup('controller:application').get('currentPath'),
            blacklist = [/^discovery\.categories/],
            whitelist = [/^topic\./],
            check = function (regex) {
          return !!currentPath.match(regex);
        };
        var showSearch = whitelist.any(check) && !blacklist.any(check);

        // If we're viewing a topic, only intercept search if there are cloaked posts
        if (showSearch && currentPath.match(/^topic\./)) {
          showSearch = $('.cooked').length < this.container.lookup('controller:topic').get('model.postStream.stream.length');
        }

        if (showSearch) {
          this.searchService.set('searchContextEnabled', true);
          this.toggleSearch();
          return false;
        }

        return true;
      },

      createTopic: function () {
        this.container.lookup('controller:composer').open({ action: Composer.CREATE_TOPIC, draftKey: Composer.CREATE_TOPIC });
      },

      pinUnpinTopic: function () {
        this.container.lookup('controller:topic').togglePinnedState();
      },

      toggleProgress: function () {
        this.container.lookup('controller:topic-progress').send('toggleExpansion', { highlight: true });
      },

      toggleSearch: function () {
        this.container.lookup('controller:header').send('toggleSearch');
        return false;
      },

      toggleHamburgerMenu: function () {
        this.container.lookup('controller:header').send('toggleMenuPanel', 'hamburgerVisible');
      },

      showCurrentUser: function () {
        this.container.lookup('controller:header').send('toggleMenuPanel', 'userMenuVisible');
      },

      showHelpModal: function () {
        this.container.lookup('controller:application').send('showKeyboardShortcutsHelp');
      },

      sendToTopicListItemView: function (action) {
        var elem = $('tr.selected.topic-list-item.ember-view')[0];
        if (elem) {
          var view = Ember.View.views[elem.id];
          view.send(action);
        }
      },

      currentTopic: function () {
        var topicController = this.container.lookup('controller:topic');
        if (topicController) {
          var topic = topicController.get('model');
          if (topic) {
            return topic;
          }
        }
      },

      sendToSelectedPost: function (action) {
        var container = this.container;
        // TODO: We should keep track of the post without a CSS class
        var selectedPostId = parseInt($('.topic-post.selected article.boxed').data('post-id'), 10);
        if (selectedPostId) {
          var topicController = container.lookup('controller:topic'),
              post = topicController.get('model.postStream.posts').findBy('id', selectedPostId);
          if (post) {
            topicController.send(action, post);
          }
        }
      },

      _bindToSelectedPost: function (action, binding) {
        var _this2 = this;

        this.keyTrapper.bind(binding, function () {
          return _this2.sendToSelectedPost(action);
        });
      },

      _bindToPath: function (path, key) {
        this.keyTrapper.bind(key, function () {
          return DiscourseURL.routeTo(path);
        });
      },

      _bindToClick: function (selector, binding) {
        binding = binding.split(',');
        this.keyTrapper.bind(binding, function (e) {
          var $sel = $(selector);

          // Special case: We're binding to enter.
          if (e && e.keyCode === 13) {
            // Binding to enter should only be effective when there is something
            // to select.
            if ($sel.length === 0) {
              return;
            }

            // If effective, prevent default.
            e.preventDefault();
          }
          $sel.click();
        });
      },

      _bindToFunction: function (func, binding) {
        if (typeof this[func] === 'function') {
          this.keyTrapper.bind(binding, _.bind(this[func], this));
        }
      },

      _moveSelection: function (direction) {
        var $articles = this._findArticles();

        if (typeof $articles === 'undefined') {
          return;
        }

        var $selected = $articles.filter('.selected');
        var index = $articles.index($selected);

        if ($selected.length !== 0) {
          //boundries check
          // loop is not allowed
          if (direction === -1 && index === 0) {
            return;
          }
          if (direction === 1 && index === $articles.size() - 1) {
            return;
          }
        }

        // if nothing is selected go to the first post on screen
        if ($selected.length === 0) {
          (function () {
            var scrollTop = $(document).scrollTop();

            index = 0;
            $articles.each(function () {
              var top = $(this).position().top;
              if (top > scrollTop) {
                return false;
              }
              index += 1;
            });

            if (index >= $articles.length) {
              index = $articles.length - 1;
            }

            direction = 0;
          })();
        }

        var $article = $articles.eq(index + direction);

        if ($article.size() > 0) {

          $articles.removeClass('selected');
          $article.addClass('selected');

          if ($article.is('.topic-list-item')) {
            this.sendToTopicListItemView('select');
          }

          if ($article.is('.topic-post')) {
            var tabLoc = $article.find('a.tabLoc');
            if (tabLoc.length === 0) {
              tabLoc = $('<a href class="tabLoc"></a>');
              $article.prepend(tabLoc);
            }
            tabLoc.focus();
          }

          this._scrollList($article, direction);
        }
      },

      _scrollList: function ($article) {
        // Try to keep the article on screen
        var pos = $article.offset();
        var height = $article.height();
        var scrollTop = $(window).scrollTop();
        var windowHeight = $(window).height();

        // skip if completely on screen
        if (pos.top > scrollTop && pos.top + height < scrollTop + windowHeight) {
          return;
        }

        var scrollPos = pos.top + height / 2 - windowHeight * 0.5;
        if (scrollPos < 0) {
          scrollPos = 0;
        }

        if (this._scrollAnimation) {
          this._scrollAnimation.stop();
        }
        this._scrollAnimation = $("html, body").animate({ scrollTop: scrollPos + "px" }, 100);
      },

      _findArticles: function () {
        var $topicList = $('.topic-list'),
            $topicArea = $('.posts-wrapper');

        if ($topicArea.size() > 0) {
          return $('.posts-wrapper .topic-post, .topic-list tbody tr');
        } else if ($topicList.size() > 0) {
          return $topicList.find('.topic-list-item');
        }
      },

      _changeSection: function (direction) {
        var $sections = $('.nav.nav-pills li'),
            active = $('.nav.nav-pills li.active'),
            index = $sections.index(active) + direction;

        if (index >= 0 && index < $sections.length) {
          $sections.eq(index).find('a').click();
        }
      },

      _stopCallback: function () {
        var oldStopCallback = this.keyTrapper.prototype.stopCallback;

        this.keyTrapper.prototype.stopCallback = function (e, element, combo, sequence) {
          if ((combo === 'ctrl+f' || combo === 'command+f') && element.id === 'search-term') {
            return false;
          }
          return oldStopCallback.call(this, e, element, combo, sequence);
        };
      },

      _replyToPost: function () {
        this.container.lookup('controller:topic').send('replyToPost');
      }
    };
  });define("discourse/lib/lightbox", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];

    __exports__["default"] = function ($elem) {
      $("a.lightbox", $elem).each(function (i, e) {
        loadScript("/javascripts/jquery.magnific-popup-min.js").then(function () {
          var $e = $(e);
          // do not lightbox spoiled images
          if ($e.parents(".spoiler").length > 0 || $e.parents(".spoiled").length > 0) {
            return;
          }

          $e.magnificPopup({
            type: "image",
            closeOnContentClick: false,
            removalDelay: 300,
            mainClass: "mfp-zoom-in",

            callbacks: {
              open: function () {
                var wrap = this.wrap,
                    img = this.currItem.img,
                    maxHeight = img.css("max-height");

                wrap.on("click.pinhandler", "img", function () {
                  wrap.toggleClass("mfp-force-scrollbars");
                  img.css("max-height", wrap.hasClass("mfp-force-scrollbars") ? "none" : maxHeight);
                });
              },
              beforeClose: function () {
                this.wrap.off("click.pinhandler");
                this.wrap.removeClass("mfp-force-scrollbars");
              }
            },

            image: {
              titleSrc: function (item) {
                var href = item.el.data("download-href") || item.src;
                var src = [item.el.attr("title"), $("span.informations", item.el).text().replace('x', '&times;')];
                if (!Discourse.SiteSettings.prevent_anons_from_downloading_files || Discourse.User.current()) {
                  src.push('<a class="image-source-link" href="' + href + '">' + I18n.t("lightbox.download") + '</a>');
                }
                return src.join(' &middot; ');
              }
            }

          });
        });
      });
    }
  });define("discourse/lib/logout", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = logout;

    function logout(siteSettings, keyValueStore) {
      keyValueStore.abandonLocal();

      var redirect = siteSettings.logout_redirect;
      if (Ember.isEmpty(redirect)) {
        window.location.pathname = Discourse.getURL('/');
      } else {
        window.location.href = redirect;
      }
    }
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

//  An object that is responsible for logic related to mobile devices.
Discourse.Mobile = {
  isMobileDevice: false,
  mobileView: false,

  init: function() {
    var $html = $('html');
    this.isMobileDevice = $html.hasClass('mobile-device');
    this.mobileView = $html.hasClass('mobile-view');

    try{
      if (window.location.search.match(/mobile_view=1/)){
        localStorage.mobileView = true;
      }
      if (window.location.search.match(/mobile_view=0/)){
        localStorage.mobileView = false;
      }
      if (localStorage.mobileView) {
        var savedValue = (localStorage.mobileView === 'true');
        if (savedValue !== this.mobileView) {
          this.reloadPage(savedValue);
        }
      }
    } catch(err) {
      // localStorage may be disabled, just skip this
      // you get security errors if it is disabled
    }
  },

  toggleMobileView: function() {
    try{
      if (localStorage) {
        localStorage.mobileView = !this.mobileView;
      }
    } catch(err) {
      // localStorage may be disabled, skip
    }
    this.reloadPage(!this.mobileView);
  },

  reloadPage: function(mobile) {
    window.location.assign(window.location.pathname + '?mobile_view=' + (mobile ? '1' : '0'));
  }
};


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  A helper for looking up oneboxes and displaying them

  For now it only stores in a local Javascript Object, in future we can change it so it uses localStorage
  or some other mechanism.

  @class Onebox
  @namespace Discourse
  @module Discourse
**/

Discourse.Onebox = {

  // The cache is just a JS Object
  localCache: {},

  // A cache of failed URLs
  failedCache: {},

  /**
    Perform a lookup of a onebox based an anchor element. It will insert a loading
    indicator and remove it when the loading is complete or fails.

    @method load
    @param {HTMLElement} e the anchor element whose onebox we want to look up
    @param {Boolean} refresh true if we want to force a refresh of the onebox
  **/
  load: function(e, refresh) {

    var $elem = $(e);

    // If the onebox has loaded, return
    if ($elem.data('onebox-loaded')) return;
    if ($elem.hasClass('loading-onebox')) return;

    var url = e.href;

    // Unless we're forcing a refresh...
    if (!refresh) {
      // If we have it in our cache, return it.
      var cached = this.localCache[url];
      if (cached) return cached;

      // If the request failed, don't do anything
      var failed = this.failedCache[url];
      if (failed) return;
    }

    // Add the loading CSS class
    $elem.addClass('loading-onebox');

    // Retrieve the onebox
    var promise = Discourse.ajax("/onebox", {
      dataType: 'html',
      data: { url: url, refresh: refresh },
      cache: true
    });

    // We can call this when loading is complete
    var loadingFinished = function() {
      $elem.removeClass('loading-onebox');
      $elem.data('onebox-loaded');
    };

    var onebox = this;
    promise.then(function(html) {

      // loaded onebox
      loadingFinished();

      onebox.localCache[url] = html;
      $elem.replaceWith(html);

    }, function() {
      // If the request failed log it as such
      onebox.failedCache[url] = true;
      loadingFinished();
    });

  },

  /**
    Return the cached contents of a Onebox

    @method lookupCache
    @param {String} url the url of the onebox
    @return {String} the cached contents of the onebox or null if not found
  **/
  lookupCache: function(url) {
    return this.localCache[url];
  },

  /**
    Store the contents of a Onebox in our local cache.

    @method cache
    @private
    @param {String} url the url of the onebox we crawled
    @param {String} contents the contents we want to cache
  **/
  cache: function(url, contents) {
    this.localCache[url] = contents;
  }

};




// IIFE Wrapped Content Ends

 })(this);define("discourse/lib/page-tracker", 
  ["discourse/mixins/singleton","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Singleton = __dependency1__["default"];

    /**
      Called whenever the "page" changes. This allows us to set up analytics
      and other tracking.

      To get notified when the page changes, you can install a hook like so:

      ```javascript
        PageTracker.current().on('change', function(url, title) {
          console.log('the page changed to: ' + url + ' and title ' + title);
        });
      ```
    **/
    var PageTracker = Ember.Object.extend(Ember.Evented, {
      start: function () {
        if (this.get('started')) {
          return;
        }

        var router = Discourse.__container__.lookup('router:main'),
            self = this;

        router.on('didTransition', function () {
          this.send('refreshTitle');
          var url = this.get('url');

          // Refreshing the title is debounced, so we need to trigger this in the
          // next runloop to have the correct title.
          Em.run.next(function () {
            self.trigger('change', url, Discourse.get('_docTitle'));
          });
        });
        this.set('started', true);
      }
    });
    PageTracker.reopenClass(Singleton);

    __exports__["default"] = PageTracker;
  });define("discourse/lib/plugin-api", 
  ["discourse/components/composer-editor","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.decorateCooked = decorateCooked;
    var ComposerEditor = __dependency1__["default"];

    var _decorateId = 0;
    function decorate(klass, evt, cb) {
      var mixin = {};
      mixin["_decorate_" + _decorateId++] = (function ($elem) {
        cb($elem);
      }).on(evt);
      klass.reopen(mixin);
    }

    function decorateCooked(container, cb) {
      var postView = container.lookupFactory('view:post');
      decorate(postView, 'postViewInserted', cb);
      decorate(postView, 'postViewUpdated', cb);
      decorate(ComposerEditor, 'previewRefreshed', cb);
      decorate(container.lookupFactory('view:embedded-post'), 'didInsertElement', cb);
      decorate(container.lookupFactory('view:user-stream'), 'didInsertElement', cb);
    }
  });define("discourse/lib/round", 
  ["discourse/lib/decimal-adjust","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var decimalAdjust = __dependency1__["default"];

    __exports__["default"] = function (value, exp) {
      return decimalAdjust("round", value, exp);
    }
  });define("discourse/lib/sharing", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      If you want to add a new sharing source to Discourse, you can do so like this:

      ```javascript
        import Sharing from 'discourse/lib/sharing';

        Sharing.addSource({

          // This id must be present in the `share_links` site setting too
          id: 'twitter',

          // The icon that will be displayed, choose between font awesome class name `faIcon` and custom HTML `htmlIcon`.
          // When both provided, prefer `faIcon`
          faIcon: 'fa-twitter-square'
          htmlIcon: '<img src="example.com/example.jpg">',

          // A callback for generating the remote link from the `link` and `title`
          generateUrl: function(link, title) {
            return "http://twitter.com/intent/tweet?url=" + encodeURIComponent(link) + "&text=" + encodeURIComponent(title);
          },

          // If true, opens in a popup of `popupHeight` size. If false it's opened in a new tab
          shouldOpenInPopup: true,
          popupHeight: 265
        });
      ```
    **/

    var _sources = {};

    __exports__["default"] = {
      addSource: function (source) {
        _sources[source.id] = source;
      },

      activeSources: function (linksSetting) {
        return linksSetting.split('|').map(function (s) {
          return _sources[s];
        }).compact();
      }
    };
  });define("discourse/lib/static-route-builder", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    var configs = {
      "faq": "faq_url",
      "tos": "tos_url",
      "privacy": "privacy_policy_url"
    };

    __exports__["default"] = function (page) {
      return Discourse.Route.extend({
        renderTemplate: function () {
          this.render("static");
        },

        beforeModel: function (transition) {
          var configKey = configs[page];
          if (configKey && Discourse.SiteSettings[configKey].length > 0) {
            transition.abort();
            DiscourseURL.redirectTo(Discourse.SiteSettings[configKey]);
          }
        },

        activate: function () {
          this._super();
          // Scroll to an element if exists
          DiscourseURL.scrollToId(document.location.hash);
        },

        model: function () {
          return Discourse.StaticPage.find(page);
        },

        setupController: function (controller, model) {
          this.controllerFor("static").set("model", model);
        },

        actions: {
          didTransition: function () {
            this.controllerFor("application").set("showFooter", true);
            return true;
          }
        }
      });
    };
  });define("discourse/router", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.mapRoutes = mapRoutes;
    var rootURL = Discourse.BaseUri;

    var BareRouter = Ember.Router.extend({
      rootURL: rootURL,
      location: Ember.testing ? 'none' : 'discourse-location'
    });

    function mapRoutes() {

      var Router = BareRouter.extend();
      var resources = {};
      var paths = {};

      // If a module is defined as `route-map` in discourse or a plugin, its routes
      // will be built automatically. You can supply a `resource` property to
      // automatically put it in that resource, such as `admin`. That way plugins
      // can define admin routes.
      Ember.keys(requirejs._eak_seen).forEach(function (key) {
        if (/route-map$/.test(key)) {
          var module = require(key, null, null, true);
          if (!module || !module.default) {
            throw new Error(key + ' must export a route map.');
          }

          var mapObj = module.default;
          if (typeof mapObj === 'function') {
            mapObj = { resource: 'root', map: mapObj };
          }

          if (!resources[mapObj.resource]) {
            resources[mapObj.resource] = [];
          }
          resources[mapObj.resource].push(mapObj.map);
          if (mapObj.path) {
            paths[mapObj.resource] = mapObj.path;
          }
        }
      });

      return Router.map(function () {
        var router = this;

        // Do the root resources first
        if (resources.root) {
          resources.root.forEach(function (m) {
            m.call(router);
          });
          delete resources.root;
        }

        // Even if no plugins set it up, we need an `adminPlugins` route
        var adminPlugins = 'admin.adminPlugins';
        resources[adminPlugins] = resources[adminPlugins] || [Ember.K];
        paths[adminPlugins] = paths[adminPlugins] || "/plugins";

        var segments = {},
            standalone = [];

        Object.keys(resources).forEach(function (r) {
          var m = /^([^\.]+)\.(.*)$/.exec(r);
          if (m) {
            segments[m[1]] = m[2];
          } else {
            standalone.push(r);
          }
        });

        // Apply other resources next. A little hacky but works!
        standalone.forEach(function (r) {
          router.resource(r, { path: paths[r] }, function () {
            var res = this;
            resources[r].forEach(function (m) {
              m.call(res);
            });

            var s = segments[r];
            if (s) {
              var full = r + '.' + s;
              res.resource(s, { path: paths[full] }, function () {
                var nestedRes = this;
                resources[full].forEach(function (m) {
                  m.call(nestedRes);
                });
              });
            }
          });
        });

        this.route('unknown', { path: '*path' });
      });
    }

    __exports__["default"] = BareRouter;
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  This addition handles auto linking of text. When included, it will parse out links and create
  a hrefs for them.
**/

var urlReplacerArgs = {
  matcher: /^((?:https?:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.])(?:[^\s()<>]+|\([^\s()<>]+\))+(?:\([^\s()<>]+\)|[^`!()\[\]{};:'".,<>?«»“”‘’\s]))/,
  spaceOrTagBoundary: true,

  emitter: function(matches) {
    var url = matches[1],
        displayUrl = url;

    // Don't autolink a markdown link to something
    if (url.match(/\]\[\d$/)) { return; }

    // If we improperly caught a markdown link abort
    if (url.match(/\(http/)) { return; }

    if (url.match(/^www/)) { url = "http://" + url; }
    return ['a', {href: url}, displayUrl];
  }
};

Discourse.Dialect.inlineRegexp(_.merge({start: 'http'}, urlReplacerArgs));
Discourse.Dialect.inlineRegexp(_.merge({start: 'www'}, urlReplacerArgs));


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.BBCode = {};

/**
  Create a simple BBCode tag handler

  @method replaceBBCode
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
  @param {Object} opts options to pass to Discourse.Dialect.inlineBetween
    @param {Function} [opts.emitter] The function that will be called with the contents and returns JsonML.
    @param {String} [opts.start] The starting token we want to find
    @param {String} [opts.stop] The ending token we want to find
    @param {String} [opts.between] A shortcut for when the `start` and `stop` are the same.
    @param {Boolean} [opts.rawContents] If true, the contents between the tokens will not be parsed.
    @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
    @param {Boolean} [opts.spaceBoundary] If true, the match must be on a sppace boundary
**/

Discourse.BBCode.register = function(codeName, args, emitter) {

  // Optional second param for args
  if (typeof args === "function") {
    emitter = args;
    args = {};
  }

  Discourse.Dialect.replaceBlock({
    start: new RegExp("\\[" + codeName + "(=[^\\[\\]]+)?\\]([\\s\\S]*)", "igm"),
    stop: new RegExp("\\[\\/" + codeName + "\\]", "igm"),
    emitter: function(blockContents, matches, options) {
      while (blockContents.length && (typeof blockContents[0] === "string" || blockContents[0] instanceof String)) {
        blockContents[0] = String(blockContents[0]).replace(/^\s+/, '');
        if (!blockContents[0].length) {
          blockContents.shift();
        } else {
          break;
        }
      }

      var contents = [];
      if (blockContents.length) {
        var self = this;

        var nextContents = blockContents.slice(1);
        blockContents = this.processBlock(blockContents[0], nextContents).concat(nextContents);

        blockContents.forEach(function (bc) {
          if (typeof bc === "string" || bc instanceof String) {
            var processed = self.processInline(String(bc));
            if (processed.length) {
              contents.push(['p'].concat(processed));
            }
          } else {
            contents.push(bc);
          }
        });
      }
      if (!args.singlePara && contents.length === 1 && contents[0] instanceof Array && contents[0][0] === "para") {
        contents[0].shift();
        contents = contents[0];
      }
      var result = emitter(contents, matches[1] ? matches[1].replace(/^=|\"/g, '') : null, options);
      return args.noWrap ? result : ['p', result];
    }
  });
};

Discourse.BBCode.replaceBBCode = function (tag, emitter, opts) {
  opts = opts || {};
  opts = _.merge(opts, { start: "[" + tag + "]", stop: "[/" + tag + "]", emitter: emitter });
  Discourse.Dialect.inlineBetween(opts);

  tag = tag.toUpperCase();
  opts = _.merge(opts, { start: "[" + tag + "]", stop: "[/" + tag + "]", emitter: emitter });
  Discourse.Dialect.inlineBetween(opts);
};

/**
  Shortcut to call replaceBBCode with `rawContents` as true.

  @method replaceBBCode
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
**/
Discourse.BBCode.rawBBCode = function (tag, emitter) {
  Discourse.BBCode.replaceBBCode(tag, emitter, { rawContents: true });
};

/**
  Creates a BBCode handler that accepts parameters. Passes them to the emitter.

  @method replaceBBCodeParamsRaw
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
**/
Discourse.BBCode.replaceBBCodeParamsRaw = function (tag, emitter) {
  var opts = {
    rawContents: true,
    emitter: function(contents) {
      var regexp = /^([^\]]+)\]([\S\s]*)$/,
          m = regexp.exec(contents);

      if (m) { return emitter.call(this, m[1], m[2]); }
    }
  };

  Discourse.Dialect.inlineBetween(_.merge(opts, { start: "[" + tag + "=", stop: "[/" + tag + "]" }));

  tag = tag.toUpperCase();
  Discourse.Dialect.inlineBetween(_.merge(opts, { start: "[" + tag + "=", stop: "[/" + tag + "]" }));
};

/**
  Filters an array of JSON-ML nodes, removing nodes that represent empty lines ("\n").

  @method removeEmptyLines
  @param {Array} [contents] Array of JSON-ML nodes
**/
Discourse.BBCode.removeEmptyLines = function (contents) {
  var result = [];
  for (var i=0; i < contents.length; i++) {
    if (contents[i] !== "\n") { result.push(contents[i]); }
  }
  return result;
};

Discourse.BBCode.replaceBBCode('b', function(contents) { return ['span', {'class': 'bbcode-b'}].concat(contents); });
Discourse.BBCode.replaceBBCode('i', function(contents) { return ['span', {'class': 'bbcode-i'}].concat(contents); });
Discourse.BBCode.replaceBBCode('u', function(contents) { return ['span', {'class': 'bbcode-u'}].concat(contents); });
Discourse.BBCode.replaceBBCode('s', function(contents) { return ['span', {'class': 'bbcode-s'}].concat(contents); });
Discourse.Markdown.whiteListTag('span', 'class', /^bbcode-[bius]$/);

Discourse.BBCode.replaceBBCode('ul', function(contents) { return ['ul'].concat(Discourse.BBCode.removeEmptyLines(contents)); });
Discourse.BBCode.replaceBBCode('ol', function(contents) { return ['ol'].concat(Discourse.BBCode.removeEmptyLines(contents)); });
Discourse.BBCode.replaceBBCode('li', function(contents) { return ['li'].concat(Discourse.BBCode.removeEmptyLines(contents)); });

Discourse.BBCode.rawBBCode('img', function(contents) { return ['img', {href: contents}]; });
Discourse.BBCode.rawBBCode('email', function(contents) { return ['a', {href: "mailto:" + contents, 'data-bbcode': true}, contents]; });

Discourse.BBCode.replaceBBCode('url', function(contents) {
  if (!Array.isArray(contents)) { return; }
  if (contents.length === 1 && contents[0][0] === 'a') {
    // single-line bbcode links shouldn't be oneboxed, so we mark this as a bbcode link.
    if (typeof contents[0][1] !== 'object') { contents[0].splice(1, 0, {}); }
    contents[0][1]['data-bbcode'] = true;
  }
  return ['concat'].concat(contents);
});
Discourse.BBCode.replaceBBCodeParamsRaw('url', function(param, contents) {
  var url = param.replace(/(^")|("$)/g, '');
  return ['a', {'href': url}].concat(this.processInline(contents));
});
Discourse.Dialect.on('parseNode', function(event) {
  if (!Array.isArray(event.node)) { return; }
  var result = [ event.node[0] ];
  var nodes = event.node.slice(1);
  var i, j;
  for (i = 0; i < nodes.length; i++) {
    if (Array.isArray(nodes[i]) && nodes[i][0] === 'concat') {
      for (j = 1; j < nodes[i].length; j++) { result.push(nodes[i][j]); }
    } else {
      result.push(nodes[i]);
    }
  }
  for (i = 0; i < result.length; i++) { event.node[i] = result[i]; }
});

Discourse.BBCode.replaceBBCodeParamsRaw("email", function(param, contents) {
  return ['a', {href: "mailto:" + param, 'data-bbcode': true}].concat(contents);
});

Discourse.BBCode.register('size', function(contents, params) {
  return ['span', {'class': "bbcode-size-" + (parseInt(params, 10) || 1)}].concat(contents);
});
Discourse.Markdown.whiteListTag('span', 'class', /^bbcode-size-\d+$/);

// Handles `[code] ... [/code]` blocks
Discourse.Dialect.replaceBlock({
  start: /(\[code\])([\s\S]*)/igm,
  stop: /\[\/code\]/igm,
  rawContents: true,

  emitter: function(blockContents) {
    var inner = blockContents.join("\n");
    return ['p', ['pre', ['code', {'class': Discourse.SiteSettings.default_code_lang}, inner]]];
  }
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/* global md5:true */

/**
  markdown-js doesn't ensure that em/strong codes are present on word boundaries.
  So we create our own handlers here.
**/

// From PageDown
var aLetter = /[a-zA-Z0-9\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua67f-\ua697\ua717-\ua71f\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]/;


var unhoist = function(obj,from,to){
  var unhoisted = 0;
  var regex = new RegExp(from, "g");

  if(_.isArray(obj)){
    for(var i=0; i<obj.length; i++){
      var item = obj[i];

      if(_.isString(item)){
        // Odd, but we need +1 for the / in front of /*
        var matches = item.match(regex);
        unhoisted -= matches ? matches.length : 0;

        obj[i] = item.replace(regex, to);
        unhoisted += item.length - obj[i].length;
      }
      if(_.isArray(item)){
        unhoisted += unhoist(item, from, to);
      }
    }
  }
  return unhoisted;
};

var replaceMarkdown = function(match, tag) {
  var hash = md5(match[0]);

  Discourse.Dialect.registerInline(match, function(text, matched, prev){
    if(!text || text.length < match.length + 1) {
      return;
    }
    var lastText = prev[prev.length-1];
    lastText = typeof lastText === "string" && lastText;
    lastText = lastText && lastText[lastText.length-1];
    if(lastText && (lastText === "/" || lastText.match(aLetter))){
      return;
    }

    if(text[match.length].match(/\s/)) {
      return;
    }

    // hoist out escaped \*
    text = text.replace(new RegExp("\\\\\\" + match[0], "g"), hash);

    var endText = new RegExp("[^\\s|" + match[0] + "]" + match.replace(/\*/g,"\\*") + "([^" + match[0] + "]|$)");

    var finish = text.split("\n")[0].search(endText);
    if(finish && finish >= 0) {
      var newText = text.substring(match.length, finish+1);
      newText = this.processInline(newText);

      var unhoisted_length = unhoist(newText,hash,match[0]);

      var array = typeof tag === "string" ? [tag].concat(newText) : [tag[0], [tag[1]].concat(newText)];

      return [(finish + match.length + 1) - unhoisted_length, array];
    }
  });
};

replaceMarkdown('***', ['strong','em']);
replaceMarkdown('___', ['strong','em']);
replaceMarkdown('**', 'strong');
replaceMarkdown('__', 'strong');
replaceMarkdown('*', 'em');
replaceMarkdown('_', 'em');




// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.Dialect.addPreProcessor(function(text) {
  return Discourse.CensoredWords.censor(text);
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Support for various code blocks
**/


var acceptableCodeClasses;

function init() {
  acceptableCodeClasses = Discourse.SiteSettings.highlighted_languages.split("|");
  if (Discourse.SiteSettings.highlighted_languages.length > 0) {
    var regexpSource = "^lang-(" + "nohighlight|auto|" + Discourse.SiteSettings.highlighted_languages + ")$";
    Discourse.Markdown.whiteListTag('code', 'class', new RegExp(regexpSource, "i"));
  }
}

if (Discourse.SiteSettings) {
  init();
} else {
  Discourse.initializer({initialize: init, name: 'load-acceptable-code-classes'});
}


var textCodeClasses = ["text", "pre", "plain"];

function codeFlattenBlocks(blocks) {
  var result = "";
  blocks.forEach(function(b) {
    result += b;
    if (b.trailing) { result += b.trailing; }
  });
  return result;
}

Discourse.Dialect.replaceBlock({
  start: /^`{3}([^\n\[\]]+)?\n?([\s\S]*)?/gm,
  stop: /^```$/gm,
  withoutLeading: /\[quote/gm, //if leading text contains a quote this should not match
  emitter: function(blockContents, matches) {

    var klass = Discourse.SiteSettings.default_code_lang;

    if (acceptableCodeClasses && matches[1] && acceptableCodeClasses.indexOf(matches[1]) !== -1) {
      klass = matches[1];
    }

    if (textCodeClasses.indexOf(matches[1]) !== -1) {
      return ['p', ['pre', ['code', {'class': 'lang-nohighlight'}, codeFlattenBlocks(blockContents) ]]];
    } else  {
      return ['p', ['pre', ['code', {'class': 'lang-' + klass}, codeFlattenBlocks(blockContents) ]]];
    }
  }
});

Discourse.Dialect.replaceBlock({
  start: /(<pre[^\>]*\>)([\s\S]*)/igm,
  stop: /<\/pre>/igm,
  rawContents: true,
  skipIfTradtionalLinebreaks: true,

  emitter: function(blockContents) {
    return ['p', ['pre', codeFlattenBlocks(blockContents)]];
  }
});

// Ensure that content in a code block is fully escaped. This way it's not white listed
// and we can use HTML and Javascript examples.
Discourse.Dialect.on('parseNode', function (event) {
  var node = event.node,
      path = event.path;

  if (node[0] === 'code') {
    var contents = node[node.length-1],
        regexp;

    if (path && path[path.length-1] && path[path.length-1][0] && path[path.length-1][0] === "pre") {
      regexp = / +$/g;
    } else {
      regexp = /^ +| +$/g;
    }
    node[node.length-1] = Discourse.Utilities.escapeExpression(contents.replace(regexp,''));
  }
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  If a row begins with HTML tags, don't parse it.
**/

var blockTags = ['address', 'article', 'aside', 'audio', 'blockquote', 'canvas', 'dd', 'div',
                 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3',
                 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'noscript', 'ol', 'output',
                 'p', 'pre', 'section', 'table', 'tfoot', 'ul', 'video'],

    splitAtLast = function(tag, block, next, first) {
      var endTag = "</" + tag + ">",
          endTagIndex = first ? block.indexOf(endTag) : block.lastIndexOf(endTag);

      if (endTagIndex !== -1) {
        endTagIndex += endTag.length;

        var leading = block.substr(0, endTagIndex),
            trailing = block.substr(endTagIndex).replace(/^\s+/, '');

        if (trailing.length) {
          next.unshift(trailing);
        }

        return [ leading ];
      }
    };

Discourse.Dialect.registerBlock('html', function(block, next) {
  var split, pos;

  // Fix manual blockquote paragraphing even though it's not strictly correct
  // PERF NOTE: /\S+<blockquote/ is a perf hog for search, try on huge string
  if (pos = block.search(/<blockquote/) >= 0) {
    if(block.substring(0, pos).search(/\s/) === -1) {
      split = splitAtLast('blockquote', block, next, true);
      if (split) { return this.processInline(split[0]); }
    }
  }

  var m = /^<([^>]+)\>/.exec(block);
  if (m && m[1]) {
    var tag = m[1].split(/\s/);
    if (tag && tag[0] && blockTags.indexOf(tag[0]) !== -1) {
      split = splitAtLast(tag[0], block, next);
      if (split) {
        if (split.length === 1 && split[0] === block) { return; }
        return split;
      }
      return [ block.toString() ];
    }
  }
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Supports Discourse's custom @mention syntax for calling out a user in a post.
  It will add a special class to them, and create a link if the user is found in a
  local map.
**/

Discourse.Dialect.inlineRegexp({
  start: '@',
  // NOTE: we really should be using SiteSettings here, but it loads later in process
  // also, if we do, we must ensure serverside version works as well
  matcher: /^(@[A-Za-z0-9][A-Za-z0-9_\.\-]{0,40}[A-Za-z0-9\_])/,
  wordBoundary: true,

  emitter: function(matches) {
    var username = matches[1],
        mentionLookup = this.dialect.options.mentionLookup;

    var type = mentionLookup && mentionLookup(username.substr(1));
    if (type === "user") {
      return ['a', {'class': 'mention', href: Discourse.getURL("/users/") + username.substr(1).toLowerCase()}, username];
    } else if (type === "group") {
      return ['a', {'class': 'mention-group', href: Discourse.getURL("/groups/") + username.substr(1)}, username];
    } else {
      return ['span', {'class': 'mention'}, username];
    }
  }
});

// We have to prune @mentions that are within links.
Discourse.Dialect.on("parseNode", function(event) {
  var node = event.node,
      path = event.path;

  if (node[1] && node[1]["class"] === 'mention')  {
    var parent = path[path.length - 1];
    // If the parent is an 'a', remove it
    if (parent && parent[0] === 'a') {
      var username = node[2];
      node.length = 0;
      node[0] = "__RAW";
      node[1] = username;
    }
  }

});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.Dialect.on('parseNode', function (event) {
  var node = event.node,
      path = event.path;

  if (node[0] === 'a') {

    // It's invalid HTML to nest a link within another so strip it out.
    for (var i=0; i<path.length; i++) {
      if (path[i][0] === 'a') {
        var parent = path[path.length - 1],
            pos = parent.indexOf(node);

        // Just leave the link text
        if (pos !== -1) {
          parent[pos] = node[2];
        }
        return;
      }
    }
  }
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Support for the newline behavior in markdown that most expect. Look through all text nodes
  in the tree, replace any new lines with `br`s.
**/

Discourse.Dialect.postProcessText(function (text, event) {
  var opts = event.dialect.options,
      insideCounts = event.insideCounts,
      linebreaks = opts.traditional_markdown_linebreaks || Discourse.SiteSettings.traditional_markdown_linebreaks;

  if (linebreaks || (insideCounts.pre > 0)) { return; }

  if (text === "\n") {
    // If the tag is just a new line, replace it with a `<br>`
    return [['br']];
  } else {


    // If the text node contains new lines, perhaps with text between them, insert the
    // `<br>` tags.
    var split = text.split(/\n+/);
    if (split.length) {
      var replacement = [];
      for (var i=0; i<split.length; i++) {
        if (split[i].length > 0) { replacement.push(split[i]); }
        if (i !== split.length-1) { replacement.push(['br']); }
      }

      return replacement;
    }
  }

});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Given a node in the document and its parent, determine whether it is on its
  own line or not.

  @method isOnOneLine
  @namespace Discourse.Dialect
**/

var isOnOneLine = function(link, parent) {
  if (!parent) { return false; }

  var siblings = parent.slice(1);
  if ((!siblings) || (siblings.length < 1)) { return false; }

  var idx = siblings.indexOf(link);
  if (idx === -1) { return false; }

  if (idx > 0) {
    var prev = siblings[idx-1];
    if (prev[0] !== 'br') { return false; }
  }

  if (idx < siblings.length) {
    var next = siblings[idx+1];
    if (next && (!((next[0] === 'br') || (typeof next === 'string' && next.trim() === "")))) { return false; }
  }

  return true;
};

/**
  We only onebox stuff that is on its own line. This navigates the JsonML tree and
  correctly inserts the oneboxes.

  @event parseNode
  @namespace Discourse.Dialect
**/
Discourse.Dialect.on("parseNode", function(event) {
  var node = event.node,
      path = event.path;

  // We only care about links
  if (node[0] !== 'a')  { return; }

  var parent = path[path.length - 1];

  // We don't onebox bbcode
  if (node[1]['data-bbcode']) {
    delete node[1]['data-bbcode'];
    return;
  }

  // We don't onebox mentions
  if (node[1]['class'] === 'mention') { return; }

  // Don't onebox links within a list
  for (var i=0; i<path.length; i++) {
    if (path[i][0] === 'li') { return; }
  }

  // If the link has a different label text than the link itself, don't onebox it.
  var label = node[node.length-1];
  if (label !== node[1]['href']) { return; }

  if (isOnOneLine(node, parent)) {

    node[1]['class'] = 'onebox';
    node[1].target = '_blank';

    if (Discourse && Discourse.Onebox) {
      var contents = Discourse.Onebox.lookupCache(node[1].href);
      if (contents) {
        node[0] = '__RAW';
        node[1] = contents;
        node.length = 2;
      }
    }
  }
});



// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

var esc = Handlebars.Utils.escapeExpression;

Discourse.BBCode.register('quote', {noWrap: true, singlePara: true}, function(contents, bbParams, options) {
  var params = {'class': 'quote'},
      username = null;

  if (bbParams) {
    var paramsSplit = bbParams.split(/\,\s*/);
    username = paramsSplit[0];

    paramsSplit.forEach(function(p,i) {
      if (i > 0) {
        var assignment = p.split(':');
        if (assignment[0] && assignment[1]) {
          var escaped = esc(assignment[0]);
          // don't escape attributes, makes no sense
          if(escaped === assignment[0]) {
            params['data-' + assignment[0]] = esc(assignment[1].trim());
          }
        }
      }
    });
  }

  var avatarImg;
  var postNumber = parseInt(params['data-post'], 10);
  var topicId = parseInt(params['data-topic'], 10);

  if (options.lookupAvatarByPostNumber) {
    // client-side, we can retrieve the avatar from the post
    avatarImg = options.lookupAvatarByPostNumber(postNumber, topicId);
  } else if (options.lookupAvatar) {
    // server-side, we need to lookup the avatar from the username
    avatarImg = options.lookupAvatar(username);
  }

  // If there's no username just return a simple quote
  if (!username) {
    return ['p', ['aside', params, ['blockquote'].concat(contents)]];
  }

  var header = [ 'div', {'class': 'title'},
                 ['div', {'class': 'quote-controls'}],
                 avatarImg ? ['__RAW', avatarImg] : "",
                 username ? I18n.t('user.said', {username: username}) : ""
               ];

  if (options.topicId && postNumber && options.getTopicInfo && topicId !== options.topicId) {
    var topicInfo = options.getTopicInfo(topicId);
    if (topicInfo) {
      var href = topicInfo.href;
      if (postNumber > 0) { href += "/" + postNumber; }
      // get rid of username said stuff
      header.pop();
      header.push(['a', {'href': href}, topicInfo.title]);
    }
  }


  return ['aside', params, header, ['blockquote'].concat(contents)];
});


// IIFE Wrapped Content Ends

 })(this);(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

var tableFlattenBlocks = function(blocks) {
  var result = "";
  blocks.forEach(function(b) {
    result += b;
    if (b.trailing) { result += b.trailing; }
  });

  // bypass newline insertion
  return result.replace(/[\n\r]/g, " ");
};

var emitter = function(contents) {
  // TODO event should be fired when sanitizer loads
  if (window.html4 && window.html4.ELEMENTS.td !== 1) {
     window.html4.ELEMENTS.table = 0;
     window.html4.ELEMENTS.tbody = 1;
     window.html4.ELEMENTS.td = 1;
     window.html4.ELEMENTS.thead = 1;
     window.html4.ELEMENTS.th = 1;
     window.html4.ELEMENTS.tr = 1;
  }
  return ['table', {"class": "md-table"}, tableFlattenBlocks.apply(this, [contents])];
};

var tableBlock = {
  start: /(<table[^>]*>)([\S\s]*)/igm,
  stop: /<\/table>/igm,
  rawContents: true,
  emitter: emitter,
  priority: 1
};

var init = function(){
  if (Discourse.SiteSettings.allow_html_tables) {
    Discourse.Markdown.whiteListTag("table");
    Discourse.Markdown.whiteListTag("table", "class", "md-table");
    Discourse.Markdown.whiteListTag("tbody");
    Discourse.Markdown.whiteListTag("thead");
    Discourse.Markdown.whiteListTag("tr");
    Discourse.Markdown.whiteListTag("th");
    Discourse.Markdown.whiteListTag("td");
    Discourse.Dialect.replaceBlock(tableBlock);

  }
};

if (Discourse.SiteSettings) {
  init();
} else {
  Discourse.initializer({initialize: init, name: 'enable-html-tables'});
}


// IIFE Wrapped Content Ends

 })(this);define("discourse/controllers/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      faqOverriden: Ember.computed.gt('siteSettings.faq_url.length', 0),

      contactInfo: (function () {
        if (this.siteSettings.contact_url) {
          return I18n.t('about.contact_info', { contact_info: "<a href='" + this.siteSettings.contact_url + "' target='_blank'>" + this.siteSettings.contact_url + "</a>" });
        } else if (this.siteSettings.contact_email) {
          return I18n.t('about.contact_info', { contact_info: this.siteSettings.contact_email });
        } else {
          return null;
        }
      }).property()
    });
  });define("discourse/controllers/application", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'showTop',
      initializer: function () {
        return true;
      }
    }, {
      key: 'showFooter',
      initializer: function () {
        return false;
      }
    }, {
      key: 'styleCategory',
      initializer: function () {
        return null;
      }
    }, {
      key: 'canSignUp',
      decorators: [computed],
      value: function () {
        return !Discourse.SiteSettings.invite_only && Discourse.SiteSettings.allow_new_registrations && !Discourse.SiteSettings.enable_sso;
      }
    }, {
      key: 'loginRequired',
      decorators: [computed],
      value: function () {
        return Discourse.SiteSettings.login_required && !Discourse.User.current();
      }
    }]));
  });define("discourse/controllers/avatar-selector", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: "selectedUploadId",
      decorators: [computed("selected", "system_avatar_upload_id", "gravatar_avatar_upload_id", "custom_avatar_upload_id")],
      value: function (selected, system, gravatar, custom) {
        switch (selected) {
          case "system":
            return system;
          case "gravatar":
            return gravatar;
          default:
            return custom;
        }
      }
    }, {
      key: "selectedAvatarTemplate",
      decorators: [computed("selected", "system_avatar_template", "gravatar_avatar_template", "custom_avatar_template")],
      value: function (selected, system, gravatar, custom) {
        switch (selected) {
          case "system":
            return system;
          case "gravatar":
            return gravatar;
          default:
            return custom;
        }
      }
    }, {
      key: "allowAvatarUpload",
      decorators: [computed()],
      value: function () {
        return this.siteSettings.allow_uploaded_avatars && Discourse.Utilities.allowsImages();
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          useUploadedAvatar: function () {
            this.set("selected", "uploaded");
          },
          useGravatar: function () {
            this.set("selected", "gravatar");
          },
          useSystem: function () {
            this.set("selected", "system");
          },

          refreshGravatar: function () {
            var _this = this;

            this.set("gravatarRefreshDisabled", true);
            return Discourse.ajax("/user_avatar/" + this.get("username") + "/refresh_gravatar.json", { method: "POST" }).then(function (result) {
              return _this.setProperties({
                gravatar_avatar_template: result.gravatar_avatar_template,
                gravatar_avatar_upload_id: result.gravatar_upload_id
              });
            }).finally(function () {
              return _this.set("gravatarRefreshDisabled", false);
            });
          }
        };
      }
    }]));
  });define("discourse/controllers/badges/index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      badgeGroups: (function () {
        var sorted = _.sortBy(this.get('model'), function (badge) {
          var pos = badge.get('badge_grouping.position');
          var type = badge.get('badge_type_id');
          var name = badge.get('displayName');

          return ("000" + pos).slice(-4) + (10 - type) + name;
        });

        var grouped = [];
        var group = [],
            groupId;

        sorted.forEach(function (badge) {
          if (groupId !== badge.badge_grouping_id) {
            if (group && group.length > 0) {
              grouped.push({ badges: group, badgeGrouping: group[0].badge_grouping });
            }
            group = [];
            groupId = badge.badge_grouping_id;
          }
          group.push(badge);
        });

        if (group && group.length > 0) {
          grouped.push({ badges: group, badgeGrouping: group[0].badge_grouping });
        }

        return grouped;
      }).property('model')
    });
  });define("discourse/controllers/badges/show", 
  ["discourse/models/user-badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      noMoreBadges: false,
      userBadges: null,
      needs: ["application"],

      actions: {
        loadMore: function () {
          var self = this;
          var userBadges = this.get('userBadges');

          UserBadge.findByBadgeId(this.get('model.id'), {
            offset: userBadges.length
          }).then(function (result) {
            userBadges.pushObjects(result);
            if (userBadges.length === 0) {
              self.set('noMoreBadges', true);
            }
          });
        }
      },

      layoutClass: (function () {
        var ub = this.get("userBadges");
        if (ub && ub[0] && ub[0].post_id) {
          return "user-badge-with-posts";
        } else {
          return "user-badge-no-posts";
        }
      }).property("userBadges"),

      canLoadMore: (function () {
        if (this.get('noMoreBadges')) {
          return false;
        }

        if (this.get('userBadges')) {
          return this.get('model.grant_count') > this.get('userBadges.length');
        } else {
          return false;
        }
      }).property('noMoreBadges', 'model.grant_count', 'userBadges.length'),

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("canLoadMore"));
      }).observes("canLoadMore"),

      showLongDescription: (function () {
        return window.location.search.match("long-description");
      }).property('userBadges')

    });
  });define("discourse/controllers/bulk-notification-level", 
  ["discourse/lib/notification-levels","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationLevels = __dependency1__["default"];

    // Support for changing the notification level of various topics
    __exports__["default"] = Em.Controller.extend({
      needs: ['topic-bulk-actions'],
      notificationLevelId: null,

      notificationLevels: (function () {
        var result = [];
        Object.keys(NotificationLevels).forEach(function (k) {
          result.push({
            id: NotificationLevels[k].toString(),
            name: I18n.t('topic.notifications.' + k.toLowerCase() + ".title"),
            description: I18n.t('topic.notifications.' + k.toLowerCase() + ".description")
          });
        });
        return result;
      }).property(),

      disabled: Em.computed.empty("notificationLevelId"),

      actions: {
        changeNotificationLevel: function () {
          this.get('controllers.topic-bulk-actions').performAndRefresh({
            type: 'change_notification_level',
            notification_level_id: this.get('notificationLevelId')
          });
        }
      }
    });
  });define("discourse/controllers/change-owner", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var DiscourseURL = __dependency3__["default"];

    // Modal related to changing the ownership of posts
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      saving: false,
      new_user: null,

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('new_user'));
      }).property('saving', 'new_user'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.change_owner.action');
      }).property('saving'),

      onShow: function () {
        this.setProperties({
          saving: false,
          new_user: ''
        });
      },

      actions: {
        changeOwnershipOfPosts: function () {
          this.set('saving', true);

          var postIds = this.get('selectedPosts').map(function (p) {
            return p.get('id');
          }),
              self = this,
              saveOpts = {
            post_ids: postIds,
            username: this.get('new_user')
          };

          Discourse.Topic.changeOwners(this.get('topicController.model.id'), saveOpts).then(function () {
            // success
            self.send('closeModal');
            self.get('topicController').send('deselectAll');
            if (self.get('topicController.multiSelect')) {
              self.get('topicController').send('toggleMultiSelect');
            }
            Em.run.next(function () {
              DiscourseURL.routeTo(self.get("topicController.model.url"));
            });
          }, function () {
            // failure
            self.flash(I18n.t('topic.change_owner.error'), 'alert-error');
            self.set('saving', false);
          });
          return false;
        }
      }
    });
  });define("discourse/controllers/change-timestamp", 
  ["discourse/mixins/modal-functionality","ember-addons/ember-computed-decorators","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var computed = __dependency2__["default"];
    var DiscourseURL = __dependency3__["default"];

    // Modal related to changing the timestamp of posts
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic'];
      }
    }, {
      key: 'topicController',
      initializer: function () {
        return Em.computed.alias('controllers.topic');
      }
    }, {
      key: 'saving',
      initializer: function () {
        return false;
      }
    }, {
      key: 'date',
      initializer: function () {
        return '';
      }
    }, {
      key: 'time',
      initializer: function () {
        return '';
      }
    }, {
      key: 'buttonTitle',
      decorators: [computed('saving')],
      value: function (saving) {
        return saving ? I18n.t('saving') : I18n.t('topic.change_timestamp.action');
      }
    }, {
      key: 'createdAt',
      decorators: [computed('date', 'time')],
      value: function (date, time) {
        return moment(date + ' ' + time, 'YYYY-MM-DD HH:mm:ss');
      }
    }, {
      key: 'validTimestamp',
      decorators: [computed('createdAt')],
      value: function (createdAt) {
        return moment().diff(createdAt, 'minutes') < 0;
      }
    }, {
      key: 'buttonDisabled',
      decorators: [computed('saving', 'date', 'validTimestamp')],
      value: function () {
        if (this.get('saving') || this.get('validTimestamp')) return true;
        return Ember.isEmpty(this.get('date'));
      }
    }, {
      key: 'onShow',
      initializer: function () {
        return function () {
          this.setProperties({
            date: moment().format('YYYY-MM-DD')
          });
        };
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          changeTimestamp: function () {
            this.set('saving', true);
            var self = this,
                topic = this.get('topicController.model');

            Discourse.Topic.changeTimestamp(topic.get('id'), this.get('createdAt').unix()).then(function () {
              self.send('closeModal');
              self.setProperties({ date: '', time: '', saving: false });
              Em.run.next(function () {
                DiscourseURL.routeTo(topic.get('url'));
              });
            }).catch(function () {
              self.flash(I18n.t('topic.change_timestamp.error'), 'alert-error');
              self.set('saving', false);
            });
            return false;
          }
        };
      }
    }]));
  });define("discourse/controllers/composer-messages", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // A controller for displaying messages as the user composes a message.
    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['composer'],

      // Whether we've checked our messages
      checkedMessages: false,

      _init: (function () {
        this.reset();
      }).on("init"),

      actions: {
        closeMessage: function (message) {
          this.removeObject(message);
        },

        hideMessage: function (message) {
          this.removeObject(message);
          // kind of hacky but the visibility depends on this
          this.get('messagesByTemplate')[message.get('templateName')] = undefined;
        },

        popup: function (message) {
          var messagesByTemplate = this.get('messagesByTemplate');
          var templateName = message.get('templateName');

          if (!messagesByTemplate[templateName]) {
            this.pushObject(message);
            messagesByTemplate[templateName] = message;
          }
        }
      },

      // Resets all active messages.
      // For example if composing a new post.
      reset: function () {
        this.clear();
        this.setProperties({
          messagesByTemplate: {},
          queuedForTyping: [],
          checkedMessages: false
        });
      },

      // Called after the user has typed a reply.
      // Some messages only get shown after being typed.
      typedReply: function () {
        var _this = this;

        this.get('queuedForTyping').forEach(function (msg) {
          return _this.send("popup", msg);
        });
      },

      groupsMentioned: function (groups) {
        var _this2 = this;

        // reset existing messages, this should always win it is critical
        this.reset();
        groups.forEach(function (group) {
          var msg = I18n.t('composer.group_mentioned', {
            group: "@" + group.name,
            count: group.user_count,
            group_link: Discourse.getURL('/group/' + group.name + '/members')
          });
          _this2.send("popup", Em.Object.create({
            templateName: 'composer/group-mentioned',
            body: msg }));
        });
      },

      // Figure out if there are any messages that should be displayed above the composer.
      queryFor: function (composer) {
        if (this.get('checkedMessages')) {
          return;
        }

        var self = this;
        var queuedForTyping = self.get('queuedForTyping');

        Discourse.ComposerMessage.find(composer).then(function (messages) {
          self.set('checkedMessages', true);
          messages.forEach(function (msg) {
            return msg.wait_for_typing ? queuedForTyping.addObject(msg) : self.send("popup", msg);
          });
        });
      }

    });
  });define("discourse/controllers/composer", 
  ["discourse/lib/url","discourse/lib/quote","discourse/models/draft","discourse/models/composer","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var DiscourseURL = __dependency1__["default"];
    var Quote = __dependency2__["default"];
    var Draft = __dependency3__["default"];
    var Composer = __dependency4__["default"];
    var computed = __dependency5__.default;
    var observes = __dependency5__.observes;

    function loadDraft(store, opts) {
      opts = opts || {};

      var draft = opts.draft;
      var draftKey = opts.draftKey;
      var draftSequence = opts.draftSequence;

      try {
        if (draft && typeof draft === 'string') {
          draft = JSON.parse(draft);
        }
      } catch (error) {
        draft = null;
        Draft.clear(draftKey, draftSequence);
      }
      if (draft && (draft.title && draft.title !== '' || draft.reply && draft.reply !== '')) {
        var composer = store.createRecord('composer');
        composer.open({
          draftKey: draftKey,
          draftSequence: draftSequence,
          action: draft.action,
          title: draft.title,
          categoryId: draft.categoryId || opts.categoryId,
          postId: draft.postId,
          archetypeId: draft.archetypeId,
          reply: draft.reply,
          metaData: draft.metaData,
          usernames: draft.usernames,
          draft: true,
          composerState: Composer.DRAFT,
          composerTime: draft.composerTime,
          typingTime: draft.typingTime
        });
        return composer;
      }
    }

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['modal', 'topic', 'composer-messages', 'application'];
      }
    }, {
      key: 'replyAsNewTopicDraft',
      initializer: function () {
        return Em.computed.equal('model.draftKey', Composer.REPLY_AS_NEW_TOPIC_KEY);
      }
    }, {
      key: 'checkedMessages',
      initializer: function () {
        return false;
      }
    }, {
      key: 'showEditReason',
      initializer: function () {
        return false;
      }
    }, {
      key: 'editReason',
      initializer: function () {
        return null;
      }
    }, {
      key: 'scopedCategoryId',
      initializer: function () {
        return null;
      }
    }, {
      key: 'similarTopics',
      initializer: function () {
        return null;
      }
    }, {
      key: 'similarTopicsMessage',
      initializer: function () {
        return null;
      }
    }, {
      key: 'lastSimilaritySearch',
      initializer: function () {
        return null;
      }
    }, {
      key: 'optionsVisible',
      initializer: function () {
        return false;
      }
    }, {
      key: 'lastValidatedAt',
      initializer: function () {
        return null;
      }
    }, {
      key: 'isUploading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'topic',
      initializer: function () {
        return null;
      }
    }, {
      key: '_initializeSimilar',
      initializer: function () {
        return (function () {
          this.set('similarTopics', []);
        }).on('init');
      }
    }, {
      key: 'canWhisper',
      decorators: [computed('model.action')],
      value: function (action) {
        var currentUser = this.currentUser;
        return currentUser && currentUser.get('staff') && this.siteSettings.enable_whispers && action === Composer.REPLY;
      }
    }, {
      key: 'showWarning',
      initializer: function () {
        return (function () {
          if (!Discourse.User.currentProp('staff')) {
            return false;
          }

          var usernames = this.get('model.targetUsernames');
          var hasTargetGroups = this.get('model.hasTargetGroups');

          // We need exactly one user to issue a warning
          if (Ember.isEmpty(usernames) || usernames.split(',').length !== 1 || hasTargetGroups) {
            return false;
          }
          return this.get('model.creatingPrivateMessage');
        }).property('model.creatingPrivateMessage', 'model.targetUsernames');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          toggleWhisper: function () {
            this.toggleProperty('model.whisper');
          },

          showOptions: function (loc) {
            this.appEvents.trigger('popup-menu:open', loc);
            this.set('optionsVisible', true);
          },

          hideOptions: function () {
            this.set('optionsVisible', false);
          },

          // Toggle the reply view
          toggle: function () {
            this.toggle();
          },

          togglePreview: function () {
            this.get('model').togglePreview();
          },

          // Import a quote from the post
          importQuote: function (toolbarEvent) {
            var _this = this;

            var postStream = this.get('topic.postStream');
            var postId = this.get('model.post.id');

            // If there is no current post, use the first post id from the stream
            if (!postId && postStream) {
              postId = postStream.get('stream.firstObject');
            }

            // If we're editing a post, fetch the reply when importing a quote
            if (this.get('model.editingPost')) {
              var replyToPostNumber = this.get('model.post.reply_to_post_number');
              if (replyToPostNumber) {
                var replyPost = postStream.get('posts').findBy('post_number', replyToPostNumber);
                if (replyPost) {
                  postId = replyPost.get('id');
                }
              }
            }

            if (postId) {
              var _ret = (function () {
                _this.set('model.loading', true);
                var composer = _this;

                return {
                  v: _this.store.find('post', postId).then(function (post) {
                    var quote = Quote.build(post, post.get("raw"), { raw: true, full: true });
                    toolbarEvent.addText(quote);
                    composer.set('model.loading', false);
                  })
                };
              })();

              if (typeof _ret === 'object') return _ret.v;
            }
          },

          cancel: function () {
            this.cancelComposer();
          },

          save: function () {
            this.save();
          },

          displayEditReason: function () {
            this.set("showEditReason", true);
          },

          hitEsc: function () {
            var messages = this.get('controllers.composer-messages.model');
            if (messages.length) {
              messages.popObject();
              return;
            }

            if (this.get('model.viewOpen')) {
              this.shrink();
            }
          },

          openIfDraft: function () {
            if (this.get('model.viewDraft')) {
              this.set('model.composeState', Composer.OPEN);
            }
          },

          groupsMentioned: function (groups) {
            if (!this.get('model.creatingPrivateMessage') && !this.get('model.topic.isPrivateMessage')) {
              this.get('controllers.composer-messages').groupsMentioned(groups);
            }
          }

        };
      }
    }, {
      key: 'categories',
      initializer: function () {
        return (function () {
          return Discourse.Category.list();
        }).property();
      }
    }, {
      key: 'toggle',
      value: function () {
        this.closeAutocomplete();
        switch (this.get('model.composeState')) {
          case Composer.OPEN:
            if (Ember.isEmpty(this.get('model.reply')) && Ember.isEmpty(this.get('model.title'))) {
              this.close();
            } else {
              this.shrink();
            }
            break;
          case Composer.DRAFT:
            this.set('model.composeState', Composer.OPEN);
            break;
          case Composer.SAVING:
            this.close();
        }
        return false;
      }
    }, {
      key: 'disableSubmit',
      initializer: function () {
        return Ember.computed.or("model.loading", "isUploading");
      }
    }, {
      key: 'save',
      value: function (force) {
        var _this2 = this;

        var composer = this.get('model');
        var self = this;

        // Clear the warning state if we're not showing the checkbox anymore
        if (!this.get('showWarning')) {
          this.set('model.isWarning', false);
        }

        if (composer.get('cantSubmitPost')) {
          this.set('lastValidatedAt', Date.now());
          return;
        }

        composer.set('disableDrafts', true);

        // for now handle a very narrow use case
        // if we are replying to a topic AND not on the topic pop the window up
        if (!force && composer.get('replyingToTopic')) {
          var _ret2 = (function () {

            var currentTopic = _this2.get('controllers.topic.model');
            if (!currentTopic || currentTopic.get('id') !== composer.get('topic.id')) {
              var message = I18n.t("composer.posting_not_on_topic");

              var buttons = [{
                "label": I18n.t("composer.cancel"),
                "class": "cancel",
                "link": true
              }];

              if (currentTopic) {
                buttons.push({
                  "label": I18n.t("composer.reply_here") + "<br/><div class='topic-title overflow-ellipsis'>" + Discourse.Utilities.escapeExpression(currentTopic.get('title')) + "</div>",
                  "class": "btn btn-reply-here",
                  "callback": function () {
                    composer.set('topic', currentTopic);
                    composer.set('post', null);
                    self.save(true);
                  }
                });
              }

              buttons.push({
                "label": I18n.t("composer.reply_original") + "<br/><div class='topic-title overflow-ellipsis'>" + Discourse.Utilities.escapeExpression(_this2.get('model.topic.title')) + "</div>",
                "class": "btn-primary btn-reply-on-original",
                "callback": function () {
                  self.save(true);
                }
              });

              bootbox.dialog(message, buttons, { "classes": "reply-where-modal" });
              return {
                v: undefined
              };
            }
          })();

          if (typeof _ret2 === 'object') return _ret2.v;
        }

        var staged = false;
        var disableJumpReply = Discourse.User.currentProp('disable_jump_reply');

        // TODO: This should not happen in model
        var imageSizes = {};
        $('#reply-control .d-editor-preview img').each(function (i, e) {
          var $img = $(e);
          var src = $img.prop('src');

          if (src && src.length) {
            imageSizes[src] = { width: $img.width(), height: $img.height() };
          }
        });

        var promise = composer.save({ imageSizes: imageSizes, editReason: this.get("editReason") }).then(function (result) {
          if (result.responseJson.action === "enqueued") {
            self.send('postWasEnqueued', result.responseJson);
            self.destroyDraft();
            self.close();
            return result;
          }

          // If user "created a new topic/post" or "replied as a new topic" successfully, remove the draft.
          if (result.responseJson.action === "create_post" || self.get('replyAsNewTopicDraft')) {
            self.destroyDraft();
          }

          self.close();

          var currentUser = Discourse.User.current();
          if (composer.get('creatingTopic')) {
            currentUser.set('topic_count', currentUser.get('topic_count') + 1);
          } else {
            currentUser.set('reply_count', currentUser.get('reply_count') + 1);
          }

          // TODO disableJumpReply is super crude, it needs to provide some sort
          // of notification to the end user
          if (!composer.get('replyingToTopic') || !disableJumpReply) {
            var post = result.target;
            if (post && !staged) {
              DiscourseURL.routeTo(post.get('url'));
            }
          }
        }).catch(function (error) {
          composer.set('disableDrafts', false);
          self.appEvents.one('composer:opened', function () {
            return bootbox.alert(error);
          });
        });

        if (this.get('controllers.application.currentRouteName').split('.')[0] === 'topic' && composer.get('topic.id') === this.get('controllers.topic.model.id')) {
          staged = composer.get('stagedPost');
        }

        Em.run.schedule('afterRender', function () {
          if (staged && !disableJumpReply) {
            var postNumber = staged.get('post_number');
            DiscourseURL.jumpToPost(postNumber, { skipIfOnScreen: true });
            self.appEvents.trigger('post:highlight', postNumber);
          }
        });

        this.messageBus.pause();
        promise.finally(function () {
          self.messageBus.resume();
        });

        return promise;
      }
    }, {
      key: 'checkReplyLength',

      // Checks to see if a reply has been typed.
      // This is signaled by a keyUp event in a view.
      value: function () {
        if (!Ember.isEmpty('model.reply')) {
          // Notify the composer messages controller that a reply has been typed. Some
          // messages only appear after typing.
          this.get('controllers.composer-messages').typedReply();
        }
      }
    }, {
      key: 'findSimilarTopics',

      // Fired after a user stops typing.
      // Considers whether to check for similar topics based on the current composer state.
      value: function () {
        // We don't care about similar topics unless creating a topic
        if (!this.get('model.creatingTopic')) {
          return;
        }

        var body = this.get('model.reply') || '';
        var title = this.get('model.title') || '';

        // Ensure the fields are of the minimum length
        if (body.length < Discourse.SiteSettings.min_body_similar_length) {
          return;
        }
        if (title.length < Discourse.SiteSettings.min_title_similar_length) {
          return;
        }

        // TODO pass the 200 in from somewhere
        body = body.substr(0, 200);

        // Done search over and over
        if (title + body === this.get('lastSimilaritySearch')) {
          return;
        }
        this.set('lastSimilaritySearch', title + body);

        var messageController = this.get('controllers.composer-messages'),
            similarTopics = this.get('similarTopics');

        var message = this.get('similarTopicsMessage');
        if (!message) {
          message = Discourse.ComposerMessage.create({
            templateName: 'composer/similar_topics',
            extraClass: 'similar-topics'
          });
          this.set('similarTopicsMessage', message);
        }

        this.store.find('similar-topic', { title: title, raw: body }).then(function (newTopics) {
          similarTopics.clear();
          similarTopics.pushObjects(newTopics.get('content'));

          if (similarTopics.get('length') > 0) {
            message.set('similarTopics', similarTopics);
            messageController.send("popup", message);
          } else if (message) {
            messageController.send("hideMessage", message);
          }
        });
      }
    }, {
      key: 'open',

      /**
        Open the composer view
         @method open
        @param {Object} opts Options for creating a post
          @param {String} opts.action The action we're performing: edit, reply or createTopic
          @param {Discourse.Post} [opts.post] The post we're replying to
          @param {Discourse.Topic} [opts.topic] The topic we're replying to
          @param {String} [opts.quote] If we're opening a reply from a quote, the quote we're making
      **/
      value: function (opts) {
        opts = opts || {};

        if (!opts.draftKey) {
          alert("composer was opened without a draft key");
          throw "composer opened without a proper draft key";
        }

        // If we show the subcategory list, scope the categories drop down to
        // the category we opened the composer with.
        if (this.siteSettings.show_subcategory_list && opts.draftKey !== 'reply_as_new_topic') {
          this.set('scopedCategoryId', opts.categoryId);
        }

        var composerMessages = this.get('controllers.composer-messages'),
            self = this;

        var composerModel = this.get('model');

        this.setProperties({ showEditReason: false, editReason: null });
        composerMessages.reset();

        // If we want a different draft than the current composer, close it and clear our model.
        if (composerModel && opts.draftKey !== composerModel.draftKey && composerModel.composeState === Composer.DRAFT) {
          this.close();
          composerModel = null;
        }

        return new Ember.RSVP.Promise(function (resolve, reject) {
          if (composerModel && composerModel.get('replyDirty')) {

            // If we're already open, we don't have to do anything
            if (composerModel.get('composeState') === Composer.OPEN && composerModel.get('draftKey') === opts.draftKey && !opts.action) {
              return resolve();
            }

            // If it's the same draft, just open it up again.
            if (composerModel.get('composeState') === Composer.DRAFT && composerModel.get('draftKey') === opts.draftKey) {
              composerModel.set('composeState', Composer.OPEN);
              if (!opts.action) return resolve();
            }

            // If it's a different draft, cancel it and try opening again.
            return self.cancelComposer().then(function () {
              return self.open(opts);
            }).then(resolve, reject);
          }

          // we need a draft sequence for the composer to work
          if (opts.draftSequence === undefined) {
            return Draft.get(opts.draftKey).then(function (data) {
              opts.draftSequence = data.draft_sequence;
              opts.draft = data.draft;
              self._setModel(composerModel, opts);
            }).then(resolve, reject);
          }

          self._setModel(composerModel, opts);
          resolve();
        });
      }
    }, {
      key: '_setModel',

      // Given a potential instance and options, set the model for this composer.
      value: function (composerModel, opts) {
        var _this3 = this;

        if (opts.draft) {
          composerModel = loadDraft(this.store, opts);
          if (composerModel) {
            composerModel.set('topic', opts.topic);
          }
        } else {
          composerModel = composerModel || this.store.createRecord('composer');
          composerModel.open(opts);
        }

        this.set('model', composerModel);
        composerModel.set('composeState', Composer.OPEN);
        composerModel.set('isWarning', false);

        if (opts.topicTitle && opts.topicTitle.length <= this.siteSettings.max_topic_title_length) {
          this.set('model.title', opts.topicTitle);
        }

        if (opts.topicCategoryId) {
          this.set('model.categoryId', opts.topicCategoryId);
        } else if (opts.topicCategory) {
          (function () {
            var splitCategory = opts.topicCategory.split("/");
            var category = undefined;

            if (!splitCategory[1]) {
              category = _this3.site.get('categories').findProperty('nameLower', splitCategory[0].toLowerCase());
            } else {
              (function () {
                var categories = Discourse.Category.list();
                var mainCategory = categories.findProperty('nameLower', splitCategory[0].toLowerCase());
                category = categories.find(function (item) {
                  return item && item.get('nameLower') === splitCategory[1].toLowerCase() && item.get('parent_category_id') === mainCategory.id;
                });
              })();
            }

            if (category) {
              _this3.set('model.categoryId', category.get('id'));
            }
          })();
        }

        if (opts.topicBody) {
          this.set('model.reply', opts.topicBody);
        }

        this.get('controllers.composer-messages').queryFor(composerModel);
      }
    }, {
      key: 'viewNewReply',

      // View a new reply we've made
      value: function () {
        DiscourseURL.routeTo(this.get('model.createdPost.url'));
        this.close();
        return false;
      }
    }, {
      key: 'destroyDraft',
      value: function () {
        var key = this.get('model.draftKey');
        if (key) {
          Draft.clear(key, this.get('model.draftSequence'));
        }
      }
    }, {
      key: 'cancelComposer',
      value: function () {
        var self = this;

        return new Ember.RSVP.Promise(function (resolve) {
          if (self.get('model.hasMetaData') || self.get('model.replyDirty')) {
            bootbox.confirm(I18n.t("post.abandon.confirm"), I18n.t("post.abandon.no_value"), I18n.t("post.abandon.yes_value"), function (result) {
              if (result) {
                self.destroyDraft();
                self.get('model').clearState();
                self.close();
                resolve();
              }
            });
          } else {
            // it is possible there is some sort of crazy draft with no body ... just give up on it
            self.destroyDraft();
            self.get('model').clearState();
            self.close();
            resolve();
          }
        });
      }
    }, {
      key: 'shrink',
      value: function () {
        if (this.get('model.replyDirty')) {
          this.collapse();
        } else {
          this.close();
        }
      }
    }, {
      key: '_saveDraft',
      value: function () {
        var model = this.get('model');
        if (model) {
          model.saveDraft();
        };
      }
    }, {
      key: '_shouldSaveDraft',
      decorators: [observes('model.reply', 'model.title')],
      value: function () {
        Ember.run.debounce(this, this._saveDraft, 2000);
      }
    }, {
      key: 'categoryValidation',
      decorators: [computed('model.categoryId', 'lastValidatedAt')],
      value: function (categoryId, lastValidatedAt) {
        if (!this.siteSettings.allow_uncategorized_topics && !categoryId) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t('composer.error.category_missing'), lastShownAt: lastValidatedAt });
        }
      }
    }, {
      key: 'collapse',
      value: function () {
        this._saveDraft();
        this.set('model.composeState', Composer.DRAFT);
      }
    }, {
      key: 'close',
      value: function () {
        this.setProperties({ model: null, lastValidatedAt: null });
      }
    }, {
      key: 'closeAutocomplete',
      value: function () {
        $('.d-editor-input').autocomplete({ cancel: true });
      }
    }, {
      key: 'showOptions',
      value: function () {
        var _ref;
        return (_ref = this.get('controllers.modal')) ? _ref.show(Discourse.ArchetypeOptionsModalView.create({
          archetype: this.get('model.archetype'),
          metaData: this.get('model.metaData')
        })) : void 0;
      }
    }, {
      key: 'canEdit',
      initializer: function () {
        return (function () {
          return this.get("model.action") === "edit" && Discourse.User.current().get("can_edit");
        }).property("model.action");
      }
    }, {
      key: 'visible',
      initializer: function () {
        return (function () {
          var state = this.get('model.composeState');
          return state && state !== 'closed';
        }).property('model.composeState');
      }
    }]));
  });define("discourse/controllers/create-account", 
  ["discourse/lib/debounce","discourse/mixins/modal-functionality","discourse/lib/computed","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var debounce = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var setting = __dependency3__.setting;
    var on = __dependency4__.on;

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['login'];
      }
    }, {
      key: 'uniqueUsernameValidation',
      initializer: function () {
        return null;
      }
    }, {
      key: 'globalNicknameExists',
      initializer: function () {
        return false;
      }
    }, {
      key: 'complete',
      initializer: function () {
        return false;
      }
    }, {
      key: 'accountPasswordConfirm',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'accountChallenge',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'formSubmitted',
      initializer: function () {
        return false;
      }
    }, {
      key: 'rejectedEmails',
      initializer: function () {
        return Em.A([]);
      }
    }, {
      key: 'rejectedPasswords',
      initializer: function () {
        return Em.A([]);
      }
    }, {
      key: 'prefilledUsername',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFields',
      initializer: function () {
        return null;
      }
    }, {
      key: 'hasAuthOptions',
      initializer: function () {
        return Em.computed.notEmpty('authOptions');
      }
    }, {
      key: 'canCreateLocal',
      initializer: function () {
        return setting('enable_local_logins');
      }
    }, {
      key: 'showCreateForm',
      initializer: function () {
        return Em.computed.or('hasAuthOptions', 'canCreateLocal');
      }
    }, {
      key: 'maxUsernameLength',
      initializer: function () {
        return setting('max_username_length');
      }
    }, {
      key: 'minUsernameLength',
      initializer: function () {
        return setting('min_username_length');
      }
    }, {
      key: 'resetForm',
      value: function () {
        // We wrap the fields in a structure so we can assign a value
        this.setProperties({
          accountName: '',
          accountEmail: '',
          accountUsername: '',
          accountPassword: '',
          authOptions: null,
          globalNicknameExists: false,
          complete: false,
          formSubmitted: false,
          rejectedEmails: [],
          rejectedPasswords: [],
          prefilledUsername: null
        });
        this._createUserFields();
      }
    }, {
      key: 'submitDisabled',
      initializer: function () {
        return (function () {
          if (!this.get('emailValidation.failed') && !this.get('passwordRequired')) return false; // 3rd party auth
          if (this.get('formSubmitted')) return true;
          if (this.get('nameValidation.failed')) return true;
          if (this.get('emailValidation.failed')) return true;
          if (this.get('usernameValidation.failed')) return true;
          if (this.get('passwordValidation.failed')) return true;

          // Validate required fields
          var userFields = this.get('userFields');
          if (userFields) {
            userFields = userFields.filterProperty('field.required');
          }
          if (!Ember.isEmpty(userFields)) {
            var anyEmpty = userFields.any(function (uf) {
              var val = uf.get('value');
              return !val || Ember.isEmpty(val);
            });
            if (anyEmpty) {
              return true;
            }
          }
          return false;
        }).property('passwordRequired', 'nameValidation.failed', 'emailValidation.failed', 'usernameValidation.failed', 'passwordValidation.failed', 'formSubmitted', 'userFields.@each.value');
      }
    }, {
      key: 'usernameRequired',
      initializer: function () {
        return Ember.computed.not('authOptions.omit_username');
      }
    }, {
      key: 'passwordRequired',
      initializer: function () {
        return (function () {
          return Ember.isEmpty(this.get('authOptions.auth_provider'));
        }).property('authOptions.auth_provider');
      }
    }, {
      key: 'passwordInstructions',
      initializer: function () {
        return (function () {
          return I18n.t('user.password.instructions', { count: Discourse.SiteSettings.min_password_length });
        }).property();
      }
    }, {
      key: 'nameInstructions',
      initializer: function () {
        return (function () {
          return I18n.t(Discourse.SiteSettings.full_name_required ? 'user.name.instructions_required' : 'user.name.instructions');
        }).property();
      }
    }, {
      key: 'nameValidation',

      // Validate the name.
      initializer: function () {
        return (function () {
          if (Discourse.SiteSettings.full_name_required && Ember.isEmpty(this.get('accountName'))) {
            return Discourse.InputValidation.create({ failed: true });
          }

          return Discourse.InputValidation.create({ ok: true });
        }).property('accountName');
      }
    }, {
      key: 'emailValidation',

      // Check the email address
      initializer: function () {
        return (function () {
          // If blank, fail without a reason
          var email = undefined;
          if (Ember.isEmpty(this.get('accountEmail'))) {
            return Discourse.InputValidation.create({
              failed: true
            });
          }

          email = this.get("accountEmail");

          if (this.get('rejectedEmails').contains(email)) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.email.invalid')
            });
          }

          if (this.get('authOptions.email') === email && this.get('authOptions.email_valid')) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.email.authenticated', {
                provider: this.get('authOptions.auth_provider')
              })
            });
          }

          if (Discourse.Utilities.emailValid(email)) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.email.ok')
            });
          }

          return Discourse.InputValidation.create({
            failed: true,
            reason: I18n.t('user.email.invalid')
          });
        }).property('accountEmail', 'rejectedEmails.@each');
      }
    }, {
      key: 'emailValidated',
      initializer: function () {
        return (function () {
          return this.get('authOptions.email') === this.get("accountEmail") && this.get('authOptions.email_valid');
        }).property('accountEmail', 'authOptions.email', 'authOptions.email_valid');
      }
    }, {
      key: 'prefillUsername',
      initializer: function () {
        return (function () {
          if (this.get('prefilledUsername')) {
            // If username field has been filled automatically, and email field just changed,
            // then remove the username.
            if (this.get('accountUsername') === this.get('prefilledUsername')) {
              this.set('accountUsername', '');
            }
            this.set('prefilledUsername', null);
          }
          if (this.get('emailValidation.ok') && (Ember.isEmpty(this.get('accountUsername')) || this.get('authOptions.email'))) {
            // If email is valid and username has not been entered yet,
            // or email and username were filled automatically by 3rd parth auth,
            // then look for a registered username that matches the email.
            this.fetchExistingUsername();
          }
        }).observes('emailValidation', 'accountEmail');
      }
    }, {
      key: 'fetchExistingUsername',
      initializer: function () {
        return debounce(function () {
          var self = this;
          Discourse.User.checkUsername(null, this.get('accountEmail')).then(function (result) {
            if (result.suggestion && (Ember.isEmpty(self.get('accountUsername')) || self.get('accountUsername') === self.get('authOptions.username'))) {
              self.set('accountUsername', result.suggestion);
              self.set('prefilledUsername', result.suggestion);
            }
          });
        }, 500);
      }
    }, {
      key: 'usernameMatch',
      initializer: function () {
        return (function () {
          if (this.usernameNeedsToBeValidatedWithEmail()) {
            if (this.get('emailValidation.failed')) {
              if (this.shouldCheckUsernameMatch()) {
                return this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                  failed: true,
                  reason: I18n.t('user.username.enter_email')
                }));
              } else {
                return this.set('uniqueUsernameValidation', Discourse.InputValidation.create({ failed: true }));
              }
            } else if (this.shouldCheckUsernameMatch()) {
              this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                failed: true,
                reason: I18n.t('user.username.checking')
              }));
              return this.checkUsernameAvailability();
            }
          }
        }).observes('accountEmail');
      }
    }, {
      key: 'basicUsernameValidation',
      initializer: function () {
        return (function () {
          this.set('uniqueUsernameValidation', null);

          if (this.get('accountUsername') === this.get('prefilledUsername')) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.username.prefilled')
            });
          }

          // If blank, fail without a reason
          if (Ember.isEmpty(this.get('accountUsername'))) {
            return Discourse.InputValidation.create({
              failed: true
            });
          }

          // If too short
          if (this.get('accountUsername').length < Discourse.SiteSettings.min_username_length) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.username.too_short')
            });
          }

          // If too long
          if (this.get('accountUsername').length > this.get('maxUsernameLength')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.username.too_long')
            });
          }

          this.checkUsernameAvailability();
          // Let's check it out asynchronously
          return Discourse.InputValidation.create({
            failed: true,
            reason: I18n.t('user.username.checking')
          });
        }).property('accountUsername');
      }
    }, {
      key: 'shouldCheckUsernameMatch',
      initializer: function () {
        return function () {
          return !Ember.isEmpty(this.get('accountUsername')) && this.get('accountUsername').length >= this.get('minUsernameLength');
        };
      }
    }, {
      key: 'checkUsernameAvailability',
      initializer: function () {
        return debounce(function () {
          var _this = this;
          if (this.shouldCheckUsernameMatch()) {
            return Discourse.User.checkUsername(this.get('accountUsername'), this.get('accountEmail')).then(function (result) {
              _this.set('globalNicknameExists', false);
              if (result.available) {
                if (result.global_match) {
                  _this.set('globalNicknameExists', true);
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    ok: true,
                    reason: I18n.t('user.username.global_match')
                  }));
                } else {
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    ok: true,
                    reason: I18n.t('user.username.available')
                  }));
                }
              } else {
                if (result.suggestion) {
                  if (result.global_match !== void 0 && result.global_match === false) {
                    _this.set('globalNicknameExists', true);
                    return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                      failed: true,
                      reason: I18n.t('user.username.global_mismatch', result)
                    }));
                  } else {
                    return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                      failed: true,
                      reason: I18n.t('user.username.not_available', result)
                    }));
                  }
                } else if (result.errors) {
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    failed: true,
                    reason: result.errors.join(' ')
                  }));
                } else {
                  _this.set('globalNicknameExists', true);
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    failed: true,
                    reason: I18n.t('user.username.enter_email')
                  }));
                }
              }
            });
          }
        }, 500);
      }
    }, {
      key: 'usernameValidation',

      // Actually wait for the async name check before we're 100% sure we're good to go
      initializer: function () {
        return (function () {
          var basicValidation = this.get('basicUsernameValidation');
          var uniqueUsername = this.get('uniqueUsernameValidation');
          return uniqueUsername ? uniqueUsername : basicValidation;
        }).property('uniqueUsernameValidation', 'basicUsernameValidation');
      }
    }, {
      key: 'usernameNeedsToBeValidatedWithEmail',
      value: function () {
        return this.get('globalNicknameExists') || false;
      }
    }, {
      key: 'passwordValidation',

      // Validate the password
      initializer: function () {
        return (function () {
          if (!this.get('passwordRequired')) {
            return Discourse.InputValidation.create({ ok: true });
          }

          // If blank, fail without a reason
          var password = this.get("accountPassword");
          if (Ember.isEmpty(this.get('accountPassword'))) {
            return Discourse.InputValidation.create({ failed: true });
          }

          // If too short
          if (password.length < Discourse.SiteSettings.min_password_length) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.too_short')
            });
          }

          if (this.get('rejectedPasswords').contains(password)) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.common')
            });
          }

          if (!Ember.isEmpty(this.get('accountUsername')) && this.get('accountPassword') === this.get('accountUsername')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.same_as_username')
            });
          }

          if (!Ember.isEmpty(this.get('accountEmail')) && this.get('accountPassword') === this.get('accountEmail')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.same_as_email')
            });
          }

          // Looks good!
          return Discourse.InputValidation.create({
            ok: true,
            reason: I18n.t('user.password.ok')
          });
        }).property('accountPassword', 'rejectedPasswords.@each', 'accountUsername', 'accountEmail');
      }
    }, {
      key: 'fetchConfirmationValue',
      decorators: [on('init')],
      value: function () {
        var _this2 = this;

        return Discourse.ajax('/users/hp.json').then(function (json) {
          _this2.set('accountPasswordConfirm', json.value);
          _this2.set('accountChallenge', json.challenge.split("").reverse().join(""));
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          externalLogin: function (provider) {
            this.get('controllers.login').send('externalLogin', provider);
          },

          createAccount: function () {
            var self = this,
                attrs = this.getProperties('accountName', 'accountEmail', 'accountPassword', 'accountUsername', 'accountPasswordConfirm', 'accountChallenge'),
                userFields = this.get('userFields');

            // Add the userfields to the data
            if (!Ember.isEmpty(userFields)) {
              attrs.userFields = {};
              userFields.forEach(function (f) {
                attrs.userFields[f.get('field.id')] = f.get('value');
              });
            }

            this.set('formSubmitted', true);
            return Discourse.User.createAccount(attrs).then(function (result) {
              if (result.success) {
                // Trigger the browser's password manager using the hidden static login form:
                var $hidden_login_form = $('#hidden-login-form');
                $hidden_login_form.find('input[name=username]').val(attrs.accountUsername);
                $hidden_login_form.find('input[name=password]').val(attrs.accountPassword);
                $hidden_login_form.find('input[name=redirect]').val(Discourse.getURL('/users/account-created'));
                $hidden_login_form.submit();
              } else {
                self.flash(result.message || I18n.t('create_account.failed'), 'error');
                if (result.errors && result.errors.email && result.errors.email.length > 0 && result.values) {
                  self.get('rejectedEmails').pushObject(result.values.email);
                }
                if (result.errors && result.errors.password && result.errors.password.length > 0) {
                  self.get('rejectedPasswords').pushObject(attrs.accountPassword);
                }
                self.set('formSubmitted', false);
              }
              if (result.active && !Discourse.SiteSettings.must_approve_users) {
                return window.location.reload();
              }
            }, function () {
              self.set('formSubmitted', false);
              return self.flash(I18n.t('create_account.failed'), 'error');
            });
          }
        };
      }
    }, {
      key: '_createUserFields',
      initializer: function () {
        return (function () {
          if (!this.site) {
            return;
          }

          var userFields = this.site.get('user_fields');
          if (userFields) {
            userFields = _.sortBy(userFields, 'position').map(function (f) {
              return Ember.Object.create({ value: null, field: f });
            });
          }
          this.set('userFields', userFields);
        }).on('init');
      }
    }]));
  });define("discourse/controllers/directory-item", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Ember.Controller.extend({
      me: propertyEqual('model.user.id', 'currentUser.id')
    });
  });define("discourse/controllers/discovery", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ['navigation/category', 'discovery/topics', 'application'],
      loading: false,

      category: Em.computed.alias('controllers.navigation/category.category'),
      noSubcategories: Em.computed.alias('controllers.navigation/category.noSubcategories'),

      loadedAllItems: Em.computed.not("controllers.discovery/topics.model.canLoadMore"),

      _showFooter: (function () {
        this.set("controllers.application.showFooter", this.get("loadedAllItems"));
      }).observes("loadedAllItems"),

      showMoreUrl: function (period) {
        var url = '',
            category = this.get('category');
        if (category) {
          url = '/c/' + Discourse.Category.slugFor(category) + (this.get('noSubcategories') ? '/none' : '') + '/l';
        }
        url += '/top/' + period;
        return url;
      },

      actions: {
        changePeriod: function (p) {
          DiscourseURL.routeTo(this.showMoreUrl(p));
        }
      }

    });
  });define("discourse/controllers/discovery/categories", 
  ["discourse/controllers/discovery","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscoveryController = __dependency1__["default"];

    __exports__["default"] = DiscoveryController.extend({
      needs: ['modal', 'discovery'],

      withLogo: Em.computed.filterBy('model.categories', 'logo_url'),
      showPostsColumn: Em.computed.empty('withLogo'),

      // this makes sure the composer isn't scoping to a specific category
      category: null,

      actions: {

        refresh: function () {
          // Don't refresh if we're still loading
          if (this.get('controllers.discovery.loading')) {
            return;
          }

          // If we `send('loading')` here, due to returning true it bubbles up to the
          // router and ember throws an error due to missing `handlerInfos`.
          // Lesson learned: Don't call `loading` yourself.
          this.set('controllers.discovery.loading', true);

          var CategoryList = require('discourse/models/category-list').default;
          var parentCategory = this.get('model.parentCategory');
          var promise = parentCategory ? CategoryList.listForParent(this.store, parentCategory) : CategoryList.list(this.store);

          var self = this;
          promise.then(function (list) {
            self.set('model', list);
            self.send('loadingComplete');
          });
        }
      },

      canEdit: (function () {
        return Discourse.User.currentProp('staff');
      }).property(),

      latestTopicOnly: (function () {
        return this.get('model.categories').find(function (c) {
          return c.get('featuredTopics.length') > 1;
        }) === undefined;
      }).property('model.categories.@each.featuredTopics.length')

    });
  });define("discourse/controllers/discovery/topics", 
  ["discourse/controllers/discovery","discourse/controllers/discovery-sortable","discourse/mixins/bulk-topic-selection","discourse/lib/computed","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var DiscoveryController = __dependency1__["default"];
    var queryParams = __dependency2__.queryParams;
    var BulkTopicSelection = __dependency3__["default"];
    var endWith = __dependency4__.endWith;
    var showModal = __dependency5__["default"];

    var controllerOpts = {
      needs: ['discovery'],
      period: null,

      canStar: Em.computed.alias('controllers.discovery/topics.currentUser.id'),
      showTopicPostBadges: Em.computed.not('controllers.discovery/topics.new'),

      redirectedReason: Em.computed.alias('currentUser.redirected_to_top.reason'),

      order: 'default',
      ascending: false,
      expandGloballyPinned: false,
      expandAllPinned: false,

      actions: {

        changeSort: function (sortBy) {
          if (sortBy === this.get('order')) {
            this.toggleProperty('ascending');
          } else {
            this.setProperties({ order: sortBy, ascending: false });
          }

          this.get('model').refreshSort(sortBy, this.get('ascending'));
        },

        // Show newly inserted topics
        showInserted: function () {
          var tracker = this.topicTrackingState;

          // Move inserted into topics
          this.get('content').loadBefore(tracker.get('newIncoming'));
          tracker.resetTracking();
          return false;
        },

        refresh: function () {
          var _this = this;

          var filter = this.get('model.filter');

          this.setProperties({ order: "default", ascending: false });

          // Don't refresh if we're still loading
          if (this.get('controllers.discovery.loading')) {
            return;
          }

          // If we `send('loading')` here, due to returning true it bubbles up to the
          // router and ember throws an error due to missing `handlerInfos`.
          // Lesson learned: Don't call `loading` yourself.
          this.set('controllers.discovery.loading', true);

          this.store.findFiltered('topicList', { filter: filter }).then(function (list) {
            var TopicList = require('discourse/models/topic-list').default;
            TopicList.hideUniformCategory(list, _this.get('category'));

            _this.setProperties({ model: list });
            _this.resetSelected();

            if (_this.topicTrackingState) {
              _this.topicTrackingState.sync(list, filter);
            }

            _this.send('loadingComplete');
          });
        },

        resetNew: function () {
          var _this2 = this;

          this.topicTrackingState.resetNew();
          Discourse.Topic.resetNew().then(function () {
            return _this2.send('refresh');
          });
        },

        dismissReadPosts: function () {
          showModal('dismiss-read', { title: 'topics.bulk.dismiss_read' });
        }
      },

      isFilterPage: function (filter, filterType) {
        if (!filter) {
          return false;
        }
        return filter.match(new RegExp(filterType + '$', 'gi')) ? true : false;
      },

      showDismissRead: (function () {
        return this.isFilterPage(this.get('model.filter'), 'unread') && this.get('model.topics.length') > 0;
      }).property('model.filter', 'model.topics.length'),

      showResetNew: (function () {
        return this.get('model.filter') === 'new' && this.get('model.topics.length') > 0;
      }).property('model.filter', 'model.topics.length'),

      showDismissAtTop: (function () {
        return (this.isFilterPage(this.get('model.filter'), 'new') || this.isFilterPage(this.get('model.filter'), 'unread')) && this.get('model.topics.length') >= 30;
      }).property('model.filter', 'model.topics.length'),

      hasTopics: Em.computed.gt('model.topics.length', 0),
      allLoaded: Em.computed.empty('model.more_topics_url'),
      latest: endWith('model.filter', 'latest'),
      new: endWith('model.filter', 'new'),
      top: Em.computed.notEmpty('period'),
      yearly: Em.computed.equal('period', 'yearly'),
      quarterly: Em.computed.equal('period', 'quarterly'),
      monthly: Em.computed.equal('period', 'monthly'),
      weekly: Em.computed.equal('period', 'weekly'),
      daily: Em.computed.equal('period', 'daily'),

      footerMessage: (function () {
        if (!this.get('allLoaded')) {
          return;
        }

        var category = this.get('category');
        if (category) {
          return I18n.t('topics.bottom.category', { category: category.get('name') });
        } else {
          var split = (this.get('model.filter') || '').split('/');
          if (this.get('model.topics.length') === 0) {
            return I18n.t("topics.none." + split[0], {
              category: split[1]
            });
          } else {
            return I18n.t("topics.bottom." + split[0], {
              category: split[1]
            });
          }
        }
      }).property('allLoaded', 'model.topics.length'),

      footerEducation: (function () {
        if (!this.get('allLoaded') || this.get('model.topics.length') > 0 || !Discourse.User.current()) {
          return;
        }

        var split = (this.get('model.filter') || '').split('/');

        if (split[0] !== 'new' && split[0] !== 'unread') {
          return;
        }

        return I18n.t("topics.none.educate." + split[0], {
          userPrefsUrl: Discourse.getURL("/users/") + Discourse.User.currentProp("username_lower") + "/preferences"
        });
      }).property('allLoaded', 'model.topics.length'),

      loadMoreTopics: function () {
        return this.get('model').loadMore();
      }
    };

    Ember.keys(queryParams).forEach(function (p) {
      // If we don't have a default value, initialize it to null
      if (typeof controllerOpts[p] === 'undefined') {
        controllerOpts[p] = null;
      }
    });

    __exports__["default"] = DiscoveryController.extend(controllerOpts, BulkTopicSelection);
  });define("discourse/controllers/edit-category", 
  ["discourse/mixins/modal-functionality","discourse/lib/url","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];
    var extractError = __dependency3__.extractError;

    // Modal for editing / creating a category
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      selectedTab: null,
      saving: false,
      deleting: false,
      panels: null,

      _initPanels: (function () {
        this.set('panels', []);
      }).on('init'),

      onShow: function () {
        this.changeSize();
        this.titleChanged();
      },

      changeSize: (function () {
        if (!Ember.isEmpty(this.get('model.description'))) {
          this.set('controllers.modal.modalClass', 'edit-category-modal full');
        } else {
          this.set('controllers.modal.modalClass', 'edit-category-modal small');
        }
      }).observes('model.description'),

      title: (function () {
        if (this.get('model.id')) {
          return I18n.t("category.edit_long") + " : " + this.get('model.name');
        }
        return I18n.t("category.create") + (this.get('model.name') ? " : " + this.get('model.name') : '');
      }).property('model.id', 'model.name'),

      titleChanged: (function () {
        this.set('controllers.modal.title', this.get('title'));
      }).observes('title'),

      disabled: (function () {
        if (this.get('saving') || this.get('deleting')) return true;
        if (!this.get('model.name')) return true;
        if (!this.get('model.color')) return true;
        return false;
      }).property('saving', 'model.name', 'model.color', 'deleting'),

      deleteDisabled: (function () {
        return this.get('deleting') || this.get('saving') || false;
      }).property('disabled', 'saving', 'deleting'),

      categoryName: (function () {
        var name = this.get('name') || "";
        return name.trim().length > 0 ? name : I18n.t("preview");
      }).property('name'),

      saveLabel: (function () {
        if (this.get('saving')) return "saving";
        if (this.get('model.isUncategorizedCategory')) return "save";
        return this.get('model.id') ? "category.save" : "category.create";
      }).property('saving', 'model.id'),

      actions: {
        saveCategory: function () {
          var self = this,
              model = this.get('model'),
              parentCategory = Discourse.Category.list().findBy('id', parseInt(model.get('parent_category_id'), 10));

          this.set('saving', true);
          model.set('parentCategory', parentCategory);

          this.get('model').save().then(function (result) {
            self.set('saving', false);
            self.send('closeModal');
            model.setProperties({ slug: result.category.slug, id: result.category.id });
            DiscourseURL.redirectTo("/c/" + Discourse.Category.slugFor(model));
          }).catch(function (error) {
            self.flash(extractError(error), 'error');
            self.set('saving', false);
          });
        },

        deleteCategory: function () {
          var self = this;
          this.set('deleting', true);

          this.send('hideModal');
          bootbox.confirm(I18n.t("category.delete_confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (result) {
            if (result) {
              self.get('model').destroy().then(function () {
                // success
                self.send('closeModal');
                DiscourseURL.redirectTo("/categories");
              }, function (error) {
                self.flash(extractError(error), 'error');
                self.send('reopenModal');
                self.displayErrors([I18n.t("category.delete_error")]);
                self.set('deleting', false);
              });
            } else {
              self.send('reopenModal');
              self.set('deleting', false);
            }
          });
        }
      }

    });
  });define("discourse/controllers/edit-topic-auto-close", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var ModalFunctionality = __dependency2__["default"];

    // Modal related to auto closing of topics
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'auto_close_valid',
      initializer: function () {
        return true;
      }
    }, {
      key: 'auto_close_invalid',
      initializer: function () {
        return Em.computed.not('auto_close_valid');
      }
    }, {
      key: 'disable_submit',
      initializer: function () {
        return Em.computed.or('auto_close_invalid', 'loading');
      }
    }, {
      key: 'loading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'setAutoCloseTime',
      decorators: [observes("model.details.auto_close_at", "model.details.auto_close_hours")],
      value: function () {
        var autoCloseTime = null;

        if (this.get("model.details.auto_close_based_on_last_post")) {
          autoCloseTime = this.get("model.details.auto_close_hours");
        } else if (this.get("model.details.auto_close_at")) {
          var closeTime = new Date(this.get("model.details.auto_close_at"));
          if (closeTime > new Date()) {
            autoCloseTime = moment(closeTime).format("YYYY-MM-DD HH:mm");
          }
        }

        this.set("model.auto_close_time", autoCloseTime);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          saveAutoClose: function () {
            this.setAutoClose(this.get("model.auto_close_time"));
          },
          removeAutoClose: function () {
            this.setAutoClose(null);
          }
        };
      }
    }, {
      key: 'setAutoClose',
      value: function (time) {
        var _this = this;

        var self = this;
        this.set('loading', true);
        Discourse.ajax({
          url: '/t/' + this.get('model.id') + '/autoclose',
          type: 'PUT',
          dataType: 'json',
          data: {
            auto_close_time: time,
            auto_close_based_on_last_post: this.get("model.details.auto_close_based_on_last_post"),
            timezone_offset: new Date().getTimezoneOffset()
          }
        }).then(function (result) {
          self.set('loading', false);
          if (result.success) {
            _this.send('closeModal');
            _this.set('model.details.auto_close_at', result.auto_close_at);
            _this.set('model.details.auto_close_hours', result.auto_close_hours);
          } else {
            bootbox.alert(I18n.t('composer.auto_close.error'));
          }
        }).catch(function () {
          // TODO - incorrectly responds to network errors as bad input
          bootbox.alert(I18n.t('composer.auto_close.error'));
          self.set('loading', false);
        });
      }
    }, {
      key: 'willCloseImmediately',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.auto_close_based_on_last_post')) {
            return false;
          }
          var closeDate = new Date(this.get('model.last_posted_at'));
          closeDate.setHours(closeDate.getHours() + this.get('model.auto_close_time'));
          return closeDate < new Date();
        }).property('model.details.auto_close_based_on_last_post', 'model.auto_close_time', 'model.last_posted_at');
      }
    }, {
      key: 'willCloseI18n',
      initializer: function () {
        return (function () {
          if (this.get('model.details.auto_close_based_on_last_post')) {
            return I18n.t('topic.auto_close_immediate', { hours: this.get('model.auto_close_time') });
          }
        }).property('model.details.auto_close_based_on_last_post', 'model.auto_close_time');
      }
    }]));
  });define("discourse/controllers/exception", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var ButtonBackBright = {
      classes: "btn-primary",
      action: "back",
      key: "errors.buttons.back"
    },
        ButtonBackDim = {
      classes: "",
      action: "back",
      key: "errors.buttons.back"
    },
        ButtonTryAgain = {
      classes: "btn-primary",
      action: "tryLoading",
      key: "errors.buttons.again"
    },
        ButtonLoadPage = {
      classes: "btn-primary",
      action: "tryLoading",
      key: "errors.buttons.fixed"
    };

    // The controller for the nice error page
    __exports__["default"] = Ember.Controller.extend({
      thrown: null,
      lastTransition: null,

      isNetwork: (function () {
        // never made it on the wire
        if (this.get('thrown.readyState') === 0) return true;
        // timed out
        if (this.get('thrown.jqTextStatus') === "timeout") return true;
        return false;
      }).property(),
      isNotFound: Em.computed.equal('thrown.status', 404),
      isForbidden: Em.computed.equal('thrown.status', 403),
      isServer: Em.computed.gte('thrown.status', 500),
      isUnknown: Em.computed.none('isNetwork', 'isServer'),

      // TODO
      // make ajax requests to /srv/status with exponential backoff
      // if one succeeds, set networkFixed to true, which puts a "Fixed!" message on the page
      networkFixed: false,
      loading: false,

      _init: (function () {
        this.set('loading', false);
      }).on('init'),

      reason: (function () {
        if (this.get('isNetwork')) {
          return I18n.t('errors.reasons.network');
        } else if (this.get('isServer')) {
          return I18n.t('errors.reasons.server');
        } else if (this.get('isNotFound')) {
          return I18n.t('errors.reasons.not_found');
        } else if (this.get('isForbidden')) {
          return I18n.t('errors.reasons.forbidden');
        } else {
          // TODO
          return I18n.t('errors.reasons.unknown');
        }
      }).property('isNetwork', 'isServer', 'isUnknown'),

      requestUrl: Em.computed.alias('thrown.requestedUrl'),

      desc: (function () {
        if (this.get('networkFixed')) {
          return I18n.t('errors.desc.network_fixed');
        } else if (this.get('isNetwork')) {
          return I18n.t('errors.desc.network');
        } else if (this.get('isNotFound')) {
          return I18n.t('errors.desc.not_found');
        } else if (this.get('isServer')) {
          return I18n.t('errors.desc.server', { status: this.get('thrown.status') + " " + this.get('thrown.statusText') });
        } else {
          // TODO
          return I18n.t('errors.desc.unknown');
        }
      }).property('networkFixed', 'isNetwork', 'isServer', 'isUnknown'),

      enabledButtons: (function () {
        if (this.get('networkFixed')) {
          return [ButtonLoadPage];
        } else if (this.get('isNetwork')) {
          return [ButtonBackDim, ButtonTryAgain];
        } else {
          return [ButtonBackBright, ButtonTryAgain];
        }
      }).property('networkFixed', 'isNetwork', 'isServer', 'isUnknown'),

      actions: {
        back: function () {
          window.history.back();
        },

        tryLoading: function () {
          this.set('loading', true);
          var self = this;
          Em.run.schedule('afterRender', function () {
            self.get('lastTransition').retry();
            self.set('loading', false);
          });
        }
      }
    });
  });define("discourse/controllers/feature-topic", 
  ["discourse/mixins/modal-functionality","discourse/helpers/category-link","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var categoryLinkHTML = __dependency2__.categoryLinkHTML;
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ["topic"];
      }
    }, {
      key: 'loading',
      initializer: function () {
        return true;
      }
    }, {
      key: 'pinnedInCategoryCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'pinnedGloballyCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'bannerCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'reset',
      value: function () {
        this.setProperties({
          "model.pinnedInCategoryUntil": null,
          "model.pinnedGloballyUntil": null,
          pinInCategoryTipShownAt: false,
          pinGloballyTipShownAt: false
        });
      }
    }, {
      key: 'categoryLink',
      decorators: [computed("model.category")],
      value: function (category) {
        return categoryLinkHTML(category, { allowUncategorized: true });
      }
    }, {
      key: 'unPinMessage',
      decorators: [computed("categoryLink", "model.pinned_globally", "model.pinned_until")],
      value: function (categoryLink, pinnedGlobally, pinnedUntil) {
        var name = "topic.feature_topic.unpin";
        if (pinnedGlobally) name += "_globally";
        if (moment(pinnedUntil) > moment()) name += "_until";
        var until = moment(pinnedUntil).format("LL");

        return I18n.t(name, { categoryLink: categoryLink, until: until });
      }
    }, {
      key: 'pinMessage',
      decorators: [computed("categoryLink")],
      value: function (categoryLink) {
        return I18n.t("topic.feature_topic.pin", { categoryLink: categoryLink });
      }
    }, {
      key: 'alreadyPinnedMessage',
      decorators: [computed("categoryLink", "pinnedInCategoryCount")],
      value: function (categoryLink, count) {
        var key = count === 0 ? "topic.feature_topic.not_pinned" : "topic.feature_topic.already_pinned";
        return I18n.t(key, { categoryLink: categoryLink, count: count });
      }
    }, {
      key: 'pinDisabled',
      decorators: [computed("parsedPinnedInCategoryUntil")],
      value: function (parsedPinnedInCategoryUntil) {
        return !this._isDateValid(parsedPinnedInCategoryUntil);
      }
    }, {
      key: 'pinGloballyDisabled',
      decorators: [computed("parsedPinnedGloballyUntil")],
      value: function (parsedPinnedGloballyUntil) {
        return !this._isDateValid(parsedPinnedGloballyUntil);
      }
    }, {
      key: 'parsedPinnedInCategoryUntil',
      decorators: [computed("model.pinnedInCategoryUntil")],
      value: function (pinnedInCategoryUntil) {
        return this._parseDate(pinnedInCategoryUntil);
      }
    }, {
      key: 'parsedPinnedGloballyUntil',
      decorators: [computed("model.pinnedGloballyUntil")],
      value: function (pinnedGloballyUntil) {
        return this._parseDate(pinnedGloballyUntil);
      }
    }, {
      key: 'pinInCategoryValidation',
      decorators: [computed("pinDisabled")],
      value: function (pinDisabled) {
        if (pinDisabled) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t("topic.feature_topic.pin_validation") });
        }
      }
    }, {
      key: 'pinGloballyValidation',
      decorators: [computed("pinGloballyDisabled")],
      value: function (pinGloballyDisabled) {
        if (pinGloballyDisabled) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t("topic.feature_topic.pin_validation") });
        }
      }
    }, {
      key: '_parseDate',
      value: function (date) {
        return moment(date, ["YYYY-MM-DD", "YYYY-MM-DD HH:mm"]);
      }
    }, {
      key: '_isDateValid',
      value: function (parsedDate) {
        return parsedDate.isValid() && parsedDate > moment();
      }
    }, {
      key: 'onShow',
      value: function () {
        var _this = this;

        this.set("loading", true);

        return Discourse.ajax("/topics/feature_stats.json", {
          data: { category_id: this.get("model.category.id") }
        }).then(function (result) {
          if (result) {
            _this.setProperties({
              pinnedInCategoryCount: result.pinned_in_category_count,
              pinnedGloballyCount: result.pinned_globally_count,
              bannerCount: result.banner_count
            });
          }
        }).finally(function () {
          return _this.set("loading", false);
        });
      }
    }, {
      key: '_forwardAction',
      value: function (name) {
        this.get("controllers.topic").send(name);
        this.send("closeModal");
      }
    }, {
      key: '_confirmBeforePinning',
      value: function (count, name, action) {
        var _this2 = this;

        if (count < 4) {
          this._forwardAction(action);
        } else {
          this.send("hideModal");
          bootbox.confirm(I18n.t("topic.feature_topic.confirm_" + name, { count: count }), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
            return confirmed ? _this2._forwardAction(action) : _this2.send("reopenModal");
          });
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          pin: function () {
            if (this.get("pinDisabled")) {
              this.set("pinInCategoryTipShownAt", Date.now());
            } else {
              this._forwardAction("togglePinned");
            }
          },

          pinGlobally: function () {
            if (this.get("pinGloballyDisabled")) {
              this.set("pinGloballyTipShownAt", Date.now());
            } else {
              this._confirmBeforePinning(this.get("pinnedGloballyCount"), "pin_globally", "pinGlobally");
            }
          },

          unpin: function () {
            this._forwardAction("togglePinned");
          },
          makeBanner: function () {
            this._forwardAction("makeBanner");
          },
          removeBanner: function () {
            this._forwardAction("removeBanner");
          }
        };
      }
    }]));
  });define("discourse/controllers/flag-action-type", 
  ["discourse/models/post-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var MAX_MESSAGE_LENGTH = __dependency1__.MAX_MESSAGE_LENGTH;

    // Supports logic for flags in the modal
    __exports__["default"] = Ember.Controller.extend({
      needs: ['flag'],

      message: Em.computed.alias('controllers.flag.message'),

      customPlaceholder: (function () {
        return I18n.t("flagging.custom_placeholder_" + this.get('model.name_key'));
      }).property('model.name_key'),

      formattedName: (function () {
        if (this.get("model.is_custom_flag")) {
          return this.get('model.name').replace("{{username}}", this.get('controllers.flag.model.username'));
        } else {
          return I18n.t("flagging.formatted_name." + this.get('model.name_key'));
        }
      }).property('model.name', 'model.name_key', 'model.is_custom_flag'),

      selected: (function () {
        return this.get('model') === this.get('controllers.flag.selected');
      }).property('controllers.flag.selected'),

      showMessageInput: Em.computed.and('model.is_custom_flag', 'selected'),
      showDescription: Em.computed.not('showMessageInput'),
      isNotifyUser: Em.computed.equal('model.name_key', 'notify_user'),

      customMessageLengthClasses: (function () {
        return this.get('message.length') < Discourse.SiteSettings.min_private_message_post_length ? "too-short" : "ok";
      }).property('message.length'),

      customMessageLength: (function () {
        var len = this.get('message.length') || 0;
        var minLen = Discourse.SiteSettings.min_private_message_post_length;
        if (len === 0) {
          return I18n.t("flagging.custom_message.at_least", { n: minLen });
        } else if (len < minLen) {
          return I18n.t("flagging.custom_message.more", { n: minLen - len });
        } else {
          return I18n.t("flagging.custom_message.left", {
            n: MAX_MESSAGE_LENGTH - len
          });
        }
      }).property('message.length')

    });
  });define("discourse/controllers/flag", 
  ["discourse/mixins/modal-functionality","discourse/models/action-summary","discourse/models/post-action-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var ActionSummary = __dependency2__["default"];
    var MAX_MESSAGE_LENGTH = __dependency3__.MAX_MESSAGE_LENGTH;

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      userDetails: null,
      selected: null,
      flagTopic: null,
      message: null,
      topicActionByName: null,

      onShow: function () {
        this.set('selected', null);
      },

      flagsAvailable: (function () {
        var _this = this;

        if (!this.get('flagTopic')) {
          // flagging post
          var flagsAvailable = this.get('model.flagsAvailable');

          // "message user" option should be at the top
          var notifyUserIndex = flagsAvailable.indexOf(flagsAvailable.filterProperty('name_key', 'notify_user')[0]);
          if (notifyUserIndex !== -1) {
            var notifyUser = flagsAvailable[notifyUserIndex];
            flagsAvailable.splice(notifyUserIndex, 1);
            flagsAvailable.splice(0, 0, notifyUser);
          }
          return flagsAvailable;
        } else {
          var _ret = (function () {
            // flagging topic
            var self = _this,
                lookup = Em.Object.create();

            _.each(_this.get("model.actions_summary"), function (a) {
              a.flagTopic = self.get('model');
              a.actionType = self.site.topicFlagTypeById(a.id);
              var actionSummary = ActionSummary.create(a);
              lookup.set(a.actionType.get('name_key'), actionSummary);
            });
            _this.set('topicActionByName', lookup);

            return {
              v: _this.site.get('topic_flag_types').filter(function (item) {
                return _.any(self.get("model.actions_summary"), function (a) {
                  return a.id === item.get('id') && a.can_act;
                });
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }).property('post', 'flagTopic', 'model.actions_summary.@each.can_act'),

      staffFlagsAvailable: (function () {
        return this.get('model.flagsAvailable').length > 1;
      }).property('post', 'flagTopic', 'model.actions_summary.@each.can_act'),

      submitEnabled: (function () {
        var selected = this.get('selected');
        if (!selected) return false;

        if (selected.get('is_custom_flag')) {
          var len = this.get('message.length') || 0;
          return len >= Discourse.SiteSettings.min_private_message_post_length && len <= MAX_MESSAGE_LENGTH;
        }
        return true;
      }).property('selected.is_custom_flag', 'message.length'),

      submitDisabled: Em.computed.not('submitEnabled'),

      // Staff accounts can "take action"
      canTakeAction: (function () {
        if (this.get("flagTopic")) return false;

        // We can only take actions on non-custom flags
        if (this.get('selected.is_custom_flag')) return false;
        return Discourse.User.currentProp('staff');
      }).property('selected.is_custom_flag'),

      submitText: (function () {
        if (this.get('selected.is_custom_flag')) {
          return "<i class='fa fa-envelope'></i>" + I18n.t(this.get('flagTopic') ? "flagging_topic.notify_action" : "flagging.notify_action");
        } else {
          return "<i class='fa fa-flag'></i>" + I18n.t(this.get('flagTopic') ? "flagging_topic.action" : "flagging.action");
        }
      }).property('selected.is_custom_flag'),

      actions: {
        takeAction: function () {
          this.send('createFlag', { takeAction: true });
          this.set('model.hidden', true);
        },

        createFlag: function (opts) {
          var self = this;
          var postAction = undefined; // an instance of ActionSummary

          if (!this.get('flagTopic')) {
            postAction = this.get('model.actions_summary').findProperty('id', this.get('selected.id'));
          } else {
            postAction = this.get('topicActionByName.' + this.get('selected.name_key'));
          }

          var params = this.get('selected.is_custom_flag') ? { message: this.get('message') } : {};
          if (opts) {
            params = $.extend(params, opts);
          }

          this.send('hideModal');

          postAction.act(this.get('model'), params).then(function () {
            self.send('closeModal');
            if (params.message) {
              self.set('message', '');
            }
          }, function (errors) {
            self.send('closeModal');
            if (errors && errors.responseText) {
              bootbox.alert($.parseJSON(errors.responseText).errors);
            } else {
              bootbox.alert(I18n.t('generic_error'));
            }
          });
        },

        changePostActionType: function (action) {
          this.set('selected', action);
        }
      },

      canDeleteSpammer: (function () {
        if (this.get("flagTopic")) return false;

        if (Discourse.User.currentProp('staff') && this.get('selected.name_key') === 'spam') {
          return this.get('userDetails.can_be_deleted') && this.get('userDetails.can_delete_all_posts');
        } else {
          return false;
        }
      }).property('selected.name_key', 'userDetails.can_be_deleted', 'userDetails.can_delete_all_posts'),

      usernameChanged: (function () {
        this.set('userDetails', null);
        this.fetchUserDetails();
      }).observes('model.username'),

      fetchUserDetails: function () {
        var _this2 = this;

        if (Discourse.User.currentProp('staff') && this.get('model.username')) {
          var AdminUser = require('admin/models/admin-user').default;
          AdminUser.find(this.get('model.username').toLowerCase()).then(function (user) {
            return _this2.set('userDetails', user);
          });
        }
      }

    });
  });define("discourse/controllers/forgot-password", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {

      // You need a value in the field to submit it.
      submitDisabled: (function () {
        return Ember.isEmpty(this.get('accountEmailOrUsername').trim()) || this.get('disabled');
      }).property('accountEmailOrUsername', 'disabled'),

      actions: {
        submit: function () {
          var self = this;

          if (this.get('submitDisabled')) return false;

          this.set('disabled', true);

          var success = function (data) {
            // don't tell people what happened, this keeps it more secure (ensure same on server)
            var escaped = Discourse.Utilities.escapeExpression(self.get('accountEmailOrUsername'));
            var isEmail = self.get('accountEmailOrUsername').match(/@/);

            var key = 'forgot_password.complete_' + (isEmail ? 'email' : 'username');
            var extraClass;

            if (data.user_found === true) {
              key += '_found';
              self.set('accountEmailOrUsername', '');
              bootbox.alert(I18n.t(key, { email: escaped, username: escaped }));
              self.send("closeModal");
            } else {
              if (data.user_found === false) {
                key += '_not_found';
                extraClass = 'error';
              }

              self.flash(I18n.t(key, { email: escaped, username: escaped }), extraClass);
            }
          };

          var fail = function (e) {
            self.flash(e.responseJSON.errors[0], 'error');
          };

          Discourse.ajax('/session/forgot_password', {
            data: { login: this.get('accountEmailOrUsername').trim() },
            type: 'POST'
          }).then(success, fail).finally(function () {
            setTimeout(function () {
              self.set('disabled', false);
            }, 1000);
          });

          return false;
        }
      }

    });
  });define("discourse/controllers/full-page-search", 
  ["discourse/lib/search","discourse/lib/show-modal","ember-addons/ember-computed-decorators","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var translateResults = __dependency1__.translateResults;
    var searchContextDescription = __dependency1__.searchContextDescription;
    var getSearchKey = __dependency1__.getSearchKey;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;
    var showModal = __dependency2__["default"];
    var computed = __dependency3__.default;
    var observes = __dependency3__.observes;
    var Category = __dependency4__["default"];

    var SortOrders = [{ name: I18n.t('search.relevance'), id: 0 }, { name: I18n.t('search.latest_post'), id: 1, term: 'order:latest' }, { name: I18n.t('search.most_liked'), id: 2, term: 'order:likes' }, { name: I18n.t('search.most_viewed'), id: 3, term: 'order:views' }];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ["application"];
      }
    }, {
      key: 'loading',
      initializer: function () {
        return Em.computed.not("model");
      }
    }, {
      key: 'queryParams',
      initializer: function () {
        return ["q", "context_id", "context", "skip_context"];
      }
    }, {
      key: 'q',
      initializer: function () {
        return null;
      }
    }, {
      key: 'selected',
      initializer: function () {
        return [];
      }
    }, {
      key: 'context_id',
      initializer: function () {
        return null;
      }
    }, {
      key: 'context',
      initializer: function () {
        return null;
      }
    }, {
      key: 'searching',
      initializer: function () {
        return false;
      }
    }, {
      key: 'sortOrder',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'sortOrders',
      initializer: function () {
        return SortOrders;
      }
    }, {
      key: 'resultCount',
      decorators: [computed('model.posts')],
      value: function (posts) {
        return posts && posts.length;
      }
    }, {
      key: 'hasAutofocus',
      decorators: [computed('q')],
      value: function (q) {
        return Em.isEmpty(q);
      }
    }, {
      key: 'searchContextEnabled',
      decorators: [computed('skip_context', 'context')],
      initializer: function () {
        return {
          get: function (skip, context) {
            return !skip && context || skip === "false";
          },
          set: function (val) {
            this.set('skip_context', val ? "false" : "true");
          }
        };
      }
    }, {
      key: 'searchContextDescription',
      decorators: [computed('context', 'context_id')],
      value: function (context, id) {
        var name = id;
        if (context === 'category') {
          var category = Category.findById(id);
          if (!category) {
            return;
          }

          name = category.get('name');
        }
        return searchContextDescription(context, name);
      }
    }, {
      key: 'searchActive',
      decorators: [computed('q')],
      value: function (q) {
        return isValidSearchTerm(q);
      }
    }, {
      key: 'searchButtonDisabled',
      decorators: [computed('searchTerm', 'searching')],
      value: function (searchTerm, searching) {
        return !!(searching || !isValidSearchTerm(searchTerm));
      }
    }, {
      key: 'noSortQ',
      decorators: [computed('q')],
      value: function (q) {
        if (q) {
          SortOrders.forEach(function (order) {
            if (q.indexOf(order.term) > -1) {
              q = q.replace(order.term, "");
              q = q.trim();
            }
          });
        }
        return Discourse.Utilities.escapeExpression(q);
      }
    }, {
      key: '_searchOnSortChange',
      initializer: function () {
        return true;
      }
    }, {
      key: 'setSearchTerm',
      value: function (term) {
        var _this = this;

        this._searchOnSortChange = false;
        if (term) {
          SortOrders.forEach(function (order) {
            if (term.indexOf(order.term) > -1) {
              _this.set('sortOrder', order.id);
              term = term.replace(order.term, "");
              term = term.trim();
            }
          });
        }
        this._searchOnSortChange = true;
        this.set('searchTerm', term);
      }
    }, {
      key: 'triggerSearch',
      decorators: [observes('sortOrder')],
      value: function () {
        if (this._searchOnSortChange) {
          this.search();
        }
      }
    }, {
      key: 'modelChanged',
      decorators: [observes('model')],
      value: function () {
        if (this.get("searchTerm") !== this.get("q")) {
          this.setSearchTerm(this.get("q"));
        }
      }
    }, {
      key: 'showLikeCount',
      decorators: [computed('q')],
      value: function (q) {
        return q && q.indexOf("order:likes") > -1;
      }
    }, {
      key: 'qChanged',
      decorators: [observes('q')],
      value: function () {
        var model = this.get("model");
        if (model && this.get("model.q") !== this.get("q")) {
          this.setSearchTerm(this.get("q"));
          this.send("search");
        }
      }
    }, {
      key: '_showFooter',
      decorators: [observes('loading')],
      value: function () {
        this.set("controllers.application.showFooter", !this.get("loading"));
      }
    }, {
      key: 'canBulkSelect',
      initializer: function () {
        return Em.computed.alias('currentUser.staff');
      }
    }, {
      key: 'search',
      value: function () {
        var _this2 = this;

        if (this.get("searching")) return;
        this.set("searching", true);

        var router = Discourse.__container__.lookup('router:main');

        var args = { q: this.get("searchTerm") };

        var sortOrder = this.get("sortOrder");
        if (sortOrder && SortOrders[sortOrder].term) {
          args.q += " " + SortOrders[sortOrder].term;
        }

        this.set("q", args.q);
        this.set("model", null);

        var skip = this.get("skip_context");
        if (!skip && this.get('context') || skip === "false") {
          args.search_context = {
            type: this.get('context'),
            id: this.get('context_id')
          };
        }

        var searchKey = getSearchKey(args);

        Discourse.ajax("/search", { data: args }).then(function (results) {
          var model = translateResults(results) || {};
          router.transientCache('lastSearch', { searchKey: searchKey, model: model }, 5);
          _this2.set("model", model);
        }).finally(function () {
          _this2.set("searching", false);
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          selectAll: function () {
            this.get('selected').addObjects(this.get('model.posts').map(function (r) {
              return r.topic;
            }));
            // Doing this the proper way is a HUGE pain,
            // we can hack this to work by observing each on the array
            // in the component, however, when we select ANYTHING, we would force
            // 50 traversals of the list
            // This hack is cheap and easy
            $('.fps-result input[type=checkbox]').prop('checked', true);
          },

          clearAll: function () {
            this.get('selected').clear();
            $('.fps-result input[type=checkbox]').prop('checked', false);
          },

          toggleBulkSelect: function () {
            this.toggleProperty('bulkSelectEnabled');
            this.get('selected').clear();
          },

          refresh: function () {
            this.set('bulkSelectEnabled', false);
            this.get('selected').clear();
            this.search();
          },

          showSearchHelp: function () {
            // TODO: dupe code should be centralized
            Discourse.ajax("/static/search_help.html", { dataType: 'html' }).then(function (model) {
              showModal('searchHelp', { model: model });
            });
          },

          search: function () {
            if (this.get("searchButtonDisabled")) return;
            this.search();
          }
        };
      }
    }]));
  });define("discourse/controllers/group", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;

    var Tab = Em.Object.extend(_createDecoratedObject([{
      key: 'location',
      decorators: [computed('name')],
      value: function (name) {
        return 'group.' + name;
      }
    }]));

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'counts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'showing',
      initializer: function () {
        return 'posts';
      }
    }, {
      key: 'countsChanged',
      decorators: [observes('counts')],
      value: function () {
        var counts = this.get('counts');
        this.get('tabs').forEach(function (tab) {
          tab.set('count', counts.get(tab.get('name')));
        });
      }
    }, {
      key: 'showingChanged',
      decorators: [observes('showing')],
      value: function () {
        var showing = this.get('showing');

        this.get('tabs').forEach(function (tab) {
          tab.set('active', showing === tab.get('name'));
        });
      }
    }, {
      key: 'tabs',
      initializer: function () {
        return [Tab.create({ name: 'posts', active: true, 'location': 'group.index' }), Tab.create({ name: 'topics' }), Tab.create({ name: 'mentions' }), Tab.create({ name: 'members' }), Tab.create({ name: 'messages' })];
      }
    }]));
  });define("discourse/controllers/group/index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Handles displaying posts within a group
    **/

    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['group'],
      loading: false,

      actions: {
        loadMore: function () {

          if (this.get('loading')) {
            return;
          }
          this.set('loading', true);
          var posts = this.get('model'),
              self = this;
          if (posts && posts.length) {
            var lastPostId = posts[posts.length - 1].get('id'),
                group = this.get('controllers.group.model');

            var opts = { beforePostId: lastPostId, type: this.get('type') };
            group.findPosts(opts).then(function (newPosts) {
              posts.addObjects(newPosts);
              self.set('loading', false);
            });
          }
        }
      }
    });
  });define("discourse/controllers/group/members", 
  ["discourse/lib/ajax-error","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var popupAjaxError = __dependency1__.popupAjaxError;
    var computed = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'loading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'limit',
      initializer: function () {
        return null;
      }
    }, {
      key: 'offset',
      initializer: function () {
        return null;
      }
    }, {
      key: 'isOwner',
      decorators: [computed('model.owners.@each')],
      value: function (owners) {
        if (this.get('currentUser.admin')) {
          return true;
        }
        var currentUserId = this.get('currentUser.id');
        if (currentUserId) {
          return !!owners.findBy('id', currentUserId);
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          removeMember: function (user) {
            this.get('model').removeMember(user);
          },

          addMembers: function () {
            var _this = this;

            var usernames = this.get('usernames');
            if (usernames && usernames.length > 0) {
              this.get('model').addMembers(usernames).then(function () {
                return _this.set('usernames', []);
              }).catch(popupAjaxError);
            }
          },

          loadMore: function () {
            var _this2 = this;

            var Group = require('discourse/models/group').default;

            if (this.get("loading")) {
              return;
            }
            // we've reached the end
            if (this.get("model.members.length") >= this.get("model.user_count")) {
              return;
            }

            this.set("loading", true);

            Group.loadMembers(this.get("model.name"), this.get("model.members.length"), this.get("limit")).then(function (result) {
              _this2.get("model.members").addObjects(result.members.map(function (member) {
                return Discourse.User.create(member);
              }));
              _this2.setProperties({
                loading: false,
                user_count: result.meta.total,
                limit: result.meta.limit,
                offset: Math.min(result.meta.offset + result.meta.limit, result.meta.total)
              });
            });
          }
        };
      }
    }]));
  });define("discourse/controllers/group/mentions", 
  ["discourse/controllers/group/index","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var IndexController = __dependency1__["default"];

    __exports__["default"] = IndexController.extend({ type: 'mentions' });
  });define("discourse/controllers/group/topics", 
  ["discourse/controllers/group/index","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var IndexController = __dependency1__["default"];

    __exports__["default"] = IndexController.extend({ type: 'topics' });
  });define("discourse/controllers/header", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    var HeaderController = Ember.Controller.extend({
      topic: null,
      showExtraInfo: null,
      hamburgerVisible: false,
      searchVisible: false,
      userMenuVisible: false,
      needs: ['application'],

      canSignUp: Em.computed.alias('controllers.application.canSignUp'),

      showSignUpButton: (function () {
        return this.get('canSignUp') && !this.get('showExtraInfo');
      }).property('canSignUp', 'showExtraInfo'),

      showStarButton: (function () {
        return Discourse.User.current() && !this.get('topic.isPrivateMessage');
      }).property('topic.isPrivateMessage'),

      actions: {
        toggleSearch: function () {
          // there may be a cleaner way, but this is so trivial code wise
          var $fullpageSearch = $('input.full-page-search');
          if ($fullpageSearch.length === 1) {
            $fullpageSearch.focus().select();
          } else {
            this.toggleProperty('searchVisible');
          }
        },
        showUserMenu: function () {
          if (!this.get('userMenuVisible')) {
            this.appEvents.trigger('dropdowns:closeAll');
            this.set('userMenuVisible', true);
          }
        },

        fullPageSearch: function () {
          var searchService = this.container.lookup('search-service:main');
          var context = searchService.get('searchContext');
          var params = "";

          if (context) {
            params = '?context=' + context.type + '&context_id=' + context.id + '&skip_context=true';
          }

          DiscourseURL.routeTo('/search' + params);
        },
        toggleMenuPanel: function (visibleProp) {
          this.toggleProperty(visibleProp);
          this.appEvents.trigger('dropdowns:closeAll');
        },

        toggleStar: function () {
          var topic = this.get('topic');
          if (topic) topic.toggleStar();
          return false;
        }
      }
    });

    // Allow plugins to add to the sum of "flags" above the site map
    var _flagProperties = [];
    function addFlagProperty(prop) {
      _flagProperties.pushObject(prop);
    }

    function applyFlaggedProperties() {
      var args = _flagProperties.slice();
      args.push(function () {
        var _this = this;

        var sum = 0;
        _flagProperties.forEach(function (fp) {
          return sum += _this.get(fp) || 0;
        });
        return sum;
      });
      HeaderController.reopen({ flaggedPostsCount: Ember.computed.apply(this, args) });
    }

    addFlagProperty('currentUser.site_flagged_posts_count');
    addFlagProperty('currentUser.post_queue_new_count');

    __exports__.addFlagProperty = addFlagProperty;
    __exports__.applyFlaggedProperties = applyFlaggedProperties;
    __exports__["default"] = HeaderController;
  });define("discourse/controllers/history", 
  ["discourse/mixins/modal-functionality","discourse/helpers/category-link","ember-addons/ember-computed-decorators","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var categoryBadgeHTML = __dependency2__.categoryBadgeHTML;
    var computed = __dependency3__["default"];
    var propertyGreaterThan = __dependency4__.propertyGreaterThan;
    var propertyLessThan = __dependency4__.propertyLessThan;

    // This controller handles displaying of history
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'loading',
      initializer: function () {
        return true;
      }
    }, {
      key: 'viewMode',
      initializer: function () {
        return "side_by_side";
      }
    }, {
      key: 'revisionsTextKey',
      initializer: function () {
        return "post.revisions.controls.comparing_previous_to_current_out_of_total";
      }
    }, {
      key: '_changeViewModeOnMobile',
      initializer: function () {
        return (function () {
          if (Discourse.Mobile.mobileView) {
            this.set("viewMode", "inline");
          }
        }).on("init");
      }
    }, {
      key: 'refresh',
      value: function (postId, postVersion) {
        var _this = this;

        this.set("loading", true);

        Discourse.Post.loadRevision(postId, postVersion).then(function (result) {
          _this.setProperties({ loading: false, model: result });
        });
      }
    }, {
      key: 'hide',
      value: function (postId, postVersion) {
        var _this2 = this;

        Discourse.Post.hideRevision(postId, postVersion).then(function () {
          return _this2.refresh(postId, postVersion);
        });
      }
    }, {
      key: 'show',
      value: function (postId, postVersion) {
        var _this3 = this;

        Discourse.Post.showRevision(postId, postVersion).then(function () {
          return _this3.refresh(postId, postVersion);
        });
      }
    }, {
      key: 'createdAtDate',
      decorators: [computed('model.created_at')],
      value: function (createdAt) {
        return moment(createdAt).format("LLLL");
      }
    }, {
      key: 'previousVersion',
      decorators: [computed('model.current_version')],
      value: function (current) {
        return current - 1;
      }
    }, {
      key: 'displayGoToPrevious',
      decorators: [computed('model.current_revision', 'model.previous_revision')],
      value: function (current, prev) {
        return prev && current > prev;
      }
    }, {
      key: 'displayRevisions',
      initializer: function () {
        return Ember.computed.gt("model.version_count", 2);
      }
    }, {
      key: 'displayGoToFirst',
      initializer: function () {
        return propertyGreaterThan("model.current_revision", "model.first_revision");
      }
    }, {
      key: 'displayGoToNext',
      initializer: function () {
        return propertyLessThan("model.current_revision", "model.next_revision");
      }
    }, {
      key: 'displayGoToLast',
      initializer: function () {
        return propertyLessThan("model.current_revision", "model.next_revision");
      }
    }, {
      key: 'hideGoToFirst',
      initializer: function () {
        return Ember.computed.not("displayGoToFirst");
      }
    }, {
      key: 'hideGoToPrevious',
      initializer: function () {
        return Ember.computed.not("displayGoToPrevious");
      }
    }, {
      key: 'hideGoToNext',
      initializer: function () {
        return Ember.computed.not("displayGoToNext");
      }
    }, {
      key: 'hideGoToLast',
      initializer: function () {
        return Ember.computed.not("displayGoToLast");
      }
    }, {
      key: 'loadFirstDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToFirst");
      }
    }, {
      key: 'loadPreviousDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToPrevious");
      }
    }, {
      key: 'loadNextDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToNext");
      }
    }, {
      key: 'loadLastDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToLast");
      }
    }, {
      key: 'displayShow',
      decorators: [computed('model.previous_hidden')],
      value: function (prevHidden) {
        return prevHidden && this.currentUser && this.currentUser.get('staff');
      }
    }, {
      key: 'displayHide',
      decorators: [computed('model.previous_hidden')],
      value: function (prevHidden) {
        return !prevHidden && this.currentUser && this.currentUser.get('staff');
      }
    }, {
      key: 'isEitherRevisionHidden',
      initializer: function () {
        return Ember.computed.or("model.previous_hidden", "model.current_hidden");
      }
    }, {
      key: 'hiddenClasses',
      decorators: [computed('model.previous_hidden', 'model.current_hidden', 'displayingInline')],
      value: function (prevHidden, currentHidden, displayingInline) {
        if (displayingInline) {
          return this.get("isEitherRevisionHidden") ? "hidden-revision-either" : null;
        } else {
          var result = [];
          if (prevHidden) {
            result.push("hidden-revision-previous");
          }
          if (currentHidden) {
            result.push("hidden-revision-current");
          }
          return result.join(" ");
        }
      }
    }, {
      key: 'displayingInline',
      initializer: function () {
        return Em.computed.equal("viewMode", "inline");
      }
    }, {
      key: 'displayingSideBySide',
      initializer: function () {
        return Em.computed.equal("viewMode", "side_by_side");
      }
    }, {
      key: 'displayingSideBySideMarkdown',
      initializer: function () {
        return Em.computed.equal("viewMode", "side_by_side_markdown");
      }
    }, {
      key: 'inlineClass',
      decorators: [computed("displayingInline")],
      value: function (displayingInline) {
        return displayingInline ? "btn-primary" : "";
      }
    }, {
      key: 'sideBySideClass',
      decorators: [computed("displayingSideBySide")],
      value: function (displayingSideBySide) {
        return displayingSideBySide ? "btn-primary" : "";
      }
    }, {
      key: 'sideBySideMarkdownClass',
      decorators: [computed("displayingSideBySideMarkdown")],
      value: function (displayingSideBySideMarkdown) {
        return displayingSideBySideMarkdown ? "btn-primary" : "";
      }
    }, {
      key: 'previousCategory',
      decorators: [computed('model.category_id_changes')],
      value: function (changes) {
        if (changes) {
          var category = Discourse.Category.findById(changes["previous"]);
          return categoryBadgeHTML(category, { allowUncategorized: true });
        }
      }
    }, {
      key: 'currentCategory',
      decorators: [computed('model.category_id_changes')],
      value: function (changes) {
        if (changes) {
          var category = Discourse.Category.findById(changes["current"]);
          return categoryBadgeHTML(category, { allowUncategorized: true });
        }
      }
    }, {
      key: 'wikiDisabled',
      decorators: [computed('model.wiki_changes')],
      value: function (changes) {
        return changes && !changes['current'];
      }
    }, {
      key: 'postTypeDisabled',
      decorators: [computed('model.post_type_changes')],
      value: function (changes) {
        return changes && changes['current'] !== this.site.get('post_types.moderator_action');
      }
    }, {
      key: 'titleDiff',
      decorators: [computed('viewMode', 'model.title_changes')],
      value: function (viewMode) {
        if (viewMode === "side_by_side_markdown") {
          viewMode = "side_by_side";
        }
        return this.get("model.title_changes." + viewMode);
      }
    }, {
      key: 'bodyDiff',
      decorators: [computed('viewMode', 'model.body_changes')],
      value: function (viewMode) {
        return this.get("model.body_changes." + viewMode);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          loadFirstVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.first_revision"));
          },
          loadPreviousVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.previous_revision"));
          },
          loadNextVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.next_revision"));
          },
          loadLastVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.last_revision"));
          },

          hideVersion: function () {
            this.hide(this.get("model.post_id"), this.get("model.current_revision"));
          },
          showVersion: function () {
            this.show(this.get("model.post_id"), this.get("model.current_revision"));
          },

          displayInline: function () {
            this.set("viewMode", "inline");
          },
          displaySideBySide: function () {
            this.set("viewMode", "side_by_side");
          },
          displaySideBySideMarkdown: function () {
            this.set("viewMode", "side_by_side_markdown");
          }
        };
      }
    }]));
  });define("discourse/controllers/invite", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['user-invited-show'],

      // If this isn't defined, it will proxy to the user model on the preferences
      // page which is wrong.
      emailOrUsername: null,

      isAdmin: (function () {
        return Discourse.User.currentProp("admin");
      }).property(),

      disabled: (function () {
        if (this.get('model.saving')) return true;
        if (Ember.isEmpty(this.get('emailOrUsername'))) return true;
        var emailOrUsername = this.get('emailOrUsername').trim();
        // when inviting to forum, email must be valid
        if (!this.get('invitingToTopic') && !Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // normal users (not admin) can't invite users to private topic via email
        if (!this.get('isAdmin') && this.get('isPrivateTopic') && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // when inviting to private topic via email, group name must be specified
        if (this.get('isPrivateTopic') && Ember.isEmpty(this.get('model.groupNames')) && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        if (this.get('model.details.can_invite_to')) return false;
        return false;
      }).property('isAdmin', 'emailOrUsername', 'invitingToTopic', 'isPrivateTopic', 'model.groupNames', 'model.saving'),

      disabledCopyLink: (function () {
        if (this.get('model.saving')) return true;
        if (Ember.isEmpty(this.get('emailOrUsername'))) return true;
        var emailOrUsername = this.get('emailOrUsername').trim();
        // email must be valid
        if (!Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // normal users (not admin) can't invite users to private topic via email
        if (!this.get('isAdmin') && this.get('isPrivateTopic') && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // when inviting to private topic via email, group name must be specified
        if (this.get('isPrivateTopic') && Ember.isEmpty(this.get('model.groupNames')) && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        return false;
      }).property('emailOrUsername', 'model.saving', 'isPrivateTopic', 'model.groupNames'),

      buttonTitle: (function () {
        return this.get('model.saving') ? 'topic.inviting' : 'topic.invite_reply.action';
      }).property('model.saving'),

      // We are inviting to a topic if the model isn't the current user.
      // The current user would mean we are inviting to the forum in general.
      invitingToTopic: (function () {
        return this.get('model') !== this.currentUser;
      }).property('model'),

      showCopyInviteButton: (function () {
        return !Discourse.SiteSettings.enable_sso && !this.get('isMessage');
      }).property('isMessage'),

      topicId: Ember.computed.alias('model.id'),

      // Is Private Topic? (i.e. visible only to specific group members)
      isPrivateTopic: Em.computed.and('invitingToTopic', 'model.category.read_restricted'),

      // Is Private Message?
      isMessage: Em.computed.equal('model.archetype', 'private_message'),

      // Allow Existing Members? (username autocomplete)
      allowExistingMembers: (function () {
        return this.get('invitingToTopic');
      }).property('invitingToTopic'),

      // Show Groups? (add invited user to private group)
      showGroups: (function () {
        return this.get('isAdmin') && (Discourse.Utilities.emailValid(this.get('emailOrUsername')) || this.get('isPrivateTopic') || !this.get('invitingToTopic')) && !Discourse.SiteSettings.enable_sso && Discourse.SiteSettings.enable_local_logins && !this.get('isMessage');
      }).property('isAdmin', 'emailOrUsername', 'isPrivateTopic', 'isMessage', 'invitingToTopic'),

      // Instructional text for the modal.
      inviteInstructions: (function () {
        if (Discourse.SiteSettings.enable_sso || !Discourse.SiteSettings.enable_local_logins) {
          // inviting existing user when SSO enabled
          return I18n.t('topic.invite_reply.sso_enabled');
        } else if (this.get('isMessage')) {
          // inviting to a message
          return I18n.t('topic.invite_private.email_or_username');
        } else if (this.get('invitingToTopic')) {
          // inviting to a private/public topic
          if (this.get('isPrivateTopic') && !this.get('isAdmin')) {
            // inviting to a private topic and is not admin
            return I18n.t('topic.invite_reply.to_username');
          } else {
            // when inviting to a topic, display instructions based on provided entity
            if (Ember.isEmpty(this.get('emailOrUsername'))) {
              return I18n.t('topic.invite_reply.to_topic_blank');
            } else if (Discourse.Utilities.emailValid(this.get('emailOrUsername'))) {
              return I18n.t('topic.invite_reply.to_topic_email');
            } else {
              return I18n.t('topic.invite_reply.to_topic_username');
            }
          }
        } else {
          // inviting to forum
          return I18n.t('topic.invite_reply.to_forum');
        }
      }).property('isMessage', 'invitingToTopic', 'emailOrUsername'),

      // Instructional text for the group selection.
      groupInstructions: (function () {
        return this.get('isPrivateTopic') ? I18n.t('topic.automatically_add_to_groups_required') : I18n.t('topic.automatically_add_to_groups_optional');
      }).property('isPrivateTopic'),

      groupFinder: function (term) {
        var Group = require('discourse/models/group').default;
        return Group.findAll({ search: term, ignore_automatic: true });
      },

      successMessage: (function () {
        if (this.get('model.inviteLink')) {
          return I18n.t('user.invited.generated_link_message', { inviteLink: this.get('model.inviteLink'), invitedEmail: this.get('emailOrUsername') });
        } else if (this.get('isMessage')) {
          return I18n.t('topic.invite_private.success');
        } else if (Discourse.Utilities.emailValid(this.get('emailOrUsername'))) {
          return I18n.t('topic.invite_reply.success_email', { emailOrUsername: this.get('emailOrUsername') });
        } else {
          return I18n.t('topic.invite_reply.success_username');
        }
      }).property('model.inviteLink', 'isMessage', 'emailOrUsername'),

      errorMessage: (function () {
        return this.get('isMessage') ? I18n.t('topic.invite_private.error') : I18n.t('topic.invite_reply.error');
      }).property('isMessage'),

      placeholderKey: (function () {
        return Discourse.SiteSettings.enable_sso || !Discourse.SiteSettings.enable_local_logins ? 'topic.invite_reply.username_placeholder' : 'topic.invite_private.email_or_username_placeholder';
      }).property(),

      // Reset the modal to allow a new user to be invited.
      reset: function () {
        this.set('emailOrUsername', null);
        this.get('model').setProperties({
          groupNames: null,
          error: false,
          saving: false,
          finished: false,
          inviteLink: null
        });
      },

      actions: {

        createInvite: function () {
          var _this = this;

          var Invite = require('discourse/models/invite').default;

          if (this.get('disabled')) {
            return;
          }

          var groupNames = this.get('model.groupNames'),
              userInvitedController = this.get('controllers.user-invited-show'),
              model = this.get('model');

          model.setProperties({ saving: true, error: false });

          return this.get('model').createInvite(this.get('emailOrUsername').trim(), groupNames).then(function (result) {
            model.setProperties({ saving: false, finished: true });
            if (!_this.get('invitingToTopic')) {
              Invite.findInvitedBy(_this.currentUser, userInvitedController.get('filter')).then(function (invite_model) {
                userInvitedController.set('model', invite_model);
                userInvitedController.set('totalInvites', invite_model.invites.length);
              });
            } else if (_this.get('isMessage') && result && result.user) {
              _this.get('model.details.allowed_users').pushObject(result.user);
            }
          }).catch(function () {
            return model.setProperties({ saving: false, error: true });
          });
        },

        generateInvitelink: function () {
          var _this2 = this;

          var Invite = require('discourse/models/invite').default;

          if (this.get('disabled')) {
            return;
          }

          var groupNames = this.get('model.groupNames'),
              userInvitedController = this.get('controllers.user-invited-show'),
              model = this.get('model');

          var topicId = null;
          if (this.get('invitingToTopic')) {
            topicId = this.get('model.id');
          }

          model.setProperties({ saving: true, error: false });

          return this.get('model').generateInviteLink(this.get('emailOrUsername').trim(), groupNames, topicId).then(function (result) {
            model.setProperties({ saving: false, finished: true, inviteLink: result });
            Invite.findInvitedBy(_this2.currentUser, userInvitedController.get('filter')).then(function (invite_model) {
              userInvitedController.set('model', invite_model);
              userInvitedController.set('totalInvites', invite_model.invites.length);
            });
          }).catch(function () {
            return model.setProperties({ saving: false, error: true });
          });
        }
      }

    });
  });define("discourse/controllers/keyboard-shortcuts-help", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal'],

      onShow: function () {
        this.set('controllers.modal.modalClass', 'keyboard-shortcuts-modal');
      }
    });
  });define("discourse/controllers/login", 
  ["discourse/mixins/modal-functionality","discourse/lib/show-modal","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var showModal = __dependency2__["default"];
    var setting = __dependency3__.setting;

    // This is happening outside of the app via popup
    var AuthErrors = ['requires_invite', 'awaiting_approval', 'awaiting_confirmation', 'admin_not_allowed_from_ip_address', 'not_allowed_from_ip_address'];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal', 'createAccount', 'forgotPassword', 'application'],
      authenticate: null,
      loggingIn: false,
      loggedIn: false,

      canLoginLocal: setting('enable_local_logins'),
      loginRequired: Em.computed.alias('controllers.application.loginRequired'),

      resetForm: function () {
        this.set('authenticate', null);
        this.set('loggingIn', false);
        this.set('loggedIn', false);
      },

      /**
       Determines whether at least one login button is enabled
      **/
      hasAtLeastOneLoginButton: (function () {
        return Em.get("Discourse.LoginMethod.all").length > 0;
      }).property("Discourse.LoginMethod.all.@each"),

      loginButtonText: (function () {
        return this.get('loggingIn') ? I18n.t('login.logging_in') : I18n.t('login.title');
      }).property('loggingIn'),

      loginDisabled: Em.computed.or('loggingIn', 'loggedIn'),

      showSignupLink: (function () {
        return this.get('controllers.application.canSignUp') && !this.get('loggingIn') && Ember.isEmpty(this.get('authenticate'));
      }).property('loggingIn', 'authenticate'),

      showSpinner: (function () {
        return this.get('loggingIn') || this.get('authenticate');
      }).property('loggingIn', 'authenticate'),

      actions: {
        login: function () {
          var self = this;

          if (Ember.isEmpty(this.get('loginName')) || Ember.isEmpty(this.get('loginPassword'))) {
            self.flash(I18n.t('login.blank_username_or_password'), 'error');
            return;
          }

          this.set('loggingIn', true);

          Discourse.ajax("/session", {
            data: { login: this.get('loginName'), password: this.get('loginPassword') },
            type: 'POST'
          }).then(function (result) {
            // Successful login
            if (result.error) {
              self.set('loggingIn', false);
              if (result.reason === 'not_activated') {
                self.send('showNotActivated', {
                  username: self.get('loginName'),
                  sentTo: result.sent_to_email,
                  currentEmail: result.current_email
                });
              } else {
                self.flash(result.error, 'error');
              }
            } else {
              self.set('loggedIn', true);
              // Trigger the browser's password manager using the hidden static login form:
              var $hidden_login_form = $('#hidden-login-form');
              var destinationUrl = $.cookie('destination_url');
              var shouldRedirectToUrl = self.session.get("shouldRedirectToUrl");
              var ssoDestinationUrl = $.cookie('sso_destination_url');
              $hidden_login_form.find('input[name=username]').val(self.get('loginName'));
              $hidden_login_form.find('input[name=password]').val(self.get('loginPassword'));

              if (ssoDestinationUrl) {
                $.cookie('sso_destination_url', null);
                window.location.assign(ssoDestinationUrl);
                return;
              } else if (destinationUrl) {
                // redirect client to the original URL
                $.cookie('destination_url', null);
                $hidden_login_form.find('input[name=redirect]').val(destinationUrl);
              } else if (shouldRedirectToUrl) {
                self.session.set("shouldRedirectToUrl", null);
                $hidden_login_form.find('input[name=redirect]').val(shouldRedirectToUrl);
              } else {
                $hidden_login_form.find('input[name=redirect]').val(window.location.href);
              }

              if (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) && navigator.userAgent.match(/Safari/g)) {
                // In case of Safari on iOS do not submit hidden login form
                window.location.href = $hidden_login_form.find('input[name=redirect]').val();
              } else {
                $hidden_login_form.submit();
              }
              return;
            }
          }, function (e) {
            // Failed to login
            if (e.jqXHR && e.jqXHR.status === 429) {
              self.flash(I18n.t('login.rate_limit'), 'error');
            } else {
              self.flash(I18n.t('login.error'), 'error');
            }
            self.set('loggingIn', false);
          });

          return false;
        },

        externalLogin: function (loginMethod) {
          var _this = this;

          var name = loginMethod.get("name");
          var customLogin = loginMethod.get("customLogin");

          if (customLogin) {
            customLogin();
          } else {
            var authUrl = Discourse.getURL("/auth/" + name);
            if (loginMethod.get("fullScreenLogin")) {
              window.location = authUrl;
            } else {
              (function () {
                _this.set('authenticate', name);
                var left = _this.get('lastX') - 400;
                var top = _this.get('lastY') - 200;

                var height = loginMethod.get("frameHeight") || 400;
                var width = loginMethod.get("frameWidth") || 800;
                var w = window.open(authUrl, "_blank", "menubar=no,status=no,height=" + height + ",width=" + width + ",left=" + left + ",top=" + top);
                var self = _this;
                var timer = setInterval(function () {
                  if (!w || w.closed) {
                    clearInterval(timer);
                    self.set('authenticate', null);
                  }
                }, 1000);
              })();
            }
          }
        },

        createAccount: function () {
          var createAccountController = this.get('controllers.createAccount');
          if (createAccountController) {
            createAccountController.resetForm();
            var loginName = this.get('loginName');
            if (loginName && loginName.indexOf('@') > 0) {
              createAccountController.set("accountEmail", loginName);
            } else {
              createAccountController.set("accountUsername", loginName);
            }
          }
          this.send('showCreateAccount');
        },

        forgotPassword: function () {
          var forgotPasswordController = this.get('controllers.forgotPassword');
          if (forgotPasswordController) {
            forgotPasswordController.set("accountEmailOrUsername", this.get("loginName"));
          }
          this.send("showForgotPassword");
        }
      },

      authMessage: (function () {
        if (Ember.isEmpty(this.get('authenticate'))) return "";
        var method = Discourse.get('LoginMethod.all').findProperty("name", this.get("authenticate"));
        if (method) {
          return method.get('message');
        }
      }).property('authenticate'),

      authenticationComplete: function (options) {

        var self = this;
        function loginError(errorMsg, className) {
          showModal('login');
          Ember.run.next(function () {
            self.flash(errorMsg, className || 'success');
            self.set('authenticate', null);
          });
        }

        for (var i = 0; i < AuthErrors.length; i++) {
          var cond = AuthErrors[i];
          if (options[cond]) {
            return loginError(I18n.t("login." + cond));
          }
        }

        if (options.suspended) {
          return loginError(options.suspended_message, 'error');
        }

        // Reload the page if we're authenticated
        if (options.authenticated) {
          var destinationUrl = $.cookie('destination_url');
          var shouldRedirectToUrl = self.session.get("shouldRedirectToUrl");
          if (self.get('loginRequired') && destinationUrl) {
            // redirect client to the original URL
            $.cookie('destination_url', null);
            window.location.href = destinationUrl;
          } else if (shouldRedirectToUrl) {
            self.session.set("shouldRedirectToUrl", null);
            window.location.href = shouldRedirectToUrl;
          } else if (window.location.pathname === Discourse.getURL('/login')) {
            window.location.pathname = Discourse.getURL('/');
          } else {
            window.location.reload();
          }
          return;
        }

        var createAccountController = this.get('controllers.createAccount');
        createAccountController.setProperties({
          accountEmail: options.email,
          accountUsername: options.username,
          accountName: options.name,
          authOptions: Ember.Object.create(options)
        });
        showModal('createAccount');
      }

    });
  });define("discourse/controllers/merge-topic", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var movePosts = __dependency3__.movePosts;
    var mergeTopic = __dependency3__.mergeTopic;
    var DiscourseURL = __dependency4__["default"];

    // Modal related to merging of topics
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],

      saving: false,
      selectedTopicId: null,

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      selectedReplies: Em.computed.alias('topicController.selectedReplies'),
      allPostsSelected: Em.computed.alias('topicController.allPostsSelected'),

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('selectedTopicId'));
      }).property('selectedTopicId', 'saving'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.merge_topic.title');
      }).property('saving'),

      onShow: function () {
        this.set('controllers.modal.modalClass', 'split-modal');
      },

      actions: {
        movePostsToExistingTopic: function () {
          var topicId = this.get('model.id');

          this.set('saving', true);

          var promise = null;
          if (this.get('allPostsSelected')) {
            promise = mergeTopic(topicId, this.get('selectedTopicId'));
          } else {
            var postIds = this.get('selectedPosts').map(function (p) {
              return p.get('id');
            });
            var replyPostIds = this.get('selectedReplies').map(function (p) {
              return p.get('id');
            });

            promise = movePosts(topicId, {
              destination_topic_id: this.get('selectedTopicId'),
              post_ids: postIds,
              reply_post_ids: replyPostIds
            });
          }

          var self = this;
          promise.then(function (result) {
            // Posts moved
            self.send('closeModal');
            self.get('topicController').send('toggleMultiSelect');
            Em.run.next(function () {
              DiscourseURL.routeTo(result.url);
            });
          }).catch(function () {
            self.flash(I18n.t('topic.merge_topic.error'));
          }).finally(function () {
            self.set('saving', false);
          });
          return false;
        }
      }

    });
  });define("discourse/controllers/modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend();
  });define("discourse/controllers/navigation/categories", 
  ["discourse/controllers/navigation/default","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NavigationDefaultController = __dependency1__["default"];

    __exports__["default"] = NavigationDefaultController.extend();
  });define("discourse/controllers/navigation/category", 
  ["ember-addons/ember-computed-decorators","discourse/controllers/navigation/default","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var NavigationDefaultController = __dependency2__["default"];
    var setting = __dependency3__.setting;

    __exports__["default"] = NavigationDefaultController.extend(_createDecoratedObject([{
      key: 'subcategoryListSetting',
      initializer: function () {
        return setting('show_subcategory_list');
      }
    }, {
      key: 'showingParentCategory',
      initializer: function () {
        return Em.computed.none('category.parentCategory');
      }
    }, {
      key: 'showingSubcategoryList',
      initializer: function () {
        return Em.computed.and('subcategoryListSetting', 'showingParentCategory');
      }
    }, {
      key: 'navItems',
      decorators: [computed("showingSubcategoryList", "category", "noSubcategories")],
      value: function (showingSubcategoryList, category, noSubcategories) {
        if (showingSubcategoryList) {
          return [];
        }
        return Discourse.NavItem.buildList(category, { noSubcategories: noSubcategories });
      }
    }]));
  });define("discourse/controllers/not-activated", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      emailSent: false,

      onShow: function () {
        this.set("emailSent", false);
      },

      actions: {
        sendActivationEmail: function () {
          Discourse.ajax('/users/action/send_activation_email', { data: { username: this.get('username') }, type: 'POST' });
          this.set('emailSent', true);
        }
      }

    });
  });define("discourse/controllers/post-enqueued", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      description: Ember.computed('model.reason', function () {
        var reason = this.get('model.reason');
        return reason ? I18n.t('queue_reason.' + reason + '.description') : I18n.t('queue.approval.description');
      })
    });
  });define("discourse/controllers/preferences", 
  ["discourse/lib/computed","discourse/mixins/can-check-emails","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var setting = __dependency1__.setting;
    var CanCheckEmails = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;
    var computed = __dependency4__["default"];

    __exports__["default"] = Ember.Controller.extend(CanCheckEmails, _createDecoratedObject([{
      key: 'selectedCategories',
      decorators: [computed("model.watchedCategories", "model.trackedCategories", "model.mutedCategories")],
      value: function (watched, tracked, muted) {
        return [].concat(watched, tracked, muted);
      }
    }, {
      key: 'saved',

      // By default we haven't saved anything
      initializer: function () {
        return false;
      }
    }, {
      key: 'newNameInput',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFields',
      decorators: [computed("model.user_fields.@each.value")],
      value: function () {
        var _this = this;

        var siteUserFields = this.site.get('user_fields');
        if (!Ember.isEmpty(siteUserFields)) {
          var _ret = (function () {
            var userFields = _this.get('model.user_fields');

            // Staff can edit fields that are not `editable`
            if (!_this.get('currentUser.staff')) {
              siteUserFields = siteUserFields.filterProperty('editable', true);
            }
            return {
              v: siteUserFields.sortBy('position').map(function (field) {
                var value = userFields ? userFields[field.get('id').toString()] : null;
                return Ember.Object.create({ value: value, field: field });
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    }, {
      key: 'cannotDeleteAccount',
      initializer: function () {
        return Em.computed.not('can_delete_account');
      }
    }, {
      key: 'deleteDisabled',
      initializer: function () {
        return Em.computed.or('saving', 'deleting', 'cannotDeleteAccount');
      }
    }, {
      key: 'canEditName',
      initializer: function () {
        return setting('enable_names');
      }
    }, {
      key: 'nameInstructions',
      decorators: [computed()],
      value: function () {
        return I18n.t(this.siteSettings.full_name_required ? 'user.name.instructions_required' : 'user.name.instructions');
      }
    }, {
      key: 'canSelectTitle',
      decorators: [computed("model.has_title_badges")],
      value: function (hasTitleBadges) {
        return this.siteSettings.enable_badges && hasTitleBadges;
      }
    }, {
      key: 'canChangePassword',
      decorators: [computed()],
      value: function () {
        return !this.siteSettings.enable_sso && this.siteSettings.enable_local_logins;
      }
    }, {
      key: 'canReceiveDigest',
      decorators: [computed()],
      value: function () {
        return !this.siteSettings.disable_digest_emails;
      }
    }, {
      key: 'availableLocales',
      decorators: [computed()],
      value: function () {
        return this.siteSettings.available_locales.split('|').map(function (s) {
          return { name: s, value: s };
        });
      }
    }, {
      key: 'digestFrequencies',
      initializer: function () {
        return [{ name: I18n.t('user.email_digests.daily'), value: 1 }, { name: I18n.t('user.email_digests.every_three_days'), value: 3 }, { name: I18n.t('user.email_digests.weekly'), value: 7 }, { name: I18n.t('user.email_digests.every_two_weeks'), value: 14 }];
      }
    }, {
      key: 'autoTrackDurations',
      initializer: function () {
        return [{ name: I18n.t('user.auto_track_options.never'), value: -1 }, { name: I18n.t('user.auto_track_options.immediately'), value: 0 }, { name: I18n.t('user.auto_track_options.after_30_seconds'), value: 30000 }, { name: I18n.t('user.auto_track_options.after_1_minute'), value: 60000 }, { name: I18n.t('user.auto_track_options.after_2_minutes'), value: 120000 }, { name: I18n.t('user.auto_track_options.after_3_minutes'), value: 180000 }, { name: I18n.t('user.auto_track_options.after_4_minutes'), value: 240000 }, { name: I18n.t('user.auto_track_options.after_5_minutes'), value: 300000 }, { name: I18n.t('user.auto_track_options.after_10_minutes'), value: 600000 }];
      }
    }, {
      key: 'considerNewTopicOptions',
      initializer: function () {
        return [{ name: I18n.t('user.new_topic_duration.not_viewed'), value: -1 }, { name: I18n.t('user.new_topic_duration.after_1_day'), value: 60 * 24 }, { name: I18n.t('user.new_topic_duration.after_2_days'), value: 60 * 48 }, { name: I18n.t('user.new_topic_duration.after_1_week'), value: 7 * 60 * 24 }, { name: I18n.t('user.new_topic_duration.after_2_weeks'), value: 2 * 7 * 60 * 24 }, { name: I18n.t('user.new_topic_duration.last_here'), value: -2 }];
      }
    }, {
      key: 'saveButtonText',
      decorators: [computed("model.isSaving")],
      value: function (isSaving) {
        return isSaving ? I18n.t('saving') : I18n.t('save');
      }
    }, {
      key: 'passwordProgress',
      initializer: function () {
        return null;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          save: function () {
            var _this2 = this;

            this.set('saved', false);

            var model = this.get('model');
            var userFields = this.get('userFields');

            // Update the user fields
            if (!Ember.isEmpty(userFields)) {
              (function () {
                var modelFields = model.get('user_fields');
                if (!Ember.isEmpty(modelFields)) {
                  userFields.forEach(function (uf) {
                    modelFields[uf.get('field.id').toString()] = uf.get('value');
                  });
                }
              })();
            }

            // Cook the bio for preview
            model.set('name', this.get('newNameInput'));
            return model.save().then(function () {
              if (Discourse.User.currentProp('id') === model.get('id')) {
                Discourse.User.currentProp('name', model.get('name'));
              }
              model.set('bio_cooked', Discourse.Markdown.cook(Discourse.Markdown.sanitize(model.get('bio_raw'))));
              _this2.set('saved', true);
            }).catch(popupAjaxError);
          },

          changePassword: function () {
            var _this3 = this;

            if (!this.get('passwordProgress')) {
              this.set('passwordProgress', I18n.t("user.change_password.in_progress"));
              return this.get('model').changePassword().then(function () {
                // password changed
                _this3.setProperties({
                  changePasswordProgress: false,
                  passwordProgress: I18n.t("user.change_password.success")
                });
              }).catch(function () {
                // password failed to change
                _this3.setProperties({
                  changePasswordProgress: false,
                  passwordProgress: I18n.t("user.change_password.error")
                });
              });
            }
          },

          delete: function () {
            var _this4 = this;

            this.set('deleting', true);
            var self = this,
                message = I18n.t('user.delete_account_confirm'),
                model = this.get('model'),
                buttons = [{ label: I18n.t("cancel"),
              class: "cancel-inline",
              link: true,
              callback: function () {
                _this4.set('deleting', false);
              }
            }, { label: '<i class="fa fa-exclamation-triangle"></i> ' + I18n.t("user.delete_account"),
              class: "btn btn-danger",
              callback: function () {
                model.delete().then(function () {
                  bootbox.alert(I18n.t('user.deleted_yourself'), function () {
                    window.location.pathname = Discourse.getURL('/');
                  });
                }, function () {
                  bootbox.alert(I18n.t('user.delete_yourself_not_allowed'));
                  self.set('deleting', false);
                });
              }
            }];
            bootbox.dialog(message, buttons, { "classes": "delete-account" });
          }
        };
      }
    }]));
  });define("discourse/controllers/preferences/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      saving: false,
      newBio: null,

      saveButtonText: (function () {
        return this.get('saving') ? I18n.t("saving") : I18n.t('user.change');
      }).property('saving')

    });
  });define("discourse/controllers/preferences/badge-title", 
  ["discourse/mixins/badge-select-controller","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var BadgeSelectController = __dependency1__["default"];

    __exports__["default"] = Ember.ArrayController.extend(BadgeSelectController, {

      filteredList: (function () {
        return this.get('model').filterBy('badge.allow_title', true);
      }).property('model'),

      actions: {
        save: function () {
          this.setProperties({ saved: false, saving: true });

          var self = this;
          Discourse.ajax(this.get('user.path') + "/preferences/badge_title", {
            type: "PUT",
            data: { user_badge_id: self.get('selectedUserBadgeId') }
          }).then(function () {
            self.setProperties({
              saved: true,
              saving: false,
              "user.title": self.get('selectedUserBadge.badge.name')
            });
          }, function () {
            bootbox.alert(I18n.t('generic_error'));
          });
        }
      }
    });
  });define("discourse/controllers/preferences/card-badge", 
  ["discourse/mixins/badge-select-controller","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var BadgeSelectController = __dependency1__["default"];

    __exports__["default"] = Ember.ArrayController.extend(BadgeSelectController, {
      filteredList: (function () {
        return this.get('model').filter(function (b) {
          return !Ember.isEmpty(b.get('badge.image'));
        });
      }).property('model'),

      actions: {
        save: function () {
          this.setProperties({ saved: false, saving: true });

          var self = this;
          Discourse.ajax(this.get('user.path') + "/preferences/card-badge", {
            type: "PUT",
            data: { user_badge_id: self.get('selectedUserBadgeId') }
          }).then(function () {
            self.setProperties({
              saved: true,
              saving: false,
              "user.card_image_badge": self.get('selectedUserBadge.badge.image')
            });
          }).catch(function () {
            self.set('saving', false);
            bootbox.alert(I18n.t('generic_error'));
          });
        }
      }
    });
  });define("discourse/controllers/preferences/email", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Ember.Controller.extend({
      taken: false,
      saving: false,
      error: false,
      success: false,
      newEmail: null,

      newEmailEmpty: Em.computed.empty('newEmail'),
      saveDisabled: Em.computed.or('saving', 'newEmailEmpty', 'taken', 'unchanged'),
      unchanged: propertyEqual('newEmailLower', 'email'),

      newEmailLower: (function () {
        return this.get('newEmail').toLowerCase();
      }).property('newEmail'),

      saveButtonText: (function () {
        if (this.get('saving')) return I18n.t("saving");
        return I18n.t("user.change");
      }).property('saving'),

      actions: {
        changeEmail: function () {
          var self = this;
          this.set('saving', true);
          return this.get('content').changeEmail(this.get('newEmail')).then(function () {
            self.set('success', true);
          }, function (data) {
            self.setProperties({ error: true, saving: false });
            if (data.responseJSON && data.responseJSON.errors && data.responseJSON.errors[0]) {
              self.set('errorMessage', data.responseJSON.errors[0]);
            } else {
              self.set('errorMessage', I18n.t('user.change_email.error'));
            }
          });
        }
      }

    });
  });define("discourse/controllers/preferences/username", 
  ["discourse/lib/computed","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var propertyEqual = __dependency1__.propertyEqual;
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend({
      taken: false,
      saving: false,
      error: false,
      errorMessage: null,
      newUsername: null,

      maxLength: setting('max_username_length'),
      minLength: setting('min_username_length'),
      newUsernameEmpty: Em.computed.empty('newUsername'),
      saveDisabled: Em.computed.or('saving', 'newUsernameEmpty', 'taken', 'unchanged', 'errorMessage'),
      unchanged: propertyEqual('newUsername', 'username'),

      checkTaken: (function () {
        if (this.get('newUsername') && this.get('newUsername').length < this.get('minLength')) {
          this.set('errorMessage', I18n.t('user.name.too_short'));
        } else {
          var self = this;
          this.set('taken', false);
          this.set('errorMessage', null);
          if (Ember.isEmpty(this.get('newUsername'))) return;
          if (this.get('unchanged')) return;
          Discourse.User.checkUsername(this.get('newUsername'), undefined, this.get('content.id')).then(function (result) {
            if (result.errors) {
              self.set('errorMessage', result.errors.join(' '));
            } else if (result.available === false) {
              self.set('taken', true);
            }
          });
        }
      }).observes('newUsername'),

      saveButtonText: (function () {
        if (this.get('saving')) return I18n.t("saving");
        return I18n.t("user.change");
      }).property('saving'),

      actions: {
        changeUsername: function () {
          var self = this;
          return bootbox.confirm(I18n.t("user.change_username.confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (result) {
            if (result) {
              self.set('saving', true);
              self.get('content').changeUsername(self.get('newUsername')).then(function () {
                DiscourseURL.redirectTo("/users/" + self.get('newUsername').toLowerCase() + "/preferences");
              }, function () {
                // error
                self.set('error', true);
                self.set('saving', false);
              });
            }
          });
        }
      }

    });
  });define("discourse/controllers/queued-post", 
  ["discourse/lib/computed","discourse/mixins/buffered-content","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var BufferedContent = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;

    function updateState(state, opts) {
      opts = opts || {};

      return function () {
        var _this = this;

        var post = this.get('post');
        var args = { state: state };

        if (opts.deleteUser) {
          args.delete_user = true;
        }

        post.update(args).then(function () {
          _this.get('controllers.queued-posts.model').removeObject(post);
        }).catch(popupAjaxError);
      };
    }

    __exports__["default"] = Ember.Controller.extend(BufferedContent, {
      needs: ['queued-posts'],
      post: Ember.computed.alias('model'),
      currentlyEditing: Ember.computed.alias('controllers.queued-posts.editing'),

      editing: propertyEqual('model', 'currentlyEditing'),

      _confirmDelete: updateState('rejected', { deleteUser: true }),

      actions: {
        approve: updateState('approved'),
        reject: updateState('rejected'),

        deleteUser: function () {
          var _this2 = this;

          bootbox.confirm(I18n.t('queue.delete_prompt', { username: this.get('model.user.username') }), function (confirmed) {
            if (confirmed) {
              _this2._confirmDelete();
            }
          });
        },

        edit: function () {
          var _this3 = this;

          // This is stupid but pagedown cannot be on the screen twice or it will break
          this.set('currentlyEditing', null);
          Ember.run.scheduleOnce('afterRender', function () {
            return _this3.set('currentlyEditing', _this3.get('model'));
          });
        },

        confirmEdit: function () {
          var _this4 = this;

          this.get('post').update({ raw: this.get('buffered.raw') }).then(function () {
            _this4.commitBuffer();
            _this4.set('currentlyEditing', null);
          });
        },

        cancelEdit: function () {
          this.rollbackBuffer();
          this.set('currentlyEditing', null);
        }
      }
    });
  });define("discourse/controllers/quote-button", 
  ["discourse/lib/load-script","discourse/lib/quote","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var loadScript = __dependency1__["default"];
    var Quote = __dependency2__["default"];
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic', 'composer'];
      }
    }, {
      key: '_loadSanitizer',
      initializer: function () {
        return (function () {
          loadScript('defer/html-sanitizer-bundle');
        }).on('init');
      }
    }, {
      key: 'post',
      decorators: [computed('buffer', 'postId')],
      value: function (buffer, postId) {
        if (!postId || Ember.isEmpty(buffer)) {
          return null;
        }

        var postStream = this.get('controllers.topic.model.postStream');
        var post = postStream.findLoadedPost(postId);

        return post;
      }
    }, {
      key: 'selectText',

      // Save the currently selected text and displays the
      //  "quote reply" button
      value: function (postId) {
        // anonymous users cannot "quote-reply"
        if (!this.currentUser) return;

        // don't display the "quote-reply" button if we can't reply
        var topicDetails = this.get('controllers.topic.model.details');
        if (!(topicDetails.get('can_reply_as_new_topic') || topicDetails.get('can_create_post'))) {
          return;
        }

        var selection = window.getSelection();

        // no selections
        if (selection.isCollapsed) {
          this.set('buffer', '');
          return;
        }

        // retrieve the selected range
        var range = selection.getRangeAt(0),
            cloned = range.cloneRange(),
            $ancestor = $(range.commonAncestorContainer);

        if ($ancestor.closest('.cooked').length === 0) {
          this.set('buffer', '');
          return;
        }

        var selectedText = Discourse.Utilities.selectedText();
        if (this.get('buffer') === selectedText) return;

        // we need to retrieve the post data from the posts collection in the topic controller
        this.set('postId', postId);
        this.set('buffer', selectedText);

        // create a marker element
        var markerElement = document.createElement("span");
        // containing a single invisible character
        markerElement.appendChild(document.createTextNode("\ufeff"));

        // collapse the range at the beginning/end of the selection
        range.collapse(!Discourse.Mobile.isMobileDevice);
        // and insert it at the start of our selection range
        range.insertNode(markerElement);

        // retrieve the position of the marker
        var markerOffset = $(markerElement).offset(),
            $quoteButton = $('.quote-button');

        // remove the marker
        markerElement.parentNode.removeChild(markerElement);

        // work around Chrome that would sometimes lose the selection
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(cloned);

        // move the quote button above the marker
        Em.run.schedule('afterRender', function () {
          var topOff = markerOffset.top;
          var leftOff = markerOffset.left;

          if (Discourse.Mobile.isMobileDevice) {
            topOff = topOff + 20;
            leftOff = Math.min(leftOff + 10, $(window).width() - $quoteButton.outerWidth());
          } else {
            topOff = topOff - $quoteButton.outerHeight() - 5;
          }

          $quoteButton.offset({ top: topOff, left: leftOff });
        });
      }
    }, {
      key: 'quoteText',
      value: function () {
        var _this = this;

        var Composer = require('discourse/models/composer').default;
        var postId = this.get('postId');
        var post = this.get('post');

        // defer load if needed, if in an expanded replies section
        if (!post) {
          var postStream = this.get('controllers.topic.model.postStream');
          return postStream.loadPost(postId).then(function (p) {
            _this.set('post', p);
            return _this.quoteText();
          });
        }

        // If we can't create a post, delegate to reply as new topic
        if (!this.get('controllers.topic.model.details.can_create_post')) {
          this.get('controllers.topic').send('replyAsNewTopic', post);
          return;
        }

        var composerController = this.get('controllers.composer');
        var composerOpts = {
          action: Composer.REPLY,
          draftKey: post.get('topic.draft_key')
        };

        if (post.get('post_number') === 1) {
          composerOpts.topic = post.get("topic");
        } else {
          composerOpts.post = post;
        }

        // If the composer is associated with a different post, we don't change it.
        var composerPost = composerController.get('content.post');
        if (composerPost && composerPost.get('id') !== this.get('post.id')) {
          composerOpts.post = composerPost;
        }

        var buffer = this.get('buffer');
        var quotedText = Quote.build(post, buffer);
        composerOpts.quote = quotedText;
        if (composerController.get('content.viewOpen') || composerController.get('content.viewDraft')) {
          this.appEvents.trigger('composer:insert-text', quotedText.trim());
        } else {
          composerController.open(composerOpts);
        }
        this.set('buffer', '');
        return false;
      }
    }, {
      key: 'deselectText',
      value: function () {
        // clear selected text
        window.getSelection().removeAllRanges();
        // clean up the buffer
        this.set('buffer', '');
      }
    }]));
  });define("discourse/controllers/raw-email", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    // This controller handles displaying of raw email
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      rawEmail: "",

      loadRawEmail: function (postId) {
        var self = this;
        Discourse.Post.loadRawEmail(postId).then(function (result) {
          self.set("rawEmail", result);
        });
      }

    });
  });define("discourse/controllers/reorder-categories", 
  ["discourse/mixins/modal-functionality","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","ember","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    // import BufferedProxy from 'ember-buffered-proxy/proxy';
    var popupAjaxError = __dependency2__.popupAjaxError;
    var on = __dependency3__.on;
    var computed = __dependency3__.default;
    var Ember = __dependency4__["default"];

    var BufferedProxy = window.BufferedProxy;var SortableArrayProxy = Ember.ArrayProxy.extend(Ember.SortableMixin);

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, Ember.Evented, _createDecoratedObject([{
      key: '_fixOrder',
      decorators: [on('init')],
      value: function () {
        this.send('fixIndices');
      }
    }, {
      key: 'categoriesBuffered',
      decorators: [computed("site.categories")],
      value: function (categories) {
        var bufProxy = Ember.ObjectProxy.extend(BufferedProxy);
        return categories.map(function (c) {
          return bufProxy.create({ content: c });
        });
      }
    }, {
      key: 'categoriesOrdered',
      initializer: function () {
        return (function () {
          return SortableArrayProxy.create({
            sortProperties: ['content.position'],
            content: this.get('categoriesBuffered')
          });
        }).property('categoriesBuffered');
      }
    }, {
      key: 'showFixIndices',
      initializer: function () {
        return (function () {
          var cats = this.get('categoriesOrdered');
          var len = cats.get('length');
          for (var i = 0; i < len; i++) {
            if (cats.objectAt(i).get('position') !== i) {
              return true;
            }
          }
          return false;
        }).property('categoriesOrdered.@each.position');
      }
    }, {
      key: 'showApplyAll',
      initializer: function () {
        return (function () {
          var anyChanged = false;
          this.get('categoriesBuffered').forEach(function (bc) {
            anyChanged = anyChanged || bc.get('hasBufferedChanges');
          });
          return anyChanged;
        }).property('categoriesBuffered.@each.hasBufferedChanges');
      }
    }, {
      key: 'saveDisabled',
      initializer: function () {
        return Ember.computed.or('showApplyAll', 'showFixIndices');
      }
    }, {
      key: 'moveDir',
      value: function (cat, dir) {
        var cats = this.get('categoriesOrdered');
        var curIdx = cats.indexOf(cat);
        var desiredIdx = curIdx + dir;
        if (desiredIdx >= 0 && desiredIdx < cats.get('length')) {
          var curPos = cat.get('position');
          cat.set('position', curPos + dir);
          var otherCat = cats.objectAt(desiredIdx);
          otherCat.set('position', curPos - dir);
          this.send('commit');
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          moveUp: function (cat) {
            this.moveDir(cat, -1);
          },
          moveDown: function (cat) {
            this.moveDir(cat, 1);
          },

          fixIndices: function () {
            var cats = this.get('categoriesOrdered');
            var len = cats.get('length');
            for (var i = 0; i < len; i++) {
              cats.objectAt(i).set('position', i);
            }
            this.send('commit');
          },

          commit: function () {
            this.get('categoriesBuffered').forEach(function (bc) {
              if (bc.get('hasBufferedChanges')) {
                bc.applyBufferedChanges();
              }
            });
            this.propertyDidChange('categoriesBuffered');
          },

          saveOrder: function () {
            var _this = this;

            var data = {};
            this.get('categoriesBuffered').forEach(function (cat) {
              data[cat.get('id')] = cat.get('position');
            });
            Discourse.ajax('/categories/reorder', { type: 'POST', data: { mapping: JSON.stringify(data) } }).then(function () {
              return _this.send("closeModal");
            }).catch(popupAjaxError);
          }
        };
      }
    }]));
  });define("discourse/controllers/search-help", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal'],

      showGoogleSearch: (function () {
        return !Discourse.SiteSettings.login_required;
      }).property()
    });
  });define("discourse/controllers/share", 
  ["discourse/lib/sharing","discourse/lib/formatter","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Sharing = __dependency1__["default"];
    var longDateNoYear = __dependency2__.longDateNoYear;

    __exports__["default"] = Ember.Controller.extend({
      needs: ['topic'],
      title: Ember.computed.alias('controllers.topic.model.title'),

      displayDate: (function () {
        return longDateNoYear(new Date(this.get('date')));
      }).property('date'),

      // Close the share controller
      actions: {
        close: function () {
          this.setProperties({ link: '', postNumber: '' });
          return false;
        },

        share: function (source) {
          var url = source.generateUrl(this.get('link'), this.get('title'));
          if (source.shouldOpenInPopup) {
            window.open(url, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,width=600,height=' + (source.popupHeight || 315));
          } else {
            window.open(url, '_blank');
          }
        }
      },

      sources: (function () {
        return Sharing.activeSources(this.siteSettings.share_links);
      }).property()
    });
  });define("discourse/controllers/split-topic", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/lib/ajax-error","discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var extractError = __dependency3__.extractError;
    var movePosts = __dependency4__.movePosts;
    var DiscourseURL = __dependency5__["default"];

    // Modal related to auto closing of topics
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],
      topicName: null,
      saving: false,
      categoryId: null,

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      selectedReplies: Em.computed.alias('topicController.selectedReplies'),
      allPostsSelected: Em.computed.alias('topicController.allPostsSelected'),

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('topicName'));
      }).property('saving', 'topicName'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.split_topic.action');
      }).property('saving'),

      onShow: function () {
        this.setProperties({
          'controllers.modal.modalClass': 'split-modal',
          saving: false,
          categoryId: null,
          topicName: ''
        });
      },

      actions: {
        movePostsToNewTopic: function () {
          this.set('saving', true);

          var postIds = this.get('selectedPosts').map(function (p) {
            return p.get('id');
          }),
              replyPostIds = this.get('selectedReplies').map(function (p) {
            return p.get('id');
          }),
              self = this,
              categoryId = this.get('categoryId'),
              saveOpts = {
            title: this.get('topicName'),
            post_ids: postIds,
            reply_post_ids: replyPostIds
          };

          if (!Ember.isNone(categoryId)) {
            saveOpts.category_id = categoryId;
          }

          movePosts(this.get('model.id'), saveOpts).then(function (result) {
            // Posts moved
            self.send('closeModal');
            self.get('topicController').send('toggleMultiSelect');
            Ember.run.next(function () {
              DiscourseURL.routeTo(result.url);
            });
          }).catch(function (xhr) {
            self.flash(extractError(xhr, I18n.t('topic.split_topic.error')));
          }).finally(function () {
            self.set('saving', false);
          });
          return false;
        }
      }

    });
  });define("discourse/controllers/static", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      showLoginButton: Em.computed.equal("model.path", "login"),

      actions: {
        markFaqRead: function () {
          var currentUser = this.currentUser;
          if (currentUser) {
            Discourse.ajax("/users/read-faq", { method: "POST" }).then(function () {
              currentUser.set('read_faq', true);
            });
          }
        }
      }
    });
  });define("discourse/controllers/topic-bulk-actions", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    var _buttons = [];

    function addBulkButton(action, key) {
      _buttons.push({ action: action, label: "topics.bulk." + key });
    }

    // Default buttons
    addBulkButton('showChangeCategory', 'change_category');
    addBulkButton('deleteTopics', 'delete');
    addBulkButton('closeTopics', 'close_topics');
    addBulkButton('archiveTopics', 'archive_topics');
    addBulkButton('showNotificationLevel', 'notification_level');
    addBulkButton('resetRead', 'reset_read');
    addBulkButton('unlistTopics', 'unlist_topics');

    // Modal for performing bulk actions on topics
    __exports__["default"] = Ember.ArrayController.extend(ModalFunctionality, {
      buttonRows: null,

      onShow: function () {
        this.set('controllers.modal.modalClass', 'topic-bulk-actions-modal small');

        var buttonRows = [];
        var row = [];
        _buttons.forEach(function (b) {
          row.push(b);
          if (row.length === 4) {
            buttonRows.push(row);
            row = [];
          }
        });
        if (row.length) {
          buttonRows.push(row);
        }

        this.set('buttonRows', buttonRows);
        this.send('changeBulkTemplate', 'modal/bulk_actions_buttons');
      },

      perform: function (operation) {
        var _this = this;

        this.set('loading', true);

        var topics = this.get('model');
        return Discourse.Topic.bulkOperation(this.get('model'), operation).then(function (result) {
          _this.set('loading', false);
          if (result && result.topic_ids) {
            return result.topic_ids.map(function (t) {
              return topics.findBy('id', t);
            });
          }
          return result;
        }).catch(function () {
          bootbox.alert(I18n.t('generic_error'));
          _this.set('loading', false);
        });
      },

      forEachPerformed: function (operation, cb) {
        var _this2 = this;

        this.perform(operation).then(function (topics) {
          if (topics) {
            topics.forEach(cb);
            var refreshTarget = _this2.get('refreshTarget');
            if (refreshTarget) {
              refreshTarget.send('refresh');
            }
            _this2.send('closeModal');
          }
        });
      },

      performAndRefresh: function (operation) {
        var _this3 = this;

        return this.perform(operation).then(function () {
          var refreshTarget = _this3.get('refreshTarget');
          if (refreshTarget) {
            refreshTarget.send('refresh');
          }
          _this3.send('closeModal');
        });
      },

      actions: {
        showChangeCategory: function () {
          this.send('changeBulkTemplate', 'modal/bulk_change_category');
          this.set('controllers.modal.modalClass', 'topic-bulk-actions-modal full');
        },

        showNotificationLevel: function () {
          this.send('changeBulkTemplate', 'modal/bulk_notification_level');
        },

        deleteTopics: function () {
          this.performAndRefresh({ type: 'delete' });
        },

        closeTopics: function () {
          this.forEachPerformed({ type: 'close' }, function (t) {
            return t.set('closed', true);
          });
        },

        archiveTopics: function () {
          this.forEachPerformed({ type: 'archive' }, function (t) {
            return t.set('archived', true);
          });
        },

        unlistTopics: function () {
          this.forEachPerformed({ type: 'unlist' }, function (t) {
            return t.set('visible', false);
          });
        },

        changeCategory: function () {
          var _this4 = this;

          var categoryId = parseInt(this.get('newCategoryId'), 10) || 0;
          var category = Discourse.Category.findById(categoryId);

          this.perform({ type: 'change_category', category_id: categoryId }).then(function (topics) {
            topics.forEach(function (t) {
              return t.set('category', category);
            });
            var refreshTarget = _this4.get('refreshTarget');
            if (refreshTarget) {
              refreshTarget.send('refresh');
            }
            _this4.send('closeModal');
          });
        },

        resetRead: function () {
          this.performAndRefresh({ type: 'reset_read' });
        }
      }
    });

    __exports__.addBulkButton = addBulkButton;
  });define("discourse/controllers/topic-entrance", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    function entranceDate(dt, showTime) {
      var today = new Date();

      if (dt.toDateString() === today.toDateString()) {
        return moment(dt).format(I18n.t("dates.time"));
      }

      if (dt.getYear() === today.getYear()) {
        // No year
        return moment(dt).format(showTime ? I18n.t("dates.long_date_without_year_with_linebreak") : I18n.t("dates.long_no_year_no_time"));
      }

      return moment(dt).format(showTime ? I18n.t('dates.long_date_with_year_with_linebreak') : I18n.t('dates.long_date_with_year_without_time'));
    }

    __exports__["default"] = Ember.Controller.extend({
      position: null,

      createdDate: (function () {
        return new Date(this.get('model.created_at'));
      }).property('model.created_at'),

      bumpedDate: (function () {
        return new Date(this.get('model.bumped_at'));
      }).property('model.bumped_at'),

      showTime: (function () {
        var diffMs = this.get('bumpedDate').getTime() - this.get('createdDate').getTime();
        return diffMs < 1000 * 60 * 60 * 24 * 2;
      }).property('createdDate', 'bumpedDate'),

      topDate: (function () {
        return entranceDate(this.get('createdDate'), this.get('showTime'));
      }).property('createdDate'),

      bottomDate: (function () {
        return entranceDate(this.get('bumpedDate'), this.get('showTime'));
      }).property('bumpedDate'),

      actions: {
        show: function (data) {
          // Show the chooser but only if the model changes
          if (this.get('model') !== data.topic) {
            this.set('model', data.topic);
            this.set('position', data.position);
          }
        },

        enterTop: function () {
          DiscourseURL.routeTo(this.get('model.url'));
        },

        enterBottom: function () {
          DiscourseURL.routeTo(this.get('model.lastPostUrl'));
        }
      }
    });
  });define("discourse/controllers/topic-progress", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ['topic'],
      progressPosition: null,
      expanded: false,
      toPostIndex: null,

      actions: {
        toggleExpansion: function (opts) {
          this.toggleProperty('expanded');
          if (this.get('expanded')) {
            this.set('toPostIndex', this.get('progressPosition'));
            if (opts && opts.highlight) {
              // TODO: somehow move to view?
              Em.run.next(function () {
                $('.jump-form input').select().focus();
              });
            }
          }
        },

        jumpPost: function () {
          var postIndex = parseInt(this.get('toPostIndex'), 10);

          // Validate the post index first
          if (isNaN(postIndex) || postIndex < 1) {
            postIndex = 1;
          }
          if (postIndex > this.get('model.postStream.filteredPostsCount')) {
            postIndex = this.get('model.postStream.filteredPostsCount');
          }
          this.set('toPostIndex', postIndex);
          var stream = this.get('model.postStream'),
              postId = stream.findPostIdForPostNumber(postIndex);

          if (!postId) {
            Em.Logger.warn("jump-post code broken - requested an index outside the stream array");
            return;
          }

          var post = stream.findLoadedPost(postId);
          if (post) {
            this.jumpTo(this.get('model').urlForPostNumber(post.get('post_number')));
          } else {
            var self = this;
            // need to load it
            stream.findPostsByIds([postId]).then(function (arr) {
              post = arr[0];
              self.jumpTo(self.get('model').urlForPostNumber(post.get('post_number')));
            });
          }
        },

        jumpTop: function () {
          this.jumpTo(this.get('model.firstPostUrl'));
        },

        jumpBottom: function () {
          this.jumpTo(this.get('model.lastPostUrl'));
        }
      },

      // Route and close the expansion
      jumpTo: function (url) {
        this.set('expanded', false);
        DiscourseURL.routeTo(url);
      },

      streamPercentage: (function () {
        if (!this.get('model.postStream.loaded')) {
          return 0;
        }
        if (this.get('model.postStream.highest_post_number') === 0) {
          return 0;
        }
        var perc = this.get('progressPosition') / this.get('model.postStream.filteredPostsCount');
        return perc > 1.0 ? 1.0 : perc;
      }).property('model.postStream.loaded', 'progressPosition', 'model.postStream.filteredPostsCount'),

      jumpTopDisabled: (function () {
        return this.get('progressPosition') <= 3;
      }).property('progressPosition'),

      filteredPostCountChanged: (function () {
        if (this.get('model.postStream.filteredPostsCount') < this.get('progressPosition')) {
          this.set('progressPosition', this.get('model.postStream.filteredPostsCount'));
        }
      }).observes('model.postStream.filteredPostsCount'),

      jumpBottomDisabled: (function () {
        return this.get('progressPosition') >= this.get('model.postStream.filteredPostsCount') || this.get('progressPosition') >= this.get('model.highest_post_number');
      }).property('model.postStream.filteredPostsCount', 'model.highest_post_number', 'progressPosition'),

      hideProgress: (function () {
        if (!this.get('model.postStream.loaded')) return true;
        if (!this.get('model.currentPost')) return true;
        if (this.get('model.postStream.filteredPostsCount') < 2) return true;
        return false;
      }).property('model.postStream.loaded', 'model.currentPost', 'model.postStream.filteredPostsCount'),

      hugeNumberOfPosts: (function () {
        return this.get('model.postStream.filteredPostsCount') >= Discourse.SiteSettings.short_progress_text_threshold;
      }).property('model.highest_post_number'),

      jumpToBottomTitle: (function () {
        if (this.get('hugeNumberOfPosts')) {
          return I18n.t('topic.progress.jump_bottom_with_number', { post_number: this.get('model.highest_post_number') });
        } else {
          return I18n.t('topic.progress.jump_bottom');
        }
      }).property('hugeNumberOfPosts', 'model.highest_post_number')

    });
  });define("discourse/controllers/topic-unsubscribe", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({

      stopNotificiationsText: (function () {
        return I18n.t("topic.unsubscribe.stop_notifications", { title: this.get("model.fancyTitle") });
      }).property("model.fancyTitle")

    });
  });define("discourse/controllers/topic", 
  ["discourse/mixins/buffered-content","discourse/mixins/selected-posts-count","discourse/helpers/loading-spinner","discourse/models/topic","discourse/lib/quote","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var BufferedContent = __dependency1__["default"];
    var SelectedPostsCount = __dependency2__["default"];
    var spinnerHTML = __dependency3__.spinnerHTML;
    var Topic = __dependency4__["default"];
    var Quote = __dependency5__["default"];
    var popupAjaxError = __dependency6__.popupAjaxError;
    var computed = __dependency7__["default"];
    var Composer = __dependency8__["default"];

    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, BufferedContent, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['header', 'modal', 'composer', 'quote-button', 'topic-progress', 'application'];
      }
    }, {
      key: 'multiSelect',
      initializer: function () {
        return false;
      }
    }, {
      key: 'allPostsSelected',
      initializer: function () {
        return false;
      }
    }, {
      key: 'editingTopic',
      initializer: function () {
        return false;
      }
    }, {
      key: 'selectedPosts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'selectedReplies',
      initializer: function () {
        return null;
      }
    }, {
      key: 'queryParams',
      initializer: function () {
        return ['filter', 'username_filters', 'show_deleted'];
      }
    }, {
      key: 'loadedAllPosts',
      initializer: function () {
        return Em.computed.or('model.postStream.loadedAllPosts', 'model.postStream.loadingLastPost');
      }
    }, {
      key: 'enteredAt',
      initializer: function () {
        return null;
      }
    }, {
      key: 'firstPostExpanded',
      initializer: function () {
        return false;
      }
    }, {
      key: 'retrying',
      initializer: function () {
        return false;
      }
    }, {
      key: 'adminMenuVisible',
      initializer: function () {
        return false;
      }
    }, {
      key: 'showRecover',
      initializer: function () {
        return Em.computed.and('model.deleted', 'model.details.can_recover');
      }
    }, {
      key: 'isFeatured',
      initializer: function () {
        return Em.computed.or("model.pinned_at", "model.isBanner");
      }
    }, {
      key: '_titleChanged',
      initializer: function () {
        return (function () {
          var title = this.get('model.title');
          if (!Ember.isEmpty(title)) {

            // Note normally you don't have to trigger this, but topic titles can be updated
            // and are sometimes lazily loaded.
            this.send('refreshTitle');
          }
        }).observes('model.title', 'category');
      }
    }, {
      key: 'postsToRender',
      decorators: [computed('model.postStream.posts')],
      value: function () {
        return this.capabilities.isAndroid ? this.get('model.postStream.posts') : this.get('model.postStream.postsWithPlaceholders');
      }
    }, {
      key: 'androidLoading',
      decorators: [computed('model.postStream.loadingFilter')],
      value: function (loading) {
        return this.capabilities.isAndroid && loading;
      }
    }, {
      key: 'show_deleted',
      decorators: [computed('model.postStream.summary')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('show_deleted', value);
            return postStream.get('show_deleted') ? true : undefined;
          },
          get: function () {
            return this.get('postStream.show_deleted') ? true : undefined;
          }
        };
      }
    }, {
      key: 'filter',
      decorators: [computed('model.postStream.summary')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('summary', value === "summary");
            return postStream.get('summary') ? "summary" : undefined;
          },
          get: function () {
            return this.get('postStream.summary') ? "summary" : undefined;
          }
        };
      }
    }, {
      key: 'username_filters',
      decorators: [computed('model.postStream.streamFilters.username_filters')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('streamFilters.username_filters', value);
            return postStream.get('streamFilters.username_filters');
          },
          get: function () {
            return this.get('postStream.streamFilters.username_filters');
          }
        };
      }
    }, {
      key: '_clearSelected',
      initializer: function () {
        return (function () {
          this.set('selectedPosts', []);
          this.set('selectedReplies', []);
        }).on('init');
      }
    }, {
      key: 'showCategoryChooser',
      decorators: [computed("model.isPrivateMessage", "model.category_id")],
      value: function (isPrivateMessage, categoryId) {
        var category = Discourse.Category.findById(categoryId);
        var containsMessages = category && category.get("contains_messages");
        return !isPrivateMessage && !containsMessages;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          showTopicAdminMenu: function () {
            this.set('adminMenuVisible', true);
          },

          hideTopicAdminMenu: function () {
            this.set('adminMenuVisible', false);
          },

          deleteTopic: function () {
            this.deleteTopic();
          },

          // Post related methods
          replyToPost: function (post) {
            var composerController = this.get('controllers.composer'),
                quoteController = this.get('controllers.quote-button'),
                quotedText = Quote.build(quoteController.get('post'), quoteController.get('buffer')),
                topic = post ? post.get('topic') : this.get('model');

            quoteController.set('buffer', '');

            if (composerController.get('content.topic.id') === topic.get('id') && composerController.get('content.action') === Composer.REPLY) {
              composerController.set('content.post', post);
              composerController.set('content.composeState', Composer.OPEN);
              this.appEvents.trigger('composer:insert-text', quotedText.trim());
            } else {

              var opts = {
                action: Composer.REPLY,
                draftKey: topic.get('draft_key'),
                draftSequence: topic.get('draft_sequence')
              };

              if (quotedText) {
                opts.quote = quotedText;
              }

              if (post && post.get("post_number") !== 1) {
                opts.post = post;
              } else {
                opts.topic = topic;
              }

              composerController.open(opts);
            }
            return false;
          },

          recoverPost: function (post) {
            // Recovering the first post recovers the topic instead
            if (post.get('post_number') === 1) {
              this.recoverTopic();
              return;
            }
            post.recover();
          },

          deletePost: function (post) {

            // Deleting the first post deletes the topic
            if (post.get('post_number') === 1) {
              this.deleteTopic();
              return;
            }

            var user = Discourse.User.current(),
                replyCount = post.get('reply_count'),
                self = this;

            // If the user is staff and the post has replies, ask if they want to delete replies too.
            if (user.get('staff') && replyCount > 0) {
              bootbox.dialog(I18n.t("post.controls.delete_replies.confirm", { count: replyCount }), [{ label: I18n.t("cancel"),
                'class': 'btn-danger right' }, { label: I18n.t("post.controls.delete_replies.no_value"),
                callback: function () {
                  post.destroy(user);
                }
              }, { label: I18n.t("post.controls.delete_replies.yes_value"),
                'class': 'btn-primary',
                callback: function () {
                  Discourse.Post.deleteMany([post], [post]);
                  self.get('model.postStream.posts').forEach(function (p) {
                    if (p === post || p.get('reply_to_post_number') === post.get('post_number')) {
                      p.setDeletedState(user);
                    }
                  });
                }
              }]);
            } else {
              post.destroy(user).catch(function (error) {
                popupAjaxError(error);
                post.undoDeleteState();
              });
            }
          },

          editPost: function (post) {
            if (!Discourse.User.current()) {
              return bootbox.alert(I18n.t('post.controls.edit_anonymous'));
            }

            var composer = this.get('controllers.composer'),
                composerModel = composer.get('model'),
                opts = {
              post: post,
              action: Composer.EDIT,
              draftKey: post.get('topic.draft_key'),
              draftSequence: post.get('topic.draft_sequence')
            };

            // Cancel and reopen the composer for the first post
            if (composerModel && (post.get('firstPost') || composerModel.get('editingFirstPost'))) {
              composer.cancelComposer().then(function () {
                return composer.open(opts);
              });
            } else {
              composer.open(opts);
            }
          },

          toggleBookmark: function (post) {
            if (!Discourse.User.current()) {
              alert(I18n.t("bookmarks.not_bookmarked"));
              return;
            }
            if (post) {
              return post.toggleBookmark().catch(popupAjaxError);
            } else {
              return this.get("model").toggleBookmark();
            }
          },

          jumpTop: function () {
            this.get('controllers.topic-progress').send('jumpTop');
          },

          selectAll: function () {
            var posts = this.get('model.postStream.posts'),
                selectedPosts = this.get('selectedPosts');
            if (posts) {
              selectedPosts.addObjects(posts);
            }
            this.set('allPostsSelected', true);
          },

          deselectAll: function () {
            this.get('selectedPosts').clear();
            this.get('selectedReplies').clear();
            this.set('allPostsSelected', false);
          },

          toggleParticipant: function (user) {
            this.get('model.postStream').toggleParticipant(Em.get(user, 'username'));
          },

          editTopic: function () {
            if (!this.get('model.details.can_edit')) return false;

            this.set('editingTopic', true);
            return false;
          },

          cancelEditingTopic: function () {
            this.set('editingTopic', false);
            this.rollbackBuffer();
          },

          toggleMultiSelect: function () {
            this.toggleProperty('multiSelect');
          },

          finishedEditingTopic: function () {
            if (!this.get('editingTopic')) {
              return;
            }

            // save the modifications
            var self = this,
                props = this.get('buffered.buffer');

            Topic.update(this.get('model'), props).then(function () {
              // Note we roll back on success here because `update` saves
              // the properties to the topic.
              self.rollbackBuffer();
              self.set('editingTopic', false);
            }).catch(popupAjaxError);
          },

          toggledSelectedPost: function (post) {
            this.performTogglePost(post);
          },

          toggledSelectedPostReplies: function (post) {
            var selectedReplies = this.get('selectedReplies');
            if (this.performTogglePost(post)) {
              selectedReplies.addObject(post);
            } else {
              selectedReplies.removeObject(post);
            }
          },

          deleteSelected: function () {
            var self = this;
            bootbox.confirm(I18n.t("post.delete.confirm", { count: this.get('selectedPostsCount') }), function (result) {
              if (result) {
                var _ret = (function () {

                  // If all posts are selected, it's the same thing as deleting the topic
                  if (self.get('allPostsSelected')) {
                    return {
                      v: self.deleteTopic()
                    };
                  }

                  var selectedPosts = self.get('selectedPosts'),
                      selectedReplies = self.get('selectedReplies'),
                      postStream = self.get('model.postStream'),
                      toRemove = [];

                  Discourse.Post.deleteMany(selectedPosts, selectedReplies);
                  postStream.get('posts').forEach(function (p) {
                    if (self.postSelected(p)) {
                      toRemove.addObject(p);
                    }
                  });

                  postStream.removePosts(toRemove);
                  self.send('toggleMultiSelect');
                })();

                if (typeof _ret === 'object') return _ret.v;
              }
            });
          },

          expandHidden: function (post) {
            post.expandHidden();
          },

          toggleVisibility: function () {
            this.get('content').toggleStatus('visible');
          },

          toggleClosed: function () {
            this.get('content').toggleStatus('closed');
          },

          recoverTopic: function () {
            this.get('content').recover();
          },

          makeBanner: function () {
            this.get('content').makeBanner();
          },

          removeBanner: function () {
            this.get('content').removeBanner();
          },

          togglePinned: function () {
            var value = this.get('model.pinned_at') ? false : true,
                topic = this.get('content'),
                until = this.get('model.pinnedInCategoryUntil');

            // optimistic update
            topic.setProperties({
              pinned_at: value ? moment() : null,
              pinned_globally: false,
              pinned_until: value ? until : null
            });

            return topic.saveStatus("pinned", value, until);
          },

          pinGlobally: function () {
            var topic = this.get('content'),
                until = this.get('model.pinnedGloballyUntil');

            // optimistic update
            topic.setProperties({
              pinned_at: moment(),
              pinned_globally: true,
              pinned_until: until
            });

            return topic.saveStatus("pinned_globally", true, until);
          },

          toggleArchived: function () {
            this.get('content').toggleStatus('archived');
          },

          // Toggle the star on the topic
          toggleStar: function () {
            this.get('content').toggleStar();
          },

          clearPin: function () {
            this.get('content').clearPin();
          },

          togglePinnedForUser: function () {
            if (this.get('model.pinned_at')) {
              var topic = this.get('content');
              if (topic.get('pinned')) {
                topic.clearPin();
              } else {
                topic.rePin();
              }
            }
          },

          replyAsNewTopic: function (post) {
            var _this = this;

            var composerController = this.get('controllers.composer'),
                quoteController = this.get('controllers.quote-button'),
                quotedText = Quote.build(quoteController.get('post'), quoteController.get('buffer')),
                self = this;

            quoteController.deselectText();

            composerController.open({
              action: Composer.CREATE_TOPIC,
              draftKey: Composer.REPLY_AS_NEW_TOPIC_KEY,
              categoryId: this.get('category.id')
            }).then(function () {
              return Em.isEmpty(quotedText) ? Discourse.Post.loadQuote(post.get('id')) : quotedText;
            }).then(function (q) {
              var postUrl = location.protocol + '//' + location.host + post.get('url');
              var postLink = '[' + Handlebars.escapeExpression(self.get('model.title')) + '](' + postUrl + ')';

              _this.appEvents.trigger('composer:insert-text', I18n.t("post.continue_discussion", { postLink: postLink }) + '\n\n' + q);
            });
          },

          expandFirstPost: function (post) {
            var self = this;
            this.set('loadingExpanded', true);
            post.expand().then(function () {
              self.set('firstPostExpanded', true);
            }).catch(function (error) {
              bootbox.alert($.parseJSON(error.responseText).errors);
            }).finally(function () {
              self.set('loadingExpanded', false);
            });
          },

          retryLoading: function () {
            var self = this;
            self.set('retrying', true);
            this.get('model.postStream').refresh().then(function () {
              self.set('retrying', false);
            }, function () {
              self.set('retrying', false);
            });
          },

          toggleWiki: function (post) {
            post.updatePostField('wiki', !post.get('wiki'));
          },

          togglePostType: function (post) {
            var regular = this.site.get('post_types.regular');
            var moderator = this.site.get('post_types.moderator_action');

            post.updatePostField('post_type', post.get('post_type') === moderator ? regular : moderator);
          },

          rebakePost: function (post) {
            post.rebake();
          },

          unhidePost: function (post) {
            post.unhide();
          },

          changePostOwner: function (post) {
            this.get('selectedPosts').addObject(post);
            this.send('changeOwner');
          }
        };
      }
    }, {
      key: 'togglePinnedState',
      value: function () {
        this.send('togglePinnedForUser');
      }
    }, {
      key: 'showExpandButton',
      initializer: function () {
        return (function () {
          var post = this.get('post');
          return post.get('post_number') === 1 && post.get('topic.expandable_first_post');
        }).property();
      }
    }, {
      key: 'canMergeTopic',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.can_move_posts')) return false;
          return this.get('selectedPostsCount') > 0;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'canSplitTopic',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.can_move_posts')) return false;
          if (this.get('allPostsSelected')) return false;
          return this.get('selectedPostsCount') > 0;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'canChangeOwner',
      initializer: function () {
        return (function () {
          if (!Discourse.User.current() || !Discourse.User.current().admin) return false;
          return this.get('selectedPostsUsername') !== undefined;
        }).property('selectedPostsUsername');
      }
    }, {
      key: 'categories',
      initializer: function () {
        return (function () {
          return Discourse.Category.list();
        }).property();
      }
    }, {
      key: 'canSelectAll',
      initializer: function () {
        return Em.computed.not('allPostsSelected');
      }
    }, {
      key: 'canDeselectAll',
      initializer: function () {
        return (function () {
          if (this.get('selectedPostsCount') > 0) return true;
          if (this.get('allPostsSelected')) return true;
        }).property('selectedPostsCount', 'allPostsSelected');
      }
    }, {
      key: 'canDeleteSelected',
      initializer: function () {
        return (function () {
          var selectedPosts = this.get('selectedPosts');

          if (this.get('allPostsSelected')) return true;
          if (this.get('selectedPostsCount') === 0) return false;

          var canDelete = true;
          selectedPosts.forEach(function (p) {
            if (!p.get('can_delete')) {
              canDelete = false;
              return false;
            }
          });
          return canDelete;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'hasError',
      initializer: function () {
        return Ember.computed.or('model.notFoundHtml', 'model.message');
      }
    }, {
      key: 'noErrorYet',
      initializer: function () {
        return Ember.computed.not('hasError');
      }
    }, {
      key: 'multiSelectChanged',
      initializer: function () {
        return (function () {
          // Deselect all posts when multi select is turned off
          if (!this.get('multiSelect')) {
            this.send('deselectAll');
          }
        }).observes('multiSelect');
      }
    }, {
      key: 'deselectPost',
      value: function (post) {
        this.get('selectedPosts').removeObject(post);

        var selectedReplies = this.get('selectedReplies');
        selectedReplies.removeObject(post);

        var selectedReply = selectedReplies.findProperty('post_number', post.get('reply_to_post_number'));
        if (selectedReply) {
          selectedReplies.removeObject(selectedReply);
        }

        this.set('allPostsSelected', false);
      }
    }, {
      key: 'postSelected',
      value: function (post) {
        if (this.get('allPostsSelected')) {
          return true;
        }
        if (this.get('selectedPosts').contains(post)) {
          return true;
        }
        if (this.get('selectedReplies').findProperty('post_number', post.get('reply_to_post_number'))) {
          return true;
        }

        return false;
      }
    }, {
      key: 'showStarButton',
      initializer: function () {
        return (function () {
          return Discourse.User.current() && !this.get('model.isPrivateMessage');
        }).property('model.isPrivateMessage');
      }
    }, {
      key: 'loadingHTML',
      initializer: function () {
        return (function () {
          return spinnerHTML;
        }).property();
      }
    }, {
      key: 'recoverTopic',
      value: function () {
        this.get('content').recover();
      }
    }, {
      key: 'deleteTopic',
      value: function () {
        this.unsubscribe();
        this.get('content').destroy(Discourse.User.current());
      }
    }, {
      key: 'subscribe',

      // Receive notifications for this topic
      value: function () {
        // Unsubscribe before subscribing again
        this.unsubscribe();

        var self = this;
        this.messageBus.subscribe("/topic/" + this.get('model.id'), function (data) {
          var topic = self.get('model');

          if (data.notification_level_change) {
            topic.set('details.notification_level', data.notification_level_change);
            topic.set('details.notifications_reason_id', data.notifications_reason_id);
            return;
          }

          var postStream = self.get('model.postStream');
          switch (data.type) {
            case "revised":
            case "acted":
            case "rebaked":
              {
                // TODO we could update less data for "acted" (only post actions)
                postStream.triggerChangedPost(data.id, data.updated_at);
                return;
              }
            case "deleted":
              {
                postStream.triggerDeletedPost(data.id, data.post_number);
                return;
              }
            case "recovered":
              {
                postStream.triggerRecoveredPost(data.id, data.post_number);
                return;
              }
            case "created":
              {
                postStream.triggerNewPostInStream(data.id);
                if (self.get('currentUser.id') !== data.user_id) {
                  Discourse.notifyBackgroundCountIncrement();
                }
                return;
              }
            default:
              {
                Em.Logger.warn("unknown topic bus message type", data);
              }
          }
        });
      }
    }, {
      key: 'unsubscribe',
      value: function () {
        var topicId = this.get('content.id');
        if (!topicId) return;

        // there is a condition where the view never calls unsubscribe, navigate to a topic from a topic
        this.messageBus.unsubscribe('/topic/*');
      }
    }, {
      key: 'reply',

      // Topic related
      value: function () {
        this.replyToPost();
      }
    }, {
      key: 'performTogglePost',
      value: function (post) {
        var selectedPosts = this.get('selectedPosts');
        if (this.postSelected(post)) {
          this.deselectPost(post);
          return false;
        } else {
          selectedPosts.addObject(post);
          // If the user manually selects all posts, all posts are selected
          this.set('allPostsSelected', selectedPosts.length === this.get('model.posts_count'));
          return true;
        }
      }
    }, {
      key: '_currentPostChanged',

      // If our current post is changed, notify the router
      initializer: function () {
        return (function () {
          var currentPost = this.get('model.currentPost');
          if (currentPost) {
            this.send('postChangedRoute', currentPost);
          }
        }).observes('model.currentPost');
      }
    }, {
      key: 'readPosts',
      value: function (topicId, postNumbers) {
        var topic = this.get("model"),
            postStream = topic.get("postStream");

        if (topic.get("id") === topicId) {
          // TODO identity map for postNumber
          _.each(postStream.get('posts'), function (post) {
            if (_.include(postNumbers, post.post_number) && !post.read) {
              post.set("read", true);
            }
          });

          var max = _.max(postNumbers);
          if (max > topic.get("last_read_post_number")) {
            topic.set("last_read_post_number", max);
          }

          if (this.siteSettings.automatically_unpin_topics && this.currentUser && this.currentUser.automatically_unpin_topics) {
            // automatically unpin topics when the user reaches the bottom
            if (topic.get("pinned") && max >= topic.get("highest_post_number")) {
              Em.run.next(function () {
                return topic.clearPin();
              });
            }
          }
        }
      }
    }, {
      key: 'topVisibleChanged',

      // Called the the topmost visible post on the page changes.
      value: function (post) {
        if (!post) {
          return;
        }

        var postStream = this.get('model.postStream');
        var firstLoadedPost = postStream.get('posts.firstObject');

        this.set('model.currentPost', post.get('post_number'));

        if (post.get('post_number') === 1) {
          return;
        }

        if (firstLoadedPost && firstLoadedPost === post) {
          (function () {
            // Note: jQuery shouldn't be done in a controller, but how else can we
            // trigger a scroll after a promise resolves in a controller? We need
            // to do this to preserve upwards infinte scrolling.
            var $body = $('body');
            var elemId = '#post_' + post.get('post_number');
            var $elem = $(elemId).closest('.post-cloak');
            var elemPos = $elem.position();
            var distToElement = elemPos ? $body.scrollTop() - elemPos.top : 0;

            postStream.prependMore().then(function () {
              Em.run.next(function () {
                var $refreshedElem = $(elemId).closest('.post-cloak');

                // Quickly going back might mean the element is destroyed
                var position = $refreshedElem.position();
                if (position && position.top) {
                  $('html, body').scrollTop(position.top + distToElement);
                }
              });
            });
          })();
        }
      }
    }, {
      key: 'bottomVisibleChanged',

      /**
        Called the the bottommost visible post on the page changes.
         @method bottomVisibleChanged
        @params {Discourse.Post} post that is at the bottom
      **/
      value: function (post) {
        if (!post) {
          return;
        }

        var postStream = this.get('model.postStream');
        var lastLoadedPost = postStream.get('posts.lastObject');

        this.set('controllers.topic-progress.progressPosition', postStream.progressIndexOfPost(post));

        if (lastLoadedPost && lastLoadedPost === post) {
          postStream.appendMore();
        }
      }
    }, {
      key: '_showFooter',
      initializer: function () {
        return (function () {
          var showFooter = this.get("model.postStream.loaded") && this.get("model.postStream.loadedAllPosts");
          this.set("controllers.application.showFooter", showFooter);
        }).observes("model.postStream.{loaded,loadedAllPosts}");
      }
    }]));
  });define("discourse/controllers/upload-customization", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      notReady: Em.computed.not('ready'),
      needs: ['adminCustomizeCssHtml'],

      ready: (function () {
        try {
          var parsed = JSON.parse(this.get('customizationFile'));
          return !!parsed["site_customization"];
        } catch (e) {
          return false;
        }
      }).property('customizationFile'),

      actions: {
        createCustomization: function () {
          var object = JSON.parse(this.get('customizationFile')).site_customization;

          // Slight fixup before creating object
          object.enabled = false;
          delete object.id;
          delete object.key;

          var controller = this.get('controllers.adminCustomizeCssHtml');
          controller.send('newCustomization', object);
        }
      }

    });
  });define("discourse/controllers/upload-selector", 
  ["discourse/mixins/modal-functionality","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.uploadTranslate = uploadTranslate;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var computed = __dependency2__.default;

    function uploadTranslate(key, options) {
      options = options || {};
      if (Discourse.Utilities.allowsAttachments()) {
        key += "_with_attachments";
      }
      return I18n.t('upload_selector.' + key, options);
    }

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'showMore',
      initializer: function () {
        return false;
      }
    }, {
      key: 'local',
      initializer: function () {
        return true;
      }
    }, {
      key: 'imageUrl',
      initializer: function () {
        return null;
      }
    }, {
      key: 'imageLink',
      initializer: function () {
        return null;
      }
    }, {
      key: 'remote',
      initializer: function () {
        return Ember.computed.not("local");
      }
    }, {
      key: 'uploadIcon',
      decorators: [computed],
      value: function () {
        return Discourse.Utilities.allowsAttachments() ? "upload" : "picture-o";
      }
    }, {
      key: 'tip',
      decorators: [computed('controller.local')],
      value: function (local) {
        var source = local ? "local" : "remote";
        var authorized_extensions = Discourse.Utilities.authorizesAllExtensions() ? "" : '(' + Discourse.Utilities.authorizedExtensions() + ')';
        return uploadTranslate(source + '_tip', { authorized_extensions: authorized_extensions });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          upload: function () {
            if (this.get('local')) {
              $('.wmd-controls').fileupload('add', { fileInput: $('#filename-input') });
            } else {
              var imageUrl = this.get('imageUrl') || '';
              var imageLink = this.get('imageLink') || '';
              var toolbarEvent = this.get('toolbarEvent');

              if (this.get('showMore') && imageLink.length > 3) {
                toolbarEvent.addText('[![](' + imageUrl + ')](' + imageLink + ')');
              } else {
                toolbarEvent.addText(imageUrl);
              }
            }
            this.send('closeModal');
          },

          useLocal: function () {
            this.setProperties({ local: true, showMore: false });
          },
          useRemote: function () {
            this.set("local", false);
          },
          toggleShowMore: function () {
            this.toggleProperty("showMore");
          }
        };
      }
    }]));
  });define("discourse/controllers/user-activity", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      userActionType: null,
      needs: ["application"],

      _showFooter: (function () {
        var showFooter;
        if (this.get("userActionType")) {
          var stat = _.find(this.get("model.stats"), { action_type: this.get("userActionType") });
          showFooter = stat && stat.count <= this.get("model.stream.itemsLoaded");
        } else {
          showFooter = this.get("model.statsCountNonPM") <= this.get("model.stream.itemsLoaded");
        }
        this.set("controllers.application.showFooter", showFooter);
      }).observes("userActionType", "model.stream.itemsLoaded")

    });
  });define("discourse/controllers/user-badges", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayController.extend({
      sortProperties: ['badge.badge_type.sort_order', 'badge.name'],
      orderBy: function (ub1, ub2) {
        var sr1 = ub1.get('badge.badge_type.sort_order');
        var sr2 = ub2.get('badge.badge_type.sort_order');

        if (sr1 > sr2) {
          return -1;
        }

        if (sr2 > sr1) {
          return 1;
        }

        return ub1.get('badge.name') < ub2.get('badge.name') ? -1 : 1;
      }
    });
  });define("discourse/controllers/user-card", 
  ["discourse/lib/url","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var propertyNotEqual = __dependency2__.propertyNotEqual;
    var setting = __dependency2__.setting;

    __exports__["default"] = Ember.Controller.extend({
      needs: ['topic', 'application'],
      visible: false,
      user: null,
      username: null,
      avatar: null,
      userLoading: null,
      cardTarget: null,
      post: null,

      // If inside a topic
      topicPostCount: null,

      postStream: Em.computed.alias('controllers.topic.model.postStream'),
      enoughPostsForFiltering: Em.computed.gte('topicPostCount', 2),
      viewingTopic: Em.computed.match('controllers.application.currentPath', /^topic\./),
      viewingAdmin: Em.computed.match('controllers.application.currentPath', /^admin\./),
      showFilter: Em.computed.and('viewingTopic', 'postStream.hasNoFilters', 'enoughPostsForFiltering'),
      showName: propertyNotEqual('user.name', 'user.username'),
      hasUserFilters: Em.computed.gt('postStream.userFilters.length', 0),
      isSuspended: Em.computed.notEmpty('user.suspend_reason'),
      showBadges: setting('enable_badges'),
      showMoreBadges: Em.computed.gt('moreBadgesCount', 0),
      showDelete: Em.computed.and("viewingAdmin", "showName", "user.canBeDeleted"),

      moreBadgesCount: (function () {
        return this.get('user.badge_count') - this.get('user.featured_user_badges.length');
      }).property('user.badge_count', 'user.featured_user_badges.@each'),

      hasCardBadgeImage: (function () {
        var img = this.get('user.card_badge.image');
        return img && img.indexOf('fa-') !== 0;
      }).property('user.card_badge.image'),

      show: function (username, postId, target) {
        var _this = this;

        // XSS protection (should be encapsulated)
        username = username.toString().replace(/[^A-Za-z0-9_\.\-]/g, "");

        // No user card for anon
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          return;
        }

        // Don't show on mobile
        if (Discourse.Mobile.mobileView) {
          var url = "/users/" + username;
          DiscourseURL.routeTo(url);
          return;
        }

        var currentUsername = this.get('username'),
            wasVisible = this.get('visible'),
            previousTarget = this.get('cardTarget'),
            post = this.get('viewingTopic') && postId ? this.get('postStream').findLoadedPost(postId) : null;

        if (username === currentUsername && this.get('userLoading') === username) {
          // debounce
          return;
        }

        if (wasVisible) {
          this.close();
          if (target === previousTarget) {
            return; // Same target, close it without loading the new user card
          }
        }

        this.setProperties({ username: username, userLoading: username, cardTarget: target, post: post });

        var args = { stats: false };
        args.include_post_count_for = this.get('controllers.topic.model.id');
        args.skip_track_visit = true;

        return Discourse.User.findByUsername(username, args).then(function (user) {
          if (user.topic_post_count) {
            _this.set('topicPostCount', user.topic_post_count[args.include_post_count_for]);
          }
          _this.setProperties({ user: user, avatar: user, visible: true });
        }).catch(function (error) {
          _this.close();
          throw error;
        }).finally(function () {
          _this.set('userLoading', null);
        });
      },

      close: function () {
        this.setProperties({
          visible: false,
          user: null,
          username: null,
          avatar: null,
          userLoading: null,
          cardTarget: null,
          post: null,
          topicPostCount: null
        });
      },

      actions: {
        togglePosts: function (user) {
          var postStream = this.get('postStream');
          postStream.toggleParticipant(user.get('username'));
          this.close();
        },

        cancelFilter: function () {
          var postStream = this.get('postStream');
          postStream.cancelFilter();
          postStream.refresh();
          this.close();
        },

        showUser: function () {
          this.transitionToRoute('user', this.get('user'));
          this.close();
        }
      }

    });
  });define("discourse/controllers/user-invited-show", 
  ["discourse/models/invite","discourse/lib/debounce","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Invite = __dependency1__["default"];
    var debounce = __dependency2__["default"];

    // This controller handles actions related to a user's invitations
    __exports__["default"] = Ember.Controller.extend({
      user: null,
      model: null,
      filter: null,
      totalInvites: null,
      invitesCount: null,
      canLoadMore: true,
      invitesLoading: false,

      init: function () {
        this._super();
        this.set('searchTerm', '');
      },

      uploadText: (function () {
        return I18n.t("user.invited.bulk_invite.text");
      }).property(),

      /**
        Observe the search term box with a debouncer and change the results.
         @observes searchTerm
      **/
      _searchTermChanged: debounce(function () {
        var self = this;
        Invite.findInvitedBy(self.get('user'), this.get('filter'), this.get('searchTerm')).then(function (invites) {
          self.set('model', invites);
        });
      }, 250).observes('searchTerm'),

      inviteRedeemed: Em.computed.equal('filter', 'redeemed'),

      /**
        Can the currently logged in user invite users to the site
         @property canInviteToForum
      **/
      canInviteToForum: (function () {
        return Discourse.User.currentProp('can_invite_to_forum');
      }).property(),

      /**
        Can the currently logged in user bulk invite users to the site (only Admin is allowed to perform this operation)
         @property canBulkInvite
      **/
      canBulkInvite: (function () {
        return Discourse.User.currentProp('admin');
      }).property(),

      /**
        Should the search filter input box be displayed?
         @property showSearch
      **/
      showSearch: (function () {
        return this.get('totalInvites') > 9;
      }).property('totalInvites'),

      pendingLabel: (function () {
        if (this.get('invitesCount.total') > 50) {
          return I18n.t('user.invited.pending_tab_with_count', { count: this.get('invitesCount.pending') });
        } else {
          return I18n.t('user.invited.pending_tab');
        }
      }).property('invitesCount'),

      redeemedLabel: (function () {
        if (this.get('invitesCount.total') > 50) {
          return I18n.t('user.invited.redeemed_tab_with_count', { count: this.get('invitesCount.redeemed') });
        } else {
          return I18n.t('user.invited.redeemed_tab');
        }
      }).property('invitesCount'),

      actions: {

        rescind: function (invite) {
          invite.rescind();
          return false;
        },

        reinvite: function (invite) {
          invite.reinvite();
          return false;
        },

        loadMore: function () {
          var self = this;
          var model = self.get('model');

          if (self.get('canLoadMore') && !self.get('invitesLoading')) {
            self.set('invitesLoading', true);
            Invite.findInvitedBy(self.get('user'), self.get('filter'), self.get('searchTerm'), model.invites.length).then(function (invite_model) {
              self.set('invitesLoading', false);
              model.invites.pushObjects(invite_model.invites);
              if (invite_model.invites.length === 0 || invite_model.invites.length < Discourse.SiteSettings.invites_per_page) {
                self.set('canLoadMore', false);
              }
            });
          }
        }
      }

    });
  });define("discourse/controllers/user-notifications", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['application'],

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      showDismissButton: Ember.computed.gt('user.total_unread_notifications', 0),

      actions: {
        resetNew: function () {
          var _this = this;

          Discourse.ajax('/notifications/mark-read', { method: 'PUT' }).then(function () {
            _this.setEach('read', true);
          });
        },

        loadMore: function () {
          this.get('model').loadMore();
        }
      }
    });
  });define("discourse/controllers/user-posts", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      needs: ["application"],

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore")
    });
  });define("discourse/controllers/user-topics-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Lists of topics on a user's page.
    __exports__["default"] = Ember.Controller.extend({
      needs: ["application", "user"],
      hideCategory: false,
      showParticipants: false,

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      actions: {
        loadMore: function () {
          this.get('model').loadMore();
        }
      },

      showNewPM: (function () {
        return this.get('controllers.user.viewingSelf') && Discourse.User.currentProp('can_send_private_messages');
      }).property('controllers.user.viewingSelf')

    });
  });define("discourse/controllers/user", 
  ["discourse/lib/export-csv","discourse/mixins/can-check-emails","ember-addons/ember-computed-decorators","discourse/models/user-action","discourse/models/user","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var exportUserArchive = __dependency1__.exportUserArchive;
    var CanCheckEmails = __dependency2__["default"];
    var computed = __dependency3__["default"];
    var UserAction = __dependency4__["default"];
    var User = __dependency5__["default"];

    __exports__["default"] = Ember.Controller.extend(CanCheckEmails, _createDecoratedObject([{
      key: 'indexStream',
      initializer: function () {
        return false;
      }
    }, {
      key: 'pmView',
      initializer: function () {
        return false;
      }
    }, {
      key: 'userActionType',
      initializer: function () {
        return null;
      }
    }, {
      key: 'needs',
      initializer: function () {
        return ['user-notifications', 'user-topics-list'];
      }
    }, {
      key: 'viewingSelf',
      decorators: [computed("content.username")],
      value: function (username) {
        return username === User.currentProp('username');
      }
    }, {
      key: 'collapsedInfo',
      decorators: [computed('indexStream', 'viewingSelf', 'forceExpand')],
      value: function (indexStream, viewingSelf, forceExpand) {
        return (!indexStream || viewingSelf) && !forceExpand;
      }
    }, {
      key: 'linkWebsite',
      initializer: function () {
        return Em.computed.not('model.isBasic');
      }
    }, {
      key: 'removeNoFollow',
      decorators: [computed("model.trust_level")],
      value: function (trustLevel) {
        return trustLevel > 2 && !this.siteSettings.tl3_links_no_follow;
      }
    }, {
      key: 'canSeePrivateMessages',
      decorators: [computed('viewingSelf', 'currentUser.admin')],
      value: function (viewingSelf, isAdmin) {
        return this.siteSettings.enable_private_messages && (viewingSelf || isAdmin);
      }
    }, {
      key: 'canSeeNotificationHistory',
      initializer: function () {
        return Em.computed.alias('canSeePrivateMessages');
      }
    }, {
      key: 'showBadges',
      decorators: [computed("content.badge_count")],
      value: function (badgeCount) {
        return Discourse.SiteSettings.enable_badges && badgeCount > 0;
      }
    }, {
      key: 'privateMessageView',
      decorators: [computed("userActionType")],
      value: function (userActionType) {
        return userActionType === UserAction.TYPES.messages_sent || userActionType === UserAction.TYPES.messages_received;
      }
    }, {
      key: 'canInviteToForum',
      decorators: [computed()],
      value: function () {
        return User.currentProp('can_invite_to_forum');
      }
    }, {
      key: 'canDeleteUser',
      initializer: function () {
        return Ember.computed.and("model.can_be_deleted", "model.can_delete_all_posts");
      }
    }, {
      key: 'publicUserFields',
      decorators: [computed('model.user_fields.@each.value')],
      value: function () {
        var _this = this;

        var siteUserFields = this.site.get('user_fields');
        if (!Ember.isEmpty(siteUserFields)) {
          var _ret = (function () {
            var userFields = _this.get('model.user_fields');
            return {
              v: siteUserFields.filterProperty('show_on_profile', true).sortBy('position').map(function (field) {
                var value = userFields ? userFields[field.get('id').toString()] : null;
                return Ember.isEmpty(value) ? null : Ember.Object.create({ value: value, field: field });
              }).compact()
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    }, {
      key: 'privateMessagesActive',
      initializer: function () {
        return Em.computed.equal('pmView', 'index');
      }
    }, {
      key: 'privateMessagesMineActive',
      initializer: function () {
        return Em.computed.equal('pmView', 'mine');
      }
    }, {
      key: 'privateMessagesUnreadActive',
      initializer: function () {
        return Em.computed.equal('pmView', 'unread');
      }
    }, {
      key: 'groupPMStats',
      decorators: [computed('model.private_messages_stats.groups', 'groupFilter', 'pmView')],
      value: function (stats, filter, pmView) {
        if (stats) {
          return stats.map(function (g) {
            return {
              name: g.name,
              count: g.count,
              active: g.name === filter && pmView === 'groups'
            };
          });
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          expandProfile: function () {
            this.set('forceExpand', true);
          },

          adminDelete: function () {
            // I really want this deferred, don't want to bring in all this code till used
            var AdminUser = require('admin/models/admin-user').default;
            AdminUser.find(this.get('model.username').toLowerCase()).then(function (user) {
              return user.destroy({ deletePosts: true });
            });
          },

          exportUserArchive: function () {
            bootbox.confirm(I18n.t("admin.export_csv.user_archive_confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
              if (confirmed) {
                exportUserArchive();
              }
            });
          }
        };
      }
    }]));
  });define("discourse/controllers/users", 
  ["discourse/lib/debounce","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ["application"],
      queryParams: ["period", "order", "asc", "name"],
      period: "weekly",
      order: "likes_received",
      asc: null,
      name: "",

      showTimeRead: Ember.computed.equal("period", "all"),

      _setName: debounce(function () {
        this.set("name", this.get("nameInput"));
      }, 500).observes("nameInput"),

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      actions: {
        loadMore: function () {
          this.get("model").loadMore();
        }
      }
    });
  });define("discourse/models/admin-post", 
  ["discourse/models/post","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Post = __dependency1__["default"];

    __exports__["default"] = Post.extend({

      _attachCategory: (function () {
        var categoryId = this.get("category_id");
        if (categoryId) {
          this.set("category", Discourse.Category.findById(categoryId));
        }
      }).on("init"),

      presentName: Em.computed.any('name', 'username'),

      sameUser: (function () {
        return this.get("username") === Discourse.User.currentProp("username");
      }).property("username"),

      descriptionKey: (function () {
        if (this.get("reply_to_post_number")) {
          return this.get("sameUser") ? "you_replied_to_post" : "user_replied_to_post";
        } else {
          return this.get("sameUser") ? "you_replied_to_topic" : "user_replied_to_topic";
        }
      }).property("reply_to_post_number", "sameUser")

    });
  });define("discourse/models/archetype", 
  ["discourse/lib/computed","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var RestModel = __dependency2__["default"];

    __exports__["default"] = RestModel.extend({
      hasOptions: Em.computed.gt('options.length', 0),
      isDefault: propertyEqual('id', 'site.default_archetype'),
      notDefault: Em.computed.not('isDefault')
    });
  });define("discourse/models/category-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var CategoryList = Ember.ArrayProxy.extend({
      init: function () {
        this.set('content', []);
        this._super();
      }
    });

    CategoryList.reopenClass({
      categoriesFrom: function (store, result) {
        var categories = CategoryList.create();
        var users = Discourse.Model.extractByKey(result.featured_users, Discourse.User);
        var list = Discourse.Category.list();

        result.category_list.categories.forEach(function (c) {
          if (c.parent_category_id) {
            c.parentCategory = list.findBy('id', c.parent_category_id);
          }

          if (c.subcategory_ids) {
            c.subcategories = c.subcategory_ids.map(function (scid) {
              return list.findBy('id', parseInt(scid, 10));
            });
          }

          if (c.featured_user_ids) {
            c.featured_users = c.featured_user_ids.map(function (u) {
              return users[u];
            });
          }

          if (c.topics) {
            c.topics = c.topics.map(function (t) {
              return Discourse.Topic.create(t);
            });
          }

          categories.pushObject(store.createRecord('category', c));
        });
        return categories;
      },

      listForParent: function (store, category) {
        var _this = this;

        return Discourse.ajax('/categories.json?parent_category_id=' + category.get("id")).then(function (result) {
          return CategoryList.create({
            categories: _this.categoriesFrom(store, result),
            parentCategory: category
          });
        });
      },

      list: function (store) {
        var _this2 = this;

        var getCategories = function () {
          return Discourse.ajax("/categories.json");
        };
        return PreloadStore.getAndRemove("categories_list", getCategories).then(function (result) {
          return CategoryList.create({
            categories: _this2.categoriesFrom(store, result),
            can_create_category: result.category_list.can_create_category,
            can_create_topic: result.category_list.can_create_topic,
            draft_key: result.category_list.draft_key,
            draft: result.category_list.draft,
            draft_sequence: result.category_list.draft_sequence
          });
        });
      }
    });

    __exports__["default"] = CategoryList;
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Represents a pop up message displayed over the composer

  @class ComposerMessage
  @extends Ember.Object
  @namespace Discourse
  @module Discourse
**/

Discourse.ComposerMessage = Em.Object.extend({});

Discourse.ComposerMessage.reopenClass({
  /**
    Look for composer messages given the current composing settings.

    @method find
    @param {Discourse.Composer} composer The current composer
    @returns {Discourse.ComposerMessage} the composer message to display (or null)
  **/
  find: function(composer) {

    var data = { composerAction: composer.get('action') },
        topicId = composer.get('topic.id'),
        postId = composer.get('post.id');

    if (topicId) { data.topic_id = topicId; }
    if (postId)  { data.post_id = postId; }

    return Discourse.ajax('/composer-messages', { data: data }).then(function (messages) {
      return messages.map(function (message) {
        return Discourse.ComposerMessage.create(message);
      });
    });
  }

});


// IIFE Wrapped Content Ends

 })(this);define("discourse/models/group", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    var Group = Discourse.Model.extend(_createDecoratedObject([{
      key: 'limit',
      initializer: function () {
        return 50;
      }
    }, {
      key: 'offset',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'user_count',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'owners',
      initializer: function () {
        return [];
      }
    }, {
      key: 'hasOwners',
      initializer: function () {
        return Ember.computed.notEmpty('owners');
      }
    }, {
      key: 'emailDomains',
      decorators: [computed("automatic_membership_email_domains")],
      value: function (value) {
        return Em.isEmpty(value) ? "" : value;
      }
    }, {
      key: 'type',
      initializer: function () {
        return (function () {
          return this.get("automatic") ? "automatic" : "custom";
        }).property("automatic");
      }
    }, {
      key: 'userCountDisplay',
      initializer: function () {
        return (function () {
          var c = this.get('user_count');
          // don't display zero its ugly
          if (c > 0) {
            return c;
          }
        }).property('user_count');
      }
    }, {
      key: 'findMembers',
      value: function () {
        if (Em.isEmpty(this.get('name'))) {
          return;
        }

        var self = this,
            offset = Math.min(this.get("user_count"), Math.max(this.get("offset"), 0));

        return Group.loadMembers(this.get("name"), offset, this.get("limit")).then(function (result) {
          var ownerIds = {};
          result.owners.forEach(function (owner) {
            return ownerIds[owner.id] = true;
          });

          self.setProperties({
            user_count: result.meta.total,
            limit: result.meta.limit,
            offset: result.meta.offset,
            members: result.members.map(function (member) {
              if (ownerIds[member.id]) {
                member.owner = true;
              }
              return Discourse.User.create(member);
            }),
            owners: result.owners.map(function (owner) {
              return Discourse.User.create(owner);
            })
          });
        });
      }
    }, {
      key: 'removeOwner',
      value: function (member) {
        var self = this;
        return Discourse.ajax('/admin/groups/' + this.get('id') + '/owners.json', {
          type: "DELETE",
          data: { user_id: member.get("id") }
        }).then(function () {
          // reload member list
          self.findMembers();
        });
      }
    }, {
      key: 'removeMember',
      value: function (member) {
        var self = this;
        return Discourse.ajax('/groups/' + this.get('id') + '/members.json', {
          type: "DELETE",
          data: { user_id: member.get("id") }
        }).then(function () {
          // reload member list
          self.findMembers();
        });
      }
    }, {
      key: 'addMembers',
      value: function (usernames) {
        var self = this;
        return Discourse.ajax('/groups/' + this.get('id') + '/members.json', {
          type: "PUT",
          data: { usernames: usernames }
        }).then(function () {
          self.findMembers();
        });
      }
    }, {
      key: 'addOwners',
      value: function (usernames) {
        var self = this;
        return Discourse.ajax('/admin/groups/' + this.get('id') + '/owners.json', {
          type: "PUT",
          data: { usernames: usernames }
        }).then(function () {
          self.findMembers();
        });
      }
    }, {
      key: 'asJSON',
      value: function () {
        return {
          name: this.get('name'),
          alias_level: this.get('alias_level'),
          visible: !!this.get('visible'),
          automatic_membership_email_domains: this.get('emailDomains'),
          automatic_membership_retroactive: !!this.get('automatic_membership_retroactive'),
          title: this.get('title'),
          primary_group: !!this.get('primary_group'),
          grant_trust_level: this.get('grant_trust_level'),
          incoming_email: this.get("incoming_email")
        };
      }
    }, {
      key: 'create',
      value: function () {
        var self = this;
        return Discourse.ajax("/admin/groups", { type: "POST", data: this.asJSON() }).then(function (resp) {
          self.set('id', resp.basic_group.id);
        });
      }
    }, {
      key: 'save',
      value: function () {
        return Discourse.ajax("/admin/groups/" + this.get('id'), { type: "PUT", data: this.asJSON() });
      }
    }, {
      key: 'destroy',
      value: function () {
        if (!this.get('id')) {
          return;
        }
        return Discourse.ajax("/admin/groups/" + this.get('id'), { type: "DELETE" });
      }
    }, {
      key: 'findPosts',
      value: function (opts) {
        opts = opts || {};

        var type = opts['type'] || 'posts';

        var data = {};
        if (opts.beforePostId) {
          data.before_post_id = opts.beforePostId;
        }

        return Discourse.ajax('/groups/' + this.get('name') + '/' + type + '.json', { data: data }).then(function (posts) {
          return posts.map(function (p) {
            p.user = Discourse.User.create(p.user);
            return Em.Object.create(p);
          });
        });
      }
    }]));

    Group.reopenClass({
      findAll: function (opts) {
        return Discourse.ajax("/admin/groups.json", { data: opts }).then(function (groups) {
          return groups.map(function (g) {
            return Group.create(g);
          });
        });
      },

      findGroupCounts: function (name) {
        return Discourse.ajax("/groups/" + name + "/counts.json").then(function (result) {
          return Em.Object.create(result.counts);
        });
      },

      find: function (name) {
        return Discourse.ajax("/groups/" + name + ".json").then(function (result) {
          return Group.create(result.basic_group);
        });
      },

      loadMembers: function (name, offset, limit) {
        return Discourse.ajax('/groups/' + name + '/members.json', {
          data: {
            limit: limit || 50,
            offset: offset || 0
          }
        });
      }
    });

    __exports__["default"] = Group;
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  A trivial model we use to handle input validation

  @class InputValidation
  @extends Discourse.Model
  @namespace Discourse
  @module Discourse
**/

Discourse.InputValidation = Discourse.Model.extend({});




// IIFE Wrapped Content Ends

 })(this);define("discourse/models/live-post-counts", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var LivePostCounts = Discourse.Model.extend({});

    LivePostCounts.reopenClass({
      find: function () {
        return Discourse.ajax("/about/live_post_counts.json").then(function (result) {
          return LivePostCounts.create(result);
        });
      }
    });

    __exports__["default"] = LivePostCounts;
  });(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.LoginMethod = Ember.Object.extend({
  title: function() {
    var titleSetting = this.get('titleSetting');
    if (!Ember.isEmpty(titleSetting)) {
      var result = Discourse.SiteSettings[titleSetting];
      if (!Ember.isEmpty(result)) { return result; }
    }

    return this.get("titleOverride") || I18n.t("login." + this.get("name") + ".title");
  }.property(),

  message: function() {
    return this.get("messageOverride") || I18n.t("login." + this.get("name") + ".message");
  }.property()
});

// Note, you can add login methods by adding to the list
//  just Em.get("Discourse.LoginMethod.all") and then
//  pushObject for any new methods
Discourse.LoginMethod.reopenClass({
  register: function(method) {
    if (this.methods){
      this.methods.pushObject(method);
    } else {
      this.preRegister = this.preRegister || [];
      this.preRegister.push(method);
    }
  },

  all: function(){
    if (this.methods) { return this.methods; }

    var methods = this.methods = Em.A();

    [ "google_oauth2",
      "facebook",
      "cas",
      "twitter",
      "yahoo",
      "github"
    ].forEach(function(name){
      if (Discourse.SiteSettings["enable_" + name + "_logins"]) {

        var params = {name: name};

        if (name === "google_oauth2") {
          params.frameWidth = 850;
          params.frameHeight = 500;
        } else if (name === "facebook") {
          params.frameHeight = 450;
        }

        methods.pushObject(Discourse.LoginMethod.create(params));
      }
    });

    if (this.preRegister){
      this.preRegister.forEach(function(method){
        var enabledSetting = method.get('enabledSetting');
        if (enabledSetting) {
          if (Discourse.SiteSettings[enabledSetting]) {
            methods.pushObject(method);
          }
        } else {
          methods.pushObject(method);
        }
      });
      delete this.preRegister;
    }
    return methods;
  }.property()
});



// IIFE Wrapped Content Ends

 })(this);define("discourse/models/nav-item", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.extraNavItemProperties = extraNavItemProperties;
    __exports__.customNavItemHref = customNavItemHref;
    var toTitleCase = __dependency1__.toTitleCase;

    var NavItem = Discourse.Model.extend({

      displayName: (function () {
        var categoryName = this.get('categoryName'),
            name = this.get('name'),
            count = this.get('count') || 0;

        if (name === 'latest' && !Discourse.Mobile.mobileView) {
          count = 0;
        }

        var extra = { count: count };
        var titleKey = count === 0 ? '.title' : '.title_with_count';

        if (categoryName) {
          name = 'category';
          extra.categoryName = toTitleCase(categoryName);
        }
        return I18n.t("filters." + name.replace("/", ".") + titleKey, extra);
      }).property('categoryName', 'name', 'count'),

      categoryName: (function () {
        var split = this.get('name').split('/');
        return split[0] === 'category' ? split[1] : null;
      }).property('name'),

      categorySlug: (function () {
        var split = this.get('name').split('/');
        if (split[0] === 'category' && split[1]) {
          var cat = Discourse.Site.current().categories.findProperty('nameLower', split[1].toLowerCase());
          return cat ? Discourse.Category.slugFor(cat) : null;
        }
        return null;
      }).property('name'),

      href: (function () {
        var customHref = null;
        _.each(NavItem.customNavItemHrefs, function (cb) {
          customHref = cb.call(this, this);
          if (customHref) {
            return false;
          }
        }, this);
        if (customHref) {
          return customHref;
        }
        return Discourse.getURL("/") + this.get('filterMode');
      }).property('filterMode'),

      // href from this item
      filterMode: (function () {
        var name = this.get('name');

        if (name.split('/')[0] === 'category') {
          return 'c/' + this.get('categorySlug');
        } else {
          var mode = "",
              category = this.get("category");

          if (category) {
            mode += "c/";
            mode += Discourse.Category.slugFor(this.get('category'));
            if (this.get('noSubcategories')) {
              mode += '/none';
            }
            mode += "/l/";
          }
          return mode + name.replace(' ', '-');
        }
      }).property('name'),

      count: (function () {
        var state = this.get('topicTrackingState');
        if (state) {
          return state.lookupCount(this.get('name'), this.get('category'));
        }
      }).property('topicTrackingState.messageCount')

    });

    NavItem.reopenClass({

      extraArgsCallbacks: [],
      customNavItemHrefs: [],

      // create a nav item from the text, will return null if there is not valid nav item for this particular text
      fromText: function (text, opts) {
        var split = text.split(","),
            name = split[0],
            testName = name.split("/")[0],
            anonymous = !Discourse.User.current();

        if (anonymous && !Discourse.Site.currentProp('anonymous_top_menu_items').contains(testName)) return null;
        if (!Discourse.Category.list() && testName === "categories") return null;
        if (!Discourse.Site.currentProp('top_menu_items').contains(testName)) return null;

        var args = { name: name, hasIcon: name === "unread" },
            extra = null,
            self = this;
        if (opts.category) {
          args.category = opts.category;
        }
        if (opts.noSubcategories) {
          args.noSubcategories = true;
        }
        _.each(NavItem.extraArgsCallbacks, function (cb) {
          extra = cb.call(self, text, opts);
          _.merge(args, extra);
        });

        var store = Discourse.__container__.lookup('store:main');
        return store.createRecord('nav-item', args);
      },

      buildList: function (category, args) {
        args = args || {};

        if (category) {
          args.category = category;
        }

        var items = Discourse.SiteSettings.top_menu.split("|");

        if (args.filterMode && !_.some(items, function (i) {
          return i.indexOf(args.filterMode) !== -1;
        })) {
          items.push(args.filterMode);
        }

        return items.map(function (i) {
          return Discourse.NavItem.fromText(i, args);
        }).filter(function (i) {
          return i !== null && !(category && i.get("name").indexOf("categor") === 0);
        });
      }

    });

    __exports__["default"] = NavItem;

    function extraNavItemProperties(cb) {
      NavItem.extraArgsCallbacks.push(cb);
    }

    function customNavItemHref(cb) {
      NavItem.customNavItemHrefs.push(cb);
    }
  });

Discourse.NavItem = require('discourse/models/nav-item').default;
define("discourse/models/session", 
  ["discourse/models/rest","discourse/mixins/singleton","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var Singleton = __dependency2__["default"];

    // A data model representing current session data. You can put transient
    // data here you might want later. It is not stored or serialized anywhere.
    var Session = RestModel.extend({
      init: function () {
        this.set('highestSeenByTopic', {});
      }
    });

    Session.reopenClass(Singleton);
    __exports__["default"] = Session;
  });

Discourse.Session = require('discourse/models/session').default;
define("discourse/models/site", 
  ["ember-addons/ember-computed-decorators","discourse/models/archetype","discourse/models/post-action-type","discourse/mixins/singleton","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var Archetype = __dependency2__["default"];
    var PostActionType = __dependency3__["default"];
    var Singleton = __dependency4__["default"];
    var RestModel = __dependency5__["default"];

    var Site = RestModel.extend(_createDecoratedObject([{
      key: 'isReadOnly',
      initializer: function () {
        return Em.computed.alias('is_readonly');
      }
    }, {
      key: 'notificationLookup',
      decorators: [computed("notification_types")],
      value: function (notificationTypes) {
        var result = [];
        _.each(notificationTypes, function (v, k) {
          return result[v] = k;
        });
        return result;
      }
    }, {
      key: 'flagTypes',
      decorators: [computed("post_action_types.@each")],
      value: function () {
        var postActionTypes = this.get('post_action_types');
        if (!postActionTypes) return [];
        return postActionTypes.filterProperty('is_flag', true);
      }
    }, {
      key: 'topicCountDesc',
      initializer: function () {
        return ['topic_count:desc'];
      }
    }, {
      key: 'categoriesByCount',
      initializer: function () {
        return Ember.computed.sort('categories', 'topicCountDesc');
      }
    }, {
      key: 'sortedCategories',
      decorators: [computed("categoriesByCount", "categories.@each")],
      value: function (cats) {
        var result = [],
            remaining = {};

        cats.forEach(function (c) {
          var parentCategoryId = parseInt(c.get('parent_category_id'), 10);
          if (!parentCategoryId) {
            result.pushObject(c);
          } else {
            remaining[parentCategoryId] = remaining[parentCategoryId] || [];
            remaining[parentCategoryId].pushObject(c);
          }
        });

        Ember.keys(remaining).forEach(function (parentCategoryId) {
          var category = result.findBy('id', parseInt(parentCategoryId, 10)),
              index = result.indexOf(category);

          if (index !== -1) {
            result.replace(index + 1, 0, remaining[parentCategoryId]);
          }
        });

        return result;
      }
    }, {
      key: 'postActionTypeById',
      value: function (id) {
        return this.get("postActionByIdLookup.action" + id);
      }
    }, {
      key: 'topicFlagTypeById',
      value: function (id) {
        return this.get("topicFlagByIdLookup.action" + id);
      }
    }, {
      key: 'removeCategory',
      value: function (id) {
        var categories = this.get('categories');
        var existingCategory = categories.findProperty('id', id);
        if (existingCategory) {
          categories.removeObject(existingCategory);
          delete this.get('categoriesById').categoryId;
        }
      }
    }, {
      key: 'updateCategory',
      value: function (newCategory) {
        var categories = this.get('categories');
        var categoryId = Em.get(newCategory, 'id');
        var existingCategory = categories.findProperty('id', categoryId);

        // Don't update null permissions
        if (newCategory.permission === null) {
          delete newCategory.permission;
        }

        if (existingCategory) {
          existingCategory.setProperties(newCategory);
        } else {
          // TODO insert in right order?
          newCategory = this.store.createRecord('category', newCategory);
          categories.pushObject(newCategory);
          this.get('categoriesById')[categoryId] = newCategory;
        }
      }
    }]));

    Site.reopenClass(Singleton, {

      // The current singleton will retrieve its attributes from the `PreloadStore`.
      createCurrent: function () {
        var store = Discourse.__container__.lookup('store:main');
        return store.createRecord('site', PreloadStore.get('site'));
      },

      create: function () {
        var result = this._super.apply(this, arguments);
        var store = result.store;

        if (result.categories) {
          result.categoriesById = {};
          result.categories = _.map(result.categories, function (c) {
            return result.categoriesById[c.id] = store.createRecord('category', c);
          });

          // Associate the categories with their parents
          result.categories.forEach(function (c) {
            if (c.get('parent_category_id')) {
              c.set('parentCategory', result.categoriesById[c.get('parent_category_id')]);
            }
          });
        }

        if (result.trust_levels) {
          result.trustLevels = result.trust_levels.map(function (tl) {
            return Discourse.TrustLevel.create(tl);
          });
          delete result.trust_levels;
        }

        if (result.post_action_types) {
          result.postActionByIdLookup = Em.Object.create();
          result.post_action_types = _.map(result.post_action_types, function (p) {
            var actionType = PostActionType.create(p);
            result.postActionByIdLookup.set("action" + p.id, actionType);
            return actionType;
          });
        }

        if (result.topic_flag_types) {
          result.topicFlagByIdLookup = Em.Object.create();
          result.topic_flag_types = _.map(result.topic_flag_types, function (p) {
            var actionType = PostActionType.create(p);
            result.topicFlagByIdLookup.set("action" + p.id, actionType);
            return actionType;
          });
        }

        if (result.archetypes) {
          result.archetypes = _.map(result.archetypes, function (a) {
            a.site = result;
            return Archetype.create(a);
          });
        }

        if (result.user_fields) {
          result.user_fields = result.user_fields.map(function (uf) {
            return Ember.Object.create(uf);
          });
        }

        return result;
      }
    });

    __exports__["default"] = Site;

    // Sort subcategories under parents
  });

Discourse.Site = require('discourse/models/site').default;
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.StaticPage = Em.Object.extend();

Discourse.StaticPage.reopenClass({
  find: function(path) {
    return new Em.RSVP.Promise(function(resolve) {
      // Models shouldn't really be doing Ajax request, but this is a huge speed boost if we
      // preload content.
      var $preloaded = $("noscript[data-path=\"/" + path + "\"]");
      if ($preloaded.length) {
        var text = $preloaded.text();
        text = text.match(/<!-- preload-content: -->((?:.|[\n\r])*)<!-- :preload-content -->/)[1];
        resolve(Discourse.StaticPage.create({path: path, html: text}));
      } else {
        Discourse.ajax(path + ".html", {dataType: 'html'}).then(function (result) {
          resolve(Discourse.StaticPage.create({path: path, html: result}));
        });
      }
    });
  }
});


// IIFE Wrapped Content Ends

 })(this);define("discourse/models/topic-list", 
  ["discourse/models/rest","discourse/models/model","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var Model = __dependency2__["default"];

    function topicsFrom(result, store) {
      if (!result) {
        return;
      }

      // Stitch together our side loaded data
      var categories = Discourse.Category.list(),
          users = Model.extractByKey(result.users, Discourse.User);

      return result.topic_list.topics.map(function (t) {
        t.category = categories.findBy('id', t.category_id);
        t.posters.forEach(function (p) {
          p.user = users[p.user_id];
        });
        if (t.participants) {
          t.participants.forEach(function (p) {
            p.user = users[p.user_id];
          });
        }
        return store.createRecord('topic', t);
      });
    }

    var TopicList = RestModel.extend({
      canLoadMore: Em.computed.notEmpty("more_topics_url"),

      forEachNew: function (topics, callback) {
        var topicIds = [];

        _.each(this.get('topics'), function (topic) {
          return topicIds[topic.get('id')] = true;
        });

        _.each(topics, function (topic) {
          if (!topicIds[topic.id]) {
            callback(topic);
          }
        });
      },

      refreshSort: function (order, ascending) {
        var params = this.get('params') || {};

        if (params.q) {
          // search is unique, nothing else allowed with it
          params = { q: params.q };
        } else {
          params.order = order || params.order;
          params.ascending = ascending;
        }

        this.set('params', params);
      },

      loadMore: function () {
        var _this = this;

        if (this.get('loadingMore')) {
          return Ember.RSVP.resolve();
        }

        var moreUrl = this.get('more_topics_url');
        if (moreUrl) {
          var _ret = (function () {
            var self = _this;
            _this.set('loadingMore', true);

            var store = _this.store;
            return {
              v: Discourse.ajax({ url: moreUrl }).then(function (result) {
                var topicsAdded = 0;

                if (result) {
                  var _ret2 = (function () {
                    // the new topics loaded from the server
                    var newTopics = topicsFrom(result, store),
                        topics = self.get("topics");

                    self.forEachNew(newTopics, function (t) {
                      t.set('highlight', topicsAdded++ === 0);
                      topics.pushObject(t);
                    });

                    self.setProperties({
                      loadingMore: false,
                      more_topics_url: result.topic_list.more_topics_url
                    });

                    Discourse.Session.currentProp('topicList', self);
                    return {
                      v: self.get('more_topics_url')
                    };
                  })();

                  if (typeof _ret2 === 'object') return _ret2.v;
                }
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        } else {
          // Return a promise indicating no more results
          return Ember.RSVP.resolve();
        }
      },

      // loads topics with these ids "before" the current topics
      loadBefore: function (topic_ids) {
        var topicList = this,
            topics = this.get('topics');

        // refresh dupes
        topics.removeObjects(topics.filter(function (topic) {
          return topic_ids.indexOf(topic.get('id')) >= 0;
        }));

        var url = '' + Discourse.getURL("/") + this.get('filter') + '?topic_ids=' + topic_ids.join(",");
        var store = this.store;

        return Discourse.ajax({ url: url }).then(function (result) {
          var i = 0;
          topicList.forEachNew(topicsFrom(result, store), function (t) {
            // highlight the first of the new topics so we can get a visual feedback
            t.set('highlight', true);
            topics.insertAt(i, t);
            i++;
          });
          Discourse.Session.currentProp('topicList', topicList);
        });
      }
    });

    TopicList.reopenClass({

      munge: function (json, store) {
        json.inserted = json.inserted || [];
        json.can_create_topic = json.topic_list.can_create_topic;
        json.more_topics_url = json.topic_list.more_topics_url;
        json.draft_key = json.topic_list.draft_key;
        json.draft_sequence = json.topic_list.draft_sequence;
        json.draft = json.topic_list.draft;
        json.for_period = json.topic_list.for_period;
        json.loaded = true;
        json.per_page = json.topic_list.per_page;
        json.topics = topicsFrom(json, store);

        return json;
      },

      find: function (filter, params) {
        var store = Discourse.__container__.lookup('store:main');
        return store.findFiltered('topicList', { filter: filter, params: params });
      },

      // hide the category when it has no children
      hideUniformCategory: function (list, category) {
        list.set('hideCategory', category && !category.get("has_children"));
      }

    });

    __exports__["default"] = TopicList;
  });define("discourse/models/topic-tracking-state", 
  ["discourse/lib/notification-levels","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.startTracking = startTracking;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var NotificationLevels = __dependency1__["default"];
    var computed = __dependency2__["default"];
    var on = __dependency2__.on;

    function isNew(topic) {
      return topic.last_read_post_number === null && (topic.notification_level !== 0 && !topic.notification_level || topic.notification_level >= NotificationLevels.TRACKING);
    }

    function isUnread(topic) {
      return topic.last_read_post_number !== null && topic.last_read_post_number < topic.highest_post_number && topic.notification_level >= NotificationLevels.TRACKING;
    }

    var TopicTrackingState = Discourse.Model.extend(_createDecoratedObject([{
      key: "messageCount",
      initializer: function () {
        return 0;
      }
    }, {
      key: "_setup",
      decorators: [on("init")],
      value: function () {
        this.unreadSequence = [];
        this.newSequence = [];
        this.states = {};
      }
    }, {
      key: "establishChannels",
      value: function () {
        var tracker = this;

        var process = function (data) {
          if (data.message_type === "delete") {
            tracker.removeTopic(data.topic_id);
            tracker.incrementMessageCount();
          }

          if (data.message_type === "new_topic" || data.message_type === "latest") {
            var muted_category_ids = Discourse.User.currentProp("muted_category_ids");
            if (_.include(muted_category_ids, data.payload.category_id)) {
              return;
            }
          }

          // fill parent_category_id we need it for counting new/unread
          if (data.payload && data.payload.category_id) {
            var category = Discourse.Category.findById(data.payload.category_id);

            if (category && category.parent_category_id) {
              data.payload.parent_category_id = category.parent_category_id;
            }
          }

          if (data.message_type === "latest") {
            tracker.notify(data);
          }

          if (data.message_type === "new_topic" || data.message_type === "unread" || data.message_type === "read") {
            tracker.notify(data);
            var old = tracker.states["t" + data.topic_id];

            if (!_.isEqual(old, data.payload)) {
              tracker.states["t" + data.topic_id] = data.payload;
              tracker.incrementMessageCount();
            }
          }
        };

        this.messageBus.subscribe("/new", process);
        this.messageBus.subscribe("/latest", process);
        if (this.currentUser) {
          this.messageBus.subscribe("/unread/" + this.currentUser.get('id'), process);
        }
      }
    }, {
      key: "updateSeen",
      value: function (topicId, highestSeen) {
        if (!topicId || !highestSeen) {
          return;
        }
        var state = this.states["t" + topicId];
        if (state && (!state.last_read_post_number || state.last_read_post_number < highestSeen)) {
          state.last_read_post_number = highestSeen;
          this.incrementMessageCount();
        }
      }
    }, {
      key: "notify",
      value: function (data) {
        if (!this.newIncoming) {
          return;
        }

        var filter = this.get("filter");
        var filterCategory = this.get("filterCategory");
        var categoryId = data.payload && data.payload.category_id;

        if (filterCategory && filterCategory.get("id") !== categoryId) {
          var category = categoryId && Discourse.Category.findById(categoryId);
          if (!category || category.get("parentCategory.id") !== filterCategory.get('id')) {
            return;
          }
        }

        if (filter === Discourse.Utilities.defaultHomepage()) {
          var suppressed_from_homepage_category_ids = Discourse.Site.currentProp("suppressed_from_homepage_category_ids");
          if (_.include(suppressed_from_homepage_category_ids, data.payload.category_id)) {
            return;
          }
        }

        if ((filter === "all" || filter === "latest" || filter === "new") && data.message_type === "new_topic") {
          this.addIncoming(data.topic_id);
        }

        if ((filter === "all" || filter === "unread") && data.message_type === "unread") {
          var old = this.states["t" + data.topic_id];
          if (!old || old.highest_post_number === old.last_read_post_number) {
            this.addIncoming(data.topic_id);
          }
        }

        if (filter === "latest" && data.message_type === "latest") {
          this.addIncoming(data.topic_id);
        }

        this.set("incomingCount", this.newIncoming.length);
      }
    }, {
      key: "addIncoming",
      value: function (topicId) {
        if (this.newIncoming.indexOf(topicId) === -1) {
          this.newIncoming.push(topicId);
        }
      }
    }, {
      key: "resetTracking",
      value: function () {
        this.newIncoming = [];
        this.set("incomingCount", 0);
      }
    }, {
      key: "trackIncoming",

      // track how many new topics came for this filter
      value: function (filter) {
        this.newIncoming = [];
        var split = filter.split('/');

        if (split.length >= 4) {
          filter = split[split.length - 1];
          // c/cat/subcat/l/latest
          var category = Discourse.Category.findSingleBySlug(split.splice(1, split.length - 3).join('/'));
          this.set("filterCategory", category);
        } else {
          this.set("filterCategory", null);
        }

        this.set("filter", filter);
        this.set("incomingCount", 0);
      }
    }, {
      key: "hasIncoming",
      decorators: [computed("incomingCount")],
      value: function (incomingCount) {
        return incomingCount && incomingCount > 0;
      }
    }, {
      key: "removeTopic",
      value: function (topic_id) {
        delete this.states["t" + topic_id];
      }
    }, {
      key: "updateTopics",

      // If we have a cached topic list, we can update it from our tracking
      // information.
      value: function (topics) {
        if (Em.isEmpty(topics)) {
          return;
        }

        var states = this.states;
        topics.forEach(function (t) {
          var state = states['t' + t.get('id')];

          if (state) {
            var lastRead = t.get('last_read_post_number');
            if (lastRead !== state.last_read_post_number) {
              var postsCount = t.get('posts_count');
              var newPosts = postsCount - state.highest_post_number,
                  unread = postsCount - state.last_read_post_number;

              if (newPosts < 0) {
                newPosts = 0;
              }
              if (!state.last_read_post_number) {
                unread = 0;
              }
              if (unread < 0) {
                unread = 0;
              }

              t.setProperties({
                highest_post_number: state.highest_post_number,
                last_read_post_number: state.last_read_post_number,
                new_posts: newPosts,
                unread: unread,
                unseen: !state.last_read_post_number
              });
            }
          }
        });
      }
    }, {
      key: "sync",
      value: function (list, filter) {
        var tracker = this,
            states = tracker.states;

        if (!list || !list.topics) {
          return;
        }

        // compensate for delayed "new" topics
        // client side we know they are not new, server side we think they are
        for (var i = list.topics.length - 1; i >= 0; i--) {
          var state = states["t" + list.topics[i].id];
          if (state && state.last_read_post_number > 0) {
            if (filter === "new") {
              list.topics.splice(i, 1);
            } else {
              list.topics[i].set('unseen', false);
              list.topics[i].set('dont_sync', true);
            }
          }
        }

        list.topics.forEach(function (topic) {
          var row = tracker.states["t" + topic.id] || {};
          row.topic_id = topic.id;
          row.notification_level = topic.notification_level;

          if (topic.unseen) {
            row.last_read_post_number = null;
          } else if (topic.unread || topic.new_posts) {
            row.last_read_post_number = topic.highest_post_number - ((topic.unread || 0) + (topic.new_posts || 0));
          } else {
            if (!topic.dont_sync) {
              delete tracker.states["t" + topic.id];
            }
            return;
          }

          row.highest_post_number = topic.highest_post_number;
          if (topic.category) {
            row.category_id = topic.category.id;
          }

          tracker.states["t" + topic.id] = row;
        });

        // Correct missing states, safeguard in case message bus is corrupt
        if ((filter === "new" || filter === "unread") && !list.more_topics_url) {
          (function () {

            var ids = {};
            list.topics.forEach(function (r) {
              return ids["t" + r.id] = true;
            });

            _.each(tracker.states, function (v, k) {

              // we are good if we are on the list
              if (ids[k]) {
                return;
              }

              if (filter === "unread" && isUnread(v)) {
                // pretend read
                v.last_read_post_number = v.highest_post_number;
              }

              if (filter === "new" && isNew(v)) {
                // pretend not new
                v.last_read_post_number = 1;
              }
            });
          })();
        }

        this.incrementMessageCount();
      }
    }, {
      key: "incrementMessageCount",
      value: function () {
        this.set("messageCount", this.get("messageCount") + 1);
      }
    }, {
      key: "countNew",
      value: function (category_id) {
        return _.chain(this.states).where(isNew).where(function (topic) {
          return topic.category_id === category_id || topic.parent_category_id === category_id || !category_id;
        }).value().length;
      }
    }, {
      key: "resetNew",
      value: function () {
        var _this = this;

        Object.keys(this.states).forEach(function (id) {
          if (_this.states[id].last_read_post_number === null) {
            delete _this.states[id];
          }
        });
      }
    }, {
      key: "countUnread",
      value: function (category_id) {
        return _.chain(this.states).where(isUnread).where(function (topic) {
          return topic.category_id === category_id || topic.parent_category_id === category_id || !category_id;
        }).value().length;
      }
    }, {
      key: "countCategory",
      value: function (category_id) {
        var sum = 0;
        _.each(this.states, function (topic) {
          if (topic.category_id === category_id) {
            sum += topic.last_read_post_number === null || topic.last_read_post_number < topic.highest_post_number ? 1 : 0;
          }
        });
        return sum;
      }
    }, {
      key: "lookupCount",
      value: function (name, category) {
        if (name === "latest") {
          return this.lookupCount("new", category) + this.lookupCount("unread", category);
        }

        var categoryId = category ? Em.get(category, "id") : null;
        var categoryName = category ? Em.get(category, "name") : null;

        if (name === "new") {
          return this.countNew(categoryId);
        } else if (name === "unread") {
          return this.countUnread(categoryId);
        } else {
          categoryName = name.split("/")[1];
          if (categoryName) {
            return this.countCategory(categoryId);
          }
        }
      }
    }, {
      key: "loadStates",
      value: function (data) {
        var states = this.states;
        var idMap = Discourse.Category.idMap();

        // I am taking some shortcuts here to avoid 500 gets for
        // a large list
        if (data) {
          _.each(data, function (topic) {
            var category = idMap[topic.category_id];
            if (category && category.parent_category_id) {
              topic.parent_category_id = category.parent_category_id;
            }
            states["t" + topic.topic_id] = topic;
          });
        }
      }
    }]));

    function startTracking(tracking) {
      var data = PreloadStore.get('topicTrackingStates');
      tracking.loadStates(data);
      tracking.initialStatesLength = data && data.length;
      tracking.establishChannels();
      PreloadStore.remove('topicTrackingStates');
    }

    __exports__["default"] = TopicTrackingState;
  });define("discourse/models/trust-level", 
  ["discourse/models/rest","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var fmt = __dependency2__.fmt;

    __exports__["default"] = RestModel.extend({
      detailedName: fmt('id', 'name', '%@ - %@')
    });
  });

Discourse.TrustLevel = require('discourse/models/trust-level').default;
define("discourse/models/user-action-stat", 
  ["discourse/models/rest","discourse/models/user-action","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var UserAction = __dependency2__["default"];
    var i18n = __dependency3__.i18n;

    __exports__["default"] = RestModel.extend({

      isPM: (function () {
        var actionType = this.get('action_type');
        return actionType === UserAction.TYPES.messages_sent || actionType === UserAction.TYPES.messages_received;
      }).property('action_type'),

      description: i18n('action_type', 'user_action_groups.%@'),

      isResponse: (function () {
        var actionType = this.get('action_type');
        return actionType === UserAction.TYPES.replies || actionType === UserAction.TYPES.quotes;
      }).property('action_type')

    });
  });define("discourse/models/user-posts-stream", 
  ["discourse/lib/computed","discourse/models/admin-post","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var url = __dependency1__.url;
    var AdminPost = __dependency2__["default"];

    __exports__["default"] = Discourse.Model.extend({
      loaded: false,

      _initialize: (function () {
        this.setProperties({
          itemsLoaded: 0,
          canLoadMore: true,
          content: []
        });
      }).on("init"),

      url: url("user.username_lower", "filter", "itemsLoaded", "/posts/%@/%@?offset=%@"),

      filterBy: function (filter) {
        if (this.get("loaded") && this.get("filter") === filter) {
          return Ember.RSVP.resolve();
        }

        this.setProperties({
          filter: filter,
          itemsLoaded: 0,
          canLoadMore: true,
          content: []
        });

        return this.findItems();
      },

      findItems: function () {
        var self = this;
        if (this.get("loading") || !this.get("canLoadMore")) {
          return Ember.RSVP.reject();
        }

        this.set("loading", true);

        return Discourse.ajax(this.get("url"), { cache: false }).then(function (result) {
          if (result) {
            var posts = result.map(function (post) {
              return AdminPost.create(post);
            });
            self.get("content").pushObjects(posts);
            self.setProperties({
              loaded: true,
              itemsLoaded: self.get("itemsLoaded") + posts.length,
              canLoadMore: posts.length > 0
            });
          }
        }).finally(function () {
          self.set("loading", false);
        });
      }

    });
  });define("discourse/models/user-stream", 
  ["discourse/lib/computed","discourse/models/rest","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var url = __dependency1__.url;
    var RestModel = __dependency2__["default"];
    var UserAction = __dependency3__["default"];

    __exports__["default"] = RestModel.extend({
      loaded: false,

      _initialize: (function () {
        this.setProperties({ itemsLoaded: 0, content: [] });
      }).on("init"),

      filterParam: (function () {
        var filter = this.get('filter');
        if (filter === Discourse.UserAction.TYPES.replies) {
          return [UserAction.TYPES.replies, UserAction.TYPES.quotes].join(",");
        }

        if (!filter) {
          return [UserAction.TYPES.topics, UserAction.TYPES.posts].join(",");
        }

        return filter;
      }).property('filter'),

      baseUrl: url('itemsLoaded', 'user.username_lower', '/user_actions.json?offset=%@&username=%@'),

      filterBy: function (filter) {
        this.setProperties({ filter: filter, itemsLoaded: 0, content: [], lastLoadedUrl: null });
        return this.findItems();
      },

      remove: function (userAction) {
        // 1) remove the user action from the child groups
        this.get("content").forEach(function (ua) {
          ["likes", "stars", "edits", "bookmarks"].forEach(function (group) {
            var items = ua.get("childGroups." + group + ".items");
            if (items) {
              items.removeObject(userAction);
            }
          });
        });

        // 2) remove the parents that have no children
        var content = this.get("content").filter(function (ua) {
          return ["likes", "stars", "edits", "bookmarks"].any(function (group) {
            return ua.get("childGroups." + group + ".items.length") > 0;
          });
        });

        this.setProperties({ content: content, itemsLoaded: content.length });
      },

      findItems: function () {
        var self = this;

        var findUrl = this.get('baseUrl');
        if (this.get('filterParam')) {
          findUrl += "&filter=" + this.get('filterParam');
        }

        // Don't load the same stream twice. We're probably at the end.
        var lastLoadedUrl = this.get('lastLoadedUrl');
        if (lastLoadedUrl === findUrl) {
          return Ember.RSVP.resolve();
        }

        if (this.get('loading')) {
          return Ember.RSVP.resolve();
        }
        this.set('loading', true);
        return Discourse.ajax(findUrl, { cache: 'false' }).then(function (result) {
          if (result && result.user_actions) {
            (function () {
              var copy = Em.A();
              result.user_actions.forEach(function (action) {
                action.title = Discourse.Emoji.unescape(Handlebars.Utils.escapeExpression(action.title));
                copy.pushObject(UserAction.create(action));
              });

              self.get('content').pushObjects(UserAction.collapseStream(copy));
              self.setProperties({
                loaded: true,
                itemsLoaded: self.get('itemsLoaded') + result.user_actions.length
              });
            })();
          }
        }).finally(function () {
          self.set('loading', false);
          self.set('lastLoadedUrl', findUrl);
        });
      }

    });
  });define("discourse/models/user", 
  ["discourse/lib/computed","discourse/models/rest","discourse/models/user-stream","discourse/models/user-posts-stream","discourse/mixins/singleton","discourse/lib/formatter","ember-addons/ember-computed-decorators","discourse/models/badge","discourse/models/user-badge","discourse/models/user-action-stat","discourse/models/user-action","discourse/models/group","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __dependency11__, __dependency12__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var url = __dependency1__.url;
    var RestModel = __dependency2__["default"];
    var UserStream = __dependency3__["default"];
    var UserPostsStream = __dependency4__["default"];
    var Singleton = __dependency5__["default"];
    var longDate = __dependency6__.longDate;
    var computed = __dependency7__.default;
    var observes = __dependency7__.observes;
    var Badge = __dependency8__["default"];
    var UserBadge = __dependency9__["default"];
    var UserActionStat = __dependency10__["default"];
    var UserAction = __dependency11__["default"];
    var Group = __dependency12__["default"];

    var User = RestModel.extend(_createDecoratedObject([{
      key: 'hasPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.all", 0);
      }
    }, {
      key: 'hasStartedPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.mine", 0);
      }
    }, {
      key: 'hasUnreadPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.unread", 0);
      }
    }, {
      key: 'hasPosted',
      initializer: function () {
        return Em.computed.gt("post_count", 0);
      }
    }, {
      key: 'hasNotPosted',
      initializer: function () {
        return Em.computed.not("hasPosted");
      }
    }, {
      key: 'canBeDeleted',
      initializer: function () {
        return Em.computed.and("can_be_deleted", "hasNotPosted");
      }
    }, {
      key: 'redirected_to_top',
      initializer: function () {
        return {
          reason: null
        };
      }
    }, {
      key: 'stream',
      decorators: [computed()],
      value: function () {
        return UserStream.create({ user: this });
      }
    }, {
      key: 'postsStream',
      decorators: [computed()],
      value: function () {
        return UserPostsStream.create({ user: this });
      }
    }, {
      key: 'staff',
      initializer: function () {
        return Em.computed.or('admin', 'moderator');
      }
    }, {
      key: 'destroySession',
      value: function () {
        return Discourse.ajax('/session/' + this.get('username'), { type: 'DELETE' });
      }
    }, {
      key: 'searchContext',
      decorators: [computed("username_lower")],
      value: function (username) {
        return {
          type: 'user',
          id: username,
          user: this
        };
      }
    }, {
      key: 'displayName',
      decorators: [computed("username", "name")],
      value: function (username, name) {
        if (Discourse.SiteSettings.enable_names && !Ember.isEmpty(name)) {
          return name;
        }
        return username;
      }
    }, {
      key: 'profileBackground',
      decorators: [computed('profile_background')],
      value: function (bgUrl) {
        if (Em.isEmpty(bgUrl) || !Discourse.SiteSettings.allow_profile_backgrounds) {
          return;
        }
        return ('background-image: url(' + Discourse.getURLWithCDN(bgUrl) + ')').htmlSafe();
      }
    }, {
      key: 'path',
      decorators: [computed()],
      value: function () {
        // no need to observe, requires a hard refresh to update
        return Discourse.getURL('/users/' + this.get('username_lower'));
      }
    }, {
      key: 'adminPath',
      initializer: function () {
        return url('username_lower', "/admin/users/%@");
      }
    }, {
      key: 'mutedTopicsPath',
      initializer: function () {
        return url('/latest?state=muted');
      }
    }, {
      key: 'username_lower',
      decorators: [computed("username")],
      value: function (username) {
        return username.toLowerCase();
      }
    }, {
      key: 'trustLevel',
      decorators: [computed("trust_level")],
      value: function (trustLevel) {
        return Discourse.Site.currentProp('trustLevels').findProperty('id', parseInt(trustLevel, 10));
      }
    }, {
      key: 'isBasic',
      initializer: function () {
        return Em.computed.equal('trust_level', 0);
      }
    }, {
      key: 'isLeader',
      initializer: function () {
        return Em.computed.equal('trust_level', 3);
      }
    }, {
      key: 'isElder',
      initializer: function () {
        return Em.computed.equal('trust_level', 4);
      }
    }, {
      key: 'canManageTopic',
      initializer: function () {
        return Em.computed.or('staff', 'isElder');
      }
    }, {
      key: 'isSuspended',
      initializer: function () {
        return Em.computed.equal('suspended', true);
      }
    }, {
      key: 'suspended',
      decorators: [computed("suspended_till")],
      value: function (suspendedTill) {
        return suspendedTill && moment(suspendedTill).isAfter();
      }
    }, {
      key: 'suspendedTillDate',
      decorators: [computed("suspended_till")],
      value: function (suspendedTill) {
        return longDate(suspendedTill);
      }
    }, {
      key: 'changeUsername',
      value: function (new_username) {
        return Discourse.ajax('/users/' + this.get('username_lower') + '/preferences/username', {
          type: 'PUT',
          data: { new_username: new_username }
        });
      }
    }, {
      key: 'changeEmail',
      value: function (email) {
        return Discourse.ajax('/users/' + this.get('username_lower') + '/preferences/email', {
          type: 'PUT',
          data: { email: email }
        });
      }
    }, {
      key: 'copy',
      value: function () {
        return Discourse.User.create(this.getProperties(Ember.keys(this)));
      }
    }, {
      key: 'save',
      value: function () {
        var _this = this;

        var data = this.getProperties('auto_track_topics_after_msecs', 'bio_raw', 'website', 'location', 'name', 'locale', 'email_digests', 'email_direct', 'email_always', 'email_private_messages', 'dynamic_favicon', 'digest_after_days', 'new_topic_duration_minutes', 'external_links_in_new_tab', 'mailing_list_mode', 'enable_quoting', 'disable_jump_reply', 'custom_fields', 'user_fields', 'muted_usernames', 'profile_background', 'card_background', 'automatically_unpin_topics');

        ['muted', 'watched', 'tracked'].forEach(function (s) {
          var cats = _this.get(s + 'Categories').map(function (c) {
            return c.get('id');
          });
          // HACK: denote lack of categories
          if (cats.length === 0) {
            cats = [-1];
          }
          data[s + '_category_ids'] = cats;
        });

        if (!Discourse.SiteSettings.edit_history_visible_to_public) {
          data['edit_history_public'] = this.get('edit_history_public');
        }

        // TODO: We can remove this when migrated fully to rest model.
        this.set('isSaving', true);
        return Discourse.ajax('/users/' + this.get('username_lower'), {
          data: data,
          type: 'PUT'
        }).then(function (result) {
          _this.set('bio_excerpt', result.user.bio_excerpt);
          var userProps = _this.getProperties('enable_quoting', 'external_links_in_new_tab', 'dynamic_favicon');
          Discourse.User.current().setProperties(userProps);
        }).finally(function () {
          _this.set('isSaving', false);
        });
      }
    }, {
      key: 'changePassword',
      value: function () {
        return Discourse.ajax("/session/forgot_password", {
          dataType: 'json',
          data: { login: this.get('username') },
          type: 'POST'
        });
      }
    }, {
      key: 'loadUserAction',
      value: function (id) {
        var _this2 = this;

        var stream = this.get('stream');
        return Discourse.ajax('/user_actions/' + id + '.json', { cache: 'false' }).then(function (result) {
          if (result && result.user_action) {
            var ua = result.user_action;

            if ((_this2.get('stream.filter') || ua.action_type) !== ua.action_type) return;
            if (!_this2.get('stream.filter') && !_this2.inAllStream(ua)) return;

            var action = UserAction.collapseStream([UserAction.create(ua)]);
            stream.set('itemsLoaded', stream.get('itemsLoaded') + 1);
            stream.get('content').insertAt(0, action[0]);
          }
        });
      }
    }, {
      key: 'inAllStream',
      value: function (ua) {
        return ua.action_type === UserAction.TYPES.posts || ua.action_type === UserAction.TYPES.topics;
      }
    }, {
      key: 'statsCountNonPM',
      decorators: [computed("statsExcludingPms.@each.count")],
      value: function () {
        var _this3 = this;

        if (Ember.isEmpty(this.get('statsExcludingPms'))) return 0;
        var count = 0;
        _.each(this.get('statsExcludingPms'), function (val) {
          if (_this3.inAllStream(val)) {
            count += val.count;
          }
        });
        return count;
      }
    }, {
      key: 'statsExcludingPms',
      decorators: [computed("stats.@each.isPM")],
      value: function () {
        if (Ember.isEmpty(this.get('stats'))) return [];
        return this.get('stats').rejectProperty('isPM');
      }
    }, {
      key: 'findDetails',
      value: function (options) {
        var user = this;

        return PreloadStore.getAndRemove('user_' + user.get('username'), function () {
          return Discourse.ajax('/users/' + user.get('username') + '.json', { data: options });
        }).then(function (json) {

          if (!Em.isEmpty(json.user.stats)) {
            json.user.stats = Discourse.User.groupStats(_.map(json.user.stats, function (s) {
              if (s.count) s.count = parseInt(s.count, 10);
              return UserActionStat.create(s);
            }));
          }

          if (!Em.isEmpty(json.user.custom_groups)) {
            json.user.custom_groups = json.user.custom_groups.map(function (g) {
              return Group.create(g);
            });
          }

          if (json.user.invited_by) {
            json.user.invited_by = Discourse.User.create(json.user.invited_by);
          }

          if (!Em.isEmpty(json.user.featured_user_badge_ids)) {
            (function () {
              var userBadgesMap = {};
              UserBadge.createFromJson(json).forEach(function (userBadge) {
                userBadgesMap[userBadge.get('id')] = userBadge;
              });
              json.user.featured_user_badges = json.user.featured_user_badge_ids.map(function (id) {
                return userBadgesMap[id];
              });
            })();
          }

          if (json.user.card_badge) {
            json.user.card_badge = Badge.create(json.user.card_badge);
          }

          user.setProperties(json.user);
          return user;
        });
      }
    }, {
      key: 'findStaffInfo',
      value: function () {
        var _this4 = this;

        if (!Discourse.User.currentProp("staff")) {
          return Ember.RSVP.resolve(null);
        }
        return Discourse.ajax('/users/' + this.get("username_lower") + '/staff-info.json').then(function (info) {
          _this4.setProperties(info);
        });
      }
    }, {
      key: 'pickAvatar',
      value: function (upload_id, type, avatar_template) {
        var _this5 = this;

        return Discourse.ajax('/users/' + this.get("username_lower") + '/preferences/avatar/pick', {
          type: 'PUT',
          data: { upload_id: upload_id, type: type }
        }).then(function () {
          return _this5.setProperties({
            avatar_template: avatar_template,
            uploaded_avatar_id: upload_id
          });
        });
      }
    }, {
      key: 'isAllowedToUploadAFile',
      value: function (type) {
        return this.get('staff') || this.get('trust_level') > 0 || Discourse.SiteSettings['newuser_max_' + type + 's'] > 0;
      }
    }, {
      key: 'createInvite',
      value: function (email, group_names) {
        return Discourse.ajax('/invites', {
          type: 'POST',
          data: { email: email, group_names: group_names }
        });
      }
    }, {
      key: 'generateInviteLink',
      value: function (email, group_names, topic_id) {
        return Discourse.ajax('/invites/link', {
          type: 'POST',
          data: { email: email, group_names: group_names, topic_id: topic_id }
        });
      }
    }, {
      key: 'updateMutedCategories',
      decorators: [observes("muted_category_ids")],
      value: function () {
        this.set("mutedCategories", Discourse.Category.findByIds(this.muted_category_ids));
      }
    }, {
      key: 'updateTrackedCategories',
      decorators: [observes("tracked_category_ids")],
      value: function () {
        this.set("trackedCategories", Discourse.Category.findByIds(this.tracked_category_ids));
      }
    }, {
      key: 'updateWatchedCategories',
      decorators: [observes("watched_category_ids")],
      value: function () {
        this.set("watchedCategories", Discourse.Category.findByIds(this.watched_category_ids));
      }
    }, {
      key: 'canDeleteAccount',
      decorators: [computed("can_delete_account", "reply_count", "topic_count")],
      value: function (canDeleteAccount, replyCount, topicCount) {
        return !Discourse.SiteSettings.enable_sso && canDeleteAccount && (replyCount || 0) + (topicCount || 0) <= 1;
      }
    }, {
      key: "delete",
      initializer: function () {
        return function () {
          if (this.get('can_delete_account')) {
            return Discourse.ajax("/users/" + this.get('username'), {
              type: 'DELETE',
              data: { context: window.location.pathname }
            });
          } else {
            return Ember.RSVP.reject(I18n.t('user.delete_yourself_not_allowed'));
          }
        };
      }
    }, {
      key: 'dismissBanner',
      value: function (bannerKey) {
        this.set("dismissed_banner_key", bannerKey);
        Discourse.ajax('/users/' + this.get('username'), {
          type: 'PUT',
          data: { dismissed_banner_key: bannerKey }
        });
      }
    }, {
      key: 'checkEmail',
      value: function () {
        var _this6 = this;

        return Discourse.ajax('/users/' + this.get("username_lower") + '/emails.json', {
          type: "PUT",
          data: { context: window.location.pathname }
        }).then(function (result) {
          if (result) {
            _this6.setProperties({
              email: result.email,
              associated_accounts: result.associated_accounts
            });
          }
        });
      }
    }]));

    User.reopenClass(Singleton, {

      // Find a `Discourse.User` for a given username.
      findByUsername: function (username, options) {
        var user = User.create({ username: username });
        return user.findDetails(options);
      },

      // TODO: Use app.register and junk Singleton
      createCurrent: function () {
        var userJson = PreloadStore.get('currentUser');
        if (userJson) {
          var store = Discourse.__container__.lookup('store:main');
          return store.createRecord('user', userJson);
        }
        return null;
      },

      checkUsername: function (username, email, for_user_id) {
        return Discourse.ajax('/users/check_username', {
          data: { username: username, email: email, for_user_id: for_user_id }
        });
      },

      groupStats: function (stats) {
        var responses = UserActionStat.create({
          count: 0,
          action_type: UserAction.TYPES.replies
        });

        stats.filterProperty('isResponse').forEach(function (stat) {
          responses.set('count', responses.get('count') + stat.get('count'));
        });

        var result = Em.A();
        result.pushObjects(stats.rejectProperty('isResponse'));

        var insertAt = 0;
        result.forEach(function (item, index) {
          if (item.action_type === UserAction.TYPES.topics || item.action_type === UserAction.TYPES.posts) {
            insertAt = index + 1;
          }
        });
        if (responses.count > 0) {
          result.insertAt(insertAt, responses);
        }
        return result;
      },

      createAccount: function (attrs) {
        return Discourse.ajax("/users", {
          data: {
            name: attrs.accountName,
            email: attrs.accountEmail,
            password: attrs.accountPassword,
            username: attrs.accountUsername,
            password_confirmation: attrs.accountPasswordConfirm,
            challenge: attrs.accountChallenge,
            user_fields: attrs.userFields
          },
          type: 'POST'
        });
      }
    });

    __exports__["default"] = User;

    // The user's stat count, excluding PMs.

    // The user's stats, excluding PMs.
  });

Discourse.User = require('discourse/models/user').default;
define("discourse/components/actions-summary", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","discourse/lib/formatter","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var autoUpdatingRelativeAge = __dependency3__.autoUpdatingRelativeAge;
    var on = __dependency4__.on;

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'section';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':post-actions', 'hidden'];
      }
    }, {
      key: 'actionsSummary',
      initializer: function () {
        return Em.computed.alias('post.actionsWithoutLikes');
      }
    }, {
      key: 'emptySummary',
      initializer: function () {
        return Em.computed.empty('actionsSummary');
      }
    }, {
      key: 'hidden',
      initializer: function () {
        return Em.computed.and('emptySummary', 'post.notDeleted');
      }
    }, {
      key: 'usersByType',
      initializer: function () {
        return null;
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['actionsSummary.@each', 'post.deleted'];
      }
    }, {
      key: 'initUsersByType',
      decorators: [on('init')],
      value: function () {
        this.set('usersByType', {});
      }
    }, {
      key: 'renderString',

      // This was creating way too many bound ifs and subviews in the handlebars version.
      value: function (buffer) {
        var usersByType = this.get('usersByType');

        if (!this.get('emptySummary')) {
          this.get('actionsSummary').forEach(function (c) {
            var id = c.get('id');
            var users = usersByType[id] || [];

            buffer.push("<div class='post-action'>");

            var renderLink = function (dataAttribute, text) {
              buffer.push(' <span class=\'action-link ' + dataAttribute + '-action\'><a href data-' + dataAttribute + '=\'' + id + '\'>' + text + '</a>.</span>');
            };

            // TODO multi line expansion for flags
            var iconsHtml = "";
            if (users.length) {
              (function () {
                var postUrl = undefined;
                users.forEach(function (u) {
                  var username = u.get('username');

                  iconsHtml += '<a href="' + Discourse.getURL("/users") + username + '" data-user-card="' + username + '">';
                  if (u.post_url) {
                    postUrl = postUrl || u.post_url;
                  }
                  iconsHtml += Discourse.Utilities.avatarImg({
                    size: 'small',
                    avatarTemplate: u.get('avatar_template'),
                    title: u.get('username')
                  });
                  iconsHtml += "</a>";
                });

                var key = 'post.actions.people.' + c.get('actionType.name_key');
                if (postUrl) {
                  key = key + "_with_url";
                }

                // TODO postUrl might be uninitialized? pick a good default
                buffer.push(" " + I18n.t(key, { icons: iconsHtml, postUrl: postUrl }) + ".");
              })();
            }

            if (users.length === 0) {
              renderLink('who-acted', c.get('description'));
            }

            if (c.get('can_undo')) {
              renderLink('undo', I18n.t("post.actions.undo." + c.get('actionType.name_key')));
            }
            if (c.get('can_defer_flags')) {
              renderLink('defer-flags', I18n.t("post.actions.defer_flags", { count: c.count }));
            }

            buffer.push("</div>");
          });
        }

        var post = this.get('post');
        if (post.get('deleted')) {
          buffer.push("<div class='post-action'>" + iconHTML('fa-trash-o') + '&nbsp;' + Discourse.Utilities.tinyAvatar(post.get('postDeletedBy.avatar_template'), { title: post.get('postDeletedBy.username') }) + autoUpdatingRelativeAge(new Date(post.get('postDeletedAt'))) + "</div>");
        }

        buffer.push("<div class='clearfix'></div>");
      }
    }, {
      key: 'actionTypeById',
      value: function (actionTypeId) {
        return this.get('actionsSummary').findProperty('id', actionTypeId);
      }
    }, {
      key: 'click',
      value: function (e) {
        var _this = this;

        var $target = $(e.target);
        var actionTypeId = undefined;

        var post = this.get('post');

        if (actionTypeId = $target.data('defer-flags')) {
          this.actionTypeById(actionTypeId).deferFlags(post);
          return false;
        }

        // User wants to know who actioned it
        var usersByType = this.get('usersByType');
        if (actionTypeId = $target.data('who-acted')) {
          this.actionTypeById(actionTypeId).loadUsers(post).then(function (users) {
            usersByType[actionTypeId] = users;
            _this.rerender();
          });
          return false;
        }

        if (actionTypeId = $target.data('undo')) {
          this.get('actionsSummary').findProperty('id', actionTypeId).undo(post);
          return false;
        }

        return false;
      }
    }]));
  });define("discourse/components/activity-filter", 
  ["discourse/mixins/string-buffer","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'li',
      classNameBindings: ['active', 'noGlyph'],

      rerenderTriggers: ['content.count', 'count'],
      noGlyph: Em.computed.empty('icon'),

      isIndexStream: (function () {
        return !this.get('content');
      }).property('content.count'),

      active: (function () {
        if (this.get('isIndexStream')) {
          return !this.get('userActionType');
        }
        var content = this.get('content');
        if (content) {
          return parseInt(this.get('userActionType'), 10) === parseInt(Em.get(content, 'action_type'), 10);
        }
      }).property('userActionType', 'isIndexStream'),

      activityCount: (function () {
        return this.get('content.count') || this.get('count') || 0;
      }).property('content.count', 'count'),

      typeKey: (function () {
        var actionType = this.get('content.action_type');
        if (actionType === UserAction.TYPES.messages_received) {
          return "";
        }

        var result = UserAction.TYPES_INVERTED[actionType];
        if (!result) {
          return "";
        }

        // We like our URLS to have hyphens, not underscores
        return "/" + result.replace("_", "-");
      }).property('content.action_type'),

      url: (function () {
        return "/users/" + this.get('user.username_lower') + "/activity" + this.get('typeKey');
      }).property('typeKey', 'user.username_lower'),

      description: (function () {
        return this.get('content.description') || I18n.t("user.filters.all");
      }).property('content.description'),

      renderString: function (buffer) {
        buffer.push("<a href='" + this.get('url') + "'>");
        var icon = this.get('icon');
        if (icon) {
          buffer.push("<i class='glyph fa fa-" + icon + "'></i> ");
        }
        buffer.push(this.get('description') + " <span class='count'>(" + this.get('activityCount') + ")</span></a>");
      },

      icon: (function () {
        switch (parseInt(this.get('content.action_type'), 10)) {
          case UserAction.TYPES.likes_received:
            return "heart";
          case UserAction.TYPES.bookmarks:
            return "bookmark";
          case UserAction.TYPES.edits:
            return "pencil";
          case UserAction.TYPES.replies:
            return "reply";
          case UserAction.TYPES.mentions:
            return "at";
        }
      }).property("content.action_type")
    });
  });define("discourse/components/auto-close-form", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: "limited",
      initializer: function () {
        return false;
      }
    }, {
      key: "autoCloseValid",
      initializer: function () {
        return false;
      }
    }, {
      key: "autoCloseUnits",
      decorators: [computed("limited")],
      value: function (limited) {
        var key = limited ? "composer.auto_close.limited.units" : "composer.auto_close.all.units";
        return I18n.t(key);
      }
    }, {
      key: "autoCloseExamples",
      decorators: [computed("limited")],
      value: function (limited) {
        var key = limited ? "composer.auto_close.limited.examples" : "composer.auto_close.all.examples";
        return I18n.t(key);
      }
    }, {
      key: "_updateAutoCloseValid",
      decorators: [observes("autoCloseTime", "limited")],
      value: function () {
        var limited = this.get("limited"),
            autoCloseTime = this.get("autoCloseTime"),
            isValid = this._isAutoCloseValid(autoCloseTime, limited);
        this.set("autoCloseValid", isValid);
      }
    }, {
      key: "_isAutoCloseValid",
      value: function (autoCloseTime, limited) {
        var t = (autoCloseTime || "").toString().trim();
        if (t.length === 0) {
          // "empty" is always valid
          return true;
        } else if (limited) {
          // only # of hours in limited mode
          return t.match(/^(\d+\.)?\d+$/);
        } else {
          if (t.match(/^\d{4}-\d{1,2}-\d{1,2}(?: \d{1,2}:\d{2}(\s?[AP]M)?){0,1}$/i)) {
            // timestamp must be in the future
            return moment(t).isAfter();
          } else {
            // either # of hours or absolute time
            return (t.match(/^(\d+\.)?\d+$/) || t.match(/^\d{1,2}:\d{2}(\s?[AP]M)?$/i)) !== null;
          }
        }
      }
    }]));
  });define("discourse/components/avatar-uploader", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/upload","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var UploadMixin = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, _createDecoratedObject([{
      key: "type",
      initializer: function () {
        return "avatar";
      }
    }, {
      key: "tagName",
      initializer: function () {
        return "span";
      }
    }, {
      key: "imageIsNotASquare",
      initializer: function () {
        return false;
      }
    }, {
      key: "uploadButtonText",
      decorators: [computed("uploading")],
      value: function (uploading) {
        return uploading ? I18n.t("uploading") : I18n.t("user.change_avatar.upload_picture");
      }
    }, {
      key: "uploadDone",
      value: function (upload) {
        this.setProperties({
          imageIsNotASquare: upload.width !== upload.height,
          uploadedAvatarTemplate: upload.url,
          uploadedAvatarId: upload.id
        });

        this.sendAction("done");
      }
    }, {
      key: "data",
      decorators: [computed("user_id")],
      value: function (user_id) {
        return { user_id: user_id };
      }
    }]));
  });define("discourse/components/badge-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',
      classNameBindings: [':user-badge', 'badge.badgeTypeClassName'],
      title: Em.computed.alias('badge.displayDescription'),
      attributeBindings: ['data-badge-name', 'title'],
      'data-badge-name': Em.computed.alias('badge.name')
    });
  });define("discourse/components/basic-topic-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      loading: Ember.computed.not('loaded'),

      loaded: (function () {
        var topicList = this.get('topicList');
        if (topicList) {
          return topicList.get('loaded');
        } else {
          return true;
        }
      }).property('topicList.loaded'),

      _topicListChanged: (function () {
        this._initFromTopicList(this.get('topicList'));
      }).observes('topicList.@each'),

      _initFromTopicList: function (topicList) {
        if (topicList !== null) {
          this.set('topics', topicList.get('topics'));
          this.rerender();
        }
      },

      init: function () {
        this._super();
        var topicList = this.get('topicList');
        if (topicList) {
          this._initFromTopicList(topicList);
        } else {
          // Without a topic list, we assume it's loaded always.
          this.set('loaded', true);
        }
      }

    });
  });define("discourse/components/bread-crumbs", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  A breadcrumb including category drop downs
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['hidden:hidden', ':category-breadcrumb'],
      tagName: 'ol',
      parentCategory: Em.computed.alias('category.parentCategory'),

      parentCategories: Em.computed.filter('categories', function (c) {
        if (c.id === this.site.get("uncategorized_category_id") && !this.siteSettings.allow_uncategorized_topics) {
          // Don't show "uncategorized" if allow_uncategorized_topics setting is false.
          return false;
        }
        return !c.get('parentCategory');
      }),

      hidden: (function () {
        return Discourse.Mobile.mobileView && !this.get('category');
      }).property('category'),

      firstCategory: (function () {
        return this.get('parentCategory') || this.get('category');
      }).property('parentCategory', 'category'),

      secondCategory: (function () {
        if (this.get('parentCategory')) return this.get('category');
        return null;
      }).property('category', 'parentCategory'),

      childCategories: (function () {
        if (this.get('hideSubcategories')) {
          return [];
        }
        var firstCategory = this.get('firstCategory');
        if (!firstCategory) {
          return [];
        }

        return this.get('categories').filter(function (c) {
          return c.get('parentCategory') === firstCategory;
        });
      }).property('firstCategory', 'hideSubcategories'),

      render: function (buffer) {
        if (this.get('hidden')) {
          return;
        }
        this._super(buffer);
      }

    });
  });define("discourse/components/bulk-select-button", 
  ["discourse/lib/show-modal","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend({
      actions: {
        showBulkActions: function () {
          var controller = showModal('topic-bulk-actions', { model: this.get('selected'), title: 'topics.bulk.actions' });
          controller.set('refreshTarget', this.get('refreshTarget'));
        }
      }
    });
  });define("discourse/components/categories-admin-dropdown", 
  ["discourse/helpers/fa-icon","discourse/components/dropdown-button","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var iconHTML = __dependency1__.iconHTML;
    var DropdownButton = __dependency2__["default"];
    var computed = __dependency3__["default"];

    __exports__["default"] = DropdownButton.extend(_createDecoratedObject([{
      key: 'buttonExtraClasses',
      initializer: function () {
        return 'no-text';
      }
    }, {
      key: 'title',
      initializer: function () {
        return '';
      }
    }, {
      key: 'text',
      initializer: function () {
        return iconHTML('bars') + ' ' + iconHTML('caret-down');
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['category-notification-menu', 'category-admin-menu'];
      }
    }, {
      key: 'dropDownContent',
      decorators: [computed()],
      value: function () {
        var includeReorder = this.get('siteSettings.fixed_category_positions');
        var items = [{ id: 'create',
          title: I18n.t('category.create'),
          description: I18n.t('category.create_long'),
          styleClasses: 'fa fa-plus' }];
        if (includeReorder) {
          items.push({
            id: 'reorder',
            title: I18n.t('categories.reorder.title'),
            description: I18n.t('categories.reorder.title_long'),
            styleClasses: 'fa fa-random'
          });
        }
        return items;
      }
    }, {
      key: 'actionNames',
      initializer: function () {
        return {
          create: 'createCategory',
          reorder: 'reorderCategories'
        };
      }
    }, {
      key: 'clicked',
      value: function (id) {
        this.sendAction('actionNames.' + id);
      }
    }]));
  });define("discourse/components/category-chooser", 
  ["discourse/components/combo-box","discourse/helpers/category-link","ember-addons/ember-computed-decorators","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ComboboxView = __dependency1__["default"];
    var categoryBadgeHTML = __dependency2__.categoryBadgeHTML;
    var computed = __dependency3__["default"];
    var observes = __dependency3__.observes;
    var on = __dependency3__.on;
    var PermissionType = __dependency4__["default"];

    __exports__["default"] = ComboboxView.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['combobox category-combobox'];
      }
    }, {
      key: 'overrideWidths',
      initializer: function () {
        return true;
      }
    }, {
      key: 'dataAttributes',
      initializer: function () {
        return ['id', 'description_text'];
      }
    }, {
      key: 'valueBinding',
      initializer: function () {
        return Ember.Binding.oneWay('source');
      }
    }, {
      key: 'castInteger',
      initializer: function () {
        return true;
      }
    }, {
      key: 'content',
      decorators: [computed("scopedCategoryId", "categories")],
      value: function (scopedCategoryId, categories) {
        // Always scope to the parent of a category, if present
        if (scopedCategoryId) {
          var scopedCat = Discourse.Category.findById(scopedCategoryId);
          scopedCategoryId = scopedCat.get('parent_category_id') || scopedCat.get('id');
        }

        return categories.filter(function (c) {
          if (scopedCategoryId && c.get('id') !== scopedCategoryId && c.get('parent_category_id') !== scopedCategoryId) {
            return false;
          }
          if (c.get('isUncategorizedCategory')) {
            return false;
          }
          if (c.get('contains_messages')) {
            return false;
          }
          return c.get('permission') === PermissionType.FULL;
        });
      }
    }, {
      key: '_updateCategories',
      decorators: [observes("site.sortedCategories"), on("init")],
      value: function () {
        if (!this.get('categories')) {
          var categories = Discourse.SiteSettings.fixed_category_positions_on_create ? Discourse.Category.list() : Discourse.Category.listByActivity();
          this.set('categories', categories);
        }
      }
    }, {
      key: 'none',
      decorators: [computed("rootNone")],
      value: function (rootNone) {
        if (Discourse.SiteSettings.allow_uncategorized_topics) {
          if (rootNone) {
            return "category.none";
          } else {
            return Discourse.Category.findUncategorized();
          }
        } else {
          return 'category.choose';
        }
      }
    }, {
      key: 'comboTemplate',
      value: function (item) {
        var category = undefined;

        // If we have no id, but text with the uncategorized name, we can use that badge.
        if (Ember.isEmpty(item.id)) {
          var uncat = Discourse.Category.findUncategorized();
          if (uncat && uncat.get('name') === item.text) {
            category = uncat;
          }
        } else {
          category = Discourse.Category.findById(parseInt(item.id, 10));
        }

        if (!category) return item.text;
        var result = categoryBadgeHTML(category, { link: false, allowUncategorized: true, hideParent: true });
        var parentCategoryId = category.get('parent_category_id');

        if (parentCategoryId) {
          result = categoryBadgeHTML(Discourse.Category.findById(parentCategoryId), { link: false }) + "&nbsp;" + result;
        }

        result += ' <span class=\'topic-count\'>&times; ' + category.get('topic_count') + '</span>';

        var description = category.get('description');
        // TODO wtf how can this be null?;
        if (description && description !== 'null') {
          result += '<div class="category-desc">' + description.substr(0, 200) + (description.length > 200 ? '&hellip;' : '') + '</div>';
        }

        return result;
      }
    }]));
  });define("discourse/components/category-drop", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var get = Ember.get;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['category::no-category', 'categories:has-drop', 'categoryStyle'],
      categoryStyle: setting('category_style'),

      tagName: 'li',

      iconClass: (function () {
        if (this.get('expanded')) {
          return "fa fa-caret-down";
        }
        return "fa fa-caret-right";
      }).property('expanded'),

      allCategoriesUrl: (function () {
        if (this.get('subCategory')) {
          return this.get('parentCategory.url') || "/";
        } else {
          return "/";
        }
      }).property('parentCategory.url', 'subCategory'),

      noCategoriesUrl: (function () {
        return this.get('parentCategory.url') + "/none";
      }).property('parentCategory.url'),

      allCategoriesLabel: (function () {
        if (this.get('subCategory')) {
          return I18n.t('categories.all_subcategories', { categoryName: this.get('parentCategory.name') });
        }
        return I18n.t('categories.all');
      }).property('category'),

      dropdownButtonClass: (function () {
        var result = 'badge-category category-dropdown-button';
        if (Em.isNone(this.get('category'))) {
          result += ' home';
        }
        return result;
      }).property('category'),

      categoryColor: (function () {
        var category = this.get('category');

        if (category) {
          var color = get(category, 'color');

          if (color) {
            var style = "";
            if (color) {
              style += "background-color: #" + color + ";";
            }
            return style.htmlSafe();
          }
        }

        return "background-color: #eee;".htmlSafe();
      }).property('category'),

      badgeStyle: (function () {
        var category = this.get('category');

        if (category) {
          var color = get(category, 'color'),
              textColor = get(category, 'text_color');

          if (color || textColor) {
            var style = "";
            if (color) {
              style += "background-color: #" + color + "; border-color: #" + color + ";";
            }
            if (textColor) {
              style += "color: #" + textColor + "; ";
            }
            return style.htmlSafe();
          }
        }

        return "background-color: #eee; color: #333".htmlSafe();
      }).property('category'),

      clickEventName: (function () {
        return "click.category-drop-" + (this.get('category.id') || "all");
      }).property('category.id'),

      actions: {
        expand: function () {
          var self = this;

          if (!this.get('renderCategories')) {
            this.set('renderCategories', true);
            Em.run.next(function () {
              self.send('expand');
            });
            return;
          }

          if (this.get('expanded')) {
            this.close();
            return;
          }

          if (this.get('categories')) {
            this.set('expanded', true);
          }
          var $dropdown = this.$()[0];

          this.$('a[data-drop-close]').on('click.category-drop', function () {
            self.close();
          });

          Em.run.next(function () {
            self.$('.cat a').add('html').on(self.get('clickEventName'), function (e) {
              var $target = $(e.target),
                  closest = $target.closest($dropdown);

              if ($(e.currentTarget).hasClass('badge-wrapper')) {
                self.close();
              }

              return $(e.currentTarget).hasClass('badge-category') || closest.length && closest[0] === $dropdown ? true : self.close();
            });
          });
        }
      },

      removeEvents: function () {
        $('html').off(this.get('clickEventName'));
        this.$('a[data-drop-close]').off('click.category-drop');
      },

      close: function () {
        this.removeEvents();
        this.set('expanded', false);
      },

      willDestroyElement: function () {
        this.removeEvents();
      }

    });
  });define("discourse/components/category-group", 
  ["discourse/helpers/category-link","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var categoryBadgeHTML = __dependency1__.categoryBadgeHTML;

    __exports__["default"] = Ember.Component.extend({

      _initializeAutocomplete: (function () {
        var self = this,
            template = this.container.lookup('template:category-group-autocomplete.raw'),
            regexp = new RegExp("href=['\"]" + Discourse.getURL('/c/') + "([^'\"]+)");

        this.$('input').autocomplete({
          items: this.get('categories'),
          single: false,
          allowAny: false,
          dataSource: function (term) {
            return Discourse.Category.list().filter(function (category) {
              var regex = new RegExp(term, "i");
              return category.get("name").match(regex) && !_.contains(self.get('blacklist') || [], category) && !_.contains(self.get('categories'), category);
            });
          },
          onChangeItems: function (items) {
            var categories = _.map(items, function (link) {
              var slug = link.match(regexp)[1];
              return Discourse.Category.findSingleBySlug(slug);
            });
            Em.run.next(function () {
              return self.set("categories", categories);
            });
          },
          template: template,
          transformComplete: function (category) {
            return categoryBadgeHTML(category, { allowUncategorized: true });
          }
        });
      }).on('didInsertElement')

    });
  });define("discourse/components/category-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      classNames: ['notification-options', 'category-notification-menu'],
      buttonIncludesText: false,
      hidden: Em.computed.alias('category.deleted'),
      notificationLevel: Em.computed.alias('category.notification_level'),
      i18nPrefix: 'category.notifications',

      clicked: function (id) {
        this.get('category').setNotification(id);
      }
    });
  });define("discourse/components/category-panel-base", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.buildCategoryPanel = buildCategoryPanel;
    var CategoryPanelBase = Ember.Component.extend({
      classNameBindings: [':modal-tab', 'activeTab::invisible']
    });

    __exports__["default"] = CategoryPanelBase;

    function buildCategoryPanel(tab, extras) {
      return CategoryPanelBase.extend({
        activeTab: Ember.computed.equal('selectedTab', tab)
      }, extras || {});
    }
  });define("discourse/components/category-title-link", 
  ["discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;

    __exports__["default"] = Em.Component.extend({
      tagName: 'h3',

      render: function (buffer) {
        var category = this.get('category');
        var categoryUrl = Discourse.getURL('/c/') + Discourse.Category.slugFor(category);
        var categoryName = Handlebars.Utils.escapeExpression(category.get('name'));

        if (category.get('read_restricted')) {
          buffer.push(iconHTML('lock'));
        }

        buffer.push('<a href=\'' + categoryUrl + '\'>');
        buffer.push('<span class=\'category-name\'>' + categoryName + '</span>');
        buffer.push('</a>');
      }
    });
  });define("discourse/components/category-unread", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span'
    });
  });define("discourse/components/cdn-img", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'img',
      attributeBindings: ['cdnSrc:src'],

      cdnSrc: (function () {
        return Discourse.getURLWithCDN(this.get('src'));
      }).property('src')
    });
  });define("discourse/components/color-picker", 
  ["discourse/views/container","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseContainerView = __dependency1__["default"];

    __exports__["default"] = DiscourseContainerView.extend({
      classNames: 'colors-container',

      _createButtons: (function () {
        var colors = this.get('colors'),
            isUsed,
            usedColors = this.get('usedColors') || [];

        if (!colors) return;

        var self = this;
        colors.forEach(function (color) {
          isUsed = usedColors.indexOf(color.toUpperCase()) >= 0;

          self.attachViewWithArgs({
            tagName: 'button',
            attributeBindings: ['style', 'title'],
            classNames: ['colorpicker'].concat(isUsed ? ['used-color'] : ['unused-color']),
            style: ('background-color: #' + color + ';').htmlSafe(),
            title: isUsed ? I18n.t("category.already_used") : null,
            click: function () {
              self.set("value", color);
              return false;
            }
          });
        });
      }).on('init')
    });
  });define("discourse/components/composer-editor", 
  ["discourse/lib/user-search","ember-addons/ember-computed-decorators","discourse/lib/link-mentions","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var userSearch = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var linkSeenMentions = __dependency3__.linkSeenMentions;
    var fetchUnseenMentions = __dependency3__.fetchUnseenMentions;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['wmd-controls'];
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':wmd-controls', 'showPreview', 'showPreview::hide-preview'];
      }
    }, {
      key: 'uploadProgress',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'showPreview',
      initializer: function () {
        return true;
      }
    }, {
      key: '_xhr',
      initializer: function () {
        return null;
      }
    }, {
      key: 'uploadPlaceholder',
      decorators: [computed],
      value: function () {
        return '[' + I18n.t('uploading') + ']() ';
      }
    }, {
      key: '_setupPreview',
      decorators: [on('init')],
      value: function () {
        var val = Discourse.Mobile.mobileView ? false : this.keyValueStore.get('composer.showPreview') || 'true';
        this.set('showPreview', val === 'true');
      }
    }, {
      key: 'toggleText',
      decorators: [computed('showPreview')],
      initializer: function () {
        return function (showPreview) {
          return showPreview ? I18n.t('composer.hide_preview') : I18n.t('composer.show_preview');
        };
      }
    }, {
      key: 'markdownOptions',
      decorators: [computed],
      value: function () {
        var _this = this;

        return {
          lookupAvatarByPostNumber: function (postNumber, topicId) {
            var topic = _this.get('topic');
            if (!topic) {
              return;
            }

            var posts = topic.get('postStream.posts');
            if (posts && topicId === topic.get('id')) {
              var quotedPost = posts.findProperty("post_number", postNumber);
              if (quotedPost) {
                return Discourse.Utilities.tinyAvatar(quotedPost.get('avatar_template'));
              }
            }
          }
        };
      }
    }, {
      key: '_composerEditorInit',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        var topicId = this.get('topic.id');
        var template = this.container.lookup('template:user-selector-autocomplete.raw');
        var $input = this.$('.d-editor-input');
        $input.autocomplete({
          template: template,
          dataSource: function (term) {
            return userSearch({ term: term, topicId: topicId, includeGroups: true });
          },
          key: "@",
          transformComplete: function (v) {
            return v.username || v.name;
          }
        });

        $input.on('scroll', function () {
          return Ember.run.throttle(_this2, _this2._syncEditorAndPreviewScroll, 20);
        });

        // Focus on the body unless we have a title
        if (!this.get('composer.canEditTitle') && !this.capabilities.isIOS) {
          this.$('.d-editor-input').putCursorAtEnd();
        }

        this._bindUploadTarget();
        this.appEvents.trigger('composer:opened');
      }
    }, {
      key: 'validation',
      decorators: [computed('composer.reply', 'composer.replyLength', 'composer.missingReplyCharacters', 'composer.minimumPostLength', 'lastValidatedAt')],
      value: function (reply, replyLength, missingReplyCharacters, minimumPostLength, lastValidatedAt) {
        var postType = this.get('composer.post.post_type');
        if (postType === this.site.get('post_types.small_action')) {
          return;
        }

        var reason = undefined;
        if (replyLength < 1) {
          reason = I18n.t('composer.error.post_missing');
        } else if (missingReplyCharacters > 0) {
          reason = I18n.t('composer.error.post_length', { min: minimumPostLength });
          var tl = Discourse.User.currentProp("trust_level");
          if (tl === 0 || tl === 1) {
            reason += "<br/>" + I18n.t('composer.error.try_like');
          }
        }

        if (reason) {
          return Discourse.InputValidation.create({ failed: true, reason: reason, lastShownAt: lastValidatedAt });
        }
      }
    }, {
      key: '_syncEditorAndPreviewScroll',
      value: function () {
        var $input = this.$('.d-editor-input');
        var $preview = this.$('.d-editor-preview');

        if ($input.scrollTop() === 0) {
          $preview.scrollTop(0);
          return;
        }

        var inputHeight = $input[0].scrollHeight;
        var previewHeight = $preview[0].scrollHeight;
        if ($input.height() + $input.scrollTop() + 100 > inputHeight) {
          // cheat, special case for bottom
          $preview.scrollTop(previewHeight);
          return;
        }

        var scrollPosition = $input.scrollTop();
        var factor = previewHeight / inputHeight;
        var desired = scrollPosition * factor;
        $preview.scrollTop(desired + 50);
      }
    }, {
      key: '_renderUnseen',
      initializer: function () {
        return function ($preview, unseen) {
          var _this3 = this;

          fetchUnseenMentions($preview, unseen, this.siteSettings).then(function () {
            linkSeenMentions($preview, _this3.siteSettings);
            _this3._warnMentionedGroups($preview);
          });
        };
      }
    }, {
      key: '_warnMentionedGroups',
      value: function ($preview) {
        var _this4 = this;

        Ember.run.scheduleOnce('afterRender', function () {
          _this4._warnedMentions = _this4._warnedMentions || [];
          var found = [];
          $preview.find('.mention-group.notify').each(function (idx, e) {
            var $e = $(e);
            var name = $e.data('name');
            found.push(name);
            if (_this4._warnedMentions.indexOf(name) === -1) {
              _this4._warnedMentions.push(name);
              _this4.sendAction('groupsMentioned', [{ name: name, user_count: $e.data('mentionable-user-count') }]);
            }
          });

          _this4._warnedMentions = found;
        });
      }
    }, {
      key: '_resetUpload',
      value: function (removePlaceholder) {
        this._validUploads--;
        if (this._validUploads === 0) {
          this.setProperties({ uploadProgress: 0, isUploading: false, isCancellable: false });
        }
        if (removePlaceholder) {
          this.set('composer.reply', this.get('composer.reply').replace(this.get('uploadPlaceholder'), ""));
        }
      }
    }, {
      key: '_bindUploadTarget',
      value: function () {
        var _this5 = this;

        this._unbindUploadTarget(); // in case it's still bound, let's clean it up first

        var $element = this.$();
        var csrf = this.session.get('csrfToken');
        var uploadPlaceholder = this.get('uploadPlaceholder');

        $element.fileupload({
          url: Discourse.getURL('/uploads.json?client_id=' + this.messageBus.clientId + '&authenticity_token=' + encodeURIComponent(csrf)),
          dataType: "json",
          pasteZone: $element
        });

        $element.on('fileuploadsubmit', function (e, data) {
          var isUploading = Discourse.Utilities.validateUploadedFiles(data.files);
          data.formData = { type: "composer" };
          _this5.setProperties({ uploadProgress: 0, isUploading: isUploading });
          return isUploading;
        });

        $element.on("fileuploadprogressall", function (e, data) {
          _this5.set("uploadProgress", parseInt(data.loaded / data.total * 100, 10));
        });

        $element.on("fileuploadsend", function (e, data) {
          _this5._validUploads++;
          // add upload placeholders (as much placeholders as valid files dropped)
          var placeholder = _.times(_this5._validUploads, function () {
            return uploadPlaceholder;
          }).join("\n");
          _this5.appEvents.trigger('composer:insert-text', placeholder);

          if (data.xhr && data.originalFiles.length === 1) {
            _this5.set("isCancellable", true);
            _this5._xhr = data.xhr();
          }
        });

        $element.on("fileuploadfail", function (e, data) {
          _this5._resetUpload(true);

          var userCancelled = _this5._xhr && _this5._xhr._userCancelled;
          _this5._xhr = null;

          if (!userCancelled) {
            Discourse.Utilities.displayErrorForUpload(data);
          }
        });

        this.messageBus.subscribe("/uploads/composer", function (upload) {
          // replace upload placeholder
          if (upload && upload.url) {
            if (!_this5._xhr || !_this5._xhr._userCancelled) {
              var markdown = Discourse.Utilities.getUploadMarkdown(upload);
              _this5.set('composer.reply', _this5.get('composer.reply').replace(uploadPlaceholder, markdown));
              _this5._resetUpload(false);
            } else {
              _this5._resetUpload(true);
            }
          } else {
            _this5._resetUpload(true);
            Discourse.Utilities.displayErrorForUpload(upload);
          }
        });

        if (Discourse.Mobile.mobileView) {
          this.$(".mobile-file-upload").on("click.uploader", function () {
            // redirect the click on the hidden file input
            $("#mobile-uploader").click();
          });
        }

        this._firefoxPastingHack();
      }
    }, {
      key: '_firefoxPastingHack',

      // Believe it or not pasting an image in Firefox doesn't work without this code
      value: function () {
        var _this6 = this;

        var uaMatch = navigator.userAgent.match(/Firefox\/(\d+)\.\d/);
        if (uaMatch && parseInt(uaMatch[1]) >= 24) {
          this.$().append(Ember.$("<div id='contenteditable' contenteditable='true' style='height: 0; width: 0; overflow: hidden'></div>"));
          this.$("textarea").off('keydown.contenteditable');
          this.$("textarea").on('keydown.contenteditable', function (event) {
            // Catch Ctrl+v / Cmd+v and hijack focus to a contenteditable div. We can't
            // use the onpaste event because for some reason the paste isn't resumed
            // after we switch focus, probably because it is being executed too late.
            if ((event.ctrlKey || event.metaKey) && event.keyCode === 86) {
              (function () {
                // Save the current textarea selection.
                var textarea = _this6.$("textarea")[0];
                var selectionStart = textarea.selectionStart;
                var selectionEnd = textarea.selectionEnd;

                // Focus the contenteditable div.
                var contentEditableDiv = _this6.$('#contenteditable');
                contentEditableDiv.focus();

                // The paste doesn't finish immediately and we don't have any onpaste
                // event, so wait for 100ms which _should_ be enough time.
                setTimeout(function () {
                  var pastedImg = contentEditableDiv.find('img');

                  if (pastedImg.length === 1) {
                    pastedImg.remove();
                  }

                  // For restoring the selection.
                  textarea.focus();
                  var textareaContent = $(textarea).val(),
                      startContent = textareaContent.substring(0, selectionStart),
                      endContent = textareaContent.substring(selectionEnd);

                  var restoreSelection = function (pastedText) {
                    $(textarea).val(startContent + pastedText + endContent);
                    textarea.selectionStart = selectionStart + pastedText.length;
                    textarea.selectionEnd = textarea.selectionStart;
                  };

                  if (contentEditableDiv.html().length > 0) {
                    // If the image wasn't the only pasted content we just give up and
                    // fall back to the original pasted text.
                    contentEditableDiv.find("br").replaceWith("\n");
                    restoreSelection(contentEditableDiv.text());
                  } else {
                    // Depending on how the image is pasted in, we may get either a
                    // normal URL or a data URI. If we get a data URI we can convert it
                    // to a Blob and upload that, but if it is a regular URL that
                    // operation is prevented for security purposes. When we get a regular
                    // URL let's just create an <img> tag for the image.
                    var imageSrc = pastedImg.attr('src');

                    if (imageSrc.match(/^data:image/)) {
                      (function () {
                        // Restore the cursor position, and remove any selected text.
                        restoreSelection("");

                        // Create a Blob to upload.
                        var image = new Image();
                        image.onload = function () {
                          // Create a new canvas.
                          var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                          canvas.height = image.height;
                          canvas.width = image.width;
                          var ctx = canvas.getContext('2d');
                          ctx.drawImage(image, 0, 0);

                          canvas.toBlob(function (blob) {
                            return _this6.$().fileupload('add', { files: blob });
                          });
                        };
                        image.src = imageSrc;
                      })();
                    } else {
                      restoreSelection("<img src='" + imageSrc + "'>");
                    }
                  }

                  contentEditableDiv.html('');
                }, 100);
              })();
            }
          });
        }
      }
    }, {
      key: '_unbindUploadTarget',
      decorators: [on('willDestroyElement')],
      value: function () {
        this._validUploads = 0;
        this.$(".mobile-file-upload").off("click.uploader");
        this.messageBus.unsubscribe("/uploads/composer");
        var $uploadTarget = this.$();
        try {
          $uploadTarget.fileupload("destroy");
        } catch (e) {/* wasn't initialized yet */}
        $uploadTarget.off();
      }
    }, {
      key: '_composerClosed',
      decorators: [on('willDestroyElement')],
      value: function () {
        var _this7 = this;

        Ember.run.next(function () {
          $('#main-outlet').css('padding-bottom', 0);
          // need to wait a bit for the "slide down" transition of the composer
          Ember.run.later(function () {
            return _this7.appEvents.trigger("composer:closed");
          }, 400);
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          importQuote: function (toolbarEvent) {
            this.sendAction('importQuote', toolbarEvent);
          },

          cancelUpload: function () {
            if (this._xhr) {
              this._xhr._userCancelled = true;
              this._xhr.abort();
            }
            this._resetUpload(true);
          },

          showOptions: function () {
            var myPos = this.$().position();
            var buttonPos = this.$('.options').position();

            this.sendAction('showOptions', { position: "absolute",
              left: myPos.left + buttonPos.left,
              top: myPos.top + buttonPos.top });
          },

          showUploadModal: function (toolbarEvent) {
            this.sendAction('showUploadSelector', toolbarEvent);
          },

          togglePreview: function () {
            this.toggleProperty('showPreview');
            this.keyValueStore.set({ key: 'composer.showPreview', value: this.get('showPreview') });
          },

          extraButtons: function (toolbar) {
            toolbar.addButton({
              id: 'quote',
              group: 'fontStyles',
              icon: 'comment-o',
              sendAction: 'importQuote',
              title: 'composer.quote_post_title',
              unshift: true
            });

            toolbar.addButton({
              id: 'upload',
              group: 'insertions',
              icon: 'upload',
              title: 'upload',
              sendAction: 'showUploadModal'
            });

            if (this.get('canWhisper')) {
              toolbar.addButton({
                id: 'options',
                group: 'extras',
                icon: 'gear',
                title: 'composer.options',
                sendAction: 'showOptions'
              });
            }
          },

          previewUpdated: function ($preview) {
            // Paint mentions
            var unseen = linkSeenMentions($preview, this.siteSettings);
            if (unseen.length) {
              Ember.run.debounce(this, this._renderUnseen, $preview, unseen, 500);
            }

            this._warnMentionedGroups($preview);

            var post = this.get('composer.post');
            var refresh = false;

            // If we are editing a post, we'll refresh its contents once. This is a feature that
            // allows a user to refresh its contents once.
            if (post && !post.get('refreshedPost')) {
              refresh = true;
              post.set('refreshedPost', true);
            }

            // Paint oneboxes
            $('a.onebox', $preview).each(function (i, e) {
              return Discourse.Onebox.load(e, refresh);
            });
            this.trigger('previewRefreshed', $preview);
          }
        };
      }
    }]));
  });define("discourse/components/composer-title", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['title-input'];
      }
    }, {
      key: '_focusOnTitle',
      decorators: [on('didInsertElement')],
      value: function () {
        if (!this.capabilities.isIOS) {
          this.$('input').putCursorAtEnd();
        }
      }
    }, {
      key: 'validation',
      decorators: [computed('composer.titleLength', 'composer.missingTitleCharacters', 'composer.minimumTitleLength', 'lastValidatedAt')],
      value: function (titleLength, missingTitleChars, minimumTitleLength, lastValidatedAt) {

        var reason = undefined;
        if (titleLength < 1) {
          reason = I18n.t('composer.error.title_missing');
        } else if (missingTitleChars > 0) {
          reason = I18n.t('composer.error.title_too_short', { min: minimumTitleLength });
        } else if (titleLength > this.siteSettings.max_topic_title_length) {
          reason = I18n.t('composer.error.title_too_long', { max: this.siteSettings.max_topic_title_length });
        }

        if (reason) {
          return Discourse.InputValidation.create({ failed: true, reason: reason, lastShownAt: lastValidatedAt });
        }
      }
    }]));
  });define("discourse/components/count-i18n", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend(Discourse.StringBuffer, {
      tagName: 'span',
      rerenderTriggers: ['count', 'suffix'],

      renderString: function (buffer) {
        buffer.push(I18n.t(this.get('key') + (this.get('suffix') || ''), { count: this.get('count') }));
      }
    });
  });define("discourse/components/create-topics-notice", 
  ["ember-addons/ember-computed-decorators","discourse/models/live-post-counts","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var observes = __dependency1__.observes;
    var LivePostCounts = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return ['hidden:hidden', ':create-topics-notice'];
      }
    }, {
      key: 'enabled',
      initializer: function () {
        return false;
      }
    }, {
      key: 'publicTopicCount',
      initializer: function () {
        return null;
      }
    }, {
      key: 'publicPostCount',
      initializer: function () {
        return null;
      }
    }, {
      key: 'requiredTopics',
      initializer: function () {
        return 5;
      }
    }, {
      key: 'requiredPosts',
      initializer: function () {
        return Ember.computed.alias('siteSettings.tl1_requires_read_posts');
      }
    }, {
      key: 'init',
      value: function () {
        this._super();
        if (this.get('shouldSee')) {
          var topicCount = 0,
              postCount = 0;

          // Use data we already have before fetching live stats
          _.each(this.site.get('categories'), function (c) {
            if (!c.get('read_restricted')) {
              topicCount += c.get('topic_count');
              postCount += c.get('post_count');
            }
          });

          if (topicCount < this.get('requiredTopics') || postCount < this.get('requiredPosts')) {
            this.set('enabled', true);
            this.fetchLiveStats();
          }
        }
      }
    }, {
      key: 'shouldSee',
      decorators: [computed()],
      value: function () {
        return Discourse.User.currentProp('admin') && this.siteSettings.show_create_topics_notice;
      }
    }, {
      key: 'hidden',
      decorators: [computed('enabled', 'shouldSee', 'publicTopicCount', 'publicPostCount')],
      value: function () {
        return !this.get('enabled') || !this.get('shouldSee') || this.get('publicTopicCount') == null || this.get('publicPostCount') == null;
      }
    }, {
      key: 'message',
      decorators: [computed('publicTopicCount', 'publicPostCount', 'topicTrackingState.incomingCount')],
      value: function () {
        var msg = null;

        if (this.get('publicTopicCount') < this.get('requiredTopics') && this.get('publicPostCount') < this.get('requiredPosts')) {
          msg = 'too_few_topics_and_posts_notice';
        } else if (this.get('publicTopicCount') < this.get('requiredTopics')) {
          msg = 'too_few_topics_notice';
        } else {
          msg = 'too_few_posts_notice';
        }

        return new Handlebars.SafeString(I18n.t(msg, {
          requiredTopics: this.get('requiredTopics'),
          requiredPosts: this.get('requiredPosts'),
          currentTopics: this.get('publicTopicCount'),
          currentPosts: this.get('publicPostCount')
        }));
      }
    }, {
      key: 'fetchLiveStats',
      decorators: [observes('topicTrackingState.incomingCount')],
      value: function () {
        var _this = this;

        if (!this.get('enabled')) {
          return;
        }

        LivePostCounts.find().then(function (stats) {
          if (stats) {
            _this.set('publicTopicCount', stats.get('public_topic_count'));
            _this.set('publicPostCount', stats.get('public_post_count'));
            if (_this.get('publicTopicCount') >= _this.get('requiredTopics') && _this.get('publicPostCount') >= _this.get('requiredPosts')) {
              _this.set('enabled', false); // No more checks
            }
          }
        });
      }
    }]));
  });define("discourse/components/d-button", 
  ["discourse/helpers/fa-icon","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var iconHTML = __dependency1__.iconHTML;
    var computed = __dependency2__.default;
    var observes = __dependency2__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'button';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':btn', 'noText'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['disabled', 'translatedTitle:title'];
      }
    }, {
      key: 'noText',
      initializer: function () {
        return Ember.computed.empty('translatedLabel');
      }
    }, {
      key: 'translatedTitle',
      decorators: [computed("title")],
      value: function (title) {
        if (title) return I18n.t(title);
      }
    }, {
      key: 'translatedLabel',
      decorators: [computed("label")],
      value: function (label) {
        if (label) return I18n.t(label);
      }
    }, {
      key: 'iconChanged',
      decorators: [observes('icon')],
      value: function () {
        this.rerender();
      }
    }, {
      key: 'render',
      value: function (buffer) {
        var label = this.get('translatedLabel'),
            icon = this.get('icon');

        if (label || icon) {
          if (icon) {
            buffer.push(iconHTML(icon) + ' ');
          }
          if (label) {
            buffer.push(label);
          }
        } else {
          // If no label or icon is present, yield
          return this._super(buffer);
        }
      }
    }, {
      key: 'click',
      value: function () {
        this.sendAction("action", this.get("actionParam"));
        return false;
      }
    }]));
  });define("discourse/components/d-checkbox", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'label';
      }
    }, {
      key: '_watchChanges',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        // In Ember 13.3 we can use action on the checkbox `{{input}}` but not in 1.11
        this.$('input').on('click.d-checkbox', function () {
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.sendAction('change');
          });
        });
      }
    }, {
      key: '_stopWatching',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$('input').off('click.d-checkbox');
      }
    }]));
  });define("discourse/components/d-editor-modal", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':d-editor-modal', 'hidden'];
      }
    }, {
      key: '_hiddenChanged',
      decorators: [observes('hidden')],
      value: function () {
        var _this = this;

        if (!this.get('hidden')) {
          Ember.run.scheduleOnce('afterRender', function () {
            var $modal = _this.$();
            var $parent = _this.$().closest('.d-editor');
            var w = $parent.width();
            var h = $parent.height();
            var dir = $('html').css('direction') === 'rtl' ? 'right' : 'left';
            var offset = w / 2 - $modal.outerWidth() / 2;
            $modal.css(dir, offset + 'px');
            parent.$('.d-editor-overlay').removeClass('hidden').css({ width: w, height: h });
            _this.$('input').focus();
          });
        } else {
          parent.$('.d-editor-overlay').addClass('hidden');
        }
      }
    }, {
      key: '_listenKeys',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        this.$().on('keydown.d-modal', function (key) {
          if (_this2.get('hidden')) {
            return;
          }

          if (key.keyCode === 27) {
            _this2.send('cancel');
            return false;
          }
          if (key.keyCode === 13) {
            _this2.send('ok');
            return false;
          }
        });
      }
    }, {
      key: '_stopListening',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$().off('keydown.d-modal');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          ok: function () {
            this.set('hidden', true);
            this.sendAction('okAction');
          },

          cancel: function () {
            this.set('hidden', true);
          }
        };
      }
    }]));
  });define("discourse/components/d-link", 
  ["ember-addons/ember-computed-decorators","discourse/helpers/fa-icon","discourse/lib/intercept-click","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var interceptClick = __dependency3__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'a';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['d-link'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['translatedTitle:title', 'translatedTitle:aria-title', 'href'];
      }
    }, {
      key: 'href',
      decorators: [computed('path')],
      value: function (path) {
        if (path) {
          return path;
        }

        var route = this.get('route');
        if (route) {
          var router = this.container.lookup('router:main');
          if (router && router.router) {
            var params = [route];
            var model = this.get('model');
            if (model) {
              params.push(model);
            }

            return Discourse.getURL(router.router.generate.apply(router.router, params));
          }
        }

        return '';
      }
    }, {
      key: 'translatedTitle',
      decorators: [computed("title")],
      value: function (title) {
        if (title) return I18n.t(title);
      }
    }, {
      key: 'click',
      value: function (e) {
        var action = this.get('action');
        if (action) {
          this.sendAction('action');
          return false;
        }

        return interceptClick(e);
      }
    }, {
      key: 'render',
      value: function (buffer) {
        if (!!this.get('template')) {
          return this._super(buffer);
        }

        var icon = this.get('icon');
        if (icon) {
          buffer.push(iconHTML(icon));
        }

        var label = this.get('label');
        if (label) {
          if (icon) {
            buffer.push(" ");
          }

          var count = this.get('count');
          buffer.push(I18n.t(label, { count: count }));
        }
      }
    }]));
  });define("discourse/components/date-picker", 
  ["discourse/lib/load-script","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    /* global Pikaday:true */

    var loadScript = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = Em.Component.extend(_createDecoratedObject([{
      key: "tagName",
      initializer: function () {
        return "input";
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ["date-picker"];
      }
    }, {
      key: "_picker",
      initializer: function () {
        return null;
      }
    }, {
      key: "_loadDatePicker",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        var input = this.$()[0];

        loadScript("/javascripts/pikaday.js").then(function () {
          _this._picker = new Pikaday({
            field: input,
            format: "YYYY-MM-DD",
            defaultDate: moment().add(1, "day").toDate(),
            minDate: new Date(),
            onSelect: function (date) {
              return _this.set("value", moment(date).format("YYYY-MM-DD"));
            }
          });
        });
      }
    }, {
      key: "_destroy",
      decorators: [on("willDestroyElement")],
      value: function () {
        this._picker = null;
      }
    }]));
  });define("discourse/components/desktop-notification-config", 
  ["ember-addons/ember-computed-decorators","discourse/lib/key-value-store","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];

    var keyValueStore = new KeyValueStore("discourse_desktop_notifications_");

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['controls'];
      }
    }, {
      key: 'notificationsPermission',
      decorators: [computed("isNotSupported")],
      value: function (isNotSupported) {
        return isNotSupported ? "" : Notification.permission;
      }
    }, {
      key: 'notificationsDisabled',
      decorators: [computed],
      initializer: function () {
        return {
          set: function (value) {
            keyValueStore.setItem('notifications-disabled', value);
            return keyValueStore.getItem('notifications-disabled');
          },
          get: function () {
            return keyValueStore.getItem('notifications-disabled');
          }
        };
      }
    }, {
      key: 'isNotSupported',
      decorators: [computed],
      value: function () {
        return typeof window.Notification === "undefined";
      }
    }, {
      key: 'isDefaultPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "default";
      }
    }, {
      key: 'isDeniedPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "denied";
      }
    }, {
      key: 'isGrantedPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "granted";
      }
    }, {
      key: 'isEnabled',
      decorators: [computed("isGrantedPermission", "notificationsDisabled")],
      value: function (isGrantedPermission, notificationsDisabled) {
        return isGrantedPermission ? !notificationsDisabled : false;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          requestPermission: function () {
            var _this = this;

            Notification.requestPermission(function () {
              return _this.propertyDidChange('notificationsPermission');
            });
          },

          recheckPermission: function () {
            this.propertyDidChange('notificationsPermission');
          },

          turnoff: function () {
            this.set('notificationsDisabled', 'disabled');
            this.propertyDidChange('notificationsPermission');
          },

          turnon: function () {
            this.set('notificationsDisabled', '');
            this.propertyDidChange('notificationsPermission');
          }
        };
      }
    }]));
  });define("discourse/components/directory-toggle", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'th',
      classNames: ['sortable'],
      attributeBindings: ['title'],
      rerenderTriggers: ['order', 'asc'],

      title: (function () {
        var labelKey = 'directory.' + this.get('field');
        return I18n.t(labelKey + '_long', { defaultValue: I18n.t(labelKey) });
      }).property('field'),

      renderString: function (buffer) {

        var icon = this.get('icon');
        if (icon) {
          buffer.push(iconHTML(icon));
        }

        var field = this.get('field');
        buffer.push(I18n.t('directory.' + field));

        if (field === this.get('order')) {
          buffer.push(iconHTML(this.get('asc') ? 'chevron-up' : 'chevron-down'));
        }
      },

      click: function () {
        var currentOrder = this.get('order'),
            field = this.get('field');

        if (currentOrder === field) {
          this.set('asc', this.get('asc') ? null : true);
        } else {
          this.setProperties({ order: field, asc: null });
        }
      }
    });
  });define("discourse/components/disabled-icon", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',
      classNameBindings: [':fa-stack']
    });
  });define("discourse/components/discourse-banner", 
  ["discourse/components/visible","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var VisibleComponent = __dependency1__["default"];

    __exports__["default"] = VisibleComponent.extend({

      visible: (function () {
        var bannerKey = this.get("banner.key"),
            dismissedBannerKey = this.get("user.dismissed_banner_key") || this.keyValueStore.get("dismissed_banner_key");

        if (bannerKey) {
          bannerKey = parseInt(bannerKey, 10);
        }
        if (dismissedBannerKey) {
          dismissedBannerKey = parseInt(dismissedBannerKey, 10);
        }

        return !this.get("hide") && bannerKey && dismissedBannerKey !== bannerKey;
      }).property("user.dismissed_banner_key", "banner.key", "hide"),

      actions: {
        dismiss: function () {
          if (this.get("user")) {
            this.get("user").dismissBanner(this.get("banner.key"));
          } else {
            this.set("visible", false);
            this.keyValueStore.set({ key: "dismissed_banner_key", value: this.get("banner.key") });
          }
        }
      }

    });
  });define("discourse/components/edit-category-general", 
  ["discourse/lib/url","discourse/components/edit-category-panel","discourse/helpers/category-link","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var buildCategoryPanel = __dependency2__.buildCategoryPanel;
    var categoryBadgeHTML = __dependency3__.categoryBadgeHTML;
    var Category = __dependency4__["default"];

    __exports__["default"] = buildCategoryPanel('general', {
      foregroundColors: ['FFFFFF', '000000'],
      canSelectParentCategory: Em.computed.not('category.isUncategorizedCategory'),

      // background colors are available as a pipe-separated string
      backgroundColors: (function () {
        var categories = Discourse.Category.list();
        return this.siteSettings.category_colors.split("|").map(function (i) {
          return i.toUpperCase();
        }).concat(categories.map(function (c) {
          return c.color.toUpperCase();
        })).uniq();
      }).property(),

      usedBackgroundColors: (function () {
        var categories = Discourse.Category.list();
        var category = this.get('category');

        // If editing a category, don't include its color:
        return categories.map(function (c) {
          return category.get('id') && category.get('color').toUpperCase() === c.color.toUpperCase() ? null : c.color.toUpperCase();
        }, this).compact();
      }).property('category.id', 'category.color'),

      parentCategories: (function () {
        return Discourse.Category.list().filter(function (c) {
          return !c.get('parentCategory');
        });
      }).property(),

      categoryBadgePreview: (function () {
        var category = this.get('category');
        var c = Category.create({
          name: category.get('categoryName'),
          color: category.get('color'),
          text_color: category.get('text_color'),
          parent_category_id: parseInt(category.get('parent_category_id'), 10),
          read_restricted: category.get('read_restricted')
        });
        return categoryBadgeHTML(c, { link: false });
      }).property('category.parent_category_id', 'category.categoryName', 'category.color', 'category.text_color'),

      // We can change the parent if there are no children
      subCategories: (function () {
        if (Ember.isEmpty(this.get('category.id'))) {
          return null;
        }
        return Category.list().filterBy('parent_category_id', this.get('category.id'));
      }).property('category.id'),

      showDescription: (function () {
        return !this.get('category.isUncategorizedCategory') && this.get('category.id');
      }).property('category.isUncategorizedCategory', 'category.id'),

      actions: {
        showCategoryTopic: function () {
          DiscourseURL.routeTo(this.get('category.topic_url'));
          return false;
        }
      }
    });
  });define("discourse/components/edit-category-images", 
  ["discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;
    __exports__["default"] = buildCategoryPanel('images');
  });define("discourse/components/edit-category-security", 
  ["discourse/components/edit-category-panel","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;
    var PermissionType = __dependency2__["default"];

    __exports__["default"] = buildCategoryPanel('security', {
      editingPermissions: false,
      selectedGroup: null,
      selectedPermission: null,

      actions: {
        editPermissions: function () {
          if (!this.get('category.is_special')) {
            this.set('editingPermissions', true);
          }
        },

        addPermission: function (group, id) {
          if (!this.get('category.is_special')) {
            this.get('category').addPermission({
              group_name: group + "",
              permission: PermissionType.create({ id: id })
            });
          }
        },

        removePermission: function (permission) {
          if (!this.get('category.is_special')) {
            this.get('category').removePermission(permission);
          }
        }
      }
    });
  });define("discourse/components/edit-category-settings", 
  ["discourse/lib/computed","discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var buildCategoryPanel = __dependency2__.buildCategoryPanel;

    __exports__["default"] = buildCategoryPanel('settings', {
      emailInEnabled: setting('email_in'),
      showPositionInput: setting('fixed_category_positions')
    });
  });define("discourse/components/edit-category-tab", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Em.Component.extend({
      tagName: 'li',
      classNameBindings: ['active', 'tabClassName'],

      tabClassName: (function () {
        return 'edit-category-' + this.get('tab');
      }).property('tab'),

      active: propertyEqual('selectedTab', 'tab'),

      title: (function () {
        return I18n.t('category.' + this.get('tab').replace('-', '_'));
      }).property('tab'),

      _addToCollection: (function () {
        this.get('panels').addObject(this.get('tabClassName'));
      }).on('didInsertElement'),

      actions: {
        select: function () {
          this.set('selectedTab', this.get('tab'));
        }
      }
    });
  });define("discourse/components/edit-category-topic-template", 
  ["discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;

    __exports__["default"] = buildCategoryPanel('topic-template', {
      _activeTabChanged: (function () {
        var _this = this;

        if (this.get('activeTab')) {
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.$('.d-editor-input').focus();
          });
        }
      }).observes('activeTab')
    });
  });define("discourse/components/emoji-uploader", 
  ["discourse/mixins/upload","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UploadMixin = __dependency1__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, {
      type: "emoji",
      uploadUrl: "/admin/customize/emojis",

      hasName: Em.computed.notEmpty("name"),
      addDisabled: Em.computed.not("hasName"),

      data: (function () {
        return Ember.isBlank(this.get("name")) ? {} : { name: this.get("name") };
      }).property("name"),

      uploadDone: function (upload) {
        this.set("name", null);
        this.sendAction("done", upload);
      }

    });
  });define("discourse/components/featured-topic", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':featured-topic'],

      click: function (e) {
        var $target = $(e.target);
        if ($target.closest('.last-posted-at').length) {
          this.sendAction('action', { topic: this.get('topic'), position: $target.offset() });
          return false;
        }
      }
    });
  });define("discourse/components/global-notice", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      rerenderTriggers: ['site.isReadOnly'],

      renderString: function (buffer) {
        var notices = [];

        if (this.site.get("isReadOnly")) {
          notices.push([I18n.t("read_only_mode.enabled"), 'alert-read-only']);
        }

        if (this.siteSettings.disable_emails) {
          notices.push([I18n.t("emails_are_disabled"), 'alert-emails-disabled']);
        }

        if (!_.isEmpty(this.siteSettings.global_notice)) {
          notices.push([this.siteSettings.global_notice, 'alert-global-notice']);
        }

        if (notices.length > 0) {
          buffer.push(_.map(notices, function (n) {
            return "<div class='row'><div class='alert alert-info " + n[1] + "'>" + n[0] + "</div></div>";
          }).join(""));
        }
      }
    });
  });define("discourse/components/group-selector", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      placeholder: (function () {
        return I18n.t(this.get("placeholderKey"));
      }).property("placeholderKey"),

      _initializeAutocomplete: (function () {
        var self = this;
        var selectedGroups;

        var template = this.container.lookup('template:group-selector-autocomplete.raw');
        self.$('input').autocomplete({
          allowAny: false,
          onChangeItems: function (items) {
            selectedGroups = items;
            self.set("groupNames", items.join(","));
          },
          transformComplete: function (g) {
            return g.name;
          },
          dataSource: function (term) {
            return self.get("groupFinder")(term).then(function (groups) {

              if (!selectedGroups) {
                return groups;
              }

              return groups.filter(function (group) {
                return !selectedGroups.any(function (s) {
                  return s === group.name;
                });
              });
            });
          },
          template: template
        });
      }).on('didInsertElement')
    });
  });define("discourse/components/hamburger-category", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['category-link'];
      }
    }, {
      key: 'unreadTotal',
      decorators: [computed('category.unreadTopics', 'category.newTopics')],
      value: function (unreadTopics, newTopics) {
        return parseInt(unreadTopics, 10) + parseInt(newTopics, 10);
      }
    }, {
      key: 'showTopicCount',
      initializer: function () {
        return Ember.computed.not('currentUser');
      }
    }]));
  });define("discourse/components/hamburger-menu", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['hamburger-panel'];
      }
    }, {
      key: 'prioritizeFaq',
      decorators: [computed('currentUser.read_faq')],
      value: function (readFaq) {
        // If it's a custom FAQ never prioritize it
        return Ember.isEmpty(this.siteSettings.faq_url) && !readFaq;
      }
    }, {
      key: 'showKeyboardShortcuts',
      decorators: [computed()],
      value: function () {
        return !Discourse.Mobile.mobileView && !this.capabilities.touch;
      }
    }, {
      key: 'showMobileToggle',
      decorators: [computed()],
      value: function () {
        return Discourse.Mobile.mobileView || this.siteSettings.enable_mobile_theme && this.capabilities.touch;
      }
    }, {
      key: 'mobileViewLinkTextKey',
      decorators: [computed()],
      value: function () {
        return Discourse.Mobile.mobileView ? "desktop_view" : "mobile_view";
      }
    }, {
      key: 'faqUrl',
      decorators: [computed()],
      value: function () {
        return this.siteSettings.faq_url ? this.siteSettings.faq_url : Discourse.getURL('/faq');
      }
    }, {
      key: '_lookupCount',
      value: function (type) {
        var state = this.get('topicTrackingState');
        return state ? state.lookupCount(type) : 0;
      }
    }, {
      key: 'newCount',
      decorators: [computed('topicTrackingState.messageCount')],
      value: function () {
        return this._lookupCount('new');
      }
    }, {
      key: 'unreadCount',
      decorators: [computed('topicTrackingState.messageCount')],
      value: function () {
        return this._lookupCount('unread');
      }
    }, {
      key: 'categories',
      decorators: [computed()],
      value: function () {
        var hideUncategorized = !this.siteSettings.allow_uncategorized_topics;
        var showSubcatList = this.siteSettings.show_subcategory_list;
        var isStaff = Discourse.User.currentProp('staff');

        return Discourse.Category.list().reject(function (c) {
          if (showSubcatList && c.get('parent_category_id')) {
            return true;
          }
          if (hideUncategorized && c.get('isUncategorizedCategory') && !isStaff) {
            return true;
          }
          return false;
        });
      }
    }, {
      key: 'showUserDirectoryLink',
      decorators: [computed()],
      value: function () {
        if (!this.siteSettings.enable_user_directory) return false;
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) return false;
        return true;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          keyboardShortcuts: function () {
            this.sendAction('showKeyboardAction');
          },
          toggleMobileView: function () {
            Discourse.Mobile.toggleMobileView();
          }
        };
      }
    }]));
  });define("discourse/components/header-dropdown", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':header-dropdown-toggle', 'active'];
      }
    }, {
      key: 'href',
      decorators: [computed('showUser', 'path')],
      value: function (showUser, path) {
        return showUser ? this.currentUser.get('path') : Discourse.getURL(path);
      }
    }, {
      key: 'active',
      initializer: function () {
        return Ember.computed.alias('toggleVisible');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggle: function () {

            if (this.siteSettings.login_required && !this.currentUser) {
              this.sendAction('loginAction');
            } else {
              if (Discourse.Mobile.mobileView && this.get('mobileAction')) {
                this.sendAction('mobileAction');
                return;
              }

              if (this.get('action')) {
                this.sendAction('action');
              } else {
                this.toggleProperty('toggleVisible');
              }
            }
            this.appEvents.trigger('dropdowns:closeAll');
          }
        };
      }
    }]));
  });define("discourse/components/header-extra-info", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    var TopicCategoryComponent = Ember.Component.extend({
      needsSecondRow: Ember.computed.gt('secondRowItems.length', 0),
      secondRowItems: (function () {
        return [];
      }).property(),

      showPrivateMessageGlyph: (function () {
        return !this.get('topic.is_warning') && this.get('topic.isPrivateMessage');
      }).property('topic.is_warning', 'topic.isPrivateMessage'),

      actions: {
        jumpToTopPost: function () {
          var topic = this.get('topic');
          if (topic) {
            DiscourseURL.routeTo(topic.get('firstPostUrl'));
          }
        }
      }

    });

    var id = 0;

    // Allow us (and plugins) to register themselves as needing a second
    // row in the header. If there is at least one thing in the second row
    // the style changes to accomodate it.
    function needsSecondRowIf(prop, cb) {
      var rowId = "_second_row_" + id++,
          methodHash = {};

      methodHash[id] = (function () {
        var secondRowItems = this.get('secondRowItems'),
            propVal = this.get(prop);
        if (cb.call(this, propVal)) {
          secondRowItems.addObject(rowId);
        } else {
          secondRowItems.removeObject(rowId);
        }
      }).observes(prop).on('init');

      TopicCategoryComponent.reopen(methodHash);
    }

    needsSecondRowIf('topic.category', function (cat) {
      return cat && (!cat.get('isUncategorizedCategory') || !this.siteSettings.suppress_uncategorized_badge);
    });

    __exports__["default"] = TopicCategoryComponent;
    __exports__.needsSecondRowIf = needsSecondRowIf;
  });define("discourse/components/highlight-text", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',

      _highlightOnInsert: (function () {
        var term = this.get('highlight');
        var self = this;

        if (!_.isEmpty(term)) {
          self.$().highlight(term.split(/\s+/), { className: 'search-highlight' });
        }
      }).observes('highlight').on('didInsertElement')

    });
  });define("discourse/components/home-logo", 
  ["discourse/lib/url","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var setting = __dependency2__.setting;

    __exports__["default"] = Ember.Component.extend({
      classNames: ["title"],

      linkUrl: (function () {
        return Discourse.getURL('/');
      }).property(),

      showSmallLogo: (function () {
        return !Discourse.Mobile.mobileView && this.get("minimized");
      }).property("minimized"),

      showMobileLogo: (function () {
        return Discourse.Mobile.mobileView && !Ember.isBlank(this.get('mobileBigLogoUrl'));
      }).property(),

      smallLogoUrl: setting('logo_small_url'),
      bigLogoUrl: setting('logo_url'),
      mobileBigLogoUrl: setting('mobile_logo_url'),
      title: setting('title'),

      click: function (e) {
        // if they want to open in a new tab, let it so
        if (e.shiftKey || e.metaKey || e.ctrlKey || e.which === 2) {
          return true;
        }

        e.preventDefault();

        DiscourseURL.routeTo('/');
        return false;
      }
    });
  });define("discourse/components/image-uploader", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/upload","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var UploadMixin = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, _createDecoratedObject([{
      key: "classNames",
      initializer: function () {
        return ["image-uploader"];
      }
    }, {
      key: "backgroundStyle",
      decorators: [computed('imageUrl')],
      value: function (imageUrl) {
        if (Em.isNone(imageUrl)) {
          return;
        }
        return ("background-image: url(" + imageUrl + ")").htmlSafe();
      }
    }, {
      key: "uploadDone",
      value: function (upload) {
        this.set("imageUrl", upload.url);
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          trash: function () {
            this.set("imageUrl", null);
          }
        };
      }
    }]));
  });define("discourse/components/input-tip", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNameBindings: [':tip', 'good', 'bad'],
      rerenderTriggers: ['validation'],

      bad: Em.computed.alias('validation.failed'),
      good: Em.computed.not('bad'),

      renderString: function (buffer) {
        var reason = this.get('validation.reason');
        if (reason) {
          buffer.push(iconHTML(this.get('good') ? 'check' : 'times') + ' ' + reason);
        }
      }
    });
  });define("discourse/components/json-file-uploader", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Em.Component.extend({
      fileInput: null,
      loading: false,
      expectedRootObjectName: null,
      hover: 0,

      classNames: ['json-uploader'],

      _initialize: (function () {
        var $this = this.$();
        var self = this;

        var $fileInput = $this.find('#js-file-input');
        this.set('fileInput', $fileInput[0]);

        $fileInput.on('change', function () {
          self.fileSelected(this.files);
        });

        $this.on('dragover', function (e) {
          if (e.preventDefault) e.preventDefault();
          return false;
        });
        $this.on('dragenter', function (e) {
          if (e.preventDefault) e.preventDefault();
          self.set('hover', self.get('hover') + 1);
          return false;
        });
        $this.on('dragleave', function (e) {
          if (e.preventDefault) e.preventDefault();
          self.set('hover', self.get('hover') - 1);
          return false;
        });
        $this.on('drop', function (e) {
          if (e.preventDefault) e.preventDefault();

          self.set('hover', 0);
          self.fileSelected(e.dataTransfer.files);
          return false;
        });
      }).on('didInsertElement'),

      accept: (function () {
        return ".json,application/json,application/x-javascript,text/json" + (this.get('extension') ? "," + this.get('extension') : "");
      }).property('extension'),

      setReady: (function () {
        var parsed = undefined;
        try {
          parsed = JSON.parse(this.get('value'));
        } catch (e) {
          this.set('ready', false);
          return;
        }

        var rootObject = parsed[this.get('expectedRootObjectName')];

        if (rootObject !== null && rootObject !== undefined) {
          this.set('ready', true);
        } else {
          this.set('ready', false);
        }
      }).observes('destination', 'expectedRootObjectName'),

      actions: {
        selectFile: function () {
          var $fileInput = $(this.get('fileInput'));
          $fileInput.click();
        }
      },

      fileSelected: function (fileList) {
        var self = this;
        var files = [];
        for (var i = 0; i < fileList.length; i++) {
          files[i] = fileList[i];
        }
        var fileNameRegex = /\.(json|txt)$/;
        files = files.filter(function (file) {
          if (fileNameRegex.test(file.name)) {
            return true;
          }
          if (file.type === "text/plain") {
            return true;
          }
          return false;
        });
        var firstFile = fileList[0];

        this.set('loading', true);

        var reader = new FileReader();
        reader.onload = function (evt) {
          self.set('value', evt.target.result);
          self.set('loading', false);
        };

        reader.readAsText(firstFile);
      }

    });
  });define("discourse/components/login-buttons", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      elementId: 'login-buttons',
      classNameBindings: ['hidden'],

      hidden: Em.computed.equal('buttons.length', 0),

      buttons: (function () {
        return Em.get('Discourse.LoginMethod.all');
      }).property(),

      actions: {
        externalLogin: function (provider) {
          this.sendAction('action', provider);
        }
      }
    });
  });define("discourse/components/menu-panel", 
  ["ember-addons/ember-computed-decorators","discourse/views/header","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var on = __dependency1__.on;
    var observes = __dependency1__.observes;
    var headerHeight = __dependency2__.headerHeight;

    var PANEL_BODY_MARGIN = 30;
    var mutationSupport = !Ember.testing && !!window['MutationObserver'];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':menu-panel', 'visible::hidden', 'viewMode'];
      }
    }, {
      key: 'showClose',
      initializer: function () {
        return Ember.computed.equal('viewMode', 'slide-in');
      }
    }, {
      key: '_layoutComponent',
      value: function () {
        if (!this.get('visible')) {
          return;
        }

        var $window = $(window);
        var width = this.get('maxWidth') || 300;
        var windowWidth = parseInt($window.width());

        if (windowWidth - width < 50) {
          width = windowWidth - 50;
        }

        var viewMode = this.get('viewMode');
        var $panelBody = this.$('.panel-body');
        var contentHeight = parseInt(this.$('.panel-body-contents').height());

        // We use a mutationObserver to check for style changes, so it's important
        // we don't set it if it doesn't change. Same goes for the $panelBody!
        var style = this.$().prop('style');

        if (viewMode === 'drop-down') {
          var $buttonPanel = $('header ul.icons');
          if ($buttonPanel.length === 0) {
            return;
          }

          // These values need to be set here, not in the css file - this is to deal with the
          // possibility of the window being resized and the menu changing from .slide-in to .drop-down.
          if (style.top !== '100%' || style.height !== 'auto') {
            this.$().css({ top: '100%', height: 'auto' });
          }

          // adjust panel height
          var fullHeight = parseInt($window.height());
          var offsetTop = this.$().offset().top;
          var scrollTop = $window.scrollTop();

          if (contentHeight + (offsetTop - scrollTop) + PANEL_BODY_MARGIN > fullHeight) {
            contentHeight = fullHeight - (offsetTop - scrollTop) - PANEL_BODY_MARGIN;
          }
          if ($panelBody.height() !== contentHeight) {
            $panelBody.height(contentHeight);
          }
          $('body').addClass('drop-down-visible');
        } else {
          var menuTop = headerHeight();

          var height = undefined;
          var winHeight = $(window).height() - 16;
          if (menuTop + contentHeight < winHeight) {
            height = contentHeight + "px";
          } else {
            height = winHeight - menuTop;
          }

          if ($panelBody.prop('style').height !== '100%') {
            $panelBody.height('100%');
          }
          if (style.top !== menuTop + "px" || style.height !== height) {
            this.$().css({ top: menuTop + "px", height: height });
          }
          $('body').removeClass('drop-down-visible');
        }

        this.$().width(width);
      }
    }, {
      key: 'viewMode',
      decorators: [computed('force')],
      value: function () {
        var force = this.get('force');
        if (force) {
          return force;
        }

        var headerWidth = $('#main-outlet .container').width() || 1100;
        var screenWidth = $(window).width();
        var remaining = parseInt((screenWidth - headerWidth) / 2);

        return remaining < 50 ? 'slide-in' : 'drop-down';
      }
    }, {
      key: '_visibleChanged',
      decorators: [observes('viewMode', 'visible')],
      value: function () {
        var _this = this;

        if (this.get('visible')) {
          // Allow us to hook into things being shown
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.sendAction('onVisible');
          });
          $('html').on('click.close-menu-panel', function (e) {
            var $target = $(e.target);
            if ($target.closest('.header-dropdown-toggle').length > 0) {
              return;
            }
            if ($target.closest('.menu-panel').length > 0) {
              return;
            }
            _this.hide();
          });
          this.performLayout();
          this._watchSizeChanges();

          // iOS does not handle scroll events well
          if (!this.capabilities.isIOS) {
            $(window).on('scroll.discourse-menu-panel', function () {
              return _this.performLayout();
            });
          }
        } else {
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.sendAction('onHidden');
          });
          $('html').off('click.close-menu-panel');
          $(window).off('scroll.discourse-menu-panel');
          this._stopWatchingSize();
          $('body').removeClass('drop-down-visible');
        }
      }
    }, {
      key: 'showKeyboardShortcuts',
      decorators: [computed()],
      value: function () {
        return !Discourse.Mobile.mobileView && !this.capabilities.touch;
      }
    }, {
      key: 'showMobileToggle',
      decorators: [computed()],
      value: function () {
        return Discourse.Mobile.mobileView || this.siteSettings.enable_mobile_theme && this.capabilities.touch;
      }
    }, {
      key: 'mobileViewLinkTextKey',
      decorators: [computed()],
      value: function () {
        return Discourse.Mobile.mobileView ? "desktop_view" : "mobile_view";
      }
    }, {
      key: 'faqUrl',
      decorators: [computed()],
      value: function () {
        return this.siteSettings.faq_url ? this.siteSettings.faq_url : Discourse.getURL('/faq');
      }
    }, {
      key: 'performLayout',
      value: function () {
        Ember.run.scheduleOnce('afterRender', this, this._layoutComponent);
      }
    }, {
      key: '_watchSizeChanges',
      value: function () {
        var _this2 = this;

        if (mutationSupport) {
          this._observer.disconnect();
          this._observer.observe(this.element, { childList: true, subtree: true, characterData: true, attributes: true });
        } else {
          clearInterval(this._resizeInterval);
          this._resizeInterval = setInterval(function () {
            Ember.run(function () {
              var $panelBodyContents = _this2.$('.panel-body-contents');
              if ($panelBodyContents && $panelBodyContents.length) {
                var contentHeight = parseInt($panelBodyContents.height());
                if (contentHeight !== _this2._lastHeight) {
                  _this2.performLayout();
                }
                _this2._lastHeight = contentHeight;
              }
            });
          }, 500);
        }
      }
    }, {
      key: '_stopWatchingSize',
      value: function () {
        if (mutationSupport) {
          this._observer.disconnect();
        } else {
          clearInterval(this._resizeInterval);
        }
      }
    }, {
      key: '_bindEvents',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this3 = this;

        this.$().on('click.discourse-menu-panel', 'a', function (e) {
          if (e.metaKey || e.ctrlKey || e.shiftKey) {
            return;
          }
          var $target = $(e.target);
          if ($target.data('ember-action') || $target.closest('.search-link').length > 0) {
            return;
          }
          _this3.hide();
        });

        this.appEvents.on('dropdowns:closeAll', this, this.hide);
        this.appEvents.on('dom:clean', this, this.hide);

        $('body').on('keydown.discourse-menu-panel', function (e) {
          if (e.which === 27) {
            _this3.hide();
          }
        });

        $(window).on('resize.discourse-menu-panel', function () {
          _this3.propertyDidChange('viewMode');
          _this3.performLayout();
        });

        if (mutationSupport) {
          this._observer = new MutationObserver(function () {
            Ember.run.debounce(_this3, _this3.performLayout, 50);
          });
        }

        this.propertyDidChange('viewMode');
      }
    }, {
      key: '_removeEvents',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.appEvents.off('dom:clean', this, this.hide);
        this.appEvents.off('dropdowns:closeAll', this, this.hide);
        this.$().off('click.discourse-menu-panel');
        $('body').off('keydown.discourse-menu-panel');
        $('html').off('click.close-menu-panel');
        $(window).off('resize.discourse-menu-panel');
        $(window).off('scroll.discourse-menu-panel');
      }
    }, {
      key: 'hide',
      value: function () {
        this.set('visible', false);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          close: function () {
            this.hide();
          }
        };
      }
    }]));
  });define("discourse/components/nav-item", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    /* You might be looking for navigation-item. */

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['active'];
      }
    }, {
      key: 'router',
      decorators: [computed()],
      value: function () {
        return this.container.lookup('router:main');
      }
    }, {
      key: 'fullPath',
      decorators: [computed("path")],
      value: function (path) {
        return Discourse.getURL(path);
      }
    }, {
      key: 'active',
      decorators: [computed("route", "router.url")],
      value: function (route) {
        if (!route) {
          return;
        }

        var routeParam = this.get('routeParam'),
            router = this.get('router');

        return routeParam ? router.isActive(route, routeParam) : router.isActive(route);
      }
    }]));
  });define("discourse/components/navigation-bar", 
  ["ember-addons/ember-computed-decorators","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'ul';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':nav', ':nav-pills'];
      }
    }, {
      key: 'id',
      initializer: function () {
        return 'navigation-bar';
      }
    }, {
      key: 'selectedNavItem',
      decorators: [computed("filterMode", "navItems")],
      value: function (filterMode, navItems) {
        var item = navItems.find(function (i) {
          return i.get('filterMode').indexOf(filterMode) === 0;
        });
        return item || navItems[0];
      }
    }, {
      key: 'closedNav',
      decorators: [observes("expanded")],
      value: function () {
        if (!this.get('expanded')) {
          this.ensureDropClosed();
        }
      }
    }, {
      key: 'ensureDropClosed',
      value: function () {
        if (!this.get('expanded')) {
          this.set('expanded', false);
        }
        $(window).off('click.navigation-bar');
        DiscourseURL.appEvents.off('dom:clean', this, this.ensureDropClosed);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggleDrop: function () {
            var _this = this;

            this.set('expanded', !this.get('expanded'));

            if (this.get('expanded')) {
              DiscourseURL.appEvents.on('dom:clean', this, this.ensureDropClosed);

              Em.run.next(function () {
                if (!_this.get('expanded')) {
                  return;
                }

                _this.$('.drop a').on('click', function () {
                  _this.$('.drop').hide();
                  _this.set('expanded', false);
                  return true;
                });

                $(window).on('click.navigation-bar', function () {
                  _this.set('expanded', false);
                  return true;
                });
              });
            }
          }
        };
      }
    }]));
  });define("discourse/components/navigation-item", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var StringBuffer = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['active', 'content.hasIcon:has-icon'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['title'];
      }
    }, {
      key: 'hidden',
      initializer: function () {
        return Em.computed.not('content.visible');
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['content.count'];
      }
    }, {
      key: 'title',
      decorators: [computed("content.categoryName", "content.name")],
      value: function (categoryName, name) {
        var extra = {};

        if (categoryName) {
          name = "category";
          extra.categoryName = categoryName;
        }

        return I18n.t("filters." + name.replace("/", ".") + ".help", extra);
      }
    }, {
      key: 'active',
      decorators: [computed("content.filterMode", "filterMode")],
      value: function (contentFilterMode, filterMode) {
        return contentFilterMode === filterMode || filterMode.indexOf(contentFilterMode) === 0;
      }
    }, {
      key: 'renderString',
      value: function (buffer) {
        var content = this.get('content');
        buffer.push("<a href='" + content.get('href') + "'>");
        if (content.get('hasIcon')) {
          buffer.push("<span class='" + content.get('name') + "'></span>");
        }
        buffer.push(this.get('content.displayName'));
        buffer.push("</a>");
      }
    }]));
  });define("discourse/components/notification-item", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var INVITED_TYPE = 8;

    __exports__["default"] = Ember.Component.extend({
      tagName: 'li',
      classNameBindings: ['notification.read', 'notification.is_warning'],

      name: (function () {
        var notificationType = this.get("notification.notification_type");
        var lookup = this.site.get("notificationLookup");
        return lookup[notificationType];
      }).property("notification.notification_type"),

      scope: (function () {
        if (this.get("name") === "custom") {
          return this.get("notification.data.message");
        } else {
          return "notifications." + this.get("name");
        }
      }).property("name"),

      url: (function () {
        var it = this.get('notification');
        var badgeId = it.get("data.badge_id");
        if (badgeId) {
          var badgeSlug = it.get("data.badge_slug");

          if (!badgeSlug) {
            var badgeName = it.get("data.badge_name");
            badgeSlug = badgeName.replace(/[^A-Za-z0-9_]+/g, '-').toLowerCase();
          }

          return Discourse.getURL('/badges/' + badgeId + '/' + badgeSlug);
        }

        var topicId = it.get('topic_id');
        if (topicId) {
          return Discourse.Utilities.postUrl(it.get("slug"), topicId, it.get("post_number"));
        }

        if (it.get('notification_type') === INVITED_TYPE) {
          return Discourse.getURL('/users/' + it.get('data.display_username'));
        }
      }).property("notification.data.{badge_id,badge_name,display_username}", "model.slug", "model.topic_id", "model.post_number"),

      description: (function () {
        var badgeName = this.get("notification.data.badge_name");
        if (badgeName) {
          return Discourse.Utilities.escapeExpression(badgeName);
        }

        var title = this.get('notification.data.topic_title');
        return Ember.isEmpty(title) ? "" : Discourse.Utilities.escapeExpression(title);
      }).property("notification.data.{badge_name,topic_title}"),

      _markRead: (function () {
        var _this = this;

        this.$('a').click(function () {
          _this.set('notification.read', true);
          return true;
        });
      }).on('didInsertElement'),

      render: function (buffer) {
        var notification = this.get('notification');
        var description = this.get('description');
        var username = notification.get('data.display_username');
        var text = Discourse.Emoji.unescape(I18n.t(this.get('scope'), { description: description, username: username }));

        var url = this.get('url');
        if (url) {
          buffer.push('<a href="' + url + '" alt="' + I18n.t('notifications.alt.' + this.get("name")) + '">' + text + '</a>');
        } else {
          buffer.push(text);
        }
      }
    });
  });define("discourse/components/number-field", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.TextField.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return ['invalid'];
      }
    }, {
      key: 'value',
      decorators: [computed('number')],
      initializer: function () {
        return {
          get: function (number) {
            return parseInt(number);
          },
          set: function (value) {
            var num = parseInt(value);
            if (isNaN(num)) {
              this.set('invalid', true);
              return value;
            } else {
              this.set('invalid', false);
              this.set('number', num);
              return num.toString();
            }
          }
        };
      }
    }, {
      key: 'placeholder',
      decorators: [computed("placeholderKey")],
      value: function (key) {
        return key ? I18n.t(key) : "";
      }
    }]));
  });define("discourse/components/password-field", 
  ["discourse/components/text-field","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var TextField = __dependency1__["default"];

    /**
      Same as text-field, but with special features for a password input.
      Be sure to test on a variety of browsers and operating systems when changing this logic.
    **/
    __exports__["default"] = TextField.extend({
      canToggle: false,

      keyPress: function (e) {
        if (e.which >= 65 && e.which <= 90 && !e.shiftKey || e.which >= 97 && e.which <= 122 && e.shiftKey) {
          this.set('canToggle', true);
          this.set('capsLockOn', true);
        } else if (e.which >= 65 && e.which <= 90 && e.shiftKey || e.which >= 97 && e.which <= 122 && !e.shiftKey) {
          this.set('canToggle', true);
          this.set('capsLockOn', false);
        }
      },

      keyUp: function (e) {
        if (e.which === 20 && this.get('canToggle')) {
          this.toggleProperty('capsLockOn');
        }
      },

      focusOut: function () {
        this.set('capsLockOn', false);
      },

      focusIn: function () {
        this.set('canToggle', false); // can't know the state of caps lock yet. keyPress will figure it out.
      }
    });
  });define("discourse/components/period-chooser", 
  ["discourse/mixins/cleans-up","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var CleansUp = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(CleansUp, {
      classNames: 'period-chooser',
      showPeriods: false,

      cleanUp: function () {
        this.set('showPeriods', false);
        $('html').off('mousedown.top-period');
      },

      _clickToClose: function () {
        var self = this;
        $('html').off('mousedown.top-period').on('mousedown.top-period', function (e) {
          var $target = $(e.target);
          if ($target.prop('id') === 'topic-entrance' || self.$().has($target).length !== 0) {
            return;
          }
          self.cleanUp();
        });
      },

      click: function (e) {
        if ($(e.target).closest('.period-popup').length) {
          return;
        }

        if (!this.get('showPeriods')) {
          var $chevron = this.$('i.fa-caret-down');
          this.$('#period-popup').css($chevron.position());
          this.set('showPeriods', true);
          this._clickToClose();
        }
      },

      actions: {
        changePeriod: function (p) {
          this.cleanUp();
          this.set('period', p);
          this.sendAction('action', p);
        }
      }

    });
  });define("discourse/components/pinned-button", 
  ["discourse/components/dropdown-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DropdownButton = __dependency1__["default"];

    __exports__["default"] = DropdownButton.extend({
      descriptionKey: 'help',
      classNames: ['pinned-options'],
      title: '',
      longDescription: (function () {
        var topic = this.get('topic');
        var globally = topic.get('pinned_globally') ? '_globally' : '';
        var key = 'topic_statuses.' + (topic.get('pinned') ? 'pinned' + globally : 'unpinned') + '.help';
        return I18n.t(key);
      }).property('topic.pinned'),

      target: Em.computed.alias('topic'),

      hidden: (function () {
        var topic = this.get('topic');
        return topic.get('deleted') || !topic.get('pinned') && !topic.get('unpinned');
      }).property('topic.pinned', 'topic.deleted', 'topic.unpinned'),

      activeItem: (function () {
        return this.get('topic.pinned') ? 'pinned' : 'unpinned';
      }).property('topic.pinned'),

      dropDownContent: (function () {
        var globally = this.get('topic.pinned_globally') ? '_globally' : '';
        return [{ id: 'pinned',
          title: I18n.t('topic_statuses.pinned' + globally + '.title'),
          description: I18n.t('topic_statuses.pinned' + globally + '.help'),
          styleClasses: 'fa fa-thumb-tack' }, { id: 'unpinned',
          title: I18n.t('topic_statuses.unpinned.title'),
          description: I18n.t('topic_statuses.unpinned.help'),
          styleClasses: 'fa fa-thumb-tack unpinned' }];
      }).property(),

      text: (function () {
        var globally = this.get('topic.pinned_globally') ? '_globally' : '';
        var state = this.get('topic.pinned') ? 'pinned' + globally : 'unpinned';

        return '<span class="fa fa-thumb-tack' + (state === 'unpinned' ? ' unpinned' : "") + '"></span> ' + I18n.t('topic_statuses.' + state + '.title') + "<span class='caret'></span>";
      }).property('topic.pinned', 'topic.unpinned'),

      clicked: function (id) {
        var topic = this.get('topic');
        if (id === 'unpinned') {
          topic.clearPin();
        } else {
          topic.rePin();
        }
      }

    });
  });define("discourse/components/popup-input-tip", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var computed = __dependency3__.default;
    var observes = __dependency3__.observes;

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':popup-tip', 'good', 'bad', 'lastShownAt::hide'];
      }
    }, {
      key: 'animateAttribute',
      initializer: function () {
        return null;
      }
    }, {
      key: 'bouncePixels',
      initializer: function () {
        return 6;
      }
    }, {
      key: 'bounceDelay',
      initializer: function () {
        return 100;
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['validation.reason'];
      }
    }, {
      key: 'click',
      value: function () {
        this.set('shownAt', null);
        this.set('validation.lastShownAt', null);
      }
    }, {
      key: 'bad',
      initializer: function () {
        return Ember.computed.alias("validation.failed");
      }
    }, {
      key: 'good',
      initializer: function () {
        return Ember.computed.not("bad");
      }
    }, {
      key: 'lastShownAt',
      decorators: [computed('shownAt', 'validation.lastShownAt')],
      value: function (shownAt, lastShownAt) {
        return shownAt || lastShownAt;
      }
    }, {
      key: 'bounce',
      decorators: [observes('lastShownAt')],
      value: function () {
        if (this.get("lastShownAt")) {
          var $elem = this.$();
          if (!this.animateAttribute) {
            this.animateAttribute = $elem.css('left') === 'auto' ? 'right' : 'left';
          }
          if (this.animateAttribute === 'left') {
            this.bounceLeft($elem);
          } else {
            this.bounceRight($elem);
          }
        }
      }
    }, {
      key: 'renderString',
      value: function (buffer) {
        var reason = this.get('validation.reason');
        if (!reason) {
          return;
        }

        buffer.push('<span class=\'close\'>' + iconHTML('times-circle') + '</span>' + reason);
      }
    }, {
      key: 'bounceLeft',
      value: function ($elem) {
        for (var i = 0; i < 5; i++) {
          $elem.animate({ left: '+=' + this.bouncePixels }, this.bounceDelay).animate({ left: '-=' + this.bouncePixels }, this.bounceDelay);
        }
      }
    }, {
      key: 'bounceRight',
      value: function ($elem) {
        for (var i = 0; i < 5; i++) {
          $elem.animate({ right: '-=' + this.bouncePixels }, this.bounceDelay).animate({ right: '+=' + this.bouncePixels }, this.bounceDelay);
        }
      }
    }]));
  });define("discourse/components/popup-menu", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: "classNameBindings",
      initializer: function () {
        return ["visible::hidden", ":popup-menu"];
      }
    }, {
      key: "_setup",
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        this.appEvents.on("popup-menu:open", this, "_changeLocation");

        $('html').on("mouseup.popup-menu-" + this.get('elementId'), function (e) {
          var $target = $(e.target);
          if ($target.is("button") || _this.$().has($target).length === 0) {
            _this.sendAction('hide');
          }
        });
      }
    }, {
      key: "_cleanup",
      decorators: [on('willDestroyElement')],
      value: function () {
        $('html').off("mouseup.popup-menu-" + this.get('elementId'));
        this.appEvents.off("popup-menu:open", this, "_changeLocation");
      }
    }, {
      key: "_changeLocation",
      value: function (location) {
        var $this = this.$();
        switch (location.position) {
          case "absolute":
            {
              $this.css({
                position: "absolute",
                top: location.top - $this.innerHeight() + 5,
                left: location.left
              });
              break;
            }
          case "fixed":
            {
              $this.css({
                position: "fixed",
                top: location.top,
                left: location.left - $this.innerWidth()
              });
              break;
            }
        }
      }
    }]));
  });define("discourse/components/post-gap", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':gap', ':jagged-border', 'gap::hidden'],

      initGaps: (function () {
        this.set('loading', false);
        var before = this.get('before') === 'true';
        var gaps = before ? this.get('postStream.gaps.before') : this.get('postStream.gaps.after');

        if (gaps) {
          this.set('gap', gaps[this.get('post.id')]);
        }
      }).on('init'),

      gapsChanged: (function () {
        this.initGaps();
        this.rerender();
      }).observes('post.hasGap'),

      render: function (buffer) {
        if (this.get('loading')) {
          buffer.push(I18n.t('loading'));
        } else {
          var gapLength = this.get('gap.length');
          if (gapLength) {
            buffer.push(I18n.t('post.gap', { count: gapLength }));
          }
        }
      },

      click: function () {
        var _this = this;

        if (this.get('loading') || !this.get('gap')) {
          return false;
        }
        this.set('loading', true);
        this.rerender();

        var postStream = this.get('postStream');
        var filler = this.get('before') === 'true' ? postStream.fillGapBefore : postStream.fillGapAfter;

        filler.call(postStream, this.get('post'), this.get('gap')).then(function () {
          _this.set('gap', null);
        });

        return false;
      }
    });
  });define("discourse/components/post-gutter", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var computed = __dependency3__["default"];

    var MAX_SHOWN = 5;var _Ember = Ember;
    var get = _Ember.get;
    var isEmpty = _Ember.isEmpty;
    var Component = _Ember.Component;

    __exports__["default"] = Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':gutter'];
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['expanded'];
      }
    }, {
      key: 'collapsed',
      decorators: [computed('links')],
      value: function (links) {
        var seen = {};
        var result = [];

        if (!isEmpty(links)) {
          links.forEach(function (l) {
            var title = get(l, 'title');
            if (!seen[title]) {
              result.pushObject(l);
              seen[title] = true;
            }
          });
        }
        return result;
      }
    }, {
      key: 'renderString',
      value: function (buffer) {
        var links = this.get('collapsed');
        var collapsed = !this.get('expanded');

        if (!isEmpty(links)) {
          var toRender = links;
          if (collapsed) {
            toRender = toRender.slice(0, MAX_SHOWN);
          }

          buffer.push("<ul class='post-links'>");
          toRender.forEach(function (l) {
            var direction = get(l, 'reflection') ? 'inbound' : 'outbound',
                clicks = get(l, 'clicks');

            buffer.push('<li><a href=\'' + get(l, 'url') + '\' class=\'track-link ' + direction + '\'>');

            var title = get(l, 'title');
            if (!isEmpty(title)) {
              title = Discourse.Utilities.escapeExpression(title);
              buffer.push(Discourse.Emoji.unescape(title));
            }
            if (clicks) {
              buffer.push('<span class=\'badge badge-notification clicks\'>' + clicks + '</span>');
            }
            buffer.push("</a></li>");
          });

          if (collapsed) {
            var remaining = links.length - MAX_SHOWN;
            if (remaining > 0) {
              buffer.push('<li><a href class=\'toggle-more\'>' + I18n.t('post.more_links', { count: remaining }) + '</a></li>');
            }
          }
          buffer.push('</ul>');
        }

        if (this.get('canReplyAsNewTopic')) {
          buffer.push('<a href class=\'reply-new\'>' + iconHTML('plus') + I18n.t('post.reply_as_new_topic') + '</a>');
        }
      }
    }, {
      key: 'click',
      value: function (e) {
        var $target = $(e.target);
        if ($target.hasClass('toggle-more')) {
          this.toggleProperty('expanded');
          return false;
        } else if ($target.closest('.reply-new').length) {
          this.sendAction('newTopicAction', this.get('post'));
          return false;
        }
        return true;
      }
    }]));

    // Roll up links to avoid duplicates
  });define("discourse/components/post-menu", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    // Helper class for rendering a button
    var Button = function (action, label, icon, opts) {
      this.action = action;
      this.label = label;

      if (typeof icon === "object") {
        this.opts = icon;
      } else {
        this.icon = icon;
      }
      this.opts = this.opts || opts || {};
    };

    __exports__.Button = Button;
    function animateHeart($elem, start, end, complete) {
      if (Ember.testing) {
        return Ember.run(this, complete);
      }

      $elem.stop().css('textIndent', start).animate({ textIndent: end }, {
        complete: complete,
        step: function (now) {
          $(this).css('transform', 'scale(' + now + ')');
        },
        duration: 150
      }, 'linear');
    }

    Button.prototype.render = function (buffer) {
      var opts = this.opts;

      var label = I18n.t(this.label, opts.labelOptions);
      if (opts.prefixHTML) {
        buffer.push(opts.prefixHTML);
      }
      buffer.push("<button aria-label=\"" + label + "\" " + "title=\"" + label + "\"");

      if (opts.disabled) {
        buffer.push(" disabled");
      }
      if (opts.className) {
        buffer.push(" class=\"" + opts.className + "\"");
      }
      if (opts.shareUrl) {
        buffer.push(" data-share-url=\"" + opts.shareUrl + "\"");
      }
      if (opts.postNumber) {
        buffer.push(" data-post-number=\"" + opts.postNumber + "\"");
      }
      buffer.push(" data-action=\"" + this.action + "\">");
      if (this.icon) {
        buffer.push(iconHTML(this.icon));
      }
      if (opts.textLabel) {
        buffer.push(I18n.t(opts.textLabel));
      }
      if (opts.innerHTML) {
        buffer.push(opts.innerHTML);
      }
      buffer.push("</button>");
    };

    var hiddenButtons = undefined;

    var PostMenuComponent = Ember.Component.extend(StringBuffer, {
      tagName: 'section',
      classNames: ['post-menu-area', 'clearfix'],

      rerenderTriggers: ['post.deleted_at', 'post.likeAction.count', 'post.likeAction.users.length', 'post.reply_count', 'post.showRepliesBelow', 'post.can_delete', 'post.bookmarked', 'post.shareUrl', 'post.topic.deleted_at', 'post.replies.length', 'post.wiki', 'post.post_type', 'collapsed'],

      _collapsedByDefault: (function () {
        this.set('collapsed', true);
      }).on('init'),

      renderString: function (buffer) {
        var post = this.get('post');

        buffer.push("<nav class='post-controls'>");
        this.renderReplies(post, buffer);
        this.renderButtons(post, buffer);
        this.renderAdminPopup(post, buffer);
        buffer.push("</nav>");
      },

      // Delegate click actions
      click: function (e) {
        var $target = $(e.target);
        var action = $target.data('action') || $target.parent().data('action');

        if ($target.prop('disabled') || $target.parent().prop('disabled')) {
          return;
        }

        if (!action) return;
        var handler = this["click" + action.classify()];
        if (!handler) return;

        handler.call(this, this.get('post'));
      },

      // Replies Button
      renderReplies: function (post, buffer) {
        if (!post.get('showRepliesBelow')) return;

        var replyCount = post.get('reply_count');
        buffer.push("<button class='show-replies highlight-action' data-action='replies'>");
        buffer.push(I18n.t("post.has_replies", { count: replyCount || 0 }));

        var icon = this.get('post.replies.length') > 0 ? 'chevron-up' : 'chevron-down';
        return buffer.push(iconHTML(icon) + "</button>");
      },

      renderButtons: function (post, buffer) {
        var self = this;
        var allButtons = [];
        var visibleButtons = [];

        if (typeof hiddenButtons === "undefined") {
          if (!Em.isEmpty(this.siteSettings.post_menu_hidden_items)) {
            hiddenButtons = this.siteSettings.post_menu_hidden_items.split('|');
          } else {
            hiddenButtons = [];
          }
        }

        if (post.get("bookmarked")) {
          hiddenButtons.removeObject("bookmark");
        }

        var yours = post.get('yours');
        this.siteSettings.post_menu.split("|").forEach(function (i) {
          var creator = self["buttonFor" + i.classify()];
          if (creator) {
            var button = creator.call(self, post);
            if (button) {
              allButtons.push(button);
              if (yours && button.opts.alwaysShowYours || post.get('wiki') && button.opts.alwaysShowWiki || hiddenButtons.indexOf(i) === -1) {
                visibleButtons.push(button);
              }
            }
          }
        });

        // Only show ellipsis if there is more than one button hidden
        // if there are no more buttons, we are not collapsed
        var collapsed = this.get('collapsed');
        if (!collapsed || allButtons.length <= visibleButtons.length + 1) {
          visibleButtons = allButtons;
          if (collapsed) {
            this.set('collapsed', false);
          }
        } else {
          visibleButtons.splice(visibleButtons.length - 1, 0, this.buttonForShowMoreActions(post));
        }

        var callbacks = PostMenuComponent._registerButtonCallbacks;
        if (callbacks) {
          _.each(callbacks, function (callback) {
            callback.apply(self, [visibleButtons]);
          });
        }

        buffer.push('<div class="actions">');
        visibleButtons.forEach(function (b) {
          return b.render(buffer);
        });
        buffer.push("</div>");
      },

      clickLikeCount: function () {
        this.sendActionTarget('toggleWhoLiked');
      },

      sendActionTarget: function (action, arg) {
        var target = this.get(action + 'Target');
        return target ? target.send(this.get(action), arg) : this.sendAction(action, arg);
      },

      clickReplies: function () {
        if (this.get('post.replies.length') > 0) {
          this.set('post.replies', []);
        } else {
          this.get('post').loadReplies();
        }
      },

      // Delete button
      buttonForDelete: function (post) {
        var label = undefined,
            icon = undefined;

        if (post.get('post_number') === 1) {
          // If it's the first post, the delete/undo actions are related to the topic
          var topic = post.get('topic');
          if (topic.get('deleted_at')) {
            if (!topic.get('details.can_recover')) {
              return;
            }
            label = "topic.actions.recover";
            icon = "undo";
          } else {
            if (!topic.get('details.can_delete')) {
              return;
            }
            label = "topic.actions.delete";
            icon = "trash-o";
          }
        } else {
          // The delete actions target the post iteself
          if (post.get('deleted_at') || post.get('user_deleted')) {
            if (!post.get('can_recover')) {
              return;
            }
            label = "post.controls.undelete";
            icon = "undo";
          } else {
            if (!post.get('can_delete')) {
              return;
            }
            label = "post.controls.delete";
            icon = "trash-o";
          }
        }
        var action = icon === 'trash-o' ? 'delete' : 'recover';
        var opts = undefined;
        if (icon === "trash-o") {
          opts = { className: 'delete' };
        }
        return new Button(action, label, icon, opts);
      },

      clickRecover: function (post) {
        this.sendAction('recoverPost', post);
      },

      clickDelete: function (post) {
        this.sendAction('deletePost', post);
      },

      // Like button
      buttonForLike: function () {
        var likeAction = this.get('post.likeAction');
        if (!likeAction) {
          return;
        }

        var className = likeAction.get('acted') ? 'has-like fade-out' : 'like';
        var opts = { className: className };

        if (likeAction.get('canToggle')) {
          var descKey = likeAction.get('acted') ? 'post.controls.undo_like' : 'post.controls.like';
          return new Button('like', descKey, 'heart', opts);
        } else if (likeAction.get('acted')) {
          opts.disabled = true;
          return new Button('like', 'post.controls.has_liked', 'heart', opts);
        }
      },

      buttonForLikeCount: function () {
        var likeCount = this.get('post.likeAction.count') || 0;
        if (likeCount > 0) {
          var likedPost = !!this.get('post.likeAction.acted');

          var label = likedPost ? likeCount === 1 ? 'post.has_likes_title_only_you' : 'post.has_likes_title_you' : 'post.has_likes_title';

          return new Button('like-count', label, undefined, {
            className: 'like-count highlight-action',
            innerHTML: I18n.t("post.has_likes", { count: likeCount }),
            labelOptions: { count: likedPost ? likeCount - 1 : likeCount }
          });
        }
      },

      clickLike: function (post) {
        var $heart = this.$('.fa-heart'),
            $likeButton = this.$('button[data-action=like]'),
            acted = post.get('likeAction.acted'),
            self = this;

        if (acted) {
          this.sendActionTarget('toggleLike');
          $likeButton.removeClass('has-like').addClass('like');
        } else {
          (function () {
            var scale = [1.0, 1.5];
            animateHeart($heart, scale[0], scale[1], function () {
              animateHeart($heart, scale[1], scale[0], function () {
                self.sendActionTarget('toggleLike');
                $likeButton.removeClass('like').addClass('has-like');
              });
            });
          })();
        }
      },

      // Flag button
      buttonForFlag: function (post) {
        if (Em.isEmpty(post.get('flagsAvailable'))) return;
        return new Button('flag', 'post.controls.flag', 'flag');
      },

      clickFlag: function (post) {
        this.sendAction('showFlags', post);
      },

      // Edit button
      buttonForEdit: function (post) {
        if (!post.get('can_edit')) return;
        return new Button('edit', 'post.controls.edit', 'pencil', {
          alwaysShowYours: true,
          alwaysShowWiki: true
        });
      },

      clickEdit: function (post) {
        this.sendAction('editPost', post);
      },

      // Share button
      buttonForShare: function (post) {
        var options = {
          shareUrl: post.get('shareUrl'),
          postNumber: post.get('post_number')
        };
        return new Button('share', 'post.controls.share', 'link', options);
      },

      // Reply button
      buttonForReply: function () {
        if (!this.get('canCreatePost')) return;
        var options = { className: 'create fade-out' };

        if (!Discourse.Mobile.mobileView) {
          options.textLabel = 'topic.reply.title';
        }

        return new Button('reply', 'post.controls.reply', 'reply', options);
      },

      clickReply: function (post) {
        this.sendAction('replyToPost', post);
      },

      // Bookmark button
      buttonForBookmark: function (post) {
        if (!Discourse.User.current()) return;

        var iconClass = 'read-icon',
            buttonClass = 'bookmark',
            tooltip = 'bookmarks.not_bookmarked';

        if (post.get('bookmarked')) {
          iconClass += ' bookmarked';
          buttonClass += ' bookmarked';
          tooltip = 'bookmarks.created';
        }

        return new Button('bookmark', tooltip, { className: buttonClass, innerHTML: "<div class='" + iconClass + "'>" });
      },

      clickBookmark: function (post) {
        this.sendAction('toggleBookmark', post);
      },

      buttonForAdmin: function () {
        if (!Discourse.User.currentProp('canManageTopic')) {
          return;
        }
        return new Button('admin', 'post.controls.admin', 'wrench');
      },

      renderAdminPopup: function (post, buffer) {
        if (!Discourse.User.currentProp('canManageTopic')) {
          return;
        }

        var isWiki = post.get('wiki'),
            wikiIcon = iconHTML('pencil-square-o'),
            wikiText = isWiki ? I18n.t('post.controls.unwiki') : I18n.t('post.controls.wiki'),
            isModerator = post.get('post_type') === this.site.get('post_types.moderator_action'),
            postTypeIcon = iconHTML('shield'),
            postTypeText = isModerator ? I18n.t('post.controls.revert_to_regular') : I18n.t('post.controls.convert_to_moderator'),
            rebakePostIcon = iconHTML('cog'),
            rebakePostText = I18n.t('post.controls.rebake'),
            unhidePostIcon = iconHTML('eye'),
            unhidePostText = I18n.t('post.controls.unhide'),
            changePostOwnerIcon = iconHTML('user'),
            changePostOwnerText = I18n.t('post.controls.change_owner');

        var html = '<div class="post-admin-menu popup-menu">' + '<h3>' + I18n.t('admin_title') + '</h3>' + '<ul>' + '<li class="btn" data-action="toggleWiki">' + wikiIcon + wikiText + '</li>' + (Discourse.User.currentProp('staff') ? '<li class="btn" data-action="togglePostType">' + postTypeIcon + postTypeText + '</li>' : '') + '<li class="btn" data-action="rebakePost">' + rebakePostIcon + rebakePostText + '</li>' + (post.hidden ? '<li class="btn" data-action="unhidePost">' + unhidePostIcon + unhidePostText + '</li>' : '') + (Discourse.User.currentProp('admin') ? '<li class="btn" data-action="changePostOwner">' + changePostOwnerIcon + changePostOwnerText + '</li>' : '') + '</ul>' + '</div>';

        buffer.push(html);
      },

      clickAdmin: function () {
        var $postAdminMenu = this.$(".post-admin-menu");
        $postAdminMenu.show();
        $("html").on("mouseup.post-admin-menu", function () {
          $postAdminMenu.hide();
          $("html").off("mouseup.post-admin-menu");
        });
      },

      clickToggleWiki: function () {
        this.sendAction('toggleWiki', this.get('post'));
      },

      clickTogglePostType: function () {
        this.sendAction("togglePostType", this.get("post"));
      },

      clickRebakePost: function () {
        this.sendAction("rebakePost", this.get("post"));
      },

      clickUnhidePost: function () {
        this.sendAction("unhidePost", this.get("post"));
      },

      clickChangePostOwner: function () {
        this.sendAction("changePostOwner", this.get("post"));
      },

      buttonForShowMoreActions: function () {
        return new Button('showMoreActions', 'show_more', 'ellipsis-h');
      },

      clickShowMoreActions: function () {
        this.set('collapsed', false);
      }

    });

    PostMenuComponent.reopenClass({
      registerButton: function (callback) {
        this._registerButtonCallbacks = this._registerButtonCallbacks || [];
        this._registerButtonCallbacks.push(callback);
      }
    });

    __exports__["default"] = PostMenuComponent;
  });define("discourse/components/poster-name", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;

    var PosterNameComponent = Em.Component.extend({
      classNames: ['names', 'trigger-user-card'],
      displayNameOnPosts: setting('display_name_on_posts'),

      // sanitize name for comparison
      sanitizeName: function (name) {
        return name.toLowerCase().replace(/[\s_-]/g, '');
      },

      render: function (buffer) {
        var post = this.get('post');

        if (post) {
          var username = post.get('username'),
              primaryGroupName = post.get('primary_group_name'),
              url = post.get('usernameUrl');

          var linkClass = 'username',
              name = post.get('name');

          if (post.get('staff')) {
            linkClass += ' staff';
          }
          if (post.get('admin')) {
            linkClass += ' admin';
          }
          if (post.get('moderator')) {
            linkClass += ' moderator';
          }
          if (post.get('new_user')) {
            linkClass += ' new-user';
          }

          if (!Em.isEmpty(primaryGroupName)) {
            linkClass += ' ' + primaryGroupName;
          }
          // Main link
          buffer.push("<span class='" + linkClass + "'><a href='" + url + "' data-auto-route='true' data-user-card='" + username + "'>" + username + "</a>");

          // Add a glyph if we have one
          var glyph = this.posterGlyph(post);
          if (!Em.isEmpty(glyph)) {
            buffer.push(glyph);
          }
          buffer.push("</span>");

          // Are we showing full names?
          if (name && this.get('displayNameOnPosts') && this.sanitizeName(name) !== this.sanitizeName(username)) {
            name = Discourse.Utilities.escapeExpression(name);
            buffer.push("<span class='full-name'><a href='" + url + "' data-auto-route='true' data-user-card='" + username + "'>" + name + "</a></span>");
          }

          // User titles
          var title = post.get('user_title');
          if (!Em.isEmpty(title)) {

            title = Discourse.Utilities.escapeExpression(title);
            buffer.push('<span class="user-title">');
            if (Em.isEmpty(primaryGroupName)) {
              buffer.push(title);
            } else {
              buffer.push("<a href='/groups/" + post.get('primary_group_name') + "' class='user-group'>" + title + "</a>");
            }
            buffer.push("</span>");
          }

          PosterNameComponent.trigger('renderedName', buffer, post);
        }
      },

      //  Overwrite this to give a user a custom font awesome glyph.
      posterGlyph: function (post) {
        if (post.get('moderator')) {
          var desc = I18n.t('user.moderator_tooltip');
          return '<i class="fa fa-shield" title="' + desc + '" alt="' + desc + '"></i>';
        }
      }
    });

    // Support for event triggering
    PosterNameComponent.reopenClass(Em.Evented);

    __exports__["default"] = PosterNameComponent;
  });define("discourse/components/preference-checkbox", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Component.extend({
      classNames: ['controls'],

      label: (function () {
        return I18n.t(this.get('labelKey'));
      }).property('labelKey')
    });
  });define("discourse/components/private-message-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/private-message-map',
      tagName: 'section',
      classNames: ['information'],
      details: Em.computed.alias('topic.details'),

      actions: {
        removeAllowedUser: function (user) {
          var self = this;
          bootbox.dialog(I18n.t("private_message_info.remove_allowed_user", { name: user.get('username') }), [{ label: I18n.t("no_value"),
            'class': 'btn-danger right' }, { label: I18n.t("yes_value"),
            'class': 'btn-primary',
            callback: function () {
              self.get('topic.details').removeAllowedUser(user);
            }
          }]);
        },

        showPrivateInvite: function () {
          this.sendAction('showPrivateInviteAction');
        }
      }

    });
  });define("discourse/components/radio-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: "input",
      type: "radio",
      attributeBindings: ["name", "type", "value", "checked:checked"],
      click: function () {
        this.set("selection", this.$().val());
      },
      checked: (function () {
        return this.get("value") === this.get("selection");
      }).property('selection')
    });
  });define("discourse/components/search-menu", 
  ["discourse/lib/search","discourse/lib/url","ember-addons/ember-computed-decorators","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var searchForTerm = __dependency1__.searchForTerm;
    var searchContextDescription = __dependency1__.searchContextDescription;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;
    var DiscourseURL = __dependency2__["default"];
    var computed = __dependency3__.default;
    var observes = __dependency3__.observes;
    var showModal = __dependency4__["default"];

    var _dontSearch = false;
    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'searchService',
      initializer: function () {
        return Ember.inject.service('search');
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['search-menu'];
      }
    }, {
      key: 'typeFilter',
      initializer: function () {
        return null;
      }
    }, {
      key: 'contextChanged',
      decorators: [observes('searchService.searchContext')],
      initializer: function () {
        return function () {
          if (this.get('searchService.searchContextEnabled')) {
            _dontSearch = true;
            this.set('searchService.searchContextEnabled', false);
            _dontSearch = false;
          }
        };
      }
    }, {
      key: 'fullSearchUrlRelative',
      decorators: [computed('searchService.searchContext', 'searchService.term', 'searchService.searchContextEnabled')],
      value: function (searchContext, term, searchContextEnabled) {

        if (searchContextEnabled && Ember.get(searchContext, 'type') === 'topic') {
          return null;
        }

        var url = '/search?q=' + encodeURIComponent(this.get('searchService.term'));
        if (searchContextEnabled) {
          if (searchContext.id.toString().toLowerCase() === this.get('currentUser.username_lower') && searchContext.type === "private_messages") {
            url += ' in:private';
          } else {
            url += encodeURIComponent(" " + searchContext.type + ":" + searchContext.id);
          }
        }

        return url;
      }
    }, {
      key: 'fullSearchUrl',
      decorators: [computed('fullSearchUrlRelative')],
      value: function (fullSearchUrlRelative) {
        if (fullSearchUrlRelative) {
          return Discourse.getURL(fullSearchUrlRelative);
        }
      }
    }, {
      key: 'searchContextDescription',
      decorators: [computed('searchService.searchContext')],
      value: function (ctx) {
        return searchContextDescription(Em.get(ctx, 'type'), Em.get(ctx, 'user.username') || Em.get(ctx, 'category.name'));
      }
    }, {
      key: 'searchContextEnabledChanged',
      decorators: [observes('searchService.searchContextEnabled')],
      value: function () {
        if (_dontSearch) {
          return;
        }
        this.newSearchNeeded();
      }
    }, {
      key: 'newSearchNeeded',
      decorators: [observes('searchService.term', 'typeFilter')],
      value: function () {
        this.set('noResults', false);
        var term = this.get('searchService.term');
        if (isValidSearchTerm(term)) {
          this.set('loading', true);
          Ember.run.debounce(this, 'searchTerm', term, this.get('typeFilter'), 400);
        } else {
          this.setProperties({ content: null });
        }
        this.set('selectedIndex', 0);
      }
    }, {
      key: 'searchTerm',
      value: function (term, typeFilter) {
        var _this = this;

        // for cancelling debounced search
        if (this._cancelSearch) {
          this._cancelSearch = null;
          return;
        }

        if (this._search) {
          this._search.abort();
        }

        var searchContext = this.get('searchService.searchContextEnabled') ? this.get('searchService.searchContext') : null;
        this._search = searchForTerm(term, { typeFilter: typeFilter, searchContext: searchContext, fullSearchUrl: this.get('fullSearchUrl') });

        this._search.then(function (content) {
          _this.setProperties({ noResults: !content, content: content });
        }).finally(function () {
          _this.set('loading', false);
          _this._search = null;
        });
      }
    }, {
      key: 'showCancelFilter',
      decorators: [computed('typeFilter', 'loading')],
      value: function (typeFilter, loading) {
        if (loading) {
          return false;
        }
        return !Ember.isEmpty(typeFilter);
      }
    }, {
      key: 'termChanged',
      decorators: [observes('searchService.term')],
      value: function () {
        this.cancelTypeFilter();
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          fullSearch: function () {
            var self = this;

            if (this._search) {
              this._search.abort();
            }

            // maybe we are debounced and delayed
            // stop that as well
            this._cancelSearch = true;
            Em.run.later(function () {
              self._cancelSearch = false;
            }, 400);

            var url = this.get('fullSearchUrlRelative');
            if (url) {
              DiscourseURL.routeTo(url);
            }
          },

          moreOfType: function (type) {
            this.set('typeFilter', type);
          },

          cancelType: function () {
            this.cancelTypeFilter();
          },

          showedSearch: function () {
            $('#search-term').focus().select();
          },

          showSearchHelp: function () {
            // TODO: @EvitTrout how do we get a loading indicator here?
            Discourse.ajax("/static/search_help.html", { dataType: 'html' }).then(function (model) {
              showModal('searchHelp', { model: model });
            });
          },

          cancelHighlight: function () {
            this.set('searchService.highlightTerm', null);
          }
        };
      }
    }, {
      key: 'cancelTypeFilter',
      value: function () {
        this.set('typeFilter', null);
      }
    }, {
      key: 'keyDown',
      value: function (e) {
        if (e.which === 13 && isValidSearchTerm(this.get('searchService.term'))) {
          this.set('visible', false);
          this.send('fullSearch');
        }
      }
    }]));

    // If we need to perform another search
  });define("discourse/components/search-result-category", 
  ["discourse/components/search-result","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var SearchResult = __dependency1__["default"];
    __exports__["default"] = SearchResult.extend();
  });define("discourse/components/search-result-post", 
  ["discourse/components/search-result","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var SearchResult = __dependency1__["default"];
    __exports__["default"] = SearchResult.extend();
  });define("discourse/components/search-result-topic", 
  ["discourse/components/search-result","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var SearchResult = __dependency1__["default"];
    __exports__["default"] = SearchResult.extend();
  });define("discourse/components/search-result-user", 
  ["discourse/components/search-result","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var SearchResult = __dependency1__["default"];
    __exports__["default"] = SearchResult.extend();
  });define("discourse/components/search-text-field", 
  ["ember-addons/ember-computed-decorators","discourse/components/text-field","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var on = __dependency1__.on;
    var TextField = __dependency2__["default"];

    __exports__["default"] = TextField.extend(_createDecoratedObject([{
      key: 'placeholder',
      decorators: [computed('searchService.searchContextEnabled')],
      value: function (searchContextEnabled) {
        return searchContextEnabled ? "" : I18n.t('search.title');
      }
    }, {
      key: 'becomeFocused',
      decorators: [on("didInsertElement")],
      value: function () {
        if (!this.get('hasAutofocus')) {
          return;
        }
        // iOS is crazy, without this we will not be
        // at the top of the page
        $(window).scrollTop(0);
        this.$().focus();
      }
    }]));
  });define("discourse/components/share-source", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':social-link'],

      actions: {
        share: function (source) {
          this.sendAction('action', source);
        }
      }
    });
  });define("discourse/components/show-popup-button", 
  ["discourse/components/d-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DButton = __dependency1__["default"];

    __exports__["default"] = DButton.extend({
      click: function () {
        var $target = this.$(),
            position = $target.position(),
            width = $target.innerWidth(),
            loc = {
          position: this.get('position') || "fixed",
          left: position.left + width,
          top: position.top
        };

        this.appEvents.trigger("popup-menu:open", loc);
        this.sendAction("action");
      }
    });
  });define("discourse/components/signup-cta", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      action: "showCreateAccount",

      actions: {
        neverShow: function () {
          this.keyValueStore.setItem('anon-cta-never', 't');
          this.session.set('showSignupCta', false);
        },
        hideForSession: function () {
          var _this = this;

          this.session.set('hideSignupCta', true);
          this.keyValueStore.setItem('anon-cta-hidden', new Date().getTime());
          Em.run.later(function () {
            return _this.session.set('showSignupCta', false);
          }, 20 * 1000);
        },
        showCreateAccount: function () {
          this.sendAction();
        }
      },

      _turnOffIfHidden: (function () {
        if (this.session.get('hideSignupCta')) {
          this.session.set('showSignupCta', false);
        }
      }).on('willDestroyElement')
    });
  });define("discourse/components/small-action", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.actionDescription = actionDescription;
    var relativeAge = __dependency1__.relativeAge;

    var icons = {
      'closed.enabled': 'lock',
      'closed.disabled': 'unlock-alt',
      'autoclosed.enabled': 'lock',
      'autoclosed.disabled': 'unlock-alt',
      'archived.enabled': 'folder',
      'archived.disabled': 'folder-open',
      'pinned.enabled': 'thumb-tack',
      'pinned.disabled': 'thumb-tack unpinned',
      'pinned_globally.enabled': 'thumb-tack',
      'pinned_globally.disabled': 'thumb-tack unpinned',
      'visible.enabled': 'eye',
      'visible.disabled': 'eye-slash',
      'split_topic': 'sign-out'
    };

    function actionDescription(actionCode, createdAt) {
      return (function () {
        var ac = this.get(actionCode);
        if (ac) {
          var dt = new Date(this.get(createdAt));
          var when = relativeAge(dt, { format: 'medium-with-ago' });
          return I18n.t('action_codes.' + ac, { when: when }).htmlSafe();
        }
      }).property(actionCode, createdAt);
    }

    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/small-action', // needed because `time-gap` inherits from this
      classNames: ['small-action'],

      description: actionDescription('actionCode', 'post.created_at'),

      icon: (function () {
        return icons[this.get('actionCode')] || 'exclamation';
      }).property('actionCode'),

      actions: {
        edit: function () {
          this.sendAction('editPost', this.get('post'));
        },

        delete: function () {
          this.sendAction('deletePost', this.get('post'));
        }
      }

    });
  });define("discourse/components/stream-item", 
  ["discourse/lib/computed","discourse/components/small-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var actionDescription = __dependency2__.actionDescription;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [":item", "item.hidden", "item.deleted", "moderatorAction"],
      moderatorAction: propertyEqual("item.post_type", "site.post_types.moderator_action"),
      actionDescription: actionDescription("item.action_code", "item.created_at"),

      actions: {
        removeBookmark: function (userAction) {
          this.sendAction("removeBookmark", userAction);
        }
      }
    });
  });define("discourse/components/text-overflow", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      _parse: (function () {
        var _this = this;

        Ember.run.next(null, function () {
          _this.$().find('hr').remove();
          _this.$().ellipsis();
        });
      }).on('didInsertElement'),

      render: function (buffer) {
        buffer.push(this.get('text'));
      }
    });
  });define("discourse/components/time-gap", 
  ["discourse/components/small-action","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var SmallActionComponent = __dependency1__["default"];

    __exports__["default"] = SmallActionComponent.extend({
      classNames: ['time-gap'],
      classNameBindings: ['hideTimeGap::hidden'],
      hideTimeGap: Em.computed.alias('postStream.hasNoFilters'),
      icon: 'clock-o',

      description: (function () {
        var gapDays = this.get('daysAgo');
        if (gapDays < 30) {
          return I18n.t('dates.later.x_days', { count: gapDays });
        } else if (gapDays < 365) {
          var gapMonths = Math.floor(gapDays / 30);
          return I18n.t('dates.later.x_months', { count: gapMonths });
        } else {
          var gapYears = Math.floor(gapDays / 365);
          return I18n.t('dates.later.x_years', { count: gapYears });
        }
      }).property()
    });
  });define("discourse/components/toggle-deleted", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/toggle-deleted',
      tagName: 'section',
      classNames: ['information'],
      postStream: Em.computed.alias('topic.postStream'),

      actions: {
        toggleDeleted: function () {
          this.get('postStream').toggleDeleted();
        }
      }
    });
  });define("discourse/components/toggle-summary", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/toggle-summary',
      tagName: 'section',
      classNames: ['information'],
      postStream: Em.computed.alias('topic.postStream'),

      actions: {
        toggleSummary: function () {
          this.get('postStream').toggleSummary();
        }
      }
    });
  });define("discourse/components/top-period-buttons", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNames: ['top-title-buttons'],

      periods: (function () {
        var period = this.get('period');
        return this.site.get('periods').filter(function (p) {
          return p !== period;
        });
      }).property('period'),

      actions: {
        changePeriod: function (p) {
          this.sendAction('action', p);
        }
      }
    });
  });define("discourse/components/topic-footer-mobile-dropdown", 
  ["discourse/components/combo-box","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var Combobox = __dependency1__["default"];
    var on = __dependency2__.on;
    var observes = __dependency2__.observes;

    __exports__["default"] = Combobox.extend(_createDecoratedObject([{
      key: 'none',
      initializer: function () {
        return "topic.controls";
      }
    }, {
      key: '_createContent',
      decorators: [on('init')],
      value: function () {
        var content = [];
        var topic = this.get('topic');
        var details = topic.get('details');

        if (details.get('can_invite_to')) {
          content.push({ id: 'invite', name: I18n.t('topic.invite_reply.title') });
        }

        if (topic.get('bookmarked')) {
          content.push({ id: 'bookmark', name: I18n.t('bookmarked.clear_bookmarks') });
        } else {
          content.push({ id: 'bookmark', name: I18n.t('bookmarked.title') });
        }
        content.push({ id: 'share', name: I18n.t('topic.share.title') });

        if (details.get('can_flag_topic')) {
          content.push({ id: 'flag', name: I18n.t('topic.flag_topic.title') });
        }

        this.set('content', content);
      }
    }, {
      key: '_valueChanged',
      decorators: [observes('value')],
      value: function () {
        var _this = this;

        var value = this.get('value');
        var controller = this.get('parentView.controller');
        var topic = this.get('topic');

        var refresh = function () {
          _this._createContent();
          _this.set('value', null);
        };

        switch (value) {
          case 'invite':
            controller.send('showInvite');
            refresh();
            break;
          case 'bookmark':
            topic.toggleBookmark().then(function () {
              return refresh();
            });
            break;
          case 'share':
            this.appEvents.trigger('share:url', topic.get('shareUrl'), $('#topic-footer-buttons'));
            refresh();
            break;
          case 'flag':
            controller.send('showFlagTopic', topic);
            refresh();
            break;
        }
      }
    }]));
  });define("discourse/components/topic-list", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Ember.Component.extend({
      tagName: 'table',
      classNames: ['topic-list'],
      showTopicPostBadges: true,

      _observeHideCategory: (function () {
        this.addObserver('hideCategory', this.rerender);
        this.addObserver('order', this.rerender);
        this.addObserver('ascending', this.rerender);
      }).on('init'),

      toggleInTitle: (function () {
        return !this.get('bulkSelectEnabled') && this.get('canBulkSelect');
      }).property('bulkSelectEnabled'),

      sortable: (function () {
        return !!this.get('changeSort');
      }).property(),

      skipHeader: (function () {
        return Discourse.Mobile.mobileView;
      }).property(),

      showLikes: (function () {
        return this.get('order') === "likes";
      }).property('order'),

      showOpLikes: (function () {
        return this.get('order') === "op_likes";
      }).property('order'),

      click: function (e) {
        var self = this;
        var on = function (sel, callback) {
          var target = $(e.target).closest(sel);

          if (target.length === 1) {
            callback.apply(self, [target]);
          }
        };

        on('button.bulk-select', function () {
          this.sendAction('toggleBulkSelect');
          this.rerender();
        });

        on('th.sortable', function (e2) {
          this.sendAction('changeSort', e2.data('sort-order'));
          this.rerender();
        });
      }
    });
  });define("discourse/components/topic-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var LINKS_SHOWN = 5;

    __exports__["default"] = Ember.Component.extend({
      mapCollapsed: true,
      layoutName: 'components/topic-map',
      details: Em.computed.alias('topic.details'),
      allLinksShown: false,

      init: function () {
        this._super();

        // If the topic has a summary, expand the map by default
        this.set('mapCollapsed', Discourse.Mobile.mobileView || !this.get('topic.has_summary'));
      },

      showPosterAvatar: Em.computed.gt('topic.posts_count', 2),

      toggleMapClass: (function () {
        return this.get('mapCollapsed') ? 'chevron-down' : 'chevron-up';
      }).property('mapCollapsed'),

      showAllLinksControls: (function () {
        if (this.get('allLinksShown')) return false;
        if ((this.get('details.links.length') || 0) <= LINKS_SHOWN) return false;
        return true;
      }).property('allLinksShown', 'topic.details.links'),

      infoLinks: (function () {
        var allLinks = this.get('details.links');
        if (Em.isNone(allLinks)) return [];

        if (this.get('allLinksShown')) return allLinks;
        return allLinks.slice(0, LINKS_SHOWN);
      }).property('details.links', 'allLinksShown'),

      actions: {
        toggleMap: function () {
          this.toggleProperty('mapCollapsed');
        },

        showAllLinks: function () {
          this.set('allLinksShown', true);
        }
      }
    });
  });define("discourse/components/topic-participant", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({

      postStream: Em.computed.alias('participant.topic.postStream'),
      showPostCount: Em.computed.gte('participant.post_count', 2),

      toggled: (function () {
        return this.get('postStream.userFilters').contains(this.get('participant.username'));
      }).property('postStream.userFilters.[]'),

      actions: {
        toggle: function () {
          var postStream = this.get('postStream');
          if (postStream) {
            postStream.toggleParticipant(this.get('participant.username'));
          }
        }
      }
    });
  });define("discourse/components/topic-post-badges", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    // Creates a link
    function link(buffer, prop, url, cssClass, i18nKey, text) {
      if (!prop) {
        return;
      }

      var title = I18n.t("topic." + i18nKey, { count: prop });
      buffer.push("<a href='" + url + "' class='badge " + cssClass + " badge-notification' title='" + title + "'>" + (text || prop) + "</a>\n");
    }

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'span',
      classNameBindings: [':topic-post-badges'],
      rerenderTriggers: ['url', 'unread', 'newPosts', 'unseen'],

      renderString: function (buffer) {
        var url = this.get('url');

        link(buffer, this.get('unread'), url, 'unread', 'unread_posts');
        link(buffer, this.get('newPosts'), url, 'new-posts', 'new_posts');
        link(buffer, this.get('unseen'), url, 'new-topic', 'new', I18n.t('filters.new.lower_title'));
      }
    });
  });define("discourse/components/topic-status", 
  ["discourse/helpers/fa-icon","discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;
    var StringBuffer = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNames: ['topic-statuses'],

      rerenderTriggers: ['topic.archived', 'topic.closed', 'topic.pinned', 'topic.visible', 'topic.unpinned', 'topic.is_warning'],

      click: function (e) {
        if ($(e.target).hasClass('fa-thumb-tack')) {
          var topic = this.get('topic');

          // only pin unpin for now
          if (topic.get('pinned')) {
            topic.clearPin();
          } else {
            topic.rePin();
          }
        }

        return false;
      },

      canAct: (function () {
        return Discourse.User.current() && !this.get('disableActions');
      }).property('disableActions'),

      renderString: function (buffer) {
        var self = this;

        var renderIcon = function (name, key, actionable) {
          var title = Discourse.Utilities.escapeExpression(I18n.t('topic_statuses.' + key + '.help')),
              startTag = actionable ? "a href" : "span",
              endTag = actionable ? "a" : "span",
              iconArgs = key === 'unpinned' ? { 'class': 'unpinned' } : null,
              icon = iconHTML(name, iconArgs);

          buffer.push('<' + startTag + ' title=\'' + title + '\' class=\'topic-status\'>' + icon + '</' + endTag + '>');
        };

        var renderIconIf = function (conditionProp, name, key, actionable) {
          if (!self.get(conditionProp)) {
            return;
          }
          renderIcon(name, key, actionable);
        };

        renderIconIf('topic.is_warning', 'envelope', 'warning');

        if (this.get('topic.closed') && this.get('topic.archived')) {
          renderIcon('lock', 'locked_and_archived');
        } else {
          renderIconIf('topic.closed', 'lock', 'locked');
          renderIconIf('topic.archived', 'lock', 'archived');
        }

        renderIconIf('topic.pinned', 'thumb-tack', 'pinned', this.get("canAct"));
        renderIconIf('topic.unpinned', 'thumb-tack', 'unpinned', this.get("canAct"));
        renderIconIf('topic.invisible', 'eye-slash', 'invisible');
      }
    });
  });define("discourse/components/track-selected", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: "span",
      selectionChanged: (function () {
        var selected = this.get('selected');
        var list = this.get('selectedList');
        var id = this.get('selectedId');

        if (selected) {
          list.addObject(id);
        } else {
          list.removeObject(id);
        }
      }).observes('selected')
    });
  });define("discourse/components/user-badge", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',

      showGrantCount: (function () {
        return this.get('count') && this.get('count') > 1;
      }).property('count')
    });
  });define("discourse/components/user-field", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var fmt = __dependency1__.fmt;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':user-field', 'field.field_type'],
      layoutName: fmt('field.field_type', 'components/user-fields/%@'),

      noneLabel: (function () {
        if (!this.get('field.required')) {
          return 'user_fields.none';
        }
      }).property('field.required')
    });
  });define("discourse/components/user-link", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'a',
      attributeBindings: ['href', 'data-user-card'],
      href: Ember.computed.alias('user.path'),
      'data-user-card': Ember.computed.alias('user.username')
    });
  });define("discourse/components/user-menu", 
  ["discourse/lib/computed","ember-addons/ember-computed-decorators","discourse/views/header","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var url = __dependency1__.url;
    var computed = __dependency2__.default;
    var observes = __dependency2__.observes;
    var headerHeight = __dependency3__.headerHeight;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['user-menu'];
      }
    }, {
      key: 'notifications',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingNotifications',
      initializer: function () {
        return false;
      }
    }, {
      key: 'notificationsPath',
      initializer: function () {
        return url('currentUser.path', '%@/notifications');
      }
    }, {
      key: 'bookmarksPath',
      initializer: function () {
        return url('currentUser.path', '%@/activity/bookmarks');
      }
    }, {
      key: 'messagesPath',
      initializer: function () {
        return url('currentUser.path', '%@/messages');
      }
    }, {
      key: 'preferencesPath',
      initializer: function () {
        return url('currentUser.path', '%@/preferences');
      }
    }, {
      key: 'showEnableAnon',
      decorators: [computed('allowAnon', 'isAnon')],
      value: function (allowAnon, isAnon) {
        return allowAnon && !isAnon;
      }
    }, {
      key: 'showDisableAnon',
      decorators: [computed('allowAnon', 'isAnon')],
      value: function (allowAnon, isAnon) {
        return allowAnon && isAnon;
      }
    }, {
      key: '_loadNotifications',
      decorators: [observes('visible')],
      value: function () {
        if (this.get("visible")) {
          this.refreshNotifications();
        }
      }
    }, {
      key: '_resetCachedNotifications',
      decorators: [observes('currentUser.lastNotificationChange')],
      value: function () {
        var visible = this.get('visible');

        if (!Discourse.get("hasFocus")) {
          this.set('visible', false);
          this.set('notifications', null);
          return;
        }

        if (visible) {
          this.refreshNotifications();
        } else {
          this.set('notifications', null);
        }
      }
    }, {
      key: 'refreshNotifications',
      value: function () {
        var _this = this;

        if (this.get('loadingNotifications')) {
          return;
        }

        // estimate (poorly) the amount of notifications to return
        var limit = Math.round(($(window).height() - headerHeight()) / 55);
        // we REALLY don't want to be asking for negative counts of notifications
        // less than 5 is also not that useful
        if (limit < 5) {
          limit = 5;
        }
        if (limit > 40) {
          limit = 40;
        }

        // TODO: It's a bit odd to use the store in a component, but this one really
        // wants to reach out and grab notifications
        var store = this.container.lookup('store:main');
        var stale = store.findStale('notification', { recent: true, limit: limit }, { storageKey: 'recent-notifications' });

        if (stale.hasResults) {
          var results = stale.results;
          var content = results.get('content');

          // we have to truncate to limit, otherwise we will render too much
          if (content && content.length > limit) {
            content = content.splice(0, limit);
            results.set('content', content);
            results.set('totalRows', limit);
          }

          this.set('notifications', results);
        } else {
          this.set('loadingNotifications', true);
        }

        stale.refresh().then(function (notifications) {
          _this.set('currentUser.unread_notifications', 0);
          _this.set('notifications', notifications);
        }).catch(function () {
          _this.set('notifications', null);
        }).finally(function () {
          _this.set('loadingNotifications', false);
        });
      }
    }, {
      key: 'allowAnon',
      decorators: [computed()],
      value: function () {
        return this.siteSettings.allow_anonymous_posting && (this.get("currentUser.trust_level") >= this.siteSettings.anonymous_posting_min_trust_level || this.get("isAnon"));
      }
    }, {
      key: 'isAnon',
      initializer: function () {
        return Ember.computed.alias('currentUser.is_anonymous');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggleAnon: function () {
            Discourse.ajax("/users/toggle-anon", { method: 'POST' }).then(function () {
              window.location.reload();
            });
          },
          logout: function () {
            this.sendAction('logoutAction');
          }
        };
      }
    }]));
  });define("discourse/components/user-selector", 
  ["discourse/components/text-field","discourse/lib/user-search","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var TextField = __dependency1__["default"];
    var userSearch = __dependency2__["default"];

    __exports__["default"] = TextField.extend({

      _initializeAutocomplete: (function () {
        var self = this,
            selected = [],
            groups = [],
            currentUser = this.currentUser,
            includeMentionableGroups = this.get('includeMentionableGroups') === 'true',
            includeGroups = this.get('includeGroups') === 'true',
            allowedUsers = this.get('allowedUsers') === 'true';

        function excludedUsernames() {
          if (currentUser && self.get('excludeCurrentUser')) {
            return selected.concat([currentUser.get('username')]);
          }
          return selected;
        }

        this.$().val(this.get('usernames')).autocomplete({
          template: this.container.lookup('template:user-selector-autocomplete.raw'),
          disabled: this.get('disabled'),
          single: this.get('single'),
          allowAny: this.get('allowAny'),

          dataSource: function (term) {
            var results = userSearch({
              term: term.replace(/[^a-zA-Z0-9_\-\.]/, ''),
              topicId: self.get('topicId'),
              exclude: excludedUsernames(),
              includeGroups: includeGroups,
              allowedUsers: allowedUsers,
              includeMentionableGroups: includeMentionableGroups
            });

            return results;
          },

          transformComplete: function (v) {
            if (v.username || v.name) {
              if (!v.username) {
                groups.push(v.name);
              }
              return v.username || v.name;
            } else {
              var excludes = excludedUsernames();
              return v.usernames.filter(function (item) {
                return excludes.indexOf(item) === -1;
              });
            }
          },

          onChangeItems: function (items) {
            var hasGroups = false;
            items = items.map(function (i) {
              if (groups.indexOf(i) > -1) {
                hasGroups = true;
              }
              return i.username ? i.username : i;
            });
            self.set('usernames', items.join(","));
            self.set('hasGroups', hasGroups);

            selected = items;
          },

          reverseTransform: function (i) {
            return { username: i };
          }

        });
      }).on('didInsertElement'),

      _removeAutocomplete: (function () {
        this.$().autocomplete('destroy');
      }).on('willDestroyElement'),

      // THIS IS A HUGE HACK TO SUPPORT CLEARING THE INPUT
      _clearInput: (function () {
        if (arguments.length > 1) {
          if (Em.isEmpty(this.get("usernames"))) {
            this.$().parent().find("a").click();
          }
        }
      }).observes("usernames")

    });
  });define("discourse/components/user-small", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var url = __dependency1__.url;

    __exports__["default"] = Ember.Component.extend({
      classNames: ['user-small'],

      userPath: url('user.username', '/users/%@'),

      name: (function () {
        var name = this.get('user.name');
        if (name && this.get('user.username') !== name) {
          return name;
        }
      }).property('user.name')

    });
  });define("discourse/components/user-stat", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNames: ['user-stat']
    });
  });define("discourse/components/who-liked", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      rerenderTriggers: ['users.length'],

      renderString: function (buffer) {
        var users = this.get('users');
        if (users && users.get('length') > 0) {
          buffer.push("<div class='who-liked'>");
          var iconsHtml = "";
          users.forEach(function (u) {
            iconsHtml += "<a href=\"" + Discourse.getURL("/users/") + u.get('username_lower') + "\" data-user-card=\"" + u.get('username') + "\">";
            iconsHtml += Discourse.Utilities.avatarImg({
              size: 'small',
              avatarTemplate: u.get('avatar_template'),
              title: u.get('username')
            });
            iconsHtml += "</a>";
          });
          buffer.push(I18n.t('post.actions.people.like', { icons: iconsHtml }));
          buffer.push("</div>");
        } else {
          buffer.push("<span></span>");
        }
      }
    });
  });define("discourse/views/application", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      _appendCategoryClass: (function (obj, key) {
        var newClass = Em.get(obj, key);
        if (newClass) {
          $('body').addClass('category-' + newClass);
        }
      }).observes('controller.styleCategory.id'),

      _removeOldClass: (function (obj, key) {
        var oldClass = Em.get(obj, key);
        if (oldClass) {
          $('body').removeClass('category-' + oldClass);
        }
      }).observesBefore('controller.styleCategory.id')
    });
  });define("discourse/views/archetype-options", 
  ["discourse/views/container","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseContainerView = __dependency1__["default"];

    __exports__["default"] = DiscourseContainerView.extend({
      metaDataBinding: 'parentView.metaData',

      init: function () {
        this._super();
        var metaData = this.get('metaData');
        var archetypeOptionsView = this;
        return this.get('archetype.options').forEach(function (a) {
          if (a.option_type === 1) {
            archetypeOptionsView.attachViewWithArgs({
              content: a,
              checked: metaData.get(a.key) === 'true'
            }, Discourse.OptionBooleanView);
          }
        });
      }
    });
  });define("discourse/views/avatar-selector", 
  ["ember-addons/ember-computed-decorators","discourse/views/modal-body","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;
    var ModalBodyView = __dependency2__["default"];

    __exports__["default"] = ModalBodyView.extend(_createDecoratedObject([{
      key: "templateName",
      initializer: function () {
        return 'modal/avatar_selector';
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ['avatar-selector'];
      }
    }, {
      key: "title",
      initializer: function () {
        return I18n.t('user.change_avatar.title');
      }
    }, {
      key: "selectedChanged",
      decorators: [observes("controller.selected"), on("didInsertElement")],
      value: function () {
        var _this = this;

        Em.run.next(function () {
          return $('input:radio[name="avatar"]').val([_this.get('controller.selected')]);
        });
      }
    }, {
      key: "_focusSelectedButton",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this2 = this;

        Em.run.next(function () {
          return $('input:radio[value="' + _this2.get('controller.selected') + '"]').focus();
        });
      }
    }]));

    // *HACK* used to select the proper radio button, because {{action}} stops the default behavior
  });define("discourse/views/badges-index", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop);
  });define("discourse/views/badges-show", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      eyelineSelector: '.badge-user',
      tickOrX: function (field) {
        var icon = this.get('controller.model.' + field) ? "fa-check" : "fa-times";
        return "<i class='fa " + icon + "'></i>";
      },
      allowTitle: (function () {
        return this.tickOrX("allow_title");
      }).property(),
      multipleGrant: (function () {
        return this.tickOrX("multiple_grant");
      }).property()
    });
  });define("discourse/views/bookmark-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['bookmark'],
      attributeBindings: ['disabled'],

      bookmarked: Ember.computed.alias('controller.model.bookmarked'),

      textKey: (function () {
        return this.get('bookmarked') ? 'bookmarked.clear_bookmarks' : 'bookmarked.title';
      }).property('bookmarked'),

      rerenderTriggers: ['bookmarked'],

      helpKey: (function () {
        return this.get("bookmarked") ? "bookmarked.help.unbookmark" : "bookmarked.help.bookmark";
      }).property("bookmarked"),

      click: function () {
        this.get('controller').send('toggleBookmark');
      },

      renderIcon: function (buffer) {
        var className = this.get("bookmarked") ? "bookmarked" : "";
        buffer.push(iconHTML('bookmark', { class: className }));
      }
    });
  });define("discourse/views/choose-topic", 
  ["discourse/lib/debounce","discourse/lib/search","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];
    var searchForTerm = __dependency2__.searchForTerm;

    __exports__["default"] = Ember.View.extend({
      templateName: 'choose_topic',

      topicTitleChanged: (function () {
        this.setProperties({
          loading: true,
          noResults: true,
          selectedTopicId: null
        });
        this.search(this.get('topicTitle'));
      }).observes('topicTitle'),

      topicsChanged: (function () {
        var topics = this.get('topics');
        if (topics) {
          this.set('noResults', topics.length === 0);
        }
        this.set('loading', false);
      }).observes('topics'),

      search: debounce(function (title) {
        var self = this,
            currentTopicId = this.get("currentTopicId");

        if (Em.isEmpty(title)) {
          self.setProperties({ topics: null, loading: false });
          return;
        }

        searchForTerm(title, { typeFilter: 'topic', searchForId: true }).then(function (results) {
          if (results && results.posts && results.posts.length > 0) {
            self.set('topics', results.posts.mapBy('topic').filter(function (t) {
              return t.get("id") !== currentTopicId;
            }));
          } else {
            self.setProperties({ topics: null, loading: false });
          }
        });
      }, 300),

      actions: {
        chooseTopic: function (topic) {
          var topicId = Em.get(topic, 'id');
          this.set('selectedTopicId', topicId);

          Em.run.next(function () {
            $('#choose-topic-' + topicId).prop('checked', 'true');
          });

          return false;
        }
      }

    });
  });define("discourse/views/cloaked-collection", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /*eslint no-bitwise:0 */

    var CloakedCollectionView = Ember.CollectionView.extend({
      cloakView: Ember.computed.alias('itemViewClass'),
      topVisible: null,
      bottomVisible: null,
      offsetFixedTopElement: null,
      offsetFixedBottomElement: null,
      loadingHTML: 'Loading...',
      scrollDebounce: 10,

      init: function () {
        var cloakView = this.get('cloakView'),
            idProperty = this.get('idProperty'),
            uncloakDefault = !!this.get('uncloakDefault');

        // Set the slack ratio differently to allow for more or less slack in preloading
        var slackRatio = parseFloat(this.get('slackRatio'));
        if (!slackRatio) {
          this.set('slackRatio', 1.0);
        }

        var CloakedView = this.container.lookupFactory('view:cloaked');
        this.set('itemViewClass', CloakedView.extend({
          classNames: [cloakView + '-cloak'],
          cloaks: cloakView,
          preservesContext: this.get('preservesContext') === 'true',
          cloaksController: this.get('itemController'),
          defaultHeight: this.get('defaultHeight'),

          init: function () {
            this._super();
            if (idProperty) {
              this.set('elementId', cloakView + '-cloak-' + this.get('content.' + idProperty));
            }
            if (uncloakDefault) {
              this.uncloak();
            } else {
              this.cloak();
            }
          }
        }));

        this._super();
        Ember.run.next(this, 'scrolled');
      },

      /**
        If the topmost visible view changed, we will notify the controller if it has an appropriate hook.
         @method _topVisibleChanged
        @observes topVisible
      **/
      _topVisibleChanged: (function () {
        var controller = this.get('controller');
        if (controller.topVisibleChanged) {
          controller.topVisibleChanged(this.get('topVisible'));
        }
      }).observes('topVisible'),

      /**
        If the bottommost visible view changed, we will notify the controller if it has an appropriate hook.
         @method _bottomVisible
        @observes bottomVisible
      **/
      _bottomVisible: (function () {
        var controller = this.get('controller');
        if (controller.bottomVisibleChanged) {
          controller.bottomVisibleChanged(this.get('bottomVisible'));
        }
      }).observes('bottomVisible'),

      /**
        Binary search for finding the topmost view on screen.
         @method findTopView
        @param {Array} childViews the childViews to search through
        @param {Number} windowTop The top of the viewport to search against
        @param {Number} min The minimum index to search through of the child views
        @param {Number} max The max index to search through of the child views
        @returns {Number} the index into childViews of the topmost view
      **/
      findTopView: function (childViews, viewportTop, min, max) {
        if (max < min) {
          return min;
        }

        var wrapperTop = this.get('wrapperTop') >> 0;

        while (max > min) {
          var mid = Math.floor((min + max) / 2),

          // in case of not full-window scrolling
          $view = childViews[mid].$(),

          // .position is quite expensive, shortcut here to get a slightly rougher
          // but much faster value
          parentOffsetTop = $view.offsetParent().offset().top,
              offsetTop = $view.offset().top,
              viewBottom = offsetTop - parentOffsetTop + wrapperTop + $view.height();

          if (viewBottom > viewportTop) {
            max = mid - 1;
          } else {
            min = mid + 1;
          }
        }

        return min;
      },

      /**
        Determine what views are onscreen and cloak/uncloak them as necessary.
         @method scrolled
      **/
      scrolled: function () {
        if (!this.get('scrollingEnabled')) {
          return;
        }

        var childViews = this.get('childViews');
        if (!childViews || childViews.length === 0) {
          return;
        }

        var self = this,
            toUncloak = [],
            onscreen = [],
            onscreenCloaks = [],
            $w = $(window),
            windowHeight = this.get('wrapperHeight') || (window.innerHeight ? window.innerHeight : $w.height()),
            slack = Math.round(windowHeight * this.get('slackRatio')),
            offsetFixedTopElement = this.get('offsetFixedTopElement'),
            offsetFixedBottomElement = this.get('offsetFixedBottomElement'),
            bodyHeight = this.get('wrapperHeight') ? this.$().height() : $('body').height();

        var windowTop = this.get('wrapperTop') || $w.scrollTop();

        var viewportTop = windowTop - slack,
            topView = this.findTopView(childViews, viewportTop, 0, childViews.length - 1);

        var windowBottom = windowTop + windowHeight;
        var viewportBottom = windowBottom + slack;

        if (windowBottom > bodyHeight) {
          windowBottom = bodyHeight;
        }
        if (viewportBottom > bodyHeight) {
          viewportBottom = bodyHeight;
        }

        if (offsetFixedTopElement) {
          windowTop += offsetFixedTopElement.outerHeight(true) || 0;
        }

        if (offsetFixedBottomElement) {
          windowBottom -= offsetFixedBottomElement.outerHeight(true) || 0;
        }

        // Find the bottom view and what's onscreen
        var bottomView = topView;
        var bottomVisible = null;
        while (bottomView < childViews.length) {
          var view = childViews[bottomView];
          var $view = view.$();

          if (!$view) {
            break;
          }

          // in case of not full-window scrolling
          var scrollOffset = this.get('wrapperTop') || 0;
          var viewTop = $view.offset().top + scrollOffset;
          var viewBottom = viewTop + $view.height();

          if (viewTop > viewportBottom) {
            break;
          }
          toUncloak.push(view);

          if (viewBottom > windowTop && viewTop <= windowBottom) {
            var content = view.get('content');
            onscreen.push(content);

            if (!view.get('isPlaceholder')) {
              bottomVisible = content;
            }
            onscreenCloaks.push(view);
          }

          bottomView++;
        }
        if (bottomView >= childViews.length) {
          bottomView = childViews.length - 1;
        }

        // If our controller has a `sawObjects` method, pass the on screen objects to it.
        var controller = this.get('controller');
        if (onscreen.length) {
          this.setProperties({ topVisible: onscreen[0], bottomVisible: bottomVisible });
          if (controller && controller.sawObjects) {
            Em.run.schedule('afterRender', function () {
              controller.sawObjects(onscreen);
            });
          }
        } else {
          this.setProperties({ topVisible: null, bottomVisible: null });
        }

        var toCloak = childViews.slice(0, topView).concat(childViews.slice(bottomView + 1));

        this._uncloak = toUncloak;
        if (this._nextUncloak) {
          Em.run.cancel(this._nextUncloak);
          this._nextUncloak = null;
        }

        Em.run.schedule('afterRender', this, function () {
          onscreenCloaks.forEach(function (v) {
            if (v && v.uncloak) {
              v.uncloak();
            }
          });
          toCloak.forEach(function (v) {
            v.cloak();
          });
          if (self._nextUncloak) {
            Em.run.cancel(self._nextUncloak);
          }
          self._nextUncloak = Em.run.later(self, self.uncloakQueue, 50);
        });

        for (var j = bottomView; j < childViews.length; j++) {
          var checkView = childViews[j];
          if (!checkView._containedView) {
            var loadingHTML = this.get('loadingHTML');
            if (!Em.isEmpty(loadingHTML) && !checkView.get('loading')) {
              checkView.$().html(loadingHTML);
            }
            return;
          }
        }
      },

      uncloakQueue: function () {
        var maxPerRun = 3,
            delay = 50,
            self = this;
        var processed = 0;

        if (this._uncloak) {
          while (processed < maxPerRun && this._uncloak.length > 0) {
            var view = this._uncloak.shift();
            if (view && view.uncloak && !view._containedView) {
              Em.run.schedule('afterRender', view, view.uncloak);
              processed++;
            }
          }
          if (this._uncloak.length === 0) {
            this._uncloak = null;
          } else {
            Em.run.schedule('afterRender', self, function () {
              if (self._nextUncloak) {
                Em.run.cancel(self._nextUncloak);
              }
              self._nextUncloak = Em.run.next(self, function () {
                if (self._nextUncloak) {
                  Em.run.cancel(self._nextUncloak);
                }
                self._nextUncloak = Em.run.later(self, self.uncloakQueue, delay);
              });
            });
          }
        }
      },

      scrollTriggered: function () {
        if ($('body').data('disable-cloaked-view')) {
          return;
        }
        Em.run.scheduleOnce('afterRender', this, 'scrolled');
      },

      _startEvents: (function () {
        if (this.get('offsetFixed')) {
          Em.warn("Cloaked-collection's `offsetFixed` is deprecated. Use `offsetFixedTop` instead.");
        }

        var self = this,
            offsetFixedTop = this.get('offsetFixedTop') || this.get('offsetFixed'),
            offsetFixedBottom = this.get('offsetFixedBottom'),
            scrollDebounce = this.get('scrollDebounce'),
            onScrollMethod = function () {
          Ember.run.debounce(self, 'scrollTriggered', scrollDebounce);
        };

        if (offsetFixedTop) {
          this.set('offsetFixedTopElement', $(offsetFixedTop));
        }

        if (offsetFixedBottom) {
          this.set('offsetFixedBottomElement', $(offsetFixedBottom));
        }

        $(document).bind('touchmove.ember-cloak', onScrollMethod);
        $(window).bind('scroll.ember-cloak', onScrollMethod);
        this.addObserver('wrapperTop', self, onScrollMethod);
        this.addObserver('wrapperHeight', self, onScrollMethod);
        this.addObserver('content.@each', self, onScrollMethod);
        this.scrollTriggered();

        this.set('scrollingEnabled', true);
      }).on('didInsertElement'),

      cleanUp: function () {
        $(document).unbind('touchmove.ember-cloak');
        $(window).unbind('scroll.ember-cloak');
        this.set('scrollingEnabled', false);
      },

      _endEvents: (function () {
        this.cleanUp();
      }).on('willDestroyElement')
    });

    Ember.Handlebars.helper('cloaked-collection', Ember.testing ? Ember.CollectionView : CloakedCollectionView);
    __exports__["default"] = CloakedCollectionView;
  });define("discourse/views/composer-messages", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.CollectionView.extend({
      classNameBindings: [':composer-popup-container', 'hidden'],
      content: Em.computed.alias('controller.content'),

      hidden: Em.computed.not('controller.controllers.composer.model.viewOpen'),

      itemViewClass: Ember.View.extend({
        classNames: ['composer-popup', 'hidden'],
        templateName: Em.computed.alias('content.templateName'),

        _setup: (function () {
          this._super();
          this.set('context', this.get('content'));

          if (this.get('content.extraClass')) {
            this.get('classNames').pushObject(this.get('content.extraClass'));
          }
        }).on('init'),

        _initCss: (function () {
          var composerHeight = $('#reply-control').height() || 0;
          this.$().css('bottom', composerHeight + "px").show();
        }).on('didInsertElement')
      })
    });
  });define("discourse/views/create-account", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/create-account',
      title: I18n.t('create_account.title'),
      classNames: ['create-account'],

      _setup: (function () {
        // allows the submission the form when pressing 'ENTER' on *any* text input field
        // but only when the submit button is enabled
        var createAccountController = this.get('controller');
        Em.run.schedule('afterRender', function () {
          $("input[type='text'], input[type='password']").keydown(function (e) {
            if (createAccountController.get('submitDisabled') === false && e.keyCode === 13) {
              createAccountController.send('createAccount');
            }
          });
        });
      }).on('didInsertElement')
    });
  });define("discourse/views/discovery-categories", 
  ["discourse/mixins/url-refresh","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var UrlRefresh = __dependency1__["default"];
    var on = __dependency2__.on;

    var CATEGORIES_LIST_BODY_CLASS = "categories-list";

    __exports__["default"] = Ember.View.extend(UrlRefresh, _createDecoratedObject([{
      key: 'addBodyClass',
      decorators: [on("didInsertElement")],
      value: function () {
        $('body').addClass(CATEGORIES_LIST_BODY_CLASS);
      }
    }, {
      key: 'removeBodyClass',
      decorators: [on("willDestroyElement")],
      value: function () {
        $('body').removeClass(CATEGORIES_LIST_BODY_CLASS);
      }
    }]));
  });define("discourse/views/discovery-top", 
  ["discourse/mixins/url-refresh","discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UrlRefresh = __dependency1__["default"];
    var ScrollTop = __dependency2__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, UrlRefresh);
  });define("discourse/views/discovery-topics", 
  ["discourse/mixins/url-refresh","discourse/mixins/load-more","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var UrlRefresh = __dependency1__["default"];
    var LoadMore = __dependency2__["default"];
    var on = __dependency3__.on;
    var observes = __dependency3__.observes;

    __exports__["default"] = Ember.View.extend(LoadMore, UrlRefresh, _createDecoratedObject([{
      key: "eyelineSelector",
      initializer: function () {
        return '.topic-list-item';
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          loadMore: function () {
            var _this = this;

            var self = this;
            Discourse.notifyTitle(0);
            this.get('controller').loadMoreTopics().then(function (hasMoreResults) {
              Ember.run.schedule('afterRender', function () {
                return self.saveScrollPosition();
              });
              if (!hasMoreResults) {
                _this.get('eyeline').flushRest();
              } else if ($(window).height() >= $(document).height()) {
                _this.send("loadMore");
              }
            });
          }
        };
      }
    }, {
      key: "_readjustScrollPosition",
      decorators: [observes("controller.model"), on("didInsertElement")],
      value: function () {
        var scrollTo = this.session.get('topicListScrollPosition');
        if (scrollTo && scrollTo >= 0) {
          Ember.run.schedule('afterRender', function () {
            return $(window).scrollTop(scrollTo + 1);
          });
        } else {
          Ember.run.scheduleOnce('afterRender', this, this.loadMoreUnlessFull);
        }
      }
    }, {
      key: "_updateTitle",
      decorators: [observes("controller.topicTrackingState.incomingCount")],
      value: function () {
        Discourse.notifyTitle(this.get('controller.topicTrackingState.incomingCount'));
      }
    }, {
      key: "saveScrollPosition",

      // Remember where we were scrolled to
      value: function () {
        this.session.set('topicListScrollPosition', $(window).scrollTop());
      }
    }, {
      key: "scrolled",

      // When the topic list is scrolled
      value: function () {
        this._super();
        this.saveScrollPosition();
      }
    }]));
  });define("discourse/views/edit-topic-auto-close", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: "modal/edit-topic-auto-close",
      title: I18n.t("topic.auto_close_title"),
      focusInput: false
    });
  });define("discourse/views/embedded-post", 
  ["discourse/lib/screen-track","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScreenTrack = __dependency1__["default"];

    __exports__["default"] = Discourse.GroupedView.extend({
      templateName: 'embedded-post',
      classNames: ['reply'],
      attributeBindings: ['data-post-id'],
      'data-post-id': Em.computed.alias('content.id'),

      _startTracking: (function () {
        var post = this.get('content');
        ScreenTrack.current().track(this.get('elementId'), post.get('post_number'));
      }).on('didInsertElement'),

      _stopTracking: (function () {
        ScreenTrack.current().stopTracking(this.get('elementId'));
      }).on('willDestroyElement')
    });
  });define("discourse/views/flag-topic-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['flag-topic'],
      textKey: 'topic.flag_topic.title',
      helpKey: 'topic.flag_topic.help',

      click: function () {
        this.get('controller').send('showFlagTopic', this.get('controller.content'));
      },

      renderIcon: function (buffer) {
        buffer.push(iconHTML('flag'));
      }
    });
  });define("discourse/views/full-page-search", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend();
  });define("discourse/views/group-index", 
  ["discourse/mixins/scroll-top","discourse/mixins/load-more","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];
    var LoadMore = __dependency2__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, LoadMore, {
      eyelineSelector: '.user-stream .item'
    });
  });define("discourse/views/group-members", 
  ["discourse/mixins/scroll-top","discourse/mixins/load-more","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];
    var LoadMore = __dependency2__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, LoadMore, {
      eyelineSelector: '.group-members tr'
    });
  });define("discourse/views/group-mentions", 
  ["discourse/mixins/scroll-top","discourse/mixins/load-more","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];
    var LoadMore = __dependency2__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, LoadMore, {
      eyelineSelector: '.user-stream .item'
    });
  });define("discourse/views/group-topics", 
  ["discourse/mixins/scroll-top","discourse/mixins/load-more","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];
    var LoadMore = __dependency2__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, LoadMore, {
      eyelineSelector: '.user-stream .item'
    });
  });define("discourse/views/hide-modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      // No rendering!
      render: Em.K,

      _hideModal: (function () {
        $('#discourse-modal').modal('hide');
      }).on('didInsertElement')
    });
  });define("discourse/views/history", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/history',
      title: I18n.t('history'),

      resizeModal: (function () {
        var viewPortHeight = $(window).height();
        this.$(".modal-body").css("max-height", Math.floor(0.8 * viewPortHeight) + "px");
      }).on("didInsertElement")
    });
  });define("discourse/views/invite-reply-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      textKey: 'topic.invite_reply.title',
      helpKey: 'topic.invite_reply.help',
      attributeBindings: ['disabled'],
      disabled: Em.computed.or('controller.model.archived', 'controller.model.closed', 'controller.model.deleted'),

      renderIcon: function (buffer) {
        buffer.push(iconHTML('users'));
      },

      click: function () {
        this.get('controller').send('showInvite');
      }
    });
  });define("discourse/views/invite", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/invite',

      title: (function () {
        if (this.get('controller.isMessage')) {
          return I18n.t('topic.invite_private.title');
        } else if (this.get('controller.invitingToTopic')) {
          return I18n.t('topic.invite_reply.title');
        } else {
          return I18n.t('user.invited.create');
        }
      }).property('controller.{invitingToTopic,isMessage}'),

      inviteLinkChanged: (function () {
        if (!Ember.isEmpty(this.get('controller.model.inviteLink'))) {
          Em.run.next(function () {
            $('.invite-link-input').select().focus();
          });
        }
      }).observes('controller.model.inviteLink')

    });
  });define("discourse/views/list/post-count-or-badges", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({
      postCountsPresent: Ember.computed.or('topic.unread', 'topic.displayNewPosts'),
      showBadges: Ember.computed.and('postBadgesEnabled', 'postCountsPresent')
    });
  });define("discourse/views/list/posts-count-column", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var fmt = __dependency1__.fmt;

    __exports__["default"] = Ember.Object.extend({
      tagName: "td",
      ratio: (function () {
        var likes = parseFloat(this.get('topic.like_count')),
            posts = parseFloat(this.get('topic.posts_count'));

        if (posts < 10) {
          return 0;
        }

        return (likes || 0) / posts;
      }).property(),

      title: (function () {
        return I18n.messageFormat('posts_likes_MF', {
          count: this.get('topic.replyCount'),
          ratio: this.get('ratioText')
        }).trim();
      }).property(),

      ratioText: (function () {
        var ratio = this.get('ratio');

        var settings = Discourse.SiteSettings;
        if (ratio > settings.topic_post_like_heat_high) {
          return 'high';
        }
        if (ratio > settings.topic_post_like_heat_medium) {
          return 'med';
        }
        if (ratio > settings.topic_post_like_heat_low) {
          return 'low';
        }
        return '';
      }).property(),

      likesHeat: fmt('ratioText', 'heatmap-%@')
    });
  });define("discourse/views/loading", 
  ["discourse/helpers/loading-spinner","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var spinnerHTML = __dependency1__.spinnerHTML;

    __exports__["default"] = Ember.View.extend({
      render: function (buffer) {
        buffer.push(spinnerHTML);
      }
    });
  });define("discourse/views/login-reply-button", 
  ["discourse/views/button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];

    __exports__["default"] = ButtonView.extend({
      textKey: 'topic.login_reply',
      classNames: ['btn', 'btn-primary', 'create'],
      click: function () {
        this.get('controller').send('showLogin');
      },
      renderIcon: function (buffer) {
        buffer.push("<i class='fa fa-user'></i>");
      }
    });
  });define("discourse/views/login", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/login',
      title: I18n.t('login.title'),
      classNames: ['login-modal'],

      mouseMove: function (e) {
        this.set('controller.lastX', e.screenX);
        this.set('controller.lastY', e.screenY);
      },

      _setup: (function () {
        var loginController = this.get('controller');

        // Get username and password from the browser's password manager,
        // if it filled the hidden static login form:
        loginController.set('loginName', $('#hidden-login-form input[name=username]').val());
        loginController.set('loginPassword', $('#hidden-login-form input[name=password]').val());

        Em.run.schedule('afterRender', function () {
          $('#login-account-password, #login-account-name').keydown(function (e) {
            if (e.keyCode === 13 && !loginController.get('loginDisabled')) {
              loginController.send('login');
            }
          });
        });
      }).on('didInsertElement')
    });
  });define("discourse/views/modal", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'discourse-modal';
      }
    }, {
      key: 'templateName',
      initializer: function () {
        return 'modal/modal';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':modal', ':hidden', 'controller.modalClass'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['data-keyboard'];
      }
    }, {
      key: 'data-keyboard',

      // We handle ESC ourselves
      initializer: function () {
        return 'false';
      }
    }, {
      key: 'setUp',
      decorators: [on("didInsertElement")],
      value: function () {
        $('html').on('keydown.discourse-modal', function (e) {
          if (e.which === 27) {
            Em.run.next(function () {
              return $('.modal-header a.close').click();
            });
          }
        });
      }
    }, {
      key: 'cleanUp',
      decorators: [on("willDestroyElement")],
      value: function () {
        $('html').off('keydown.discourse-modal');
      }
    }, {
      key: 'click',
      value: function (e) {
        var $target = $(e.target);
        if ($target.hasClass("modal-middle-container") || $target.hasClass("modal-outer-container")) {
          // Delegate click to modal close if clicked outside.
          // We do this because some CSS of ours seems to cover
          // the backdrop and makes it unclickable.
          $('.modal-header a.close').click();
        }
      }
    }]));
  });define("discourse/views/navigation-categories", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    var CATEGORIES_BODY_CLASS = "navigation-categories";

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: "addBodyClass",
      decorators: [on("didInsertElement")],
      value: function () {
        $('body').addClass(CATEGORIES_BODY_CLASS);
      }
    }, {
      key: "removeBodyClass",
      decorators: [on("willDestroyElement")],
      value: function () {
        $('body').removeClass(CATEGORIES_BODY_CLASS);
      }
    }]));
  });define("discourse/views/navigation-category", 
  ["discourse/mixins/add-category-class","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var AddCategoryClass = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(AddCategoryClass, {
      categoryFullSlug: Ember.computed.alias('controller.category.fullSlug')
    });
  });define("discourse/views/option-boolean", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.GroupedView.extend({
      classNames: ['archetype-option'],
      composerControllerBinding: 'Discourse.router.composerController',
      templateName: "modal/option_boolean",

      _checkedChanged: (function () {
        var metaData = this.get('parentView.metaData');
        metaData.set(this.get('content.key'), this.get('checked') ? 'true' : 'false');
        this.get('controller.controllers.composer').saveDraft();
      }).observes('checked')
    });
  });define("discourse/views/post-placeholder", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({ templateName: 'post-placeholder' });
  });define("discourse/views/post", 
  ["discourse/lib/screen-track","discourse/lib/formatter","discourse/lib/url","ember-addons/ember-computed-decorators","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ScreenTrack = __dependency1__["default"];
    var number = __dependency2__.number;
    var DiscourseURL = __dependency3__["default"];
    var computed = __dependency4__.default;
    var on = __dependency4__.on;
    var fmt = __dependency5__.fmt;

    var DAY = 60 * 50 * 1000;

    var PostView = Discourse.GroupedView.extend(Ember.Evented, _createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['topic-post', 'clearfix'];
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['needsModeratorClass:moderator:regular', 'selected', 'post.hidden:post-hidden', 'post.deleted:deleted', 'post.topicOwner:topic-owner', 'groupNameClass', 'post.wiki:wiki', 'whisper'];
      }
    }, {
      key: 'post',
      initializer: function () {
        return Ember.computed.alias('content');
      }
    }, {
      key: 'postElementId',
      initializer: function () {
        return fmt('post.post_number', 'post_%@');
      }
    }, {
      key: 'likedUsers',
      initializer: function () {
        return null;
      }
    }, {
      key: 'initLikedUsers',
      decorators: [on('init')],
      value: function () {
        this.set('likedUsers', []);
      }
    }, {
      key: 'whisper',
      decorators: [computed('post.post_type')],
      value: function (postType) {
        return postType === this.site.get('post_types.whisper');
      }
    }, {
      key: 'templateName',
      initializer: function () {
        return (function () {
          return this.get('post.post_type') === this.site.get('post_types.small_action') ? 'post-small-action' : 'post';
        }).property('post.post_type');
      }
    }, {
      key: 'historyHeat',
      initializer: function () {
        return (function () {
          var updatedAt = this.get('post.updated_at');
          if (!updatedAt) {
            return;
          }

          // Show heat on age
          var rightNow = new Date().getTime(),
              updatedAtDate = new Date(updatedAt).getTime();

          if (updatedAtDate > rightNow - DAY * Discourse.SiteSettings.history_hours_low) return 'heatmap-high';
          if (updatedAtDate > rightNow - DAY * Discourse.SiteSettings.history_hours_medium) return 'heatmap-med';
          if (updatedAtDate > rightNow - DAY * Discourse.SiteSettings.history_hours_high) return 'heatmap-low';
        }).property('post.updated_at');
      }
    }, {
      key: 'needsModeratorClass',
      initializer: function () {
        return (function () {
          return this.get('post.post_type') === this.site.get('post_types.moderator_action') || this.get('post.topic.is_warning') && this.get('post.firstPost');
        }).property('post.post_type');
      }
    }, {
      key: 'groupNameClass',
      initializer: function () {
        return (function () {
          var primaryGroupName = this.get('post.primary_group_name');
          if (primaryGroupName) {
            return "group-" + primaryGroupName;
          }
        }).property('post.primary_group_name');
      }
    }, {
      key: 'showExpandButton',
      initializer: function () {
        return (function () {
          if (this.get('controller.firstPostExpanded')) {
            return false;
          }

          var post = this.get('post');
          return post.get('post_number') === 1 && post.get('topic.expandable_first_post');
        }).property('post.post_number', 'controller.firstPostExpanded');
      }
    }, {
      key: 'cookedChanged',

      // If the cooked content changed, add the quote controls
      initializer: function () {
        return (function () {
          Em.run.scheduleOnce('afterRender', this, '_cookedWasChanged');
        }).observes('post.cooked');
      }
    }, {
      key: '_cookedWasChanged',
      value: function () {
        this.trigger('postViewUpdated', this.$());
        this._insertQuoteControls();
      }
    }, {
      key: 'mouseUp',
      value: function (e) {
        if (this.get('controller.multiSelect') && (e.metaKey || e.ctrlKey)) {
          this.get('controller').toggledSelectedPost(this.get('post'));
        }
      }
    }, {
      key: 'selected',
      initializer: function () {
        return (function () {
          return this.get('controller').postSelected(this.get('post'));
        }).property('controller.selectedPostsCount');
      }
    }, {
      key: 'canSelectReplies',
      initializer: function () {
        return (function () {
          if (this.get('post.reply_count') === 0) {
            return false;
          }
          return !this.get('selected');
        }).property('post.reply_count', 'selected');
      }
    }, {
      key: 'selectPostText',
      initializer: function () {
        return (function () {
          return this.get('selected') ? I18n.t('topic.multi_select.selected', { count: this.get('controller.selectedPostsCount') }) : I18n.t('topic.multi_select.select');
        }).property('selected', 'controller.selectedPostsCount');
      }
    }, {
      key: 'repliesShown',
      initializer: function () {
        return Em.computed.gt('post.replies.length', 0);
      }
    }, {
      key: '_updateQuoteElements',
      value: function ($aside, desc) {
        var navLink = "";
        var quoteTitle = I18n.t("post.follow_quote"),
            postNumber = $aside.data('post');

        if (postNumber) {

          // If we have a topic reference
          var topicId = undefined,
              topic = undefined;
          if (topicId = $aside.data('topic')) {
            topic = this.get('controller.content');

            // If it's the same topic as ours, build the URL from the topic object
            if (topic && topic.get('id') === topicId) {
              navLink = '<a href=\'' + topic.urlForPostNumber(postNumber) + '\' title=\'' + quoteTitle + '\' class=\'back\'></a>';
            } else {
              // Made up slug should be replaced with canonical URL
              navLink = '<a href=\'' + (Discourse.getURL("/t/via-quote/") + topicId + "/" + postNumber) + '\' title=\'' + quoteTitle + '\' class=\'quote-other-topic\'></a>';
            }
          } else if (topic = this.get('controller.content')) {
            // assume the same topic
            navLink = '<a href=\'' + topic.urlForPostNumber(postNumber) + '\' title=\'' + quoteTitle + '\' class=\'back\'></a>';
          }
        }
        // Only add the expand/contract control if it's not a full post
        var expandContract = "";
        if (!$aside.data('full')) {
          expandContract = '<i class=\'fa fa-' + desc + '\' title=\'' + I18n.t("post.expand_collapse") + '\'></i>';
          $('.title', $aside).css('cursor', 'pointer');
        }
        $('.quote-controls', $aside).html(expandContract + navLink);
      }
    }, {
      key: '_toggleQuote',
      value: function ($aside) {
        var _this = this;

        if (this.get('expanding')) {
          return;
        }

        this.set('expanding', true);

        $aside.data('expanded', !$aside.data('expanded'));

        var finished = function () {
          return _this.set('expanding', false);
        };

        if ($aside.data('expanded')) {
          (function () {
            _this._updateQuoteElements($aside, 'chevron-up');
            // Show expanded quote
            var $blockQuote = $('blockquote', $aside);
            $aside.data('original-contents', $blockQuote.html());

            var originalText = $blockQuote.text().trim();
            $blockQuote.html(I18n.t("loading"));
            var topicId = _this.get('post.topic_id');
            if ($aside.data('topic')) {
              topicId = $aside.data('topic');
            }

            var postId = parseInt($aside.data('post'), 10);
            topicId = parseInt(topicId, 10);

            Discourse.ajax('/posts/by_number/' + topicId + '/' + postId).then(function (result) {
              var div = $("<div class='expanded-quote'></div>");
              div.html(result.cooked);
              div.highlight(originalText, { caseSensitive: true, element: 'span', className: 'highlighted' });
              $blockQuote.showHtml(div, 'fast', finished);
            });
          })();
        } else {
          // Hide expanded quote
          this._updateQuoteElements($aside, 'chevron-down');
          $('blockquote', $aside).showHtml($aside.data('original-contents'), 'fast', finished);
        }
        return false;
      }
    }, {
      key: '_showLinkCounts',

      // Show how many times links have been clicked on
      value: function () {
        var self = this,
            link_counts = this.get('post.link_counts');

        if (!link_counts) {
          return;
        }

        link_counts.forEach(function (lc) {
          if (!lc.clicks || lc.clicks < 1) {
            return;
          }

          self.$(".cooked a[href]").each(function () {
            var $link = $(this),
                href = $link.attr('href');

            var valid = !lc.internal && href === lc.url;

            // this might be an attachment
            if (lc.internal) {
              valid = href.indexOf(lc.url) >= 0;
            }

            if (valid) {
              // don't display badge counts on category badge & oneboxes (unless when explicitely stated)
              if ($link.hasClass("track-link") || $link.closest('.badge-category,.onebox-result,.onebox-body').length === 0) {
                $link.append("<span class='badge badge-notification clicks' title='" + I18n.t("topic_map.clicks", { count: lc.clicks }) + "'>" + number(lc.clicks) + "</span>");
              }
            }
          });
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggleLike: function () {
            var currentUser = this.get('controller.currentUser');
            var post = this.get('post');
            var likeAction = post.get('likeAction');
            if (likeAction && likeAction.get('canToggle')) {
              var users = this.get('likedUsers');
              var store = this.get('controller.store');
              var action = store.createRecord('post-action-user', currentUser.getProperties('id', 'username', 'avatar_template'));

              if (likeAction.toggle(post) && users.get('length')) {
                users.addObject(action);
              } else {
                users.removeObject(action);
              }
            }
          },

          toggleWhoLiked: function () {
            var _this2 = this;

            var post = this.get('post');
            var likeAction = post.get('likeAction');
            if (likeAction) {
              var users = this.get('likedUsers');
              if (users.get('length')) {
                users.clear();
              } else {
                likeAction.loadUsers(post).then(function (newUsers) {
                  return _this2.set('likedUsers', newUsers);
                });
              }
            }
          },

          // Toggle the replies this post is a reply to
          toggleReplyHistory: function (post) {
            var _this3 = this;

            var replyHistory = post.get('replyHistory'),
                topicController = this.get('controller'),
                origScrollTop = $(window).scrollTop(),
                replyPostNumber = this.get('post.reply_to_post_number'),
                postNumber = this.get('post.post_number'),
                self = this;

            if (Discourse.Mobile.mobileView) {
              DiscourseURL.routeTo(this.get('post.topic').urlForPostNumber(replyPostNumber));
              return;
            }

            var stream = topicController.get('model.postStream');
            var offsetFromTop = this.$().position().top - $(window).scrollTop();

            if (Discourse.SiteSettings.experimental_reply_expansion) {
              if (postNumber - replyPostNumber > 1) {
                stream.collapsePosts(replyPostNumber + 1, postNumber - 1);
              }

              Em.run.next(function () {
                PostView.highlight(replyPostNumber);
                $(window).scrollTop(self.$().position().top - offsetFromTop);
              });
              return;
            }

            if (replyHistory.length > 0) {
              (function () {
                var origHeight = _this3.$('.embedded-posts.top').height();

                replyHistory.clear();
                Em.run.next(function () {
                  $(window).scrollTop(origScrollTop - origHeight);
                });
              })();
            } else {
              post.set('loadingReplyHistory', true);

              stream.findReplyHistory(post).then(function () {
                post.set('loadingReplyHistory', false);

                Em.run.next(function () {
                  $(window).scrollTop(origScrollTop + self.$('.embedded-posts.top').height());
                });
              });
            }
          }
        };
      }
    }, {
      key: '_insertQuoteControls',

      // Add the quote controls to a post
      value: function () {
        var self = this,
            $quotes = this.$('aside.quote');

        // Safety check - in some cases with cloackedView this seems to be `undefined`.
        if (Em.isEmpty($quotes)) {
          return;
        }

        $quotes.each(function (i, e) {
          var $aside = $(e);
          if ($aside.data('post')) {
            self._updateQuoteElements($aside, 'chevron-down');
            var $title = $('.title', $aside);

            // Unless it's a full quote, allow click to expand
            if (!($aside.data('full') || $title.data('has-quote-controls'))) {
              $title.on('click', function (e2) {
                if ($(e2.target).is('a')) return true;
                self._toggleQuote($aside);
              });
              $title.data('has-quote-controls', true);
            }
          }
        });
      }
    }, {
      key: '_destroyedPostView',
      initializer: function () {
        return (function () {
          ScreenTrack.current().stopTracking(this.get('elementId'));
        }).on('willDestroyElement');
      }
    }, {
      key: '_postViewInserted',
      initializer: function () {
        return (function () {
          var $post = this.$(),
              postNumber = this.get('post').get('post_number');

          this._showLinkCounts();

          ScreenTrack.current().track($post.prop('id'), postNumber);

          this.trigger('postViewInserted', $post);

          // Find all the quotes
          Em.run.scheduleOnce('afterRender', this, '_insertQuoteControls');

          $post.closest('.post-cloak').attr('data-post-number', postNumber);
          this._applySearchHighlight();
        }).on('didInsertElement');
      }
    }, {
      key: '_fixImageSizes',
      initializer: function () {
        return (function () {
          var maxWidth;
          this.$('img:not(.avatar)').each(function (idx, img) {

            // deferring work only for posts with images
            // we got to use screen here, cause nothing is rendered yet.
            // long term we may want to allow for weird margins that are enforced, instead of hardcoding at 70/20
            maxWidth = maxWidth || $(window).width() - (Discourse.Mobile.mobileView ? 20 : 70);
            if (Discourse.SiteSettings.max_image_width < maxWidth) {
              maxWidth = Discourse.SiteSettings.max_image_width;
            }

            var aspect = img.height / img.width;
            if (img.width > maxWidth) {
              img.width = maxWidth;
              img.height = parseInt(maxWidth * aspect, 10);
            }

            // very unlikely but lets fix this too
            if (img.height > Discourse.SiteSettings.max_image_height) {
              img.height = Discourse.SiteSettings.max_image_height;
              img.width = parseInt(maxWidth / aspect, 10);
            }
          });
        }).on('willInsertElement');
      }
    }, {
      key: '_applySearchHighlight',
      initializer: function () {
        return (function () {
          var highlight = this.get('searchService.highlightTerm');
          var cooked = this.$('.cooked');

          if (!cooked) {
            return;
          }

          if (highlight && highlight.length > 2) {
            if (this._highlighted) {
              cooked.unhighlight();
            }
            cooked.highlight(highlight.split(/\s+/));
            this._highlighted = true;
          } else if (this._highlighted) {
            cooked.unhighlight();
            this._highlighted = false;
          }
        }).observes('searchService.highlightTerm', 'cooked');
      }
    }]));

    __exports__["default"] = PostView;
  });define("discourse/views/preferences-about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/about',
      classNames: ['user-preferences'],

      _focusAbout: (function () {
        var self = this;
        Ember.run.schedule('afterRender', function () {
          self.$('textarea').focus();
        });
      }).on('didInsertElement')
    });
  });define("discourse/views/preferences-email", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      templateName: 'user/email',
      classNames: ['user-preferences'],
      _focusField: (function () {
        Em.run.schedule('afterRender', function () {
          $('#change_email').focus();
        });
      }).on('didInsertElement')
    });
  });define("discourse/views/preferences-username", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/username',
      classNames: ['user-preferences'],

      _focusUsername: (function () {
        Em.run.schedule('afterRender', function () {
          $('#change_username').focus();
        });
      }).on('didInsertElement'),

      keyDown: function (e) {
        if (e.keyCode === 13) {
          if (!this.get('controller').get('saveDisabled')) {
            return this.get('controller').send('changeUsername');
          } else {
            e.preventDefault();
            return false;
          }
        }
      }
    });
  });define("discourse/views/preferences", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/preferences',
      classNames: ['user-preferences']
    });
  });define("discourse/views/quote-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      classNames: ['quote-button'],
      classNameBindings: ['visible'],
      isMouseDown: false,
      isTouchInProgress: false,

      /**
        The button is visible whenever there is something in the buffer
        (ie. something has been selected)
      **/
      visible: Em.computed.notEmpty('controller.buffer'),

      render: function (buffer) {
        buffer.push(I18n.t("post.quote_reply"));
      },

      /**
        Binds to the following global events:
          - `mousedown` to clear the quote button if they click elsewhere.
          - `mouseup` to trigger the display of the quote button.
          - `selectionchange` to make the selection work under iOS
         @method didInsertElement
      **/
      didInsertElement: function () {
        var controller = this.get('controller'),
            view = this;

        var onSelectionChanged = function () {
          view.selectText(window.getSelection().anchorNode, controller);
        };

        // Windows Phone hack, it is not firing the touch events
        // best we can do is debounce this so we dont keep locking up
        // the selection when we add the caret to measure where we place
        // the quote reply widget
        //
        // Same hack applied to Android cause it has unreliable touchend
        var isAndroid = this.capabilities.isAndroid;
        if (this.capabilities.isWinphone || isAndroid) {
          onSelectionChanged = _.debounce(onSelectionChanged, 500);
        }

        $(document).on("mousedown.quote-button", function (e) {
          view.set('isMouseDown', true);

          var $target = $(e.target);
          // we don't want to deselect when we click on buttons that use it
          if ($target.hasClass('quote-button') || $target.closest('.create').length || $target.closest('.reply-new').length) return;

          // deselects only when the user left click
          // (allows anyone to `extend` their selection using shift+click)
          if (!window.getSelection().isCollapsed && e.which === 1 && !e.shiftKey) controller.deselectText();
        }).on('mouseup.quote-button', function (e) {
          view.selectText(e.target, controller);
          view.set('isMouseDown', false);
        }).on('selectionchange', function () {
          // there is no need to handle this event when the mouse is down
          // or if there a touch in progress
          if (view.get('isMouseDown') || view.get('isTouchInProgress')) return;
          // `selection.anchorNode` is used as a target
          onSelectionChanged();
        });

        // Android is dodgy, touchend often will not fire
        // https://code.google.com/p/android/issues/detail?id=19827
        if (!isAndroid) {
          $(document).on('touchstart.quote-button', function () {
            view.set('isTouchInProgress', true);
          }).on('touchend.quote-button', function () {
            view.set('isTouchInProgress', false);
          });
        }
      },

      selectText: function (target, controller) {
        var $target = $(target);
        // breaks if quoting has been disabled by the user
        if (!Discourse.User.currentProp('enable_quoting')) return;
        // retrieve the post id from the DOM
        var postId = $target.closest('.boxed, .reply').data('post-id');
        // select the text
        if (postId) controller.selectText(postId);
      },

      willDestroyElement: function () {
        $(document).off("mousedown.quote-button").off("mouseup.quote-button").off("touchstart.quote-button").off("touchend.quote-button").off("selectionchange");
      },

      click: function (e) {
        e.stopPropagation();
        return this.get('controller').quoteText(e);
      }

    });
  });define("discourse/views/raw-email", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/raw_email',
      title: I18n.t('raw_email.title'),

      resizeModal: (function () {
        var viewPortHeight = $(window).height();
        this.$(".modal-body").css("max-height", Math.floor(0.8 * viewPortHeight) + "px");
      }).on("didInsertElement")
    });
  });define("discourse/views/reorder-categories", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      title: I18n.t('categories.reorder.title'),
      templateName: 'modal/reorder-categories',

      _setup: (function () {
        this.get('controller').on('scrollIntoView', this, this.scrollIntoView);
      }).on('didInsertElement'),
      _teardown: (function () {
        this.get('controller').off('scrollIntoView', this, this.scrollIntoView);
        this.set('prevScrollElem', null);
      }).on('willClearRender'),

      scrollIntoView: function () {
        var elem = this.$('tr[data-category-id="' + this.get('controller.scrollIntoViewId') + '"]');
        var scrollParent = this.$('.modal-body');
        var eoff = elem.position();
        var poff = $(document.getElementById('rc-scroll-anchor')).position();
        var currHeight = scrollParent.height();

        elem[0].className = "highlighted";

        var goal = eoff.top - poff.top - currHeight / 2,
            current = scrollParent.scrollTop();
        scrollParent.scrollTop(9999999);
        var max = scrollParent.scrollTop();
        scrollParent.scrollTop(current);

        var doneTimeout = setTimeout(function () {
          elem[0].className = "highlighted done";
          setTimeout(function () {
            elem[0].className = "";
          }, 2000);
        }, 0);

        if (goal > current - currHeight / 4 && goal < current + currHeight / 4) {
          // Too close to goal
          return;
        }
        if (max - current < 10 && goal > current) {
          // Too close to bottom
          return;
        }
        if (current < 10 && goal < current) {
          // Too close to top
          return;
        }

        if (!window.requestAnimationFrame) {
          scrollParent.scrollTop(goal);
        } else {
          (function () {
            clearTimeout(doneTimeout);
            var startTime = performance.now();
            var duration = 100;

            function doScroll(timestamp) {
              var progress = (timestamp - startTime) / duration;
              if (progress > 1) {
                progress = 1;
                setTimeout(function () {
                  elem[0].className = "highlighted done";
                  setTimeout(function () {
                    elem[0].className = "";
                  }, 2000);
                }, 0);
              } else if (progress < 0) {
                progress = 0;
              }
              if (progress < 1) {
                window.requestAnimationFrame(doScroll);
              }

              var iprogress = 1 - progress;
              scrollParent.scrollTop(goal * progress + current * iprogress);
            }
            window.requestAnimationFrame(doScroll);
          })();
        }
      }
    });
  });define("discourse/views/reply-button", 
  ["discourse/views/button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];

    __exports__["default"] = ButtonView.extend({
      classNames: ['btn', 'btn-primary', 'create'],
      helpKey: 'topic.reply.help',

      text: (function () {
        var archetypeCapitalized = this.get('controller.content.archetype').capitalize();
        var customTitle = this.get("parentView.replyButtonText" + archetypeCapitalized);
        if (customTitle) {
          return customTitle;
        }

        return I18n.t("topic.reply.title");
      }).property(),

      renderIcon: function (buffer) {
        buffer.push("<i class='fa fa-reply'></i>");
      },

      click: function () {
        this.get('controller').send('replyToPost');
      }
    });
  });define("discourse/views/reply-history", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.CollectionView.extend({
      tagName: 'section',
      classNameBindings: [':embedded-posts', ':top', ':topic-body', ':offset2', 'hidden'],
      itemViewClass: 'embedded-post',
      hidden: Em.computed.equal('content.length', 0),
      previousPost: true
    });
  });define("discourse/views/search-help", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/search_help',
      title: I18n.t('search_help.title'),
      focusInput: false
    });
  });define("discourse/views/selected-posts", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      elementId: 'selected-posts',
      classNameBindings: ['customVisibility'],
      templateName: "selected-posts",

      customVisibility: (function () {
        if (!this.get('controller.multiSelect')) return 'hidden';
      }).property('controller.multiSelect')
    });
  });define("discourse/views/share-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['share'],
      textKey: 'topic.share.title',
      helpKey: 'topic.share.help',
      'data-share-url': Em.computed.alias('topic.shareUrl'),
      topic: Em.computed.alias('controller.model'),

      renderIcon: function (buffer) {
        buffer.push(iconHTML("link"));
      }
    });
  });define("discourse/views/share", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Ember.View.extend({
      templateName: 'share',
      elementId: 'share-link',
      classNameBindings: ['hasLink'],

      title: (function () {
        if (this.get('controller.type') === 'topic') return I18n.t('share.topic');
        var postNumber = this.get('controller.postNumber');
        if (postNumber) {
          return I18n.t('share.post', { postNumber: this.get('controller.postNumber') });
        } else {
          return I18n.t('share.topic');
        }
      }).property('controller.type', 'controller.postNumber'),

      hasLink: (function () {
        if (!Ember.isEmpty(this.get('controller.link'))) return 'visible';
        return null;
      }).property('controller.link'),

      linkChanged: (function () {
        var self = this;
        if (!Ember.isEmpty(this.get('controller.link'))) {
          Em.run.next(function () {
            if (!self.capabilities.touch) {
              var $linkInput = $('#share-link input');
              $linkInput.val(self.get('controller.link'));

              // Wait for the fade-in transition to finish before selecting the link:
              window.setTimeout(function () {
                $linkInput.select().focus();
              }, 160);
            } else {
              var $linkForTouch = $('#share-link .share-for-touch a');
              $linkForTouch.attr('href', self.get('controller.link'));
              $linkForTouch.html(self.get('controller.link'));
              var range = window.document.createRange();
              range.selectNode($linkForTouch[0]);
              window.getSelection().addRange(range);
            }
          });
        }
      }).observes('controller.link'),

      didInsertElement: function () {
        var self = this,
            $html = $('html');

        $html.on('mousedown.outside-share-link', function (e) {
          // Use mousedown instead of click so this event is handled before routing occurs when a
          // link is clicked (which is a click event) while the share dialog is showing.
          if (self.$().has(e.target).length !== 0) {
            return;
          }

          self.get('controller').send('close');
          return true;
        });

        function showPanel($target, url, postNumber, date) {
          var $currentTargetOffset = $target.offset();
          var $shareLink = $('#share-link');

          // Relative urls
          if (url.indexOf("/") === 0) {
            url = window.location.protocol + "//" + window.location.host + url;
          }

          var shareLinkWidth = $shareLink.width();
          var x = $currentTargetOffset.left - shareLinkWidth / 2;
          if (x < 25) {
            x = 25;
          }
          if (x + shareLinkWidth > $(window).width()) {
            x -= shareLinkWidth / 2;
          }

          var header = $('.d-header');
          var y = $currentTargetOffset.top - ($shareLink.height() + 20);
          if (y < header.offset().top + header.height()) {
            y = $currentTargetOffset.top + 10;
          }

          $shareLink.css({ top: "" + y + "px" });

          if (!Discourse.Mobile.mobileView) {
            $shareLink.css({ left: "" + x + "px" });
          }

          self.set('controller.link', url);
          self.set('controller.postNumber', postNumber);
          self.set('controller.date', date);
        }

        this.appEvents.on('share:url', function (url, $target) {
          return showPanel($target, url);
        });

        $html.on('click.discoure-share-link', '[data-share-url]', function (e) {
          // if they want to open in a new tab, let it so
          if (e.shiftKey || e.metaKey || e.ctrlKey || e.which === 2) {
            return true;
          }

          e.preventDefault();

          var $currentTarget = $(e.currentTarget),
              url = $currentTarget.data('share-url'),
              postNumber = $currentTarget.data('post-number'),
              date = $currentTarget.children().data('time');
          showPanel($currentTarget, url, postNumber, date);
          return false;
        });

        $html.on('keydown.share-view', function (e) {
          if (e.keyCode === 27) {
            self.get('controller').send('close');
          }
        });
      },

      willDestroyElement: function () {
        this.get('controller').send('close');

        $('html').off('click.discoure-share-link').off('mousedown.outside-share-link').off('keydown.share-view');
      }

    });
  });define("discourse/views/split-topic", 
  ["discourse/mixins/selected-posts-count","discourse/views/modal-body","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalBodyView = __dependency2__["default"];

    __exports__["default"] = ModalBodyView.extend(SelectedPostsCount, {
      templateName: 'modal/split-topic',
      title: I18n.t('topic.split_topic.title')
    });
  });define("discourse/views/static", 
  ["discourse/lib/is-element-in-viewport","discourse/mixins/scroll-top","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var isElementInViewport = __dependency1__["default"];
    var ScrollTop = __dependency2__["default"];
    var on = __dependency3__.on;

    __exports__["default"] = Ember.View.extend(ScrollTop, _createDecoratedObject([{
      key: '_checkRead',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        var currentUser = this.get('controller.currentUser');
        if (currentUser) {
          var path = this.get('controller.model.path');
          if (path === "faq" || path === "guidelines") {
            (function () {
              var controller = _this.get('controller');
              $(window).on('load.faq resize.faq scroll.faq', function () {
                var faqUnread = !currentUser.get('read_faq');
                if (faqUnread && isElementInViewport($(".contents p").last())) {
                  controller.send('markFaqRead');
                }
              });
            })();
          }
        }
      }
    }, {
      key: '_stopChecking',
      decorators: [on('willDestroyElement')],
      value: function () {
        $(window).off('load.faq resize.faq scroll.faq');
      }
    }]));
  });define("discourse/views/topic-closing", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(StringBuffer, {
      elementId: 'topic-closing-info',
      delayedRerender: null,

      rerenderTriggers: ['topic.closed', 'topic.details.auto_close_at', 'topic.details.auto_close_based_on_last_post', 'topic.details.auto_close_hours'],

      renderString: function (buffer) {
        if (!!Ember.isEmpty(this.get('topic.details.auto_close_at'))) return;
        if (this.get("topic.closed")) return;

        var autoCloseAt = moment(this.get('topic.details.auto_close_at'));
        if (autoCloseAt < new Date()) return;

        var duration = moment.duration(autoCloseAt - moment());
        var minutesLeft = duration.asMinutes();
        var timeLeftString = duration.humanize(true);
        var rerenderDelay = 1000;

        if (minutesLeft > 2160) {
          rerenderDelay = 12 * 60 * 60000;
        } else if (minutesLeft > 1410) {
          rerenderDelay = 60 * 60000;
        } else if (minutesLeft > 90) {
          rerenderDelay = 30 * 60000;
        } else if (minutesLeft > 2) {
          rerenderDelay = 60000;
        }

        var basedOnLastPost = this.get("topic.details.auto_close_based_on_last_post");
        var key = basedOnLastPost ? 'topic.auto_close_notice_based_on_last_post' : 'topic.auto_close_notice';
        var autoCloseHours = this.get("topic.details.auto_close_hours") || 0;

        buffer.push('<h3><i class="fa fa-clock-o"></i> ');
        buffer.push(I18n.t(key, { timeLeft: timeLeftString, duration: moment.duration(autoCloseHours, "hours").humanize() }));
        buffer.push('</h3>');

        // TODO Sam: concerned this can cause a heavy rerender loop
        this.set('delayedRerender', Em.run.later(this, this.rerender, rerenderDelay));
      },

      willDestroyElement: function () {
        if (this.delayedRerender) {
          Em.run.cancel(this.get('delayedRerender'));
        }
      }
    });
  });define("discourse/views/topic-entrance", 
  ["discourse/mixins/cleans-up","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var CleansUp = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(CleansUp, {
      elementId: 'topic-entrance',
      classNameBindings: ['visible::hidden'],
      visible: Em.computed.notEmpty('controller.model'),

      _positionChanged: (function () {
        var _this = this;

        var pos = this.get('controller.position');
        if (!pos) {
          return;
        }

        var $self = this.$();

        // Move after we render so the height is correct
        Em.run.schedule('afterRender', function () {
          var width = $self.width(),
              height = $self.height();
          pos.left = parseInt(pos.left) - width / 2;
          pos.top = parseInt(pos.top) - height / 2;

          var windowWidth = $(window).width();
          if (pos.left + width > windowWidth) {
            pos.left = windowWidth - width - 15;
          }
          $self.css(pos);
        });

        $('html').off('mousedown.topic-entrance').on('mousedown.topic-entrance', function (e) {
          var $target = $(e.target);
          if ($target.prop('id') === 'topic-entrance' || $self.has($target).length !== 0) {
            return;
          }
          _this.cleanUp();
        });
      }).observes('controller.position'),

      _removed: (function () {
        $('html').off('mousedown.topic-entrance');
      }).on('willDestroyElement'),

      cleanUp: function () {
        this.set('controller.model', null);
        $('html').off('mousedown.topic-entrance');
      },

      keyDown: function (e) {
        if (e.which === 27) {
          this.cleanUp();
        }
      }

    });
  });define("discourse/views/topic-footer-buttons", 
  ["discourse/views/container","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ContainerView = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = ContainerView.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'topic-footer-buttons';
      }
    }, {
      key: 'createButtons',
      decorators: [on('init')],
      value: function () {
        var topic = this.get('topic');
        var currentUser = this.get('controller.currentUser');

        if (currentUser) {
          var viewArgs = { topic: topic, currentUser: currentUser };
          this.attachViewWithArgs(viewArgs, 'topic-footer-main-buttons');
          this.attachViewWithArgs(viewArgs, 'pinned-button');
          this.attachViewWithArgs(viewArgs, 'topic-notifications-button');

          this.trigger('additionalButtons', this);
        } else {
          // If not logged in give them a login control
          this.attachViewClass('login-reply-button');
        }
      }
    }]));
  });define("discourse/views/topic-footer-main-buttons", 
  ["discourse/views/container","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ContainerView = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = ContainerView.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'topic-footer-main-buttons';
      }
    }, {
      key: 'createButtons',
      decorators: [on('init')],
      value: function () {
        var mobileView = Discourse.Mobile.mobileView;

        if (!mobileView && this.currentUser.get('staff')) {
          var viewArgs = { action: 'showTopicAdminMenu', title: 'topic_admin_menu', icon: 'wrench', position: 'absolute' };
          this.attachViewWithArgs(viewArgs, 'show-popup-button');
        }

        var topic = this.get('topic');
        if (!topic.get('isPrivateMessage')) {

          if (mobileView) {
            this.attachViewWithArgs({ topic: topic }, 'topic-footer-mobile-dropdown');
          } else {
            // We hide some controls from private messages
            if (this.get('topic.details.can_invite_to')) {
              this.attachViewClass('invite-reply-button');
            }
            this.attachViewClass('bookmark-button');
            this.attachViewClass('share-button');
            if (this.get('topic.details.can_flag_topic')) {
              this.attachViewClass('flag-topic-button');
            }
          }
        }
        if (this.get('topic.details.can_create_post')) {
          this.attachViewClass('reply-button');
        }
        this.trigger('additionalButtons', this);
      }
    }]));
  });define("discourse/views/topic-list-header-column", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({

      localizedName: (function () {
        if (this.forceName) {
          return this.forceName;
        }

        return I18n.t(this.name);
      }).property(),

      sortClass: (function () {
        return "fa fa-chevron-" + (this.parent.ascending ? "up" : "down");
      }).property(),

      isSorting: (function () {
        return this.sortable && this.parent.order === this.order;
      }).property(),

      className: (function () {
        var name = [];
        if (this.order) {
          name.push(this.order);
        }
        if (this.sortable) {
          name.push("sortable");

          if (this.get("isSorting")) {
            name.push("sorting");
          }
        }

        if (this.number) {
          name.push("num");
        }

        return name.join(' ');
      }).property()
    });
  });define("discourse/views/topic-list-item", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(StringBuffer, {
      topic: Em.computed.alias("content"),
      rerenderTriggers: ['controller.bulkSelectEnabled', 'topic.pinned'],
      tagName: 'tr',
      rawTemplate: 'list/topic-list-item.raw',
      classNameBindings: ['controller.checked', ':topic-list-item', 'unboundClassNames', 'selected'],
      attributeBindings: ['data-topic-id'],
      'data-topic-id': Em.computed.alias('topic.id'),

      actions: {
        select: function () {
          this.set('controller.selectedRow', this);
        },

        toggleBookmark: function () {
          var self = this;
          this.get('topic').toggleBookmark().finally(function () {
            self.rerender();
          });
        }
      },

      selected: (function () {
        return this.get('controller.selectedRow') === this;
      }).property('controller.selectedRow'),

      unboundClassNames: (function () {
        var classes = [];
        var topic = this.get('topic');

        if (topic.get('category')) {
          classes.push("category-" + topic.get('category.fullSlug'));
        }

        if (topic.get('hasExcerpt')) {
          classes.push('has-excerpt');
        }

        _.each(['liked', 'archived', 'bookmarked'], function (name) {
          if (topic.get(name)) {
            classes.push(name);
          }
        });

        return classes.join(' ');
      }).property(),

      titleColSpan: (function () {
        return !this.get('controller.hideCategory') && this.get('topic.isPinnedUncategorized') ? 2 : 1;
      }).property("topic.isPinnedUncategorized"),

      hasLikes: function () {
        return this.get('topic.like_count') > 0;
      },

      hasOpLikes: function () {
        return this.get('topic.op_like_count') > 0;
      },

      expandPinned: (function () {
        var pinned = this.get('topic.pinned');
        if (!pinned) {
          return false;
        }

        if (this.get('controller.expandGloballyPinned') && this.get('topic.pinned_globally')) {
          return true;
        }

        if (this.get('controller.expandAllPinned')) {
          return true;
        }

        return false;
      }).property(),

      click: function (e) {
        var target = $(e.target);

        if (target.hasClass('posts-map')) {
          if (target.prop('tagName') !== 'A') {
            target = target.find('a');
          }
          this.container.lookup('controller:application').send("showTopicEntrance", { topic: this.get('topic'), position: target.offset() });
          return false;
        }

        if (target.hasClass('bulk-select')) {
          var selected = this.get('controller.selected');
          var topic = this.get('topic');

          if (target.is(':checked')) {
            selected.addObject(topic);
          } else {
            selected.removeObject(topic);
          }
        }

        if (target.closest('a.topic-status').length === 1) {
          this.get('topic').togglePinnedForUser();
          return false;
        }
      },

      highlight: function () {
        var $topic = this.$();
        var originalCol = $topic.css('backgroundColor');
        $topic.addClass('highlighted').stop().animate({ backgroundColor: originalCol }, 2500, 'swing', function () {
          $topic.removeClass('highlighted');
        });
      },

      _highlightIfNeeded: (function () {
        // highlight the last topic viewed
        if (this.session.get('lastTopicIdViewed') === this.get('topic.id')) {
          this.session.set('lastTopicIdViewed', null);
          this.highlight();
        } else if (this.get('topic.highlight')) {
          // highlight new topics that have been loaded from the server or the one we just created
          this.set('topic.highlight', false);
          this.highlight();
        }
      }).on('didInsertElement')

    });
  });define("discourse/views/topic-list-poster", 
  ["discourse/helpers/user-avatar","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var renderAvatar = __dependency1__.renderAvatar;

    __exports__["default"] = Ember.View.extend({
      tagName: 'a',
      attributeBindings: ['href', 'data-user-card'],
      classNameBindings: ['content.extras'],

      user: Em.computed.alias('content.user'),
      href: Em.computed.alias('user.path'),

      'data-user-card': Em.computed.alias('user.username'),

      render: function (buffer) {
        var av = renderAvatar(this.get('content'), { usernamePath: 'user.username', imageSize: 'small' });
        buffer.push(av);
      }
    });
  });define("discourse/views/topic-map-container", 
  ["discourse/views/container","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ContainerView = __dependency1__["default"];
    var computed = __dependency2__.default;
    var observes = __dependency2__.observes;
    var on = __dependency2__.on;

    __exports__["default"] = ContainerView.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return ['hidden', ':topic-map'];
      }
    }, {
      key: '_postsChanged',
      decorators: [observes('topic.posts_count')],
      value: function () {
        Ember.run.once(this, 'rerender');
      }
    }, {
      key: 'hidden',
      decorators: [computed],
      value: function () {
        if (!this.get('post.firstPost')) return true;

        var topic = this.get('topic');
        if (topic.get('archetype') === 'private_message') return false;
        if (topic.get('archetype') !== 'regular') return true;
        return topic.get('posts_count') < 2;
      }
    }, {
      key: 'startAppending',
      decorators: [on('init')],
      value: function () {
        if (this.get('hidden')) return;

        this.attachViewWithArgs({ topic: this.get('topic') }, 'topic-map');
        this.trigger('appendMapInformation', this);
      }
    }, {
      key: 'appendMapInformation',
      value: function (view) {
        var topic = this.get('topic');

        if (topic.get('has_summary')) {
          view.attachViewWithArgs({ topic: topic, filterBinding: 'controller.filter' }, 'toggle-summary');
        }

        var currentUser = this.get('controller.currentUser');
        if (currentUser && currentUser.get('staff') && topic.get('has_deleted')) {
          view.attachViewWithArgs({ topic: topic, filterBinding: 'controller.filter' }, 'topic-deleted');
        }

        if (this.get('topic.isPrivateMessage')) {
          view.attachViewWithArgs({ topic: topic, showPrivateInviteAction: 'showInvite' }, 'private-message-map');
        }
      }
    }]));
  });define("discourse/views/topic-progress", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      elementId: 'topic-progress-wrapper',
      docked: false,
      classNameBindings: ['docked'],

      _inserted: (function () {
        this.appEvents.on("composer:opened", this, '_dock').on("composer:resized", this, '_dock').on("composer:closed", this, '_dock').on("topic:scrolled", this, '_dock');

        // Reflows are expensive. Cache the jQuery selector
        // and the width when inserted into the DOM
        this._$topicProgress = this.$('#topic-progress');
      }).on('didInsertElement'),

      _unbindEvents: (function () {
        this.appEvents.off("composer:opened", this, '_dock').off("composer:resized", this, '_dock').off("composer:closed", this, '_dock').off('topic:scrolled', this, '_dock');
      }).on('willDestroyElement'),

      _updateBar: (function () {
        Em.run.scheduleOnce('afterRender', this, '_updateProgressBar');
      }).observes('controller.streamPercentage', 'controller.model.postStream.stream.@each').on('init'),

      _updateProgressBar: function () {
        // speeds up stuff, bypass jquery slowness and extra checks
        if (!this._totalWidth) {
          this._totalWidth = this._$topicProgress[0].offsetWidth;
        }
        var totalWidth = this._totalWidth;
        var progressWidth = this.get('controller.streamPercentage') * totalWidth;

        this._$topicProgress.find('.bg').css("border-right-width", progressWidth === totalWidth ? "0px" : "1px").width(progressWidth);
      },

      _dock: function () {
        var maximumOffset = $('#topic-footer-buttons').offset(),
            composerHeight = $('#reply-control').height() || 0,
            $topicProgressWrapper = this.$(),
            style = $topicProgressWrapper.attr('style') || '',
            offset = window.pageYOffset || $('html').scrollTop();

        var isDocked = false;
        if (maximumOffset) {
          var threshold = maximumOffset.top,
              windowHeight = $(window).height(),
              topicProgressHeight = $('#topic-progress').height();

          isDocked = offset >= threshold - windowHeight + topicProgressHeight + composerHeight;
        }

        if (composerHeight > 0) {
          if (isDocked) {
            if (style.indexOf('bottom') >= 0) {
              $topicProgressWrapper.css('bottom', '');
            }
          } else {
            var height = composerHeight + "px";
            if ($topicProgressWrapper.css('bottom') !== height) {
              $topicProgressWrapper.css('bottom', height);
            }
          }
        } else {
          if (style.indexOf('bottom') >= 0) {
            $topicProgressWrapper.css('bottom', '');
          }
        }
        this.set('docked', isDocked);
      },

      _focusWhenOpened: (function () {
        var _this = this;

        // Don't focus on mobile or touch
        if (Discourse.Mobile.mobileView || this.capabilities.isIOS) {
          return;
        }

        if (this.get('controller.expanded')) {
          (function () {
            var self = _this;
            Em.run.schedule('afterRender', function () {
              self.$('input').focus();
            });
          })();
        }
      }).observes('controller.expanded'),

      click: function (e) {
        if ($(e.target).parents('#topic-progress').length) {
          this.get('controller').send('toggleExpansion');
        }
      },

      keyDown: function (e) {
        var controller = this.get('controller');
        if (controller.get('expanded')) {
          if (e.keyCode === 13) {
            this.$('input').blur();
            controller.send('jumpPost');
          } else if (e.keyCode === 27) {
            controller.send('toggleExpansion');
          }
        }
      }

    });
  });define("discourse/views/topic-status", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({
      renderDiv: (function () {
        return this.get('statuses').length > 0 && !this.noDiv;
      }).property(),
      statuses: (function () {
        var topic = this.get("topic");
        var results = [];
        var self = this;

        // TODO, custom statuses? via override?

        if (topic.get('is_warning')) {
          results.push({ icon: 'envelope', key: 'warning' });
        }

        if (topic.get('bookmarked')) {
          var url = topic.get('url');
          var postNumbers = topic.get('bookmarked_post_numbers');
          var extraClasses = "";
          if (postNumbers && postNumbers[0] > 1) {
            url += '/' + postNumbers[0];
          } else {
            extraClasses = "op-bookmark";
          }

          results.push({ extraClasses: extraClasses, icon: 'bookmark', key: 'bookmarked', href: url });
        }

        if (topic.get('closed') && topic.get('archived')) {
          results.push({ icon: 'lock', key: 'locked_and_archived' });
        } else if (topic.get('closed')) {
          results.push({ icon: 'lock', key: 'locked' });
        } else if (topic.get('archived')) {
          results.push({ icon: 'lock', key: 'archived' });
        }

        if (topic.get('pinned')) {
          results.push({ icon: 'thumb-tack', key: 'pinned' });
        }

        if (topic.get('unpinned')) {
          results.push({ icon: 'thumb-tack unpinned', key: 'unpinned' });
        }

        if (topic.get('invisible')) {
          results.push({ icon: 'eye-slash', key: 'invisible' });
        }

        _.each(results, function (result) {
          result.title = I18n.t("topic_statuses." + result.key + ".help");
          if (!self.disableActions && (result.key === "pinned" || result.key === "unpinned")) {
            result.openTag = 'a href';
            result.closeTag = 'a';
          } else {
            result.openTag = 'span';
            result.closeTag = 'span';
          }
        });

        return results;
      }).property()
    });
  });define("discourse/views/topic-unsubscribe", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      classNames: ["topic-unsubscribe"]
    });
  });define("discourse/views/topic", 
  ["discourse/mixins/add-category-class","discourse/mixins/add-archetype-class","discourse/lib/click-track","discourse/lib/app-events","discourse/helpers/category-link","discourse/mixins/scrolling","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var AddCategoryClass = __dependency1__["default"];
    var AddArchetypeClass = __dependency2__["default"];
    var ClickTrack = __dependency3__["default"];
    var listenForViewEvent = __dependency4__.listenForViewEvent;
    var categoryBadgeHTML = __dependency5__.categoryBadgeHTML;
    var Scrolling = __dependency6__["default"];

    var TopicView = Ember.View.extend(AddCategoryClass, AddArchetypeClass, Scrolling, {
      templateName: 'topic',
      topicBinding: 'controller.model',

      userFilters: Ember.computed.alias('controller.model.userFilters'),
      classNameBindings: ['controller.multiSelect:multi-select', 'topic.archetype', 'topic.is_warning', 'topic.category.read_restricted:read_restricted', 'topic.deleted:deleted-topic', 'topic.categoryClass'],
      menuVisible: true,
      SHORT_POST: 1200,

      categoryFullSlug: Em.computed.alias('topic.category.fullSlug'),

      postStream: Em.computed.alias('controller.model.postStream'),

      archetype: Em.computed.alias('topic.archetype'),

      _composeChanged: (function () {
        var composerController = Discourse.get('router.composerController');
        composerController.clearState();
        composerController.set('topic', this.get('topic'));
      }).observes('composer'),

      _enteredTopic: (function () {
        // Ember is supposed to only call observers when values change but something
        // in our view set up is firing this observer with the same value. This check
        // prevents scrolled from being called twice.
        var enteredAt = this.get('controller.enteredAt');
        if (enteredAt && this.get('lastEnteredAt') !== enteredAt) {
          this.scrolled();
          this.set('lastEnteredAt', enteredAt);
        }
      }).observes('controller.enteredAt'),

      _inserted: (function () {
        var _this = this;

        this.bindScrolling({ name: 'topic-view' });

        $(window).on('resize.discourse-on-scroll', function () {
          return _this.scrolled();
        });

        this.$().on('mouseup.discourse-redirect', '.cooked a, a.track-link', function (e) {
          // bypass if we are selecting stuff
          var selection = window.getSelection && window.getSelection();
          if (selection.type === "Range" || selection.rangeCount > 0) {
            if (Discourse.Utilities.selectedText() !== "") {
              return true;
            }
          }

          var $target = $(e.target);
          if ($target.hasClass('mention') || $target.parents('.expanded-embed').length) {
            return false;
          }

          return ClickTrack.trackClick(e);
        });
      }).on('didInsertElement'),

      // This view is being removed. Shut down operations
      _destroyed: (function () {
        this.unbindScrolling('topic-view');
        $(window).unbind('resize.discourse-on-scroll');

        // Unbind link tracking
        this.$().off('mouseup.discourse-redirect', '.cooked a, a.track-link');

        this.resetExamineDockCache();

        // this happens after route exit, stuff could have trickled in
        this.set('controller.controllers.header.showExtraInfo', false);
      }).on('willDestroyElement'),

      gotFocus: (function () {
        if (Discourse.get('hasFocus')) {
          this.scrolled();
        }
      }).observes("Discourse.hasFocus"),

      resetExamineDockCache: function () {
        this.set('docAt', false);
      },

      offset: 0,
      hasScrolled: Em.computed.gt("offset", 0),

      // The user has scrolled the window, or it is finished rendering and ready for processing.
      scrolled: function () {
        if (this.isDestroyed || this.isDestroying || this._state !== 'inDOM') {
          return;
        }

        var offset = window.pageYOffset || $('html').scrollTop();
        if (!this.get('docAt')) {
          var title = $('#topic-title');
          if (title && title.length === 1) {
            this.set('docAt', title.offset().top);
          }
        }

        this.set("offset", offset);

        var headerController = this.get('controller.controllers.header'),
            topic = this.get('controller.model');
        if (this.get('docAt')) {
          headerController.set('showExtraInfo', offset >= this.get('docAt') || topic.get('postStream.firstPostNotLoaded'));
        } else {
          headerController.set('showExtraInfo', topic.get('postStream.firstPostNotLoaded'));
        }

        // Trigger a scrolled event
        this.appEvents.trigger('topic:scrolled', offset);
      },

      browseMoreMessage: (function () {
        var opts = { latestLink: "<a href=\"" + Discourse.getURL("/latest") + "\">" + I18n.t("topic.view_latest_topics") + "</a>" },
            category = this.get('controller.content.category');

        if (category && Em.get(category, 'id') === Discourse.Site.currentProp("uncategorized_category_id")) {
          category = null;
        }

        if (category) {
          opts.catLink = categoryBadgeHTML(category);
        } else {
          opts.catLink = "<a href=\"" + Discourse.getURL("/categories") + "\">" + I18n.t("topic.browse_all_categories") + "</a>";
        }

        var tracking = this.get('topicTrackingState'),
            unreadTopics = tracking.countUnread(),
            newTopics = tracking.countNew();

        if (newTopics + unreadTopics > 0) {
          var hasBoth = unreadTopics > 0 && newTopics > 0;

          return I18n.messageFormat("topic.read_more_MF", {
            "BOTH": hasBoth,
            "UNREAD": unreadTopics,
            "NEW": newTopics,
            "CATEGORY": category ? true : false,
            latestLink: opts.latestLink,
            catLink: opts.catLink
          });
        } else if (category) {
          return I18n.t("topic.read_more_in_category", opts);
        } else {
          return I18n.t("topic.read_more", opts);
        }
      }).property('topicTrackingState.messageCount', 'controller.content.category')
    });

    function highlight(postNumber) {
      var $contents = $('#post_' + postNumber + ' .topic-body'),
          origColor = $contents.data('orig-color') || $contents.css('backgroundColor');

      $contents.data("orig-color", origColor).addClass('highlighted').stop().animate({ backgroundColor: origColor }, 2500, 'swing', function () {
        $contents.removeClass('highlighted');
        $contents.css({ 'background-color': '' });
      });
    }

    listenForViewEvent(TopicView, 'post:highlight', function (postNumber) {
      Ember.run.scheduleOnce('afterRender', null, highlight, postNumber);
    });

    __exports__["default"] = TopicView;
  });define("discourse/views/unknown", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      classNameBindings: [':container'],

      render: function (buffer) {
        buffer.push(this.get('controller.model'));
      }
    });
  });define("discourse/views/upload-customization", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/upload-customization',
      title: I18n.t('admin.customize.import_title')
    });
  });define("discourse/views/upload-selector", 
  ["discourse/views/modal-body","ember-addons/ember-computed-decorators","discourse/controllers/upload-selector","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalBodyView = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var observes = __dependency2__.observes;
    var uploadTranslate = __dependency3__.uploadTranslate;

    __exports__["default"] = ModalBodyView.extend(_createDecoratedObject([{
      key: 'templateName',
      initializer: function () {
        return 'modal/upload-selector';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['upload-selector'];
      }
    }, {
      key: 'title',
      decorators: [computed()],
      value: function () {
        return uploadTranslate("title");
      }
    }, {
      key: 'touchStart',
      value: function (evt) {
        // HACK: workaround Safari iOS being really weird and not shipping click events
        if (this.capabilities.isSafari && evt.target.id === "filename-input") {
          this.$('#filename-input').click();
        }
      }
    }, {
      key: 'selectedChanged',
      decorators: [observes('controller.local'), on('didInsertElement')],
      value: function () {
        var _this = this;

        Ember.run.next(function () {
          // *HACK* to select the proper radio button
          var value = _this.get('controller.local') ? 'local' : 'remote';
          $('input:radio[name="upload"]').val([value]);
          $('.inputs input:first').focus();
        });
      }
    }]));
  });define("discourse/views/user-activity-stream", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      loading: false,
      eyelineSelector: '.user-stream .item',
      classNames: ['user-stream'],

      _scrollTopOnModelChange: (function () {
        Em.run.schedule('afterRender', function () {
          $(document).scrollTop(0);
        });
      }).observes('controller.model.user.id'),

      actions: {
        loadMore: function () {
          var self = this;
          if (this.get('loading')) {
            return;
          }

          this.set('loading', true);
          var stream = this.get('controller.model');
          stream.findItems().then(function () {
            self.set('loading', false);
            self.get('eyeline').flushRest();
          });
        }
      }
    });
  });define("discourse/views/user-badges", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop);
  });define("discourse/views/user-card", 
  ["discourse/lib/computed","discourse/mixins/cleans-up","discourse/lib/after-transition","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var CleansUp = __dependency2__["default"];
    var afterTransition = __dependency3__["default"];

    var clickOutsideEventName = "mousedown.outside-user-card",
        clickDataExpand = "click.discourse-user-card",
        clickMention = "click.discourse-user-mention";

    __exports__["default"] = Ember.View.extend(CleansUp, {
      elementId: 'user-card',
      classNameBindings: ['controller.visible:show', 'controller.showBadges', 'controller.hasCardBadgeImage'],
      allowBackgrounds: setting('allow_profile_backgrounds'),

      addBackground: (function () {
        var url = this.get('controller.user.card_background');

        if (!this.get('allowBackgrounds')) {
          return;
        }

        var $this = this.$();
        if (!$this) {
          return;
        }

        if (Ember.isEmpty(url)) {
          $this.css('background-image', '').addClass('no-bg');
        } else {
          $this.css('background-image', "url(" + Discourse.getURLWithCDN(url) + ")").removeClass('no-bg');
        }
      }).observes('controller.user.card_background'),

      _setup: (function () {
        var _this = this;

        afterTransition(this.$(), this._hide.bind(this));

        $('html').off(clickOutsideEventName).on(clickOutsideEventName, function (e) {
          if (_this.get('controller.visible')) {
            var $target = $(e.target);
            if ($target.closest('[data-user-card]').data('userCard') || $target.closest('a.mention').length > 0 || $target.closest('#user-card').length > 0) {
              return;
            }

            _this.get('controller').close();
          }

          return true;
        });

        var expand = function (username, $target) {
          var postId = $target.parents('article').data('post-id'),
              user = _this.get('controller').show(username, postId, $target[0]);
          if (user !== undefined) {
            user.then(function () {
              return _this._willShow($target);
            }).catch(function () {
              return _this._hide();
            });
          } else {
            _this._hide();
          }
          return false;
        };

        $('#main-outlet').on(clickDataExpand, '[data-user-card]', function (e) {
          if (e.ctrlKey || e.metaKey) {
            return;
          }

          var $target = $(e.currentTarget),
              username = $target.data('user-card');
          return expand(username, $target);
        });

        $('#main-outlet').on(clickMention, 'a.mention', function (e) {
          if (e.ctrlKey || e.metaKey) {
            return;
          }

          var $target = $(e.target),
              username = $target.text().replace(/^@/, '');
          return expand(username, $target);
        });
        this.appEvents.on('usercard:shown', this, '_shown');
      }).on('didInsertElement'),

      _shown: function () {
        var _this2 = this;

        // After the card is shown, focus on the first link
        //
        // note: we DO NOT use afterRender here cause _willShow may
        //  run after _shown, if we allowed this to happen the usercard
        //  may be offscreen and we may scroll all the way to it on focus
        Ember.run.next(null, function () {
          return _this2.$('a:first').focus();
        });
      },

      _willShow: function (target) {
        var _this3 = this;

        var rtl = $('html').css('direction') === 'rtl';
        if (!target) {
          return;
        }
        var width = this.$().width();

        Ember.run.schedule('afterRender', function () {
          if (target) {
            var position = target.offset();
            if (position) {

              if (rtl) {
                // The site direction is rtl
                position.right = $(window).width() - position.left + 10;
                position.left = 'auto';
                var overage = $(window).width() - 50 - (position.right + width);
                if (overage < 0) {
                  position.right += overage;
                  position.top += target.height() + 48;
                }
              } else {
                // The site direction is ltr
                position.left += target.width() + 10;

                var overage = $(window).width() - 50 - (position.left + width);
                if (overage < 0) {
                  position.left += overage;
                  position.top += target.height() + 48;
                }
              }

              position.top -= $('#main-outlet').offset().top;
              _this3.$().css(position);
            }
            _this3.appEvents.trigger('usercard:shown');
          }
        });
      },

      _hide: function () {
        if (!this.get('controller.visible')) {
          this.$().css({ left: -9999, top: -9999 });
        }
      },

      cleanUp: function () {
        this.get('controller').close();
      },

      keyUp: function (e) {
        if (e.keyCode === 27) {
          // ESC
          var target = this.get('controller.cardTarget');
          this.cleanUp();
          target.focus();
        }
      },

      _removeEvents: (function () {
        $('html').off(clickOutsideEventName);

        $('#main').off(clickDataExpand).off(clickMention);

        this.appEvents.off('usercard:shown', this, '_shown');
      }).on('willDestroyElement')

    });
  });define("discourse/views/user-invited-show", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      classNames: ['paginated-topics-list'],
      eyelineSelector: '.paginated-topics-list .user-invite-list tr',
      templateName: 'user-invited-show'
    });
  });define("discourse/views/user-notifications", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      eyelineSelector: '.user-stream .notification',
      classNames: ['user-stream', 'notification-history']
    });
  });define("discourse/views/user-posts", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      loading: false,
      eyelineSelector: ".user-stream .item",
      classNames: ["user-stream"],

      actions: {
        loadMore: function () {
          var self = this;
          if (this.get("loading")) {
            return;
          }

          var postsStream = this.get("controller.model");
          postsStream.findItems().then(function () {
            self.set("loading", false);
            self.get("eyeline").flushRest();
          }).catch(function () {});
        }
      }
    });
  });define("discourse/views/user-stream", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      loading: false,
      eyelineSelector: '.user-stream .item',
      classNames: ['user-stream'],

      _scrollTopOnModelChange: (function () {
        Em.run.schedule('afterRender', function () {
          $(document).scrollTop(0);
        });
      }).observes('controller.model.user.id'),

      actions: {
        loadMore: function () {
          var self = this;
          if (this.get('loading')) {
            return;
          }

          this.set('loading', true);
          var stream = this.get('controller.model');
          stream.findItems().then(function () {
            self.set('loading', false);
            self.get('eyeline').flushRest();
          });
        }
      }
    });
  });define("discourse/views/user-topics-list", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      classNames: ['paginated-topics-list'],
      eyelineSelector: '.paginated-topics-list .topic-list tr'
    });
  });define("discourse/views/user", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, {
      templateName: 'user/user',
      userBinding: 'controller.content'
    });
  });define("discourse/views/users", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(LoadMore, {
      eyelineSelector: '.directory tbody tr'
    });
  });define("discourse/helpers/application", 
  ["discourse/helpers/register-unbound","discourse/lib/formatter"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];
    var longDate = __dependency2__.longDate;
    var autoUpdatingRelativeAge = __dependency2__.autoUpdatingRelativeAge;
    var number = __dependency2__.number;

    var safe = Handlebars.SafeString;

    Em.Handlebars.helper('bound-avatar', function (user, size) {
      if (Em.isEmpty(user)) {
        return new safe("<div class='avatar-placeholder'></div>");
      }

      var avatar = Em.get(user, 'avatar_template');
      return new safe(Discourse.Utilities.avatarImg({ size: size, avatarTemplate: avatar }));
    }, 'username', 'avatar_template');

    /*
     * Used when we only have a template
     */
    Em.Handlebars.helper('bound-avatar-template', function (at, size) {
      return new safe(Discourse.Utilities.avatarImg({ size: size, avatarTemplate: at }));
    });

    registerUnbound('raw-date', function (dt) {
      return longDate(new Date(dt));
    });

    registerUnbound('age-with-tooltip', function (dt) {
      return new safe(autoUpdatingRelativeAge(new Date(dt), { title: true }));
    });

    registerUnbound('number', function (orig, params) {
      orig = parseInt(orig, 10);
      if (isNaN(orig)) {
        orig = 0;
      }

      var title = orig;
      if (params.numberKey) {
        title = I18n.t(params.numberKey, { number: orig });
      }

      var classNames = 'number';
      if (params['class']) {
        classNames += ' ' + params['class'];
      }
      var result = "<span class='" + classNames + "'";

      // Round off the thousands to one decimal place
      var n = number(orig);
      if (n !== title) {
        result += " title='" + Handlebars.Utils.escapeExpression(title) + "'";
      }
      result += ">" + n + "</span>";

      return new safe(result);
    });
  });define("discourse/helpers/border-color", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (value) {
      return ("border-color: #" + value).htmlSafe();
    });
  });define("discourse/helpers/bound-date", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var autoUpdatingRelativeAge = __dependency1__.autoUpdatingRelativeAge;

    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (dt) {
      return new Handlebars.SafeString(autoUpdatingRelativeAge(new Date(dt), { format: 'medium', title: true }));
    });
  });define("discourse/helpers/bound-i18n", 
  [],
  function() {
    "use strict";
    Ember.Handlebars.registerBoundHelper("boundI18n", function (property, options) {
      return new Handlebars.SafeString(I18n.t(property, options.hash));
    });
  });define("discourse/helpers/category-badge", 
  ["discourse/helpers/category-link","discourse/helpers/register-unbound"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var categoryLinkHTML = __dependency1__.categoryLinkHTML;
    var registerUnbound = __dependency2__["default"];

    registerUnbound('category-badge', function (cat, options) {
      options.link = false;
      return categoryLinkHTML(cat, options);
    });
  });define("discourse/helpers/cook-text", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('cook-text', function (text) {
      return new Handlebars.SafeString(Discourse.Markdown.cook(text, { sanitize: true }));
    });
  });define("discourse/helpers/custom-html", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.getCustomHTML = getCustomHTML;
    __exports__.setCustomHTML = setCustomHTML;
    var _customizations = {};

    function getCustomHTML(key) {
      var c = _customizations[key];
      if (c) {
        return new Handlebars.SafeString(c);
      }

      var html = PreloadStore.get("customHTML");
      if (html && html[key] && html[key].length) {
        return new Handlebars.SafeString(html[key]);
      }
    }

    // Set a fragment of HTML by key. It can then be looked up with `getCustomHTML(key)`.

    function setCustomHTML(key, html) {
      _customizations[key] = html;
    }

    Ember.HTMLBars._registerHelper('custom-html', function (params, hash, options, env) {
      var name = params[0];
      var html = getCustomHTML(name);
      if (html) {
        return html;
      }

      var contextString = params[1];
      var container = (env || contextString).data.view.container;
      if (container.lookup('template:' + name)) {
        return env.helpers.partial.helperFunction.apply(this, arguments);
      }
    });
  });define("discourse/helpers/dash-if-empty", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (str) {
      return Ember.isEmpty(str) ? new Handlebars.SafeString('&mdash;') : str;
    });
  });define("discourse/helpers/format-age", 
  ["discourse/lib/formatter","discourse/helpers/register-unbound"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var autoUpdatingRelativeAge = __dependency1__.autoUpdatingRelativeAge;
    var registerUnbound = __dependency2__["default"];

    registerUnbound('format-age', function (dt) {
      dt = new Date(dt);
      return new Handlebars.SafeString(autoUpdatingRelativeAge(dt));
    });
  });define("discourse/helpers/format-date", 
  ["discourse/helpers/register-unbound","discourse/lib/formatter"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];
    var autoUpdatingRelativeAge = __dependency2__.autoUpdatingRelativeAge;

    /**
      Display logic for dates. It is unbound in Ember but will use jQuery to
      update the dates on a regular interval.
    **/
    registerUnbound('format-date', function (val, params) {
      var leaveAgo,
          format = 'medium',
          title = true;

      if (params.leaveAgo) {
        leaveAgo = params.leaveAgo === "true";
      }
      if (params.format) {
        format = params.format;
      }
      if (params.noTitle) {
        title = false;
      }

      if (val) {
        var date = new Date(val);
        return new Handlebars.SafeString(autoUpdatingRelativeAge(date, { format: format, title: title, leaveAgo: leaveAgo }));
      }
    });
  });define("discourse/helpers/icon-or-image", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (str) {
      if (Ember.isEmpty(str)) {
        return "";
      }

      if (str.indexOf('fa-') === 0) {
        return new Handlebars.SafeString("<i class='fa " + str + "'></i>");
      } else {
        return new Handlebars.SafeString("<img src='" + str + "'>");
      }
    });
  });define("discourse/helpers/link-domain", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('link-domain', function (link) {
      if (link) {
        var hasTitle = !Ember.isEmpty(Em.get(link, 'title'));

        if (hasTitle) {
          var domain = Ember.get(link, 'domain');
          if (!Ember.isEmpty(domain)) {
            var s = domain.split('.');
            domain = s[s.length - 2] + "." + s[s.length - 1];
            return new Handlebars.SafeString("<span class='domain'>" + domain + "</span>");
          }
        }
      }
    });
  });define("discourse/helpers/max-usernames", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('max-usernames', function (usernames, params) {
      var maxLength = parseInt(params.max) || 3;
      if (usernames.length > maxLength) {
        return usernames.slice(0, maxLength).join(", ") + ", +" + (usernames.length - maxLength);
      } else {
        return usernames.join(", ");
      }
    });
  });define("discourse/helpers/period-title", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var TITLE_SUBS = {
      all: 'all_time',
      yearly: 'this_year',
      quarterly: 'this_quarter',
      monthly: 'this_month',
      daily: 'today'
    };

    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (period, options) {
      var title = I18n.t('filters.top.' + (TITLE_SUBS[period] || 'this_week'));
      if (options.hash.showDateRange) {
        var dateString = "";
        switch (period) {
          case 'yearly':
            dateString = moment().subtract(1, 'year').format(I18n.t('dates.long_with_year_no_time')) + " - " + moment().format(I18n.t('dates.long_with_year_no_time'));
            break;
          case 'quarterly':
            dateString = moment().subtract(3, 'month').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'weekly':
            dateString = moment().subtract(1, 'week').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'monthly':
            dateString = moment().subtract(1, 'month').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'daily':
            dateString = moment().format(I18n.t('dates.full_no_year_no_time'));
            break;
        }
        return new Handlebars.SafeString(title + " <span class='top-date-string'>" + dateString + "</span>");
      } else {
        return new Handlebars.SafeString(title);
      }
    });
  });define("discourse/helpers/plugin-outlet", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.rewire = rewire;
    /**
       A plugin outlet is an extension point for templates where other templates can
       be inserted by plugins.

       ## Usage

       If your handlebars template has:

       ```handlebars
         {{plugin-outlet "evil-trout"}}
       ```

       Then any handlebars files you create in the `connectors/evil-trout` directory
       will automatically be appended. For example:

       plugins/hello/assets/javascripts/discourse/templates/connectors/evil-trout/hello.hbs

       With the contents:

       ```handlebars
         <b>Hello World</b>
       ```

       Will insert <b>Hello World</b> at that point in the template.

       Optionally you can also define a view class for the outlet as:

       plugins/hello/assets/javascripts/discourse/views/connectors/evil-trout/hello.js.es6

       And it will be wired up automatically.

       ## The block form

       If you use the block form of the outlet, its contents will be displayed
       if no connectors are found. Example:

       ```handlebars
         {{#plugin-outlet "hello-world"}}
           Nobody says hello :'(
         {{/plugin-outlet}}
       ```

       ## Disabling

       If a plugin returns a disabled status, the outlets will not be wired up for it.
       The list of disabled plugins is returned via the `Site` singleton.

    **/

    // TODO: Add all plugin-outlet names dynamically
    var rewireableOutlets = ['hamburger-admin'];

    var _rewires = {};

    var _connectorCache = undefined,
        _rawCache = undefined;

    function findOutlets(collection, callback) {

      var disabledPlugins = Discourse.Site.currentProp('disabled_plugins') || [];

      Ember.keys(collection).forEach(function (res) {
        if (res.indexOf("/connectors/") !== -1) {
          // Skip any disabled plugins
          for (var i = 0; i < disabledPlugins.length; i++) {
            if (res.indexOf("/" + disabledPlugins[i] + "/") !== -1) {
              return;
            }
          }

          var segments = res.split("/");
          var outletName = segments[segments.length - 2];
          var uniqueName = segments[segments.length - 1];

          var outletRewires = _rewires[outletName];
          if (outletRewires) {
            var newOutlet = outletRewires[uniqueName];
            if (newOutlet) {
              outletName = newOutlet;
            }
          }

          callback(outletName, res, uniqueName);
        }
      });
    }

    function buildConnectorCache() {
      _connectorCache = {};
      _rawCache = {};

      var uniqueViews = {};
      findOutlets(requirejs._eak_seen, function (outletName, resource, uniqueName) {
        _connectorCache[outletName] = _connectorCache[outletName] || [];

        var viewClass = require(resource, null, null, true).default;
        uniqueViews[uniqueName] = viewClass;
        _connectorCache[outletName].pushObject(viewClass);
      });

      findOutlets(Ember.TEMPLATES, function (outletName, resource, uniqueName) {
        _connectorCache[outletName] = _connectorCache[outletName] || [];

        var mixin = { templateName: resource.replace('javascripts/', '') };
        var viewClass = uniqueViews[uniqueName];

        if (viewClass) {
          // We are going to add it back with the proper template
          _connectorCache[outletName].removeObject(viewClass);
        } else {
          if (!/\.raw$/.test(uniqueName)) {
            viewClass = Em.View.extend({ classNames: [outletName + '-outlet', uniqueName] });
          }
        }

        if (viewClass) {
          _connectorCache[outletName].pushObject(viewClass.extend(mixin));
        } else {
          // we have a raw template
          if (!_rawCache[outletName]) {
            _rawCache[outletName] = [];
          }

          _rawCache[outletName].push(Ember.TEMPLATES[resource]);
        }
      });
    }

    var _viewInjections;
    function viewInjections(container) {
      if (_viewInjections) {
        return _viewInjections;
      }

      var injections = container._registry.getTypeInjections('view');

      _viewInjections = {};
      injections.forEach(function (i) {
        _viewInjections[i.property] = container.lookup(i.fullName);
      });

      return _viewInjections;
    }

    // unbound version of outlets, only has a template
    Handlebars.registerHelper('plugin-outlet', function (name) {

      if (!_rawCache) {
        buildConnectorCache();
      }

      var functions = _rawCache[name];
      if (functions) {
        var output = [];

        for (var i = 0; i < functions.length; i++) {
          output.push(functions[i]({ context: this }));
        }

        return new Handlebars.SafeString(output.join(""));
      }
    });

    Ember.HTMLBars._registerHelper('plugin-outlet', function (params, hash, options, env) {
      var connectionName = params[0];

      if (!_connectorCache) {
        buildConnectorCache();
      }

      if (_connectorCache[connectionName]) {
        var childViews = _connectorCache[connectionName];

        // If there is more than one view, create a container. Otherwise
        // just shove it in.
        var viewClass = childViews.length > 1 ? Ember.ContainerView : childViews[0];

        delete options.fn; // we don't need the default template since we have a connector
        env.helpers.view.helperFunction.call(this, [viewClass], viewInjections(env.data.view.container), options, env);

        var cvs = env.data.view._childViews;
        if (childViews.length > 1 && cvs && cvs.length) {
          (function () {
            var inserted = cvs[cvs.length - 1];
            if (inserted) {
              childViews.forEach(function (cv) {
                inserted.pushObject(cv.create());
              });
            }
          })();
        }
      }
    });

    // Allow plugins to rewire outlets to new outlets if they exist. For example, the akismet
    // plugin will use `hamburger-admin` if it exists, otherwise `site-menu-links`

    function rewire(uniqueName, outlet, wantedOutlet) {
      if (rewireableOutlets.indexOf(wantedOutlet) !== -1) {
        _rewires[outlet] = _rewires[outlet] || {};
        _rewires[outlet][uniqueName] = wantedOutlet;
      }
    }
  });define("discourse/helpers/raw", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    // see: https://github.com/emberjs/ember.js/issues/12634
    var missingViews = {};

    function renderRaw(ctx, template, templateName, params) {
      params.parent = params.parent || ctx;

      if (!params.view && !missingViews[templateName]) {
        var viewClass = Discourse.__container__.lookupFactory('view:' + templateName);
        if (viewClass) {
          params.view = viewClass.create(params);
        } else {
          missingViews[templateName] = true;
        }
      }

      return new Handlebars.SafeString(template(params));
    }

    registerUnbound('raw', function (templateName, params) {
      var template = Discourse.__container__.lookup('template:' + templateName + '.raw');
      if (!template) {
        Ember.warn('Could not find raw template: ' + templateName);
        return;
      }

      return renderRaw(this, template, templateName, params);
    });
  });define("discourse/helpers/shorten-url", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('shorten-url', function (url) {
      var matches = url.match(/\//g);

      if (matches && matches.length === 3) {
        url = url.replace(/\/$/, '');
      }
      url = url.replace(/^https?:\/\//, '');
      url = url.replace(/^www\./, '');
      return url.substring(0, 80);
    });
  });define("discourse/helpers/topic-link", 
  ["discourse/helpers/register-unbound"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__["default"];

    registerUnbound('topic-link', function (topic) {
      var title = topic.get('fancyTitle');
      var url = topic.linked_post_number ? topic.urlForPostNumber(topic.linked_post_number) : topic.get('lastUnreadUrl');

      var extraClass = topic.get('last_read_post_number') === topic.get('highest_post_number') ? " visited" : "";
      var string = "<a href='" + url + "' class='title" + extraClass + "'>" + title + "</a>";

      return new Handlebars.SafeString(string);
    });
  });define("discourse/helpers/user-status", 
  ["discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;

    var Safe = Handlebars.SafeString;

    __exports__["default"] = Ember.Handlebars.makeBoundHelper(function (user, args) {
      if (!user) {
        return;
      }

      var name = Discourse.Utilities.escapeExpression(user.get('name'));
      var currentUser = args.hash.currentUser;

      if (currentUser && user.get('admin') && currentUser.get('staff')) {
        return new Safe(iconHTML('shield', { label: I18n.t('user.admin', { user: name }) }));
      }
      if (user.get('moderator')) {
        return new Safe(iconHTML('shield', { label: I18n.t('user.moderator', { user: name }) }));
      }
    });
  });Ember.TEMPLATES["about"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["about.simple_title"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["guidelines"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["faq"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-guidelines");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-faq");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
        block(env, morph0, context, "link-to", ["guidelines"], {}, child0, null);
        block(env, morph1, context, "link-to", ["faq"], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["faq"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-faq");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        block(env, morph0, context, "link-to", ["faq"], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["terms_of_service"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["privacy"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "user-small", [], {"user": get(env, context, "a")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about admins");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
        var morph1 = dom.createMorphAt(element2,3,3);
        inline(env, morph0, context, "i18n", ["about.our_admins"], {});
        block(env, morph1, context, "each", [get(env, context, "model.admins")], {"keyword": "a"}, child0, null);
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "user-small", [], {"user": get(env, context, "m")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about moderators");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","users");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        inline(env, morph0, context, "i18n", ["about.our_moderators"], {});
        block(env, morph1, context, "each", [get(env, context, "model.moderators")], {"keyword": "m"}, child0, null);
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about contact");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("p");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),0,0);
        inline(env, morph0, context, "i18n", ["about.contact"], {});
        content(env, morph1, context, "contactInfo");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","contents clearfix body-page");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("ul");
      dom.setAttribute(el3,"class","nav-pills");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-about");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-tos");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-privacy");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","about");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h2");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","about stats");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h3");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("table");
      dom.setAttribute(el4,"class","table");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createTextNode(" ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      dom.setAttribute(el6,"class","title");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createTextNode("—");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0, 1]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element3, [3]);
      var element6 = dom.childAt(element3, [9]);
      var element7 = dom.childAt(element6, [3]);
      var element8 = dom.childAt(element7, [1]);
      var element9 = dom.childAt(element7, [3]);
      var element10 = dom.childAt(element7, [5]);
      var element11 = dom.childAt(element7, [7]);
      var element12 = dom.childAt(element7, [9]);
      var element13 = dom.childAt(element7, [11]);
      var morph0 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element4, [5]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element4, [7]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
      var morph5 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
      var morph6 = dom.createMorphAt(element3,5,5);
      var morph7 = dom.createMorphAt(element3,7,7);
      var morph8 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
      var morph9 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
      var morph10 = dom.createMorphAt(dom.childAt(element8, [5]),0,0);
      var morph11 = dom.createMorphAt(dom.childAt(element8, [7]),0,0);
      var morph12 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
      var morph13 = dom.createMorphAt(dom.childAt(element9, [3]),0,0);
      var morph14 = dom.createMorphAt(dom.childAt(element9, [5]),0,0);
      var morph15 = dom.createMorphAt(dom.childAt(element9, [7]),0,0);
      var morph16 = dom.createMorphAt(dom.childAt(element10, [1]),0,0);
      var morph17 = dom.createMorphAt(dom.childAt(element10, [3]),0,0);
      var morph18 = dom.createMorphAt(dom.childAt(element10, [5]),0,0);
      var morph19 = dom.createMorphAt(dom.childAt(element10, [7]),0,0);
      var morph20 = dom.createMorphAt(dom.childAt(element11, [1]),0,0);
      var morph21 = dom.createMorphAt(dom.childAt(element11, [3]),0,0);
      var morph22 = dom.createMorphAt(dom.childAt(element11, [5]),0,0);
      var morph23 = dom.createMorphAt(dom.childAt(element11, [7]),0,0);
      var morph24 = dom.createMorphAt(dom.childAt(element12, [1]),0,0);
      var morph25 = dom.createMorphAt(dom.childAt(element12, [5]),0,0);
      var morph26 = dom.createMorphAt(dom.childAt(element12, [7]),0,0);
      var morph27 = dom.createMorphAt(dom.childAt(element13, [1]),0,0);
      var morph28 = dom.createMorphAt(dom.childAt(element13, [3]),0,0);
      var morph29 = dom.createMorphAt(dom.childAt(element13, [5]),0,0);
      var morph30 = dom.createMorphAt(dom.childAt(element13, [7]),0,0);
      var morph31 = dom.createMorphAt(element3,11,11);
      block(env, morph0, context, "link-to", ["about"], {"class": "active"}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "faqOverriden")], {}, child1, child2);
      block(env, morph2, context, "link-to", ["tos"], {}, child3, null);
      block(env, morph3, context, "link-to", ["privacy"], {}, child4, null);
      inline(env, morph4, context, "i18n", ["about.title"], {"title": get(env, context, "model.title")});
      content(env, morph5, context, "model.description");
      block(env, morph6, context, "if", [get(env, context, "model.admins")], {}, child5, null);
      block(env, morph7, context, "if", [get(env, context, "model.moderators")], {}, child6, null);
      inline(env, morph8, context, "i18n", ["about.stats"], {});
      inline(env, morph9, context, "i18n", ["about.stat.all_time"], {});
      inline(env, morph10, context, "i18n", ["about.stat.last_7_days"], {});
      inline(env, morph11, context, "i18n", ["about.stat.last_30_days"], {});
      inline(env, morph12, context, "i18n", ["about.topic_count"], {});
      inline(env, morph13, context, "number", [get(env, context, "model.stats.topic_count")], {});
      inline(env, morph14, context, "number", [get(env, context, "model.stats.topics_7_days")], {});
      inline(env, morph15, context, "number", [get(env, context, "model.stats.topics_30_days")], {});
      inline(env, morph16, context, "i18n", ["about.post_count"], {});
      inline(env, morph17, context, "number", [get(env, context, "model.stats.post_count")], {});
      inline(env, morph18, context, "number", [get(env, context, "model.stats.posts_7_days")], {});
      inline(env, morph19, context, "number", [get(env, context, "model.stats.posts_30_days")], {});
      inline(env, morph20, context, "i18n", ["about.user_count"], {});
      inline(env, morph21, context, "number", [get(env, context, "model.stats.user_count")], {});
      inline(env, morph22, context, "number", [get(env, context, "model.stats.users_7_days")], {});
      inline(env, morph23, context, "number", [get(env, context, "model.stats.users_30_days")], {});
      inline(env, morph24, context, "i18n", ["about.active_user_count"], {});
      inline(env, morph25, context, "number", [get(env, context, "model.stats.active_users_7_days")], {});
      inline(env, morph26, context, "number", [get(env, context, "model.stats.active_users_30_days")], {});
      inline(env, morph27, context, "i18n", ["about.like_count"], {});
      inline(env, morph28, context, "number", [get(env, context, "model.stats.like_count")], {});
      inline(env, morph29, context, "number", [get(env, context, "model.stats.likes_7_days")], {});
      inline(env, morph30, context, "number", [get(env, context, "model.stats.likes_30_days")], {});
      block(env, morph31, context, "if", [get(env, context, "contactInfo")], {}, child7, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["additional-composer-buttons"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["application"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "custom-html", ["top"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "custom-html", ["footer"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","main-outlet");
      dom.setAttribute(el1,"class","wrap");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","container");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var element1 = dom.childAt(element0, [1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element1,3,3);
      var morph3 = dom.createMorphAt(element1,5,5);
      var morph4 = dom.createMorphAt(element0,3,3);
      var morph5 = dom.createMorphAt(element0,5,5);
      var morph6 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph7 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph8 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph9 = dom.createMorphAt(fragment,10,10,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "render", ["header"], {});
      block(env, morph1, context, "if", [get(env, context, "showTop")], {}, child0, null);
      content(env, morph2, context, "global-notice");
      content(env, morph3, context, "create-topics-notice");
      content(env, morph4, context, "outlet");
      inline(env, morph5, context, "render", ["user-card"], {});
      block(env, morph6, context, "if", [get(env, context, "showFooter")], {}, child1, null);
      inline(env, morph7, context, "render", ["modal"], {});
      inline(env, morph8, context, "render", ["topic-entrance"], {});
      inline(env, morph9, context, "render", ["composer"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["badges/index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("i");
            dom.setAttribute(el1,"class","fa fa-check");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","granted");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","badge");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","description");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","grant-count");
          var el3 = dom.createElement("span");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, content = hooks.content, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var element1 = dom.childAt(element0, [7, 0]);
          var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
          var morph2 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
          var morph3 = dom.createMorphAt(element1,0,0);
          var attrMorph0 = dom.createAttrMorph(element1, 'title');
          block(env, morph0, context, "if", [get(env, context, "b.has_badge")], {}, child0, null);
          inline(env, morph1, context, "user-badge", [], {"badge": get(env, context, "b")});
          content(env, morph2, context, "b.displayDescriptionHtml");
          attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["badges.granted"], {"count": get(env, context, "b.grant_count")})]));
          content(env, morph3, context, "b.grant_count");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("tr");
        dom.setAttribute(el1,"class","title");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        dom.setAttribute(el2,"colspan","4");
        var el3 = dom.createElement("h3");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 0]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        content(env, morph0, context, "bg.badgeGrouping.displayName");
        block(env, morph1, context, "each", [get(env, context, "bg.badges")], {"keyword": "b"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container badges");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h1");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("table");
      dom.setAttribute(el2,"class","badges-listing");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("tbody");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element2, [3, 1]),1,1);
      inline(env, morph0, context, "i18n", ["badges.title"], {});
      block(env, morph1, context, "each", [get(env, context, "badgeGroups")], {"keyword": "bg"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["badges/show"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["badges.title"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","long-description banner");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
        content(env, morph0, context, "long_description");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","details");
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","username");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [3]);
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
            var morph2 = dom.createMorphAt(element1,3,3);
            inline(env, morph0, context, "avatar", [get(env, context, "ub.user")], {"imageSize": "large"});
            content(env, morph1, context, "ub.user.username");
            inline(env, morph2, context, "format-date", [get(env, context, "ub.granted_at")], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"class","post-link");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createUnsafeMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "ub.topic.url")], {}), "/", subexpr(env, context, "unbound", [get(env, context, "ub.post_number")], {})]));
            content(env, morph0, context, "ub.topic.fancyTitle");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","badge-user");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,1,1);
          var morph1 = dom.createMorphAt(element2,3,3);
          block(env, morph0, context, "link-to", ["user", get(env, context, "ub.user")], {"classNames": "badge-info"}, child0, null);
          block(env, morph1, context, "if", [get(env, context, "ub.post_number")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, attribute = hooks.attribute, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var attrMorph0 = dom.createAttrMorph(element3, 'class');
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        attribute(env, attrMorph0, element3, "class", subexpr(env, context, "unbound", [get(env, context, "layoutClass")], {}));
        block(env, morph0, context, "each", [get(env, context, "userBadges")], {"keyword": "ub"}, child0, null);
        inline(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "canLoadMore")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container show-badge");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h1");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","badges-listing");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","row");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","badge");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","description");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","grant-count");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","info");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("br");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block, inline = hooks.inline, content = hooks.content, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element4, [3, 1]);
      var element7 = dom.childAt(element6, [7]);
      var morph0 = dom.createMorphAt(element5,1,1);
      var morph1 = dom.createMorphAt(element5,3,3);
      var morph2 = dom.createMorphAt(element5,5,5);
      var morph3 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element6, [3]),0,0);
      var morph5 = dom.createMorphAt(dom.childAt(element6, [5]),0,0);
      var morph6 = dom.createMorphAt(element7,0,0);
      var morph7 = dom.createUnsafeMorphAt(element7,2,2);
      var morph8 = dom.createMorphAt(element7,4,4);
      var morph9 = dom.createUnsafeMorphAt(element7,6,6);
      var morph10 = dom.createMorphAt(element4,5,5);
      var morph11 = dom.createMorphAt(element4,7,7);
      block(env, morph0, context, "link-to", ["badges.index"], {}, child0, null);
      inline(env, morph1, context, "fa-icon", ["angle-right"], {});
      content(env, morph2, context, "model.displayName");
      inline(env, morph3, context, "user-badge", [], {"badge": get(env, context, "model")});
      content(env, morph4, context, "model.displayDescriptionHtml");
      inline(env, morph5, context, "i18n", ["badges.granted"], {"count": get(env, context, "model.grant_count")});
      inline(env, morph6, context, "i18n", ["badges.allow_title"], {});
      content(env, morph7, context, "view.allowTitle");
      inline(env, morph8, context, "i18n", ["badges.multiple_grant"], {});
      content(env, morph9, context, "view.multipleGrant");
      block(env, morph10, context, "if", [get(env, context, "showLongDescription")], {}, child1, null);
      block(env, morph11, context, "if", [get(env, context, "userBadges")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["category-group-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "      <li><a>"
    + escapeExpression(((helpers['category-link'] || (depth0 && depth0['category-link']) || helperMissing).call(depth0, "option", {"name":"category-link","hash":{
    'link': ("false"),
    'allowUncategorized': ("true")
  },"hashTypes":{'link': "STRING",'allowUncategorized': "STRING"},"hashContexts":{'link': depth0,'allowUncategorized': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a></li>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='autocomplete'>\n  <ul>\n";
  stack1 = helpers.each.call(depth0, "option", "in", "options", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["choose_topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["loading"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "bound-category-link", [get(env, context, "t.category.parentCategory")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","controls");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("label");
            dom.setAttribute(el2,"class","radio");
            var el3 = dom.createTextNode("\n        ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("input");
            dom.setAttribute(el3,"type","radio");
            dom.setAttribute(el3,"name","choose_topic_id");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("        ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n        ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var element1 = dom.childAt(element0, [1]);
            var attrMorph0 = dom.createAttrMorph(element1, 'id');
            var morph0 = dom.createMorphAt(element0,2,2);
            var morph1 = dom.createMorphAt(element0,4,4);
            var morph2 = dom.createMorphAt(element0,6,6);
            attribute(env, attrMorph0, element1, "id", concat(env, ["choose-topic-", subexpr(env, context, "unbound", [get(env, context, "t.id")], {})]));
            element(env, element1, context, "action", ["chooseTopic", get(env, context, "t")], {"target": "view"});
            content(env, morph0, context, "t.title");
            block(env, morph1, context, "if", [get(env, context, "t.category.parentCategory")], {}, child0, null);
            inline(env, morph2, context, "bound-category-link", [get(env, context, "t.category")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "each", [get(env, context, "view.topics")], {"keyword": "t"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "view.noResults")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"for","choose-topic-title");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "i18n", ["choose_topic.title.search"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "view.topicTitle"), "placeholderKey": "choose_topic.title.placeholder", "id": "choose-topic-title"});
      block(env, morph2, context, "if", [get(env, context, "view.loading")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/admin-group-selector"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"type","text");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/auto-close-form"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","auto-close-fields");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","examples");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1, 1]);
      var element2 = dom.childAt(element0, [5, 1]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element1,5,5);
      var morph3 = dom.createMorphAt(element1,7,7);
      var morph4 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph5 = dom.createMorphAt(element2,1,1);
      var morph6 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "fa-icon", ["clock-o"], {});
      inline(env, morph1, context, "i18n", ["composer.auto_close.label"], {});
      inline(env, morph2, context, "text-field", [], {"value": get(env, context, "autoCloseTime")});
      content(env, morph3, context, "autoCloseUnits");
      content(env, morph4, context, "autoCloseExamples");
      inline(env, morph5, context, "input", [], {"type": "checkbox", "checked": get(env, context, "autoCloseBasedOnLastPost")});
      inline(env, morph6, context, "i18n", ["composer.auto_close.based_on_last_post"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/avatar-uploader"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("%");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(element0,2,2);
        inline(env, morph0, context, "i18n", ["upload_selector.uploading"], {});
        content(env, morph1, context, "view.uploadProgress");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_avatar.image_is_not_a_square"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"class","btn");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode(" ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","file");
      dom.setAttribute(el2,"accept","image/*");
      dom.setAttribute(el2,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [5]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var attrMorph0 = dom.createAttrMorph(element1, 'title');
      var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
      dom.insertBoundary(fragment, null);
      attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["user.change_avatar.upload_title"], {})]));
      element(env, element1, context, "bind-attr", [], {"disabled": "uploading"});
      inline(env, morph0, context, "fa-icon", ["picture-o"], {});
      content(env, morph1, context, "uploadButtonText");
      element(env, element2, context, "bind-attr", [], {"disabled": "uploading"});
      block(env, morph2, context, "if", [get(env, context, "uploading")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "imageIsNotASquare")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/badge-button"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","badge-display-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "icon-or-image", [get(env, context, "badge.icon")], {});
      content(env, morph1, context, "badge.displayName");
      content(env, morph2, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/basic-topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "topic-list", [], {"showParticipants": get(env, context, "showParticipants"), "hideCategory": get(env, context, "hideCategory"), "topics": get(env, context, "topics"), "expandExcerpts": get(env, context, "expandExcerpts")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","alert alert-info");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topics")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/bread-crumbs"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "category-drop", [], {"category": get(env, context, "secondCategory"), "parentCategory": get(env, context, "firstCategory"), "categories": get(env, context, "childCategories"), "subCategory": "true", "noSubcategories": get(env, context, "noSubcategories")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clear");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "category-drop", [], {"category": get(env, context, "firstCategory"), "categories": get(env, context, "parentCategories")});
      block(env, morph1, context, "if", [get(env, context, "childCategories")], {}, child0, null);
      inline(env, morph2, context, "plugin-outlet", ["bread-crumbs-right"], {"tagName": "li"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/bulk-select-button"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"id","bulk-select");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "showBulkActions", "icon": "wrench"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "selected")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-drop"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "fa-icon", ["lock"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","badge-category");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","badge-category-bg");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var element8 = dom.childAt(element7, [1]);
        var attrMorph0 = dom.createAttrMorph(element7, 'style');
        var attrMorph1 = dom.createAttrMorph(element8, 'style');
        var morph0 = dom.createMorphAt(element7,3,3);
        var morph1 = dom.createMorphAt(element7,5,5);
        attribute(env, attrMorph0, element7, "style", get(env, context, "badgeStyle"));
        element(env, element7, context, "action", ["expand"], {});
        attribute(env, attrMorph1, element8, "style", get(env, context, "categoryColor"));
        block(env, morph0, context, "if", [get(env, context, "category.read_restricted")], {}, child0, null);
        content(env, morph1, context, "category.name");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","badge-category home");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element6,0,0);
          var attrMorph0 = dom.createAttrMorph(element6, 'style');
          attribute(env, attrMorph0, element6, "style", get(env, context, "badgeStyle"));
          element(env, element6, context, "action", ["expand"], {});
          inline(env, morph0, context, "i18n", ["categories.no_subcategory"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","badge-category home");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'style');
          attribute(env, attrMorph0, element5, "style", get(env, context, "badgeStyle"));
          element(env, element5, context, "action", ["expand"], {});
          content(env, morph0, context, "allCategoriesLabel");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "noSubcategories")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","cat");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"data-drop-close","true");
          dom.setAttribute(el2,"class","badge-category home");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "bind-attr", [], {"href": get(env, context, "noCategoriesUrl")});
          inline(env, morph0, context, "i18n", ["categories.no_subcategory"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","cat");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            inline(env, morph0, context, "category-link", [get(env, context, "c")], {"allowUncategorized": true, "hideParent": get(env, context, "subCategory")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "each", [get(env, context, "categories")], {"keyword": "c"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        var el2 = dom.createElement("i");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","cat");
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"data-drop-close","true");
        dom.setAttribute(el3,"class","badge-category home");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [0]);
        var element3 = dom.childAt(fragment, [3]);
        var element4 = dom.childAt(element3, [1, 0]);
        var attrMorph0 = dom.createAttrMorph(element1, 'class');
        var attrMorph1 = dom.createAttrMorph(element1, 'style');
        var attrMorph2 = dom.createAttrMorph(element2, 'class');
        var morph0 = dom.createMorphAt(element4,0,0);
        var morph1 = dom.createMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(element3,4,4);
        attribute(env, attrMorph0, element1, "class", get(env, context, "dropdownButtonClass"));
        attribute(env, attrMorph1, element1, "style", get(env, context, "badgeStyle"));
        element(env, element1, context, "action", ["expand"], {});
        attribute(env, attrMorph2, element2, "class", get(env, context, "iconClass"));
        element(env, element3, context, "bind-attr", [], {"class": "expanded::hidden :category-dropdown-menu :chooser"});
        element(env, element4, context, "bind-attr", [], {"href": get(env, context, "allCategoriesUrl")});
        content(env, morph0, context, "allCategoriesLabel");
        block(env, morph1, context, "if", [get(env, context, "subCategory")], {}, child0, null);
        block(env, morph2, context, "if", [get(env, context, "renderCategories")], {}, child1, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "category")], {}, child0, child1);
      block(env, morph1, context, "if", [get(env, context, "categories")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-group"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"class","category-group");
      dom.setAttribute(el1,"type","text");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-unread"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","badge new-posts badge-notification");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,0,0);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var attrMorph1 = dom.createAttrMorph(element1, 'title');
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "category.unreadUrl")], {})]));
        attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "i18n", ["topic.unread_topics"], {"count": get(env, context, "category.unreadTopics")})]));
        inline(env, morph0, context, "i18n", ["filters.unread.lower_title_with_count"], {"count": get(env, context, "category.unreadTopics")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","badge new-posts badge-notification");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "category.newUrl")], {})]));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["topic.new_topics"], {"count": get(env, context, "category.newTopics")})]));
        inline(env, morph0, context, "i18n", ["filters.new.lower_title_with_count"], {"count": get(env, context, "category.newTopics")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "category.unreadTopics")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "category.newTopics")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/color-input"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"class": "hex-input", "value": get(env, context, "hexValue"), "maxlength": "6"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/composer-editor"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("input");
        dom.setAttribute(el1,"type","file");
        dom.setAttribute(el1,"id","mobile-uploader");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(element3,0,0);
        var attrMorph0 = dom.createAttrMorph(element3, 'class');
        attribute(env, attrMorph0, element3, "class", concat(env, ["mobile-file-upload ", subexpr(env, context, "if", [get(env, context, "isUploading"), "hidden"], {})]));
        inline(env, morph0, context, "i18n", ["upload"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","toggle-preview");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createUnsafeMorphAt(element2,0,0);
        element(env, element2, context, "action", ["togglePreview"], {});
        content(env, morph0, context, "toggleText");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"id","cancel-file-upload");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["cancelUpload"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"id","file-uploading");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("%\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element1,5,5);
        var morph3 = dom.createMorphAt(element1,7,7);
        inline(env, morph0, context, "loading-spinner", [], {"size": "small"});
        inline(env, morph1, context, "i18n", ["upload_selector.uploading"], {});
        content(env, morph2, context, "uploadProgress");
        block(env, morph3, context, "if", [get(env, context, "isCancellable")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","composer-bottom-right");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","draft-status");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [2]);
      var element5 = dom.childAt(element4, [4]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element4,1,1);
      var morph2 = dom.createMorphAt(element4,2,2);
      var morph3 = dom.createMorphAt(element5,1,1);
      var attrMorph0 = dom.createAttrMorph(element5, 'class');
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "d-editor", [], {"tabindex": "4", "value": get(env, context, "composer.reply"), "placeholder": "composer.reply_placeholder", "previewUpdated": "previewUpdated", "markdownOptions": get(env, context, "markdownOptions"), "extraButtons": "extraButtons", "importQuote": "importQuote", "showOptions": "showOptions", "showUploadModal": "showUploadModal", "validation": get(env, context, "validation"), "loading": get(env, context, "composer.loading")});
      block(env, morph1, context, "if", [get(env, context, "site.mobileView")], {}, child0, child1);
      block(env, morph2, context, "if", [get(env, context, "isUploading")], {}, child2, null);
      attribute(env, attrMorph0, element5, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "isUploading"), "hidden"], {})]));
      content(env, morph3, context, "draftStatus");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/composer-title"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"value": get(env, context, "composer.title"), "tabindex": "2", "id": "reply-title", "maxLength": get(env, context, "siteSettings.max_topic_title_length"), "placeholderKey": "composer.title_placeholder", "disabled": get(env, context, "composer.loading")});
      inline(env, morph1, context, "popup-input-tip", [], {"validation": get(env, context, "validation")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/create-topics-notice"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","alert alert-info alert-too-few-topics");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),1,1);
        content(env, morph0, context, "message");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "hidden")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-checkbox"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "checked")});
      inline(env, morph1, context, "i18n", [get(env, context, "label")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-editor-modal"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [3]);
      var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      content(env, morph0, context, "yield");
      inline(env, morph1, context, "d-button", [], {"class": "btn-primary", "label": "composer.modal_ok", "action": "ok"});
      inline(env, morph2, context, "d-button", [], {"class": "btn-danger", "label": "composer.modal_cancel", "action": "cancel"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-editor"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "i18n", ["composer.link_dialog_title"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "link"), "placeholderKey": "composer.link_placeholder"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "b", blockArguments[0]);
          inline(env, morph0, context, "d-button", [], {"action": get(env, context, "b.action"), "actionParam": get(env, context, "b"), "translatedTitle": get(env, context, "b.title"), "icon": get(env, context, "b.icon"), "class": get(env, context, "b.className")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","d-editor-spacer");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        set(env, context, "group", blockArguments[0]);
        block(env, morph0, context, "each", [get(env, context, "group.buttons")], {}, child0, null);
        block(env, morph1, context, "unless", [get(env, context, "group.lastGroup")], {}, child1, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-overlay hidden");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-modals");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-button-bar");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-preview-header");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-textarea-wrapper");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-preview-wrapper");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","d-editor-preview");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [4]);
      var element1 = dom.childAt(element0, [5]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph2 = dom.createMorphAt(element1,1,1);
      var morph3 = dom.createMorphAt(element1,3,3);
      var morph4 = dom.createMorphAt(element1,5,5);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element0, [7, 1]),1,1);
      block(env, morph0, context, "d-editor-modal", [], {"class": "insert-link", "hidden": get(env, context, "insertLinkHidden"), "okAction": "insertLink"}, child0, null);
      block(env, morph1, context, "each", [get(env, context, "toolbar.groups")], {}, child1, null);
      inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      inline(env, morph3, context, "textarea", [], {"tabindex": get(env, context, "tabindex"), "value": get(env, context, "value"), "class": "d-editor-input", "placeholder": get(env, context, "placeholderTranslated")});
      inline(env, morph4, context, "popup-input-tip", [], {"validation": get(env, context, "validation")});
      content(env, morph5, context, "preview");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/desktop-notification-config"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.not_supported", "disabled": "true"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.perm_default", "action": "requestPermission"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.perm_denied_btn", "action": "recheckPermission", "disabled": "true"});
        inline(env, morph1, context, "i18n", ["user.desktop_notifications.perm_denied_expl"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "bell-slash-o", "label": "user.desktop_notifications.disable", "action": "turnoff"});
          inline(env, morph1, context, "i18n", ["user.desktop_notifications.currently_enabled"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "bell-o", "label": "user.desktop_notifications.enable", "action": "turnon"});
          inline(env, morph1, context, "i18n", ["user.desktop_notifications.currently_disabled"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isEnabled")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
      var morph3 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      block(env, morph0, context, "if", [get(env, context, "isNotSupported")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "isDefaultPermission")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "isDeniedPermission")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "isGrantedPermission")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/disabled-icon"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "fa-icon", ["ban"], {"modifier": "stack-2x"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {"modifier": "stack-2x"});
      block(env, morph1, context, "if", [get(env, context, "disabled")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/discourse-banner"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createUnsafeMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        attribute(env, attrMorph0, element0, "href", concat(env, [get(env, context, "banner.url")]));
        inline(env, morph0, context, "i18n", ["banner.edit"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","banner");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","banner-content");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","close");
      var el5 = dom.createElement("i");
      dom.setAttribute(el5,"class","fa fa-times");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, subexpr = hooks.subexpr, concat = hooks.concat, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [0]);
      var attrMorph0 = dom.createAttrMorph(element1, 'class');
      var attrMorph1 = dom.createAttrMorph(element4, 'title');
      var morph0 = dom.createUnsafeMorphAt(element2,3,3);
      var morph1 = dom.createMorphAt(element2,5,5);
      attribute(env, attrMorph0, element1, "class", get(env, context, "overlay"));
      element(env, element3, context, "action", ["dismiss"], {});
      attribute(env, attrMorph1, element4, "title", concat(env, [subexpr(env, context, "i18n", ["banner.close"], {})]));
      content(env, morph0, context, "banner.html");
      block(env, morph1, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-general"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "s", blockArguments[0]);
            inline(env, morph0, context, "category-badge", [get(env, context, "s")], {"hideParent": "true"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "i18n", ["categories.subcategories"], {});
          block(env, morph1, context, "each", [get(env, context, "subCategories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["category.parent"], {});
          inline(env, morph1, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "category.parent_category_id"), "categories": get(env, context, "parentCategories"), "rootNone": true});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "subCategories")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "category.description");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["category.no_description"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("br");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "btn-small", "action": "showCategoryTopic", "icon": "pencil", "label": "category.change_in_category_topic"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createMorphAt(element0,3,3);
        var morph2 = dom.createMorphAt(element0,4,4);
        inline(env, morph0, context, "i18n", ["category.description"], {});
        block(env, morph1, context, "if", [get(env, context, "category.description")], {}, child0, child1);
        block(env, morph2, context, "if", [get(env, context, "category.topic_url")], {}, child2, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","field");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","field-item");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","field-item");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","field");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","category-color-editor");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","input-prepend input-append");
      dom.setAttribute(el4,"style","margin-top: 10px;");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","color-title");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(":");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","add-on");
      var el6 = dom.createTextNode("#");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","input-prepend input-append");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","color-title");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(":");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","add-on");
      var el6 = dom.createTextNode("#");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element2, [3]);
      var element5 = dom.childAt(element1, [7]);
      var element6 = dom.childAt(element5, [3]);
      var element7 = dom.childAt(element6, [3]);
      var element8 = dom.childAt(element6, [5]);
      var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph1 = dom.createMorphAt(element3,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph3 = dom.createMorphAt(element4,3,3);
      var morph4 = dom.createMorphAt(element1,3,3);
      var morph5 = dom.createMorphAt(element1,5,5);
      var morph6 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
      var morph7 = dom.createUnsafeMorphAt(element6,1,1);
      var morph8 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
      var morph9 = dom.createMorphAt(element7,4,4);
      var morph10 = dom.createMorphAt(element7,6,6);
      var morph11 = dom.createMorphAt(dom.childAt(element8, [1]),0,0);
      var morph12 = dom.createMorphAt(element8,4,4);
      var morph13 = dom.createMorphAt(element8,6,6);
      inline(env, morph0, context, "i18n", ["category.name"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "category.name"), "placeholderKey": "category.name_placeholder", "maxlength": "50"});
      inline(env, morph2, context, "i18n", ["category.slug"], {});
      inline(env, morph3, context, "text-field", [], {"value": get(env, context, "category.slug"), "placeholderKey": "category.slug_placeholder", "maxlength": "255"});
      block(env, morph4, context, "if", [get(env, context, "canSelectParentCategory")], {}, child0, null);
      block(env, morph5, context, "if", [get(env, context, "showDescription")], {}, child1, null);
      inline(env, morph6, context, "i18n", ["category.badge_colors"], {});
      content(env, morph7, context, "categoryBadgePreview");
      inline(env, morph8, context, "i18n", ["category.background_color"], {});
      inline(env, morph9, context, "text-field", [], {"value": get(env, context, "category.color"), "placeholderKey": "category.color_placeholder", "maxlength": "6"});
      inline(env, morph10, context, "color-picker", [], {"colors": get(env, context, "backgroundColors"), "usedColors": get(env, context, "usedBackgroundColors"), "value": get(env, context, "category.color")});
      inline(env, morph11, context, "i18n", ["category.foreground_color"], {});
      inline(env, morph12, context, "text-field", [], {"value": get(env, context, "category.text_color"), "placeholderKey": "category.color_placeholder", "maxlength": "6"});
      inline(env, morph13, context, "color-picker", [], {"colors": get(env, context, "foregroundColors"), "value": get(env, context, "category.text_color"), "id": "edit-text-color"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-images"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["category.logo"], {});
      inline(env, morph1, context, "image-uploader", [], {"imageUrl": get(env, context, "category.logo_url"), "type": "category_logo", "class": "no-repeat"});
      inline(env, morph2, context, "i18n", ["category.background_image"], {});
      inline(env, morph3, context, "image-uploader", [], {"imageUrl": get(env, context, "category.background_url"), "type": "category_background"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-panel"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "component", [get(env, context, "customComponent")], {"tab": get(env, context, "tab"), "selectedTab": get(env, context, "selectedTab"), "category": get(env, context, "category")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-security"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["category.special_warning"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,0,0);
          element(env, element2, context, "action", ["removePermission", get(env, context, "p")], {});
          inline(env, morph0, context, "fa-icon", ["times-circle"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","name");
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","badge-group");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","permission");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 0]),0,0);
        var morph1 = dom.createUnsafeMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(dom.childAt(element3, [5]),0,0);
        var morph3 = dom.createMorphAt(element3,7,7);
        set(env, context, "p", blockArguments[0]);
        content(env, morph0, context, "p.group_name");
        inline(env, morph1, context, "i18n", ["category.can"], {});
        content(env, morph2, context, "p.permission.description");
        block(env, morph3, context, "if", [get(env, context, "editingPermissions")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-small");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [5]);
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "view", ["select"], {"content": get(env, context, "category.availableGroups"), "value": get(env, context, "selectedGroup")});
        inline(env, morph1, context, "view", ["select"], {"class": "permission-selector", "optionValuePath": "content.id", "optionLabelPath": "content.description", "content": get(env, context, "category.availablePermissions"), "value": get(env, context, "selectedPermission")});
        element(env, element1, context, "action", ["addPermission", get(env, context, "selectedGroup"), get(env, context, "selectedPermission")], {});
        inline(env, morph2, context, "i18n", ["category.add_permission"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-small");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["editPermissions"], {});
          inline(env, morph0, context, "i18n", ["category.edit_permissions"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "category.is_special")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","permission-list");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
      var morph2 = dom.createMorphAt(element4,5,5);
      block(env, morph0, context, "if", [get(env, context, "category.is_special")], {}, child0, null);
      block(env, morph1, context, "each", [get(env, context, "category.permissions")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "editingPermissions")], {}, child2, child3);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-settings"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1, 1]);
        var element4 = dom.childAt(fragment, [3, 1]);
        var element5 = dom.childAt(fragment, [5, 1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var morph1 = dom.createMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(element4,1,1);
        var morph3 = dom.createMorphAt(element4,3,3);
        var morph4 = dom.createMorphAt(element5,1,1);
        var morph5 = dom.createMorphAt(element5,3,3);
        var morph6 = dom.createMorphAt(element5,5,5);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.contains_messages")});
        inline(env, morph1, context, "i18n", ["category.contains_messages"], {});
        inline(env, morph2, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.email_in_allow_strangers")});
        inline(env, morph3, context, "i18n", ["category.email_in_allow_strangers"], {});
        inline(env, morph4, context, "fa-icon", ["envelope-o"], {});
        inline(env, morph5, context, "i18n", ["category.email_in"], {});
        inline(env, morph6, context, "text-field", [], {"value": get(env, context, "category.email_in")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element2,3,3);
        inline(env, morph0, context, "i18n", ["category.position"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "category.position"), "class": "position-input"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","/admin/site_settings/category/email");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
        inline(env, morph0, context, "i18n", ["category.email_in_disabled"], {});
        inline(env, morph1, context, "i18n", ["category.email_in_disabled_click"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","/admin/site_settings/category/basic");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        inline(env, morph0, context, "i18n", ["category.position_disabled"], {});
        inline(env, morph1, context, "i18n", ["category.position_disabled_click"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element6 = dom.childAt(fragment, [2, 1]);
      var element7 = dom.childAt(fragment, [4, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(element6,1,1);
      var morph2 = dom.createMorphAt(element6,3,3);
      var morph3 = dom.createMorphAt(element7,1,1);
      var morph4 = dom.createMorphAt(element7,3,3);
      var morph5 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph6 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph7 = dom.createMorphAt(fragment,10,10,contextualElement);
      var morph8 = dom.createMorphAt(fragment,12,12,contextualElement);
      var morph9 = dom.createMorphAt(fragment,14,14,contextualElement);
      inline(env, morph0, context, "auto-close-form", [], {"autoCloseTime": get(env, context, "category.auto_close_hours"), "autoCloseBasedOnLastPost": get(env, context, "category.auto_close_based_on_last_post"), "autoCloseExamples": "", "limited": "true"});
      inline(env, morph1, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.allow_badges")});
      inline(env, morph2, context, "i18n", ["category.allow_badges_label"], {});
      inline(env, morph3, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.suppress_from_homepage")});
      inline(env, morph4, context, "i18n", ["category.suppress_from_homepage"], {});
      block(env, morph5, context, "if", [get(env, context, "emailInEnabled")], {}, child0, null);
      block(env, morph6, context, "if", [get(env, context, "showPositionInput")], {}, child1, null);
      block(env, morph7, context, "unless", [get(env, context, "emailInEnabled")], {}, child2, null);
      block(env, morph8, context, "unless", [get(env, context, "showPositionInput")], {}, child3, null);
      inline(env, morph9, context, "plugin-outlet", ["category-custom-settings"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-tab"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      element(env, element0, context, "action", ["select"], {});
      content(env, morph0, context, "title");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-topic-template"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      inline(env, morph0, context, "i18n", ["category.topic_template"], {});
      inline(env, morph1, context, "d-editor", [], {"value": get(env, context, "category.topic_template")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/emoji-uploader"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","file");
      dom.setAttribute(el2,"accept",".png,.gif");
      dom.setAttribute(el2,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var element1 = dom.childAt(element0, [5]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"name": "name", "placeholderKey": "admin.emoji.name", "value": get(env, context, "name")});
      element(env, element0, context, "bind-attr", [], {"class": ":btn :btn-primary addDisabled:disabled"});
      inline(env, morph1, context, "fa-icon", ["plus"], {});
      inline(env, morph2, context, "i18n", ["admin.emoji.add"], {});
      attribute(env, attrMorph0, element1, "disabled", get(env, context, "addDisabled"));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/featured-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","last-user-info");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [3]);
        var element2 = dom.childAt(element0, [5]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element1,0,0);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var morph2 = dom.createMorphAt(element2,0,0);
        var attrMorph1 = dom.createAttrMorph(element2, 'href');
        inline(env, morph0, context, "i18n", ["categories.latest_by"], {});
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastPosterUrl")], {})]));
        inline(env, morph1, context, "unbound", [get(env, context, "topic.last_poster.username")], {});
        attribute(env, attrMorph1, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastPostUrl")], {})]));
        inline(env, morph2, context, "format-age", [get(env, context, "topic.last_posted_at")], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("   \n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","last-posted-at");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "format-age", [get(env, context, "topic.last_posted_at")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"class","title");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createUnsafeMorphAt(element3,0,0);
      var attrMorph0 = dom.createAttrMorph(element3, 'href');
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "topic")});
      attribute(env, attrMorph0, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastUnreadUrl")], {})]));
      inline(env, morph1, context, "unbound", [get(env, context, "topic.fancyTitle")], {});
      inline(env, morph2, context, "topic-post-badges", [], {"newPosts": get(env, context, "topic.totalUnread"), "unseen": get(env, context, "topic.unseen"), "url": get(env, context, "topic.lastUnreadUrl")});
      block(env, morph3, context, "if", [get(env, context, "latestTopicOnly")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/group-post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","title");
          var el2 = dom.createTextNode(", ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
          content(env, morph0, context, "post.user_title");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","name");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        content(env, morph0, context, "post.user_long_name");
        block(env, morph1, context, "if", [get(env, context, "post.user_title")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","item");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix info");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      dom.setAttribute(el3,"class","avatar-link");
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","avatar-wrapper");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","time");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","title");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","category");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","group-member-info");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      dom.setAttribute(el2,"class","excerpt");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [5, 1]);
      var attrMorph0 = dom.createAttrMorph(element2, 'href');
      var attrMorph1 = dom.createAttrMorph(element2, 'data-user-card');
      var morph0 = dom.createMorphAt(dom.childAt(element2, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph2 = dom.createMorphAt(element3,0,0);
      var attrMorph2 = dom.createAttrMorph(element3, 'href');
      var morph3 = dom.createMorphAt(dom.childAt(element1, [7]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element1, [9]),1,1);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),1,1);
      attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "post.user.userUrl")], {})]));
      attribute(env, attrMorph1, element2, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "post.user.username")], {})]));
      inline(env, morph0, context, "avatar", [get(env, context, "post.user")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
      inline(env, morph1, context, "format-date", [get(env, context, "post.created_at")], {"leaveAgo": "true"});
      attribute(env, attrMorph2, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "post.url")], {})]));
      inline(env, morph2, context, "unbound", [get(env, context, "post.title")], {});
      inline(env, morph3, context, "category-link", [get(env, context, "post.category")], {});
      block(env, morph4, context, "if", [get(env, context, "post.user_long_name")], {}, child0, null);
      inline(env, morph5, context, "unbound", [get(env, context, "post.cooked")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/group-selector"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"class","ember-text-field group-names");
      dom.setAttribute(el1,"type","text");
      dom.setAttribute(el1,"name","groups");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      element(env, element0, context, "bind-attr", [], {"placeholder": "placeholder"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/hamburger-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","badge badge-notification");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        attribute(env, attrMorph0, element0, "href", get(env, context, "category.url"));
        content(env, morph0, context, "unreadTotal");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("b");
        dom.setAttribute(el1,"class","topics-count");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "category.topic_count");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "category-link", [get(env, context, "category")], {"allowUncategorized": "true"});
      block(env, morph1, context, "if", [get(env, context, "unreadTotal")], {}, child0, null);
      block(env, morph2, context, "if", [get(env, context, "showTopicCount")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/hamburger-menu"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","badge badge-notification");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              inline(env, morph0, context, "i18n", ["faq"], {});
              inline(env, morph1, context, "i18n", ["new_item"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            dom.setAttribute(el1,"class","heading");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "d-link", [], {"path": get(env, context, "faqUrl"), "class": "faq-link"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "menu-links", [], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("span");
                dom.setAttribute(el1,"class","badge-notification flagged-posts");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element1,0,0);
                var attrMorph0 = dom.createAttrMorph(element1, 'title');
                attribute(env, attrMorph0, element1, "title", subexpr(env, context, "i18n", ["notifications.total_flagged"], {}));
                content(env, morph0, context, "currentUser.site_flagged_posts_count");
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "fa-icon", ["flag"], {});
              inline(env, morph1, context, "i18n", ["flags_title"], {});
              block(env, morph2, context, "if", [get(env, context, "currentUser.site_flagged_posts_count")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.1",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("              ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("span");
                  dom.setAttribute(el1,"class","badge-notification flagged-posts");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, content = hooks.content;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                  content(env, morph0, context, "currentUser.post_queue_new_count");
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
                dom.insertBoundary(fragment, null);
                inline(env, morph0, context, "i18n", ["queue.title"], {});
                block(env, morph1, context, "if", [get(env, context, "currentUser.post_queue_new_count")], {}, child0, null);
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("li");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "d-link", [], {"route": "queued-posts"}, child0, null);
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("         ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("li");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              inline(env, morph0, context, "d-link", [], {"route": "adminSiteSettings", "icon": "gear", "label": "admin.site_settings.title"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, block = hooks.block, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
            var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
            var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
            var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
            inline(env, morph0, context, "d-link", [], {"route": "admin", "class": "admin-link", "icon": "wrench", "label": "admin_title"});
            block(env, morph1, context, "d-link", [], {"route": "adminFlags", "class": "flagged-posts-link"}, child0, null);
            block(env, morph2, context, "if", [get(env, context, "currentUser.show_queued_posts")], {}, child1, null);
            block(env, morph3, context, "if", [get(env, context, "currentUser.admin")], {}, child2, null);
            inline(env, morph4, context, "plugin-outlet", ["hamburger-admin"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "menu-links", [], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-link", [], {"route": "discovery.new", "class": "new-topics-link", "label": "filters.new.title_with_count", "count": get(env, context, "newCount")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-link", [], {"route": "discovery.new", "class": "new-topics-link", "label": "filters.new.title"});
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-link", [], {"route": "discovery.unread", "class": "unread-topics-link", "label": "filters.unread.title_with_count", "count": get(env, context, "unreadCount")});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-link", [], {"route": "discovery.unread", "class": "unread-topics-link", "label": "filters.unread.title"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
            block(env, morph0, context, "if", [get(env, context, "newCount")], {}, child0, child1);
            block(env, morph1, context, "if", [get(env, context, "unreadCount")], {}, child2, child3);
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "d-link", [], {"route": "badges", "class": "badge-link", "label": "badges.title"});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "d-link", [], {"route": "users", "class": "user-directory-link", "label": "directory.title"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
          var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
          var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
          var morph5 = dom.createMorphAt(fragment,11,11,contextualElement);
          var morph6 = dom.createMorphAt(fragment,13,13,contextualElement);
          inline(env, morph0, context, "d-link", [], {"route": "discovery.latest", "class": "latest-topics-link", "label": "filters.latest.title"});
          block(env, morph1, context, "if", [get(env, context, "currentUser")], {}, child0, null);
          inline(env, morph2, context, "d-link", [], {"route": "discovery.top", "class": "top-topics-link", "label": "filters.top.title"});
          block(env, morph3, context, "if", [get(env, context, "siteSettings.enable_badges")], {}, child1, null);
          block(env, morph4, context, "if", [get(env, context, "showUserDirectoryLink")], {}, child2, null);
          inline(env, morph5, context, "plugin-outlet", ["site-map-links"], {});
          inline(env, morph6, context, "plugin-outlet", ["site-map-links-last"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "c", blockArguments[0]);
            inline(env, morph0, context, "hamburger-category", [], {"category": get(env, context, "c")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("ul");
          dom.setAttribute(el1,"class","category-links clearfix");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("li");
          dom.setAttribute(el2,"class","heading");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
          var morph1 = dom.createMorphAt(element0,3,3);
          inline(env, morph0, context, "d-link", [], {"class": "heading", "route": "discovery.categories", "class": "categories-link", "label": "filters.categories.title"});
          block(env, morph1, context, "each", [get(env, context, "categories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "d-link", [], {"path": get(env, context, "faqUrl"), "class": "faq-link", "label": "faq"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "d-link", [], {"action": "keyboardShortcuts", "class": "keyboard-shortcuts-link", "label": "keyboard_shortcuts_help.title"});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "d-link", [], {"action": "toggleMobileView", "class": "mobile-toggle-link", "label": get(env, context, "mobileViewLinkTextKey")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "d-link", [], {"route": "about", "class": "about-link", "label": "about.simple_title"});
          block(env, morph1, context, "unless", [get(env, context, "prioritizeFaq")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "showKeyboardShortcuts")], {}, child1, null);
          block(env, morph3, context, "if", [get(env, context, "showMobileToggle")], {}, child2, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("hr");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
        var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
        var morph4 = dom.createMorphAt(fragment,10,10,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "prioritizeFaq")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "currentUser.staff")], {}, child1, null);
        block(env, morph2, context, "menu-links", [], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "categories")], {}, child3, null);
        block(env, morph4, context, "menu-links", [], {"omitRule": "true"}, child4, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "menu-panel", [], {"visible": get(env, context, "visible")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/header-dropdown"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "bound-avatar", [get(env, context, "currentUser"), "medium"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"class","icon");
      var el2 = dom.createTextNode(" \n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, element = hooks.element, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var attrMorph0 = dom.createAttrMorph(element0, 'href');
      var attrMorph1 = dom.createAttrMorph(element0, 'title');
      var attrMorph2 = dom.createAttrMorph(element0, 'aria-label');
      var attrMorph3 = dom.createAttrMorph(element0, 'id');
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      attribute(env, attrMorph0, element0, "href", get(env, context, "href"));
      attribute(env, attrMorph1, element0, "title", subexpr(env, context, "i18n", [get(env, context, "title")], {}));
      attribute(env, attrMorph2, element0, "aria-label", subexpr(env, context, "i18n", [get(env, context, "title")], {}));
      attribute(env, attrMorph3, element0, "id", get(env, context, "iconId"));
      element(env, element0, context, "action", ["toggle"], {});
      block(env, morph0, context, "if", [get(env, context, "showUser")], {}, child0, child1);
      content(env, morph1, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/header-extra-info"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","private-message-glyph");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "fa-icon", ["envelope"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","topic-link");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createUnsafeMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "topic")});
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.url")], {})]));
        element(env, element0, context, "action", ["jumpToTopPost"], {});
        content(env, morph1, context, "topic.fancyTitle");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "topic-category", [], {"topic": get(env, context, "topic")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","extra-info-wrapper");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","title-wrapper");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h1");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var morph0 = dom.createMorphAt(element3,1,1);
      var morph1 = dom.createMorphAt(element3,3,3);
      var morph2 = dom.createMorphAt(element2,3,3);
      element(env, element1, context, "bind-attr", [], {"class": ":extra-info needsSecondRow:two-rows"});
      block(env, morph0, context, "if", [get(env, context, "showPrivateMessageGlyph")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "topic.details.loaded")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "topic.details.loaded")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/home-logo"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("img");
          dom.setAttribute(el1,"class","logo-small");
          dom.setAttribute(el1,"width","33");
          dom.setAttribute(el1,"height","33");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var attrMorph0 = dom.createAttrMorph(element2, 'src');
          attribute(env, attrMorph0, element2, "src", concat(env, [subexpr(env, context, "unbound", [get(env, context, "smallLogoUrl")], {})]));
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","fa fa-home");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "smallLogoUrl")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("img");
          dom.setAttribute(el1,"id","site-logo");
          dom.setAttribute(el1,"class","logo-big");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var attrMorph0 = dom.createAttrMorph(element1, 'src');
          var attrMorph1 = dom.createAttrMorph(element1, 'alt');
          attribute(env, attrMorph0, element1, "src", concat(env, [subexpr(env, context, "unbound", [get(env, context, "mobileBigLogoUrl")], {})]));
          attribute(env, attrMorph1, element1, "alt", concat(env, [subexpr(env, context, "unbound", [get(env, context, "title")], {})]));
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("img");
            dom.setAttribute(el1,"id","site-logo");
            dom.setAttribute(el1,"class","logo-big");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var attrMorph0 = dom.createAttrMorph(element0, 'src');
            var attrMorph1 = dom.createAttrMorph(element0, 'alt');
            attribute(env, attrMorph0, element0, "src", concat(env, [subexpr(env, context, "unbound", [get(env, context, "bigLogoUrl")], {})]));
            attribute(env, attrMorph1, element0, "alt", concat(env, [subexpr(env, context, "unbound", [get(env, context, "title")], {})]));
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h2");
            dom.setAttribute(el1,"id","site-text-logo");
            dom.setAttribute(el1,"class","text-logo");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "unbound", [get(env, context, "title")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "bigLogoUrl")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showMobileLogo")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"data-auto-route","true");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element3,1,1);
      var attrMorph0 = dom.createAttrMorph(element3, 'href');
      attribute(env, attrMorph0, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "linkUrl")], {})]));
      block(env, morph0, context, "if", [get(env, context, "showSmallLogo")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/image-uploader"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger pad-left no-text");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["trash"], {});
        inline(env, morph0, context, "fa-icon", ["trash-o"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","uploaded-image-preview input-xxlarge");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","image-upload-controls");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","file");
      dom.setAttribute(el4,"accept","image/*");
      dom.setAttribute(el4,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("%");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, inline = hooks.inline, element = hooks.element, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [3]);
      var element5 = dom.childAt(element2, [5]);
      var attrMorph0 = dom.createAttrMorph(element1, 'style');
      var morph0 = dom.createMorphAt(element3,1,1);
      var attrMorph1 = dom.createAttrMorph(element3, 'class');
      var morph1 = dom.createMorphAt(element2,3,3);
      var morph2 = dom.createMorphAt(element5,0,0);
      var morph3 = dom.createMorphAt(element5,2,2);
      attribute(env, attrMorph0, element1, "style", get(env, context, "backgroundStyle"));
      attribute(env, attrMorph1, element3, "class", concat(env, ["btn pad-left no-text ", subexpr(env, context, "if", [get(env, context, "uploading"), "disabled"], {})]));
      inline(env, morph0, context, "fa-icon", ["picture-o"], {});
      element(env, element4, context, "bind-attr", [], {"disabled": "uploading"});
      block(env, morph1, context, "if", [get(env, context, "backgroundStyle")], {}, child0, null);
      element(env, element5, context, "bind-attr", [], {"class": ":btn uploading::hidden"});
      inline(env, morph2, context, "i18n", ["upload_selector.uploading"], {});
      content(env, morph3, context, "uploadProgress");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/ip-lookup"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element9,1,1);
        var morph1 = dom.createMorphAt(element9,2,2);
        element(env, element9, context, "action", ["lookup"], {});
        inline(env, morph0, context, "fa-icon", ["globe"], {});
        inline(env, morph1, context, "i18n", ["admin.user.ip_lookup"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.hostname"], {});
            content(env, morph1, context, "location.hostname");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"target","_blank");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("br");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element4 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element4,0,0);
            var attrMorph0 = dom.createAttrMorph(element4, 'href');
            var morph1 = dom.createMorphAt(fragment,4,4,contextualElement);
            attribute(env, attrMorph0, element4, "href", concat(env, ["https://maps.google.com/maps?q=", subexpr(env, context, "unbound", [get(env, context, "location.loc")], {})]));
            content(env, morph0, context, "location.loc");
            content(env, morph1, context, "city");
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["ip_lookup.location_not_found"], {});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.organisation"], {});
            content(env, morph1, context, "location.org");
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.phone"], {});
            content(env, morph1, context, "location.phone");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
          var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
          var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "location.hostname")], {}, child0, null);
          inline(env, morph1, context, "i18n", ["ip_lookup.location"], {});
          block(env, morph2, context, "if", [get(env, context, "location.loc")], {}, child1, child2);
          block(env, morph3, context, "if", [get(env, context, "location.org")], {}, child3, null);
          block(env, morph4, context, "if", [get(env, context, "location.phone")], {}, child4, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "loading-spinner", [], {"size": "small"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-danger pull-right");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(element3,2,2);
          element(env, element3, context, "action", ["deleteOtherAccounts"], {});
          inline(env, morph0, context, "fa-icon", ["warning"], {});
          inline(env, morph1, context, "i18n", ["ip_lookup.delete_other_accounts"], {"count": get(env, context, "otherAccountsToDelete")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode(" ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                inline(env, morph0, context, "avatar", [get(env, context, "a")], {"usernamePath": "user.username", "imageSize": "small"});
                content(env, morph1, context, "a.username");
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("tr");
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
              var morph2 = dom.createMorphAt(dom.childAt(element0, [5]),0,0);
              var morph3 = dom.createMorphAt(dom.childAt(element0, [7]),0,0);
              var morph4 = dom.createMorphAt(dom.childAt(element0, [9]),0,0);
              block(env, morph0, context, "link-to", ["adminUser", get(env, context, "a")], {}, child0, null);
              content(env, morph1, context, "a.trustLevel.id");
              content(env, morph2, context, "a.time_read");
              content(env, morph3, context, "a.topics_entered");
              content(env, morph4, context, "a.post_count");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            dom.setAttribute(el1,"class","other-accounts");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("table");
            dom.setAttribute(el2,"class","table table-condensed table-hover");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("thead");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("tr");
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("tbody");
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1, 1]);
            var element2 = dom.childAt(element1, [1, 1]);
            var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
            var morph2 = dom.createMorphAt(dom.childAt(element2, [5]),0,0);
            var morph3 = dom.createMorphAt(dom.childAt(element2, [7]),0,0);
            var morph4 = dom.createMorphAt(dom.childAt(element2, [9]),0,0);
            var morph5 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
            inline(env, morph0, context, "i18n", ["ip_lookup.username"], {});
            inline(env, morph1, context, "i18n", ["ip_lookup.trust_level"], {});
            inline(env, morph2, context, "i18n", ["ip_lookup.read_time"], {});
            inline(env, morph3, context, "i18n", ["ip_lookup.topics_entered"], {});
            inline(env, morph4, context, "i18n", ["ip_lookup.post_count"], {});
            block(env, morph5, context, "each", [get(env, context, "other_accounts")], {"keyword": "a"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "other_accounts.length")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","location-box");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","close pull-right");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h4");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("dl");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dt");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("strong");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element5 = dom.childAt(fragment, [1]);
        var element6 = dom.childAt(element5, [1]);
        var element7 = dom.childAt(element5, [5]);
        var element8 = dom.childAt(element7, [3]);
        var morph0 = dom.createMorphAt(element6,0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
        var morph2 = dom.createMorphAt(element7,1,1);
        var morph3 = dom.createMorphAt(element8,1,1);
        var morph4 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
        var morph5 = dom.createMorphAt(element8,5,5);
        var morph6 = dom.createMorphAt(element7,5,5);
        element(env, element6, context, "action", ["hide"], {});
        inline(env, morph0, context, "fa-icon", ["times"], {});
        inline(env, morph1, context, "i18n", ["ip_lookup.title"], {});
        block(env, morph2, context, "if", [get(env, context, "location")], {}, child0, child1);
        inline(env, morph3, context, "i18n", ["ip_lookup.other_accounts"], {});
        content(env, morph4, context, "totalOthersWithSameIP");
        block(env, morph5, context, "if", [get(env, context, "other_accounts.length")], {}, child2, null);
        block(env, morph6, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "otherAccountsLoading")}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "ip")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "show")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/json-file-uploader"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","jsfu-shade-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-file");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"id","js-file-input");
      dom.setAttribute(el3,"type","file");
      dom.setAttribute(el3,"style","display:none;");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-separator");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-paste");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","text");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element0, [7]);
      var attrMorph0 = dom.createAttrMorph(element2, 'accept');
      var morph0 = dom.createMorphAt(element1,3,3);
      var morph1 = dom.createMorphAt(element1,5,5);
      var morph2 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
      var attrMorph1 = dom.createAttrMorph(element3, 'class');
      var morph4 = dom.createMorphAt(dom.childAt(element3, [0]),0,0);
      attribute(env, attrMorph0, element2, "accept", get(env, context, "accept"));
      inline(env, morph0, context, "d-button", [], {"class": "fileSelect", "action": "selectFile", "class": "", "icon": "upload", "label": "upload_selector.select_file"});
      inline(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading"), "size": "small"});
      inline(env, morph2, context, "i18n", ["alternation"], {});
      inline(env, morph3, context, "textarea", [], {"value": get(env, context, "value")});
      attribute(env, attrMorph1, element3, "class", concat(env, ["jsfu-shade ", subexpr(env, context, "if", [get(env, context, "hover"), "", "hidden"], {})]));
      inline(env, morph4, context, "fa-icon", ["upload"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/list-setting"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","input-setting-list");
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","text");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var attrMorph0 = dom.createAttrMorph(element0, 'value');
      attribute(env, attrMorph0, element0, "value", concat(env, [subexpr(env, context, "unbound", [get(env, context, "settingValue")], {})]));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/login-buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, get = hooks.get, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "bind-attr", [], {"class": ":btn :btn-social b.name"});
        element(env, element0, context, "action", ["externalLogin", get(env, context, "b")], {});
        content(env, morph0, context, "b.title");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "buttons")], {"keyword": "b"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/menu-links"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("hr");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("ul");
      dom.setAttribute(el1,"class","menu-links columned");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      content(env, morph0, context, "yield");
      block(env, morph1, context, "unless", [get(env, context, "omitRule")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/menu-panel"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","panel-body");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","panel-body-contents");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),1,1);
        content(env, morph0, context, "yield");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "visible")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/nav-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            content(env, morph0, context, "i18nLabel");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route"), get(env, context, "routeParam")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route"), get(env, context, "routeParam")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "i18nLabel")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"data-auto-route","true");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,0,0);
            var attrMorph0 = dom.createAttrMorph(element1, 'href');
            attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "fullPath")], {})]));
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"data-auto-route","true");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "href")], {})]));
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "path")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "route")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "routeParam")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/navigation-bar"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "navigation-item", [], {"content": get(env, context, "navItem"), "filterMode": get(env, context, "filterMode")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "navItems")], {"keyword": "navItem"}, child0, null);
      inline(env, morph1, context, "custom-html", ["extraNavItem"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/period-chooser"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["changePeriod", get(env, context, "p")], {});
        inline(env, morph0, context, "period-title", [get(env, context, "p")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("h2");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("button");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","period-popup");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clearfix");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [4]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      inline(env, morph0, context, "period-title", [get(env, context, "period")], {"showDateRange": true});
      inline(env, morph1, context, "fa-icon", ["caret-down"], {});
      element(env, element1, context, "bind-attr", [], {"class": "showPeriods::hidden :period-popup"});
      block(env, morph2, context, "each", [get(env, context, "site.periods")], {"keyword": "p"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/popup-menu"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("h3");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("ul");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", [get(env, context, "title")], {});
      content(env, morph1, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/preference-checkbox"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"class","checkbox-label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "checked")});
      content(env, morph1, context, "label");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/private-message-map"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "unbound", [get(env, context, "ag.name")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user group");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var morph1 = dom.createMorphAt(element3,3,3);
        set(env, context, "ag", blockArguments[0]);
        inline(env, morph0, context, "fa-icon", ["users"], {});
        block(env, morph1, context, "link-to", ["group.index", get(env, context, "ag.name")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "avatar", [get(env, context, "au")], {"imageSize": "small"});
          inline(env, morph1, context, "unbound", [get(env, context, "au.username")], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","remove-invited");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element1,0,0);
          element(env, element1, context, "action", ["removeAllowedUser", get(env, context, "au")], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element2,2,2);
        set(env, context, "au", blockArguments[0]);
        block(env, morph0, context, "user-link", [], {"user": get(env, context, "au")}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "details.can_remove_allowed_users")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","controls");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["showPrivateInvite"], {});
        inline(env, morph0, context, "i18n", ["private_message_info.invite"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("h3");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode(" ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","participants clearfix");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var element5 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element4,0,0);
      var morph1 = dom.createMorphAt(element4,2,2);
      var morph2 = dom.createMorphAt(element5,1,1);
      var morph3 = dom.createMorphAt(element5,2,2);
      var morph4 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "fa-icon", ["envelope"], {});
      inline(env, morph1, context, "i18n", ["private_message_info.title"], {});
      block(env, morph2, context, "each", [get(env, context, "details.allowed_groups")], {}, child0, null);
      block(env, morph3, context, "each", [get(env, context, "details.allowed_users")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "details.can_invite_to")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/screened-ip-address-form"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("b");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("button");
      dom.setAttribute(el1,"class","btn");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [6]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(element0,0,0);
      inline(env, morph0, context, "i18n", ["admin.logs.screened_ips.form.label"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "ip_address"), "disabled": get(env, context, "formSubmitted"), "class": "ip-address-input", "placeholderKey": "admin.logs.screened_ips.form.ip_address", "autocorrect": "off", "autocapitalize": "off"});
      inline(env, morph2, context, "combo-box", [], {"content": get(env, context, "actionNames"), "value": get(env, context, "actionName")});
      element(env, element0, context, "action", ["submit"], {"target": "view"});
      element(env, element0, context, "bind-attr", [], {"disabled": "formSubmitted"});
      inline(env, morph3, context, "i18n", ["admin.logs.screened_ips.form.add"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/search-menu"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,1,1);
          var morph1 = dom.createMorphAt(element4,3,3);
          inline(env, morph0, context, "input", [], {"type": "checkbox", "name": "searchContext", "checked": get(env, context, "searchService.searchContextEnabled")});
          content(env, morph1, context, "searchContextDescription");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","searching");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "loading-spinner");
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","no-results");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "i18n", ["search.no_results"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"class","filter");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode(" ");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element1,0,0);
                var morph1 = dom.createMorphAt(element1,2,2);
                var attrMorph0 = dom.createAttrMorph(element1, 'href');
                attribute(env, attrMorph0, element1, "href", get(env, context, "resultType.moreUrl"));
                inline(env, morph0, context, "i18n", ["show_more"], {});
                inline(env, morph1, context, "fa-icon", ["chevron-down"], {});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"href","");
                dom.setAttribute(el1,"class","filter filter-type");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode(" ");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element0 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element0,0,0);
                var morph1 = dom.createMorphAt(element0,2,2);
                element(env, element0, context, "action", ["moreOfType", get(env, context, "resultType.type")], {"bubbles": false});
                inline(env, morph0, context, "i18n", ["show_more"], {});
                inline(env, morph1, context, "fa-icon", ["chevron-down"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("ul");
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("li");
              dom.setAttribute(el2,"class","heading row");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","no-results");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, content = hooks.content, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element2 = dom.childAt(fragment, [1]);
              var element3 = dom.childAt(fragment, [3]);
              var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
              var morph1 = dom.createMorphAt(element2,3,3);
              var morph2 = dom.createMorphAt(element3,1,1);
              var morph3 = dom.createMorphAt(element3,2,2);
              set(env, context, "resultType", blockArguments[0]);
              content(env, morph0, context, "resultType.name");
              inline(env, morph1, context, "component", [get(env, context, "resultType.componentName")], {"results": get(env, context, "resultType.results"), "term": get(env, context, "searchService.term")});
              block(env, morph2, context, "if", [get(env, context, "resultType.moreUrl")], {}, child0, null);
              block(env, morph3, context, "if", [get(env, context, "resultType.more")], {}, child1, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "each", [get(env, context, "content.resultTypes")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","results");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "if", [get(env, context, "noResults")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","search-context");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        dom.setAttribute(el2,"class","show-help");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element5 = dom.childAt(fragment, [5]);
        var element6 = dom.childAt(element5, [3]);
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(element5,1,1);
        var morph3 = dom.createMorphAt(element6,0,0);
        var morph4 = dom.createMorphAt(fragment,7,7,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "plugin-outlet", ["above-search"], {});
        inline(env, morph1, context, "search-text-field", [], {"value": get(env, context, "searchService.term"), "id": "search-term"});
        block(env, morph2, context, "if", [get(env, context, "searchService.searchContext")], {}, child0, null);
        element(env, element6, context, "action", ["showSearchHelp"], {"bubbles": false});
        inline(env, morph3, context, "i18n", ["show_help"], {});
        block(env, morph4, context, "if", [get(env, context, "loading")], {}, child1, child2);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "menu-panel", [], {"visible": get(env, context, "visible"), "onVisible": "showedSearch", "onHidden": "cancelHighlight", "maxWidth": "500"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/search-result-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        set(env, context, "result", blockArguments[0]);
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.url")], {})]));
        inline(env, morph0, context, "category-badge", [get(env, context, "result")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "results")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/search-result-post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","blurb");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "unbound", [get(env, context, "result.blurb")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","search-link");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","topic");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        set(env, context, "result", blockArguments[0]);
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.urlWithNumber")], {})]));
        inline(env, morph0, context, "i18n", ["search.post_format"], {"post_number": get(env, context, "result.post_number"), "username": get(env, context, "result.username")});
        block(env, morph1, context, "unless", [get(env, context, "site.mobileView")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "results")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/search-result-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","blurb");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" - ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createUnsafeMorphAt(element0,3,3);
          inline(env, morph0, context, "format-age", [get(env, context, "result.created_at")], {});
          inline(env, morph1, context, "unbound", [get(env, context, "result.blurb")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","search-link");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","topic");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","topic-title");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 1]);
        var element2 = dom.childAt(element1, [1]);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element2, [2]),0,0);
        var morph2 = dom.createMorphAt(element2,3,3);
        var morph3 = dom.createMorphAt(element2,4,4);
        var morph4 = dom.createMorphAt(element1,3,3);
        set(env, context, "result", blockArguments[0]);
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.url")], {})]));
        inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "result.topic"), "disableActions": true});
        inline(env, morph1, context, "unbound", [get(env, context, "result.topic.fancyTitle")], {});
        inline(env, morph2, context, "category-badge", [get(env, context, "result.topic.category")], {});
        inline(env, morph3, context, "plugin-outlet", ["search-category"], {});
        block(env, morph4, context, "unless", [get(env, context, "site.mobileView")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "results")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/search-result-user"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        set(env, context, "result", blockArguments[0]);
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.path")], {})]));
        inline(env, morph0, context, "avatar", [get(env, context, "result")], {"imageSize": "small"});
        inline(env, morph1, context, "unbound", [get(env, context, "result.username")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "results")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/share-source"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        element(env, element0, context, "bind-attr", [], {"class": ":fa source.faIcon"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "source.htmlIcon");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var attrMorph0 = dom.createAttrMorph(element1, 'title');
      var attrMorph1 = dom.createAttrMorph(element1, 'aria-label');
      attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "source.title")], {})]));
      attribute(env, attrMorph1, element1, "aria-label", concat(env, [subexpr(env, context, "unbound", [get(env, context, "source.title")], {})]));
      element(env, element1, context, "action", ["share", get(env, context, "source")], {});
      block(env, morph0, context, "if", [get(env, context, "source.faIcon")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/signup-cta"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var element3 = dom.childAt(element2, [3]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element3,0,0);
        inline(env, morph0, context, "i18n", ["signup_cta.hidden_for_session"], {});
        element(env, element3, context, "action", ["neverShow"], {});
        inline(env, morph1, context, "i18n", ["signup_cta.hide_forever"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","buttons");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [5]);
        var element1 = dom.childAt(element0, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
        var morph2 = dom.createMorphAt(element0,1,1);
        var morph3 = dom.createMorphAt(element0,3,3);
        var morph4 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "replace-emoji", [subexpr(env, context, "i18n", ["signup_cta.intro"], {})], {});
        inline(env, morph1, context, "replace-emoji", [subexpr(env, context, "i18n", ["signup_cta.value_prop"], {})], {});
        inline(env, morph2, context, "d-button", [], {"action": "showCreateAccount", "label": "signup_cta.sign_up", "icon": "check", "class": "btn-primary"});
        inline(env, morph3, context, "d-button", [], {"action": "hideForSession", "label": "signup_cta.hide_session", "class": "no-icon"});
        element(env, element1, context, "action", ["neverShow"], {});
        inline(env, morph4, context, "i18n", ["signup_cta.hide_forever"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","signup-cta alert alert-info");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "if", [get(env, context, "session.hideSignupCta")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/small-action"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element1,0,0);
          var attrMorph0 = dom.createAttrMorph(element1, 'title');
          attribute(env, attrMorph0, element1, "title", subexpr(env, context, "i18n", ["post.controls.delete"], {}));
          element(env, element1, context, "action", ["delete"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          var attrMorph0 = dom.createAttrMorph(element0, 'title');
          attribute(env, attrMorph0, element0, "title", subexpr(env, context, "i18n", ["post.controls.edit"], {}));
          element(env, element0, context, "action", ["edit"], {});
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(element2,1,1);
        var attrMorph0 = dom.createAttrMorph(element2, 'href');
        var attrMorph1 = dom.createAttrMorph(element2, 'data-user-card');
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "post.can_delete")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "post.can_edit")], {}, child1, null);
        attribute(env, attrMorph0, element2, "href", get(env, context, "post.usernameUrl"));
        attribute(env, attrMorph1, element2, "data-user-card", get(env, context, "post.username"));
        inline(env, morph2, context, "avatar", [get(env, context, "post")], {"imageSize": "small"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","custom-message");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "post.cooked");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","topic-avatar");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","small-action-desc");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(element3,1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
      var morph3 = dom.createMorphAt(element3,5,5);
      inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {});
      block(env, morph1, context, "if", [get(env, context, "post")], {}, child0, null);
      content(env, morph2, context, "description");
      block(env, morph3, context, "if", [get(env, context, "post.cooked")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/stream-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","excerpt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "actionDescription");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("button");
            dom.setAttribute(el1,"class","btn btn-default remove-bookmark");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            element(env, element1, context, "action", ["removeBookmark", get(env, context, "grandChild")], {});
            inline(env, morph0, context, "fa-icon", ["times"], {});
            inline(env, morph1, context, "i18n", ["bookmarks.remove"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" — ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","edit-reason");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              content(env, morph0, context, "grandChild.edit_reason");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"class","avatar-link");
            var el2 = dom.createElement("div");
            dom.setAttribute(el2,"class","avatar-wrapper");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            var attrMorph1 = dom.createAttrMorph(element0, 'data-user-card');
            var morph0 = dom.createMorphAt(dom.childAt(element0, [0]),0,0);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            attribute(env, attrMorph0, element0, "href", get(env, context, "grandChild.userUrl"));
            attribute(env, attrMorph1, element0, "data-user-card", get(env, context, "grandChild.username"));
            inline(env, morph0, context, "avatar", [get(env, context, "grandChild")], {"imageSize": "tiny", "extraClasses": "actor", "ignoreTitle": "true", "avatarTemplatePath": "acting_avatar_template"});
            block(env, morph1, context, "if", [get(env, context, "grandChild.edit_reason")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          set(env, context, "grandChild", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "grandChild.removableBookmark")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","child-actions");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var element3 = dom.childAt(element2, [1]);
        var attrMorph0 = dom.createAttrMorph(element3, 'class');
        var morph0 = dom.createMorphAt(element2,3,3);
        set(env, context, "child", blockArguments[0]);
        attribute(env, attrMorph0, element3, "class", concat(env, ["icon ", get(env, context, "child.icon")]));
        block(env, morph0, context, "each", [get(env, context, "child.items")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clearfix info");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"class","avatar-link");
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","avatar-wrapper");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("span");
      dom.setAttribute(el2,"class","time");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("span");
      dom.setAttribute(el2,"class","title");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","category");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      dom.setAttribute(el1,"class","excerpt");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element4, [7, 1]);
      var attrMorph0 = dom.createAttrMorph(element5, 'href');
      var attrMorph1 = dom.createAttrMorph(element5, 'data-user-card');
      var morph0 = dom.createMorphAt(dom.childAt(element5, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var morph2 = dom.createMorphAt(element4,5,5);
      var morph3 = dom.createUnsafeMorphAt(element6,0,0);
      var attrMorph2 = dom.createAttrMorph(element6, 'href');
      var morph4 = dom.createMorphAt(dom.childAt(element4, [9]),0,0);
      var morph5 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph6 = dom.createUnsafeMorphAt(dom.childAt(fragment, [4]),0,0);
      var morph7 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      attribute(env, attrMorph0, element5, "href", get(env, context, "item.userUrl"));
      attribute(env, attrMorph1, element5, "data-user-card", get(env, context, "item.username"));
      inline(env, morph0, context, "avatar", [get(env, context, "item")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
      inline(env, morph1, context, "format-date", [get(env, context, "item.created_at")], {});
      inline(env, morph2, context, "topic-status", [], {"topic": get(env, context, "item"), "disableActions": true});
      attribute(env, attrMorph2, element6, "href", get(env, context, "item.postUrl"));
      content(env, morph3, context, "item.title");
      inline(env, morph4, context, "category-link", [get(env, context, "item.category")], {});
      block(env, morph5, context, "if", [get(env, context, "actionDescription")], {}, child0, null);
      content(env, morph6, context, "item.excerpt");
      block(env, morph7, context, "each", [get(env, context, "item.children")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/toggle-deleted"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "i18n", ["deleted_filter.disabled_description"], {});
        element(env, element1, context, "action", ["toggleDeleted"], {});
        inline(env, morph1, context, "i18n", ["deleted_filter.enable"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element0,0,0);
        inline(env, morph0, context, "i18n", ["deleted_filter.enabled_description"], {});
        element(env, element0, context, "action", ["toggleDeleted"], {});
        inline(env, morph1, context, "i18n", ["deleted_filter.disable"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "postStream.show_deleted")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/toggle-summary"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-primary");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [3]);
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "i18n", ["summary.enabled_description"], {});
        element(env, element1, context, "action", ["toggleSummary"], {});
        inline(env, morph1, context, "i18n", ["summary.disable"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", ["summary.description_time"], {"count": get(env, context, "topic.posts_count"), "readingTime": get(env, context, "topic.estimatedReadingTime")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", ["summary.description"], {"count": get(env, context, "topic.posts_count")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-primary");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [2]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(element0,0,0);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topic.estimatedReadingTime")], {}, child0, child1);
        element(env, element0, context, "action", ["toggleSummary"], {});
        inline(env, morph1, context, "i18n", ["summary.enable"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "postStream.summary")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/top-period-buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "period-title", [get(env, context, "p")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "d-button", [], {"action": "changePeriod", "actionParam": get(env, context, "p")}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "periods")], {"keyword": "p"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "bound-category-link", [get(env, context, "topic.category.parentCategory")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "topic.category.parentCategory")], {}, child0, null);
      inline(env, morph1, context, "bound-category-link", [get(env, context, "topic.category")], {"hideParent": true});
      inline(env, morph2, context, "plugin-outlet", ["topic-category"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("thead");
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
        inline(env, morph0, context, "raw", ["topic-list-header"], {"currentUser": get(env, context, "currentUser"), "canBulkSelect": get(env, context, "canBulkSelect"), "toggleInTitle": get(env, context, "toggleInTitle"), "hideCategory": get(env, context, "hideCategory"), "showPosters": get(env, context, "showPosters"), "showLikes": get(env, context, "showLikes"), "showOpLikes": get(env, context, "showOpLikes"), "showParticipants": get(env, context, "showParticipants"), "order": get(env, context, "order"), "ascending": get(env, context, "ascending"), "sortable": get(env, context, "sortable"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("tbody");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "skipHeader")], {}, child0, null);
      inline(env, morph1, context, "each", [get(env, context, "topics")], {"itemView": "topic-list-item", "keyword": "topic"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-map"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","secondary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h4");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element9,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element9, [3]),0,0);
        inline(env, morph0, context, "number", [get(env, context, "topic.like_count")], {});
        inline(env, morph1, context, "i18n", ["likes_lowercase"], {"count": get(env, context, "topic.like_count")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","secondary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h4");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element8 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element8,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
        inline(env, morph0, context, "number", [get(env, context, "details.links.length")], {});
        inline(env, morph1, context, "i18n", ["links_lowercase"], {"count": get(env, context, "details.links.length")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "p", blockArguments[0]);
          inline(env, morph0, context, "topic-participant", [], {"participant": get(env, context, "p")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element7,1,1);
        var attrMorph0 = dom.createAttrMorph(element7, 'class');
        attribute(env, attrMorph0, element7, "class", concat(env, ["avatars ", subexpr(env, context, "unless", [get(env, context, "mapCollapsed"), "hidden"], {})]));
        block(env, morph0, context, "each", [get(env, context, "details.fewParticipants")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "p", blockArguments[0]);
          inline(env, morph0, context, "topic-participant", [], {"participant": get(env, context, "p")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              content(env, morph0, context, "link.title");
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "shorten-url", [get(env, context, "link.url")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("span");
            dom.setAttribute(el3,"class","badge badge-notification clicks");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("a");
            dom.setAttribute(el3,"target","_blank");
            dom.setAttribute(el3,"data-ignore-post-id","true");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var element2 = dom.childAt(element1, [1, 1]);
            var element3 = dom.childAt(element1, [3]);
            var element4 = dom.childAt(element3, [1]);
            var morph0 = dom.createMorphAt(element2,0,0);
            var attrMorph0 = dom.createAttrMorph(element2, 'title');
            var morph1 = dom.createMorphAt(element4,1,1);
            var attrMorph1 = dom.createAttrMorph(element4, 'href');
            var attrMorph2 = dom.createAttrMorph(element4, 'class');
            var attrMorph3 = dom.createAttrMorph(element4, 'data-user-id');
            var attrMorph4 = dom.createAttrMorph(element4, 'title');
            var morph2 = dom.createMorphAt(element3,3,3);
            set(env, context, "link", blockArguments[0]);
            attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["topic_map.clicks"], {"count": get(env, context, "link.clicks")})]));
            content(env, morph0, context, "link.clicks");
            attribute(env, attrMorph1, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.url")], {})]));
            attribute(env, attrMorph2, element4, "class", concat(env, ["topic-link track-link ", subexpr(env, context, "if", [get(env, context, "link.attachment"), "attachment"], {})]));
            attribute(env, attrMorph3, element4, "data-user-id", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.user_id")], {})]));
            attribute(env, attrMorph4, element4, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.url")], {})]));
            block(env, morph1, context, "if", [get(env, context, "link.title")], {}, child0, child1);
            inline(env, morph2, context, "link-domain", [get(env, context, "link")], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","link-summary");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("a");
            dom.setAttribute(el2,"href","");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            element(env, element0, context, "action", ["showAllLinks"], {});
            inline(env, morph0, context, "i18n", ["topic_map.links_shown"], {"totalLinks": get(env, context, "details.links.length")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("section");
          dom.setAttribute(el1,"class","links");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("h3");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("table");
          dom.setAttribute(el2,"class","topic-links");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element5, [3]),1,1);
          var morph2 = dom.createMorphAt(element5,5,5);
          inline(env, morph0, context, "i18n", ["topic_map.links_title"], {});
          block(env, morph1, context, "each", [get(env, context, "infoLinks")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "showAllLinksControls")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","avatars clearfix");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element6 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
        var morph1 = dom.createMorphAt(element6,3,3);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "i18n", ["topic_map.participants_title"], {});
        block(env, morph1, context, "each", [get(env, context, "details.participants")], {}, child0, null);
        block(env, morph2, context, "if", [get(env, context, "infoLinks")], {}, child1, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("nav");
      dom.setAttribute(el1,"class","buttons");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","clearfix");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h4");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h4");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      dom.setAttribute(el3,"class","secondary");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      dom.setAttribute(el3,"class","secondary");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element10 = dom.childAt(fragment, [2]);
      var element11 = dom.childAt(element10, [1]);
      var element12 = dom.childAt(element11, [1, 1]);
      var element13 = dom.childAt(element11, [3, 1]);
      var element14 = dom.childAt(element11, [5]);
      var element15 = dom.childAt(element11, [7]);
      var element16 = dom.childAt(element11, [9]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var attrMorph0 = dom.createAttrMorph(element10, 'class');
      var attrMorph1 = dom.createAttrMorph(element12, 'href');
      var morph1 = dom.createMorphAt(dom.childAt(element12, [1]),0,0);
      var morph2 = dom.createMorphAt(element12,3,3);
      var morph3 = dom.createMorphAt(element12,5,5);
      var attrMorph2 = dom.createAttrMorph(element13, 'href');
      var morph4 = dom.createMorphAt(dom.childAt(element13, [1]),0,0);
      var morph5 = dom.createMorphAt(element13,3,3);
      var morph6 = dom.createMorphAt(element13,5,5);
      var morph7 = dom.createMorphAt(element14,1,1);
      var morph8 = dom.createMorphAt(dom.childAt(element14, [3]),0,0);
      var morph9 = dom.createMorphAt(element15,1,1);
      var morph10 = dom.createMorphAt(dom.childAt(element15, [3]),0,0);
      var morph11 = dom.createMorphAt(element16,1,1);
      var morph12 = dom.createMorphAt(dom.childAt(element16, [3]),0,0);
      var morph13 = dom.createMorphAt(element11,11,11);
      var morph14 = dom.createMorphAt(element11,12,12);
      var morph15 = dom.createMorphAt(element11,13,13);
      var morph16 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "d-button", [], {"action": "toggleMap", "title": "topic.toggle_information", "icon": get(env, context, "toggleMapClass")});
      attribute(env, attrMorph0, element10, "class", concat(env, ["map ", subexpr(env, context, "if", [get(env, context, "mapCollapsed"), "map-collapsed"], {})]));
      attribute(env, attrMorph1, element12, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.url")], {})]));
      inline(env, morph1, context, "i18n", ["created_lowercase"], {});
      inline(env, morph2, context, "avatar", [get(env, context, "details.created_by")], {"imageSize": "tiny"});
      inline(env, morph3, context, "format-date", [get(env, context, "topic.created_at")], {});
      attribute(env, attrMorph2, element13, "href", get(env, context, "topic.lastPostUrl"));
      inline(env, morph4, context, "i18n", ["last_reply_lowercase"], {});
      inline(env, morph5, context, "avatar", [get(env, context, "details.last_poster")], {"imageSize": "tiny"});
      inline(env, morph6, context, "format-date", [get(env, context, "topic.last_posted_at")], {});
      inline(env, morph7, context, "number", [get(env, context, "topic.replyCount")], {});
      inline(env, morph8, context, "i18n", ["replies_lowercase"], {"count": get(env, context, "topic.replyCount")});
      inline(env, morph9, context, "number", [get(env, context, "topic.views")], {"class": get(env, context, "topic.viewsHeat")});
      inline(env, morph10, context, "i18n", ["views_lowercase"], {"count": get(env, context, "topic.views")});
      inline(env, morph11, context, "number", [get(env, context, "topic.participant_count")], {});
      inline(env, morph12, context, "i18n", ["users_lowercase"], {"count": get(env, context, "topic.participant_count")});
      block(env, morph13, context, "if", [get(env, context, "topic.like_count")], {}, child0, null);
      block(env, morph14, context, "if", [get(env, context, "details.links.length")], {}, child1, null);
      block(env, morph15, context, "if", [get(env, context, "showPosterAvatar")], {}, child2, null);
      block(env, morph16, context, "unless", [get(env, context, "mapCollapsed")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-participant"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","post-count");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "unbound", [get(env, context, "participant.post_count")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var attrMorph0 = dom.createAttrMorph(element0, 'title');
      attribute(env, attrMorph0, element0, "title", subexpr(env, context, "unbound", [get(env, context, "participant.username")], {}));
      element(env, element0, context, "bind-attr", [], {"class": ":poster toggled"});
      element(env, element0, context, "action", ["toggle"], {});
      block(env, morph0, context, "if", [get(env, context, "showPostCount")], {}, child0, null);
      inline(env, morph1, context, "avatar", [get(env, context, "participant")], {"imageSize": "medium"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/track-selected"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "selected")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-badge"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(× ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            content(env, morph0, context, "count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "showGrantCount")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "badge-button", [], {"badge": get(env, context, "badge")}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "link-to", ["badges.show", get(env, context, "badge")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/confirm"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var morph1 = dom.createUnsafeMorphAt(element0,2,2);
      inline(env, morph0, context, "input", [], {"checked": get(env, context, "value"), "type": "checkbox"});
      content(env, morph1, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/dropdown"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","required");
        var el2 = dom.createTextNode("*");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
      content(env, morph0, context, "field.name");
      inline(env, morph1, context, "combo-box", [], {"content": get(env, context, "field.options"), "value": get(env, context, "value"), "none": get(env, context, "noneLabel")});
      block(env, morph2, context, "if", [get(env, context, "field.required")], {}, child0, null);
      content(env, morph3, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/text"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","required");
        var el2 = dom.createTextNode("*");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
      content(env, morph0, context, "field.name");
      inline(env, morph1, context, "input", [], {"value": get(env, context, "value"), "maxlength": get(env, context, "site.user_field_max_length")});
      block(env, morph2, context, "if", [get(env, context, "field.required")], {}, child0, null);
      content(env, morph3, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-menu"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "d-link", [], {"action": "toggleAnon", "label": "switch_from_anon"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-link", [], {"path": get(env, context, "messagesPath"), "title": "user.private_messages", "icon": "envelope"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-link", [], {"action": "toggleAnon", "title": "switch_to_anon", "icon": "user-secret"});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              set(env, context, "n", blockArguments[0]);
              inline(env, morph0, context, "notification-item", [], {"notification": get(env, context, "n")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("…\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["notifications.more"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("ul");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("li");
            dom.setAttribute(el2,"class","read last heading");
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,1,1);
            var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
            block(env, morph0, context, "each", [get(env, context, "notifications")], {}, child0, null);
            block(env, morph1, context, "d-link", [], {"path": get(env, context, "notificationsPath")}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("hr");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
          dom.insertBoundary(fragment, null);
          block(env, morph0, context, "if", [get(env, context, "notifications")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","menu-links-header");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("ul");
        dom.setAttribute(el2,"class","menu-links-row");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("li");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("li");
        dom.setAttribute(el3,"class","glyphs");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","notifications");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","logout-link");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("hr");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("ul");
        dom.setAttribute(el2,"class","menu-links");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("li");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 1]);
        var element2 = dom.childAt(element1, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element2,1,1);
        var morph3 = dom.createMorphAt(element2,3,3);
        var morph4 = dom.createMorphAt(element2,4,4);
        var morph5 = dom.createMorphAt(element2,6,6);
        var morph6 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
        var morph7 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph8 = dom.createMorphAt(dom.childAt(fragment, [7, 3, 1]),0,0);
        inline(env, morph0, context, "d-link", [], {"route": "user", "model": get(env, context, "currentUser"), "class": "user-activity-link", "icon": "user", "label": "user.profile"});
        block(env, morph1, context, "if", [get(env, context, "showDisableAnon")], {}, child0, null);
        inline(env, morph2, context, "d-link", [], {"path": get(env, context, "bookmarksPath"), "title": "user.bookmarks", "icon": "bookmark"});
        block(env, morph3, context, "if", [get(env, context, "siteSettings.enable_private_messages")], {}, child1, null);
        block(env, morph4, context, "if", [get(env, context, "showEnableAnon")], {}, child2, null);
        inline(env, morph5, context, "d-link", [], {"path": get(env, context, "preferencesPath"), "title": "user.preferences", "icon": "gear"});
        block(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loadingNotifications"), "containerClass": "spinner-container"}, child3, null);
        inline(env, morph7, context, "plugin-outlet", ["user-menu-bottom"], {});
        inline(env, morph8, context, "d-link", [], {"action": "logout", "class": "logout", "icon": "sign-out", "label": "user.log_out"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "menu-panel", [], {"visible": get(env, context, "visible")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-small"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-image");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-detail");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","name-line");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","username");
      var el4 = dom.createElement("a");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","name");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","title");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(fragment, [2]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1, 0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var attrMorph0 = dom.createAttrMorph(element0, 'href');
      var attrMorph1 = dom.createAttrMorph(element0, 'data-user-card');
      var morph1 = dom.createMorphAt(element3,0,0);
      var attrMorph2 = dom.createAttrMorph(element3, 'href');
      var attrMorph3 = dom.createAttrMorph(element3, 'data-user-card');
      var morph2 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "userPath")], {})]));
      attribute(env, attrMorph1, element0, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "user.username")], {})]));
      inline(env, morph0, context, "avatar", [get(env, context, "user")], {"imageSize": "large"});
      attribute(env, attrMorph2, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "userPath")], {})]));
      attribute(env, attrMorph3, element3, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "user.username")], {})]));
      inline(env, morph1, context, "unbound", [get(env, context, "user.username")], {});
      inline(env, morph2, context, "unbound", [get(env, context, "name")], {});
      inline(env, morph3, context, "unbound", [get(env, context, "user.title")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-stat"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","value");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      block(env, morph0, context, "if", [get(env, context, "icon")], {}, child0, null);
      inline(env, morph1, context, "number", [get(env, context, "value")], {});
      inline(env, morph2, context, "i18n", [get(env, context, "label")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "toggleWhisper", "icon": "eye-slash", "label": "composer.toggle_whisper"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "popup-menu", [], {"visible": get(env, context, "optionsVisible"), "hide": "hideOptions", "title": "composer.options"}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","whisper");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "i18n", ["composer.whisper"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","edit-reason-input");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "text-field", [], {"value": get(env, context, "editReason"), "tabindex": "7", "id": "edit-reason", "maxlength": "255", "placeholderKey": "composer.edit_reason_placeholder"});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"class","display-edit-reason");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element9 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element9,0,0);
              element(env, element9, context, "action", ["displayEditReason"], {});
              inline(env, morph0, context, "i18n", ["composer.show_edit_reason"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "showEditReason")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("div");
                dom.setAttribute(el1,"class","add-warning");
                var el2 = dom.createTextNode("\n                    ");
                dom.appendChild(el1, el2);
                var el2 = dom.createElement("label");
                var el3 = dom.createTextNode("\n                      ");
                dom.appendChild(el2, el3);
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                var el3 = dom.createTextNode("\n                      ");
                dom.appendChild(el2, el3);
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                var el3 = dom.createTextNode("\n                    ");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("\n                  ");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element7 = dom.childAt(fragment, [1, 1]);
                var morph0 = dom.createMorphAt(element7,1,1);
                var morph1 = dom.createMorphAt(element7,3,3);
                inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "model.isWarning"), "tabindex": "3"});
                inline(env, morph1, context, "i18n", ["composer.add_warning"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "user-selector", [], {"topicId": get(env, context, "controller.controllers.topic.model.id"), "excludeCurrentUser": "true", "id": "private-message-users", "includeMentionableGroups": "true", "class": "span8", "placeholderKey": "composer.users_placeholder", "tabindex": "1", "usernames": get(env, context, "model.targetUsernames"), "hasGroups": get(env, context, "model.hasTargetGroups")});
              block(env, morph1, context, "if", [get(env, context, "showWarning")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("button");
                dom.setAttribute(el1,"class","btn");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element5 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element5,0,0);
                element(env, element5, context, "action", ["showOptions"], {});
                inline(env, morph0, context, "i18n", ["topic.options"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","category-input");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element6 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element6,1,1);
              var morph1 = dom.createMorphAt(element6,3,3);
              var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
              var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
              inline(env, morph0, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "model.categoryId"), "scopedCategoryId": get(env, context, "scopedCategoryId"), "tabindex": "3"});
              inline(env, morph1, context, "popup-input-tip", [], {"validation": get(env, context, "categoryValidation")});
              block(env, morph2, context, "if", [get(env, context, "model.archetype.hasOptions")], {}, child0, null);
              inline(env, morph3, context, "render", ["additional-composer-buttons", get(env, context, "model")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","form-element clearfix");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element8 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element8,1,1);
            var morph1 = dom.createMorphAt(element8,3,3);
            var morph2 = dom.createMorphAt(element8,5,5);
            block(env, morph0, context, "if", [get(env, context, "model.creatingPrivateMessage")], {}, child0, null);
            inline(env, morph1, context, "composer-title", [], {"composer": get(env, context, "model"), "lastValidatedAt": get(env, context, "lastValidatedAt")});
            block(env, morph2, context, "if", [get(env, context, "model.showCategoryChooser")], {}, child1, null);
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","submit-panel");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("button");
            dom.setAttribute(el2,"tabindex","5");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("a");
            dom.setAttribute(el2,"href","");
            dom.setAttribute(el2,"class","cancel");
            dom.setAttribute(el2,"tabindex","6");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [1]);
            var element3 = dom.childAt(element2, [3]);
            var element4 = dom.childAt(element2, [5]);
            var morph0 = dom.createMorphAt(element2,1,1);
            var morph1 = dom.createUnsafeMorphAt(element3,0,0);
            var morph2 = dom.createMorphAt(element3,1,1);
            var attrMorph0 = dom.createAttrMorph(element3, 'title');
            var morph3 = dom.createMorphAt(element4,0,0);
            inline(env, morph0, context, "plugin-outlet", ["composer-fields-below"], {});
            attribute(env, attrMorph0, element3, "title", concat(env, [subexpr(env, context, "i18n", ["composer.title"], {})]));
            element(env, element3, context, "action", ["save"], {});
            element(env, element3, context, "bind-attr", [], {"class": ":btn :btn-primary :create disableSubmit:disabled"});
            content(env, morph1, context, "model.saveIcon");
            content(env, morph2, context, "model.saveText");
            element(env, element4, context, "action", ["cancel"], {});
            inline(env, morph3, context, "i18n", ["cancel"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","control-row reply-area");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","composer-fields");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","reply-to");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var element11 = dom.childAt(element10, [1]);
          var element12 = dom.childAt(element11, [3]);
          var morph0 = dom.createMorphAt(element11,1,1);
          var morph1 = dom.createUnsafeMorphAt(element12,1,1);
          var morph2 = dom.createMorphAt(element12,3,3);
          var morph3 = dom.createMorphAt(element12,5,5);
          var morph4 = dom.createMorphAt(element11,5,5);
          var morph5 = dom.createMorphAt(element11,7,7);
          var morph6 = dom.createMorphAt(element10,3,3);
          var morph7 = dom.createMorphAt(element10,5,5);
          inline(env, morph0, context, "plugin-outlet", ["composer-open"], {});
          content(env, morph1, context, "model.actionTitle");
          block(env, morph2, context, "if", [get(env, context, "model.whisper")], {}, child0, null);
          block(env, morph3, context, "if", [get(env, context, "canEdit")], {}, child1, null);
          block(env, morph4, context, "if", [get(env, context, "model.canEditTitle")], {}, child2, null);
          inline(env, morph5, context, "plugin-outlet", ["composer-fields"], {});
          inline(env, morph6, context, "composer-editor", [], {"topic": get(env, context, "topic"), "composer": get(env, context, "model"), "lastValidatedAt": get(env, context, "lastValidatedAt"), "canWhisper": get(env, context, "canWhisper"), "draftStatus": get(env, context, "model.draftStatus"), "isUploading": get(env, context, "isUploading"), "groupsMentioned": "groupsMentioned", "importQuote": "importQuote", "showOptions": "showOptions", "showUploadSelector": "showUploadSelector"});
          block(env, morph7, context, "if", [get(env, context, "currentUser")], {}, child3, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"class","permalink");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            inline(env, morph0, context, "i18n", ["composer.saved"], {});
            attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "createdPost.url")], {})]));
            element(env, element0, context, "action", ["viewNewReply"], {});
            inline(env, morph1, context, "i18n", ["composer.view_new_post"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "i18n", ["composer.saving"], {});
            inline(env, morph1, context, "loading-spinner", [], {"size": "small"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","span24");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","saving-text");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","draft-text");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
          block(env, morph0, context, "if", [get(env, context, "model.createdPost")], {}, child0, child1);
          inline(env, morph1, context, "i18n", ["composer.saved_draft"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","contents");
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","control");
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"href","");
        dom.setAttribute(el3,"class","toggler");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element13 = dom.childAt(fragment, [0]);
        var element14 = dom.childAt(element13, [5]);
        var element15 = dom.childAt(element14, [1]);
        var morph0 = dom.createMorphAt(element13,1,1);
        var morph1 = dom.createMorphAt(element13,3,3);
        var attrMorph0 = dom.createAttrMorph(element15, 'title');
        var morph2 = dom.createMorphAt(element14,3,3);
        block(env, morph0, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
        inline(env, morph1, context, "render", ["composer-messages"], {});
        attribute(env, attrMorph0, element15, "title", subexpr(env, context, "i18n", ["composer.toggler"], {}));
        element(env, element15, context, "action", ["toggle"], {"bubbles": false});
        block(env, morph2, context, "if", [get(env, context, "model.viewOpen")], {}, child1, child2);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "visible")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/education"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createElement("i");
      dom.setAttribute(el2,"class","fa fa-times-circle");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(fragment,2,2,contextualElement);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      content(env, morph0, context, "body");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/group-mentioned"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createElement("i");
      dom.setAttribute(el2,"class","fa fa-times-circle");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(fragment,2,2,contextualElement);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      content(env, morph0, context, "body");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/similar_topics"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("h3");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("ul");
      dom.setAttribute(el1,"class","topics");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      inline(env, morph0, context, "fa-icon", ["times-circle"], {});
      inline(env, morph1, context, "i18n", ["composer.similar_topics"], {});
      inline(env, morph2, context, "search-result-topic", [], {"results": get(env, context, "similarTopics")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","list-controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","container");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","full-width");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","header-list-area");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","full-width");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","list-area");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [6]);
      var element1 = dom.childAt(element0, [3, 1, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2, 1]),1,1);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var attrMorph0 = dom.createAttrMorph(element0, 'class');
      var morph3 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),1,1);
      var morph4 = dom.createMorphAt(element1,1,1);
      var morph5 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner")});
      inline(env, morph1, context, "outlet", ["navigation-bar"], {});
      inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      attribute(env, attrMorph0, element0, "class", concat(env, ["container list-container ", subexpr(env, context, "if", [get(env, context, "loading"), "hidden"], {})]));
      inline(env, morph3, context, "outlet", ["header-list-container"], {});
      inline(env, morph4, context, "plugin-outlet", ["discovery-list-container-top"], {});
      inline(env, morph5, context, "outlet", ["list-container"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                  ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("img");
            dom.setAttribute(el1,"class","category-logo");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var attrMorph0 = dom.createAttrMorph(element1, 'src');
            attribute(env, attrMorph0, element1, "src", get(env, context, "c.logo_url"));
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              set(env, context, "s", blockArguments[0]);
              inline(env, morph0, context, "category-link", [get(env, context, "s")], {"hideParent": "true"});
              inline(env, morph1, context, "category-unread", [], {"category": get(env, context, "s")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","subcategories");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("                ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "each", [get(env, context, "c.subcategories")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "f", blockArguments[0]);
            inline(env, morph0, context, "featured-topic", [], {"topic": get(env, context, "f"), "latestTopicOnly": get(env, context, "latestTopicOnly"), "action": "showTopicEntrance"});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                  ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n                    ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","value");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                    ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","unit");
            var el3 = dom.createTextNode(" / ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                  ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
            content(env, morph0, context, "s.value");
            content(env, morph1, context, "s.unit");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","category");
          var el3 = dom.createTextNode("\n              ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          var el4 = dom.createTextNode("\n                ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n                ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n                ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("div");
          dom.setAttribute(el4,"class","category-description");
          var el5 = dom.createTextNode("\n                  ");
          dom.appendChild(el4, el5);
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n                ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n                ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("div");
          dom.setAttribute(el4,"class","clearfix");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","stats");
          var el3 = dom.createTextNode("\n              ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("table");
          dom.setAttribute(el3,"class","categoryStats");
          var el4 = dom.createTextNode("\n                ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tbody");
          var el5 = dom.createTextNode("\n");
          dom.appendChild(el4, el5);
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("                ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline, block = hooks.block, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var element3 = dom.childAt(element2, [1]);
          var element4 = dom.childAt(element3, [1]);
          var element5 = dom.childAt(element2, [3]);
          var element6 = dom.childAt(element2, [5]);
          var attrMorph0 = dom.createAttrMorph(element2, 'data-category_id');
          var attrMorph1 = dom.createAttrMorph(element3, 'style');
          var morph0 = dom.createMorphAt(element4,1,1);
          var morph1 = dom.createMorphAt(element4,3,3);
          var morph2 = dom.createMorphAt(element4,5,5);
          var morph3 = dom.createUnsafeMorphAt(dom.childAt(element4, [7]),1,1);
          var morph4 = dom.createMorphAt(element3,3,3);
          var morph5 = dom.createMorphAt(element5,1,1);
          var attrMorph2 = dom.createAttrMorph(element5, 'class');
          var morph6 = dom.createMorphAt(dom.childAt(element6, [1, 1]),1,1);
          attribute(env, attrMorph0, element2, "data-category_id", concat(env, [subexpr(env, context, "unbound", [get(env, context, "c.id")], {})]));
          element(env, element2, context, "bind-attr", [], {"class": "c.description_excerpt:has-description:no-description c.logo_url:has-logo:no-logo"});
          attribute(env, attrMorph1, element3, "style", subexpr(env, context, "border-color", [get(env, context, "c.color")], {}));
          inline(env, morph0, context, "category-title-link", [], {"category": get(env, context, "c")});
          inline(env, morph1, context, "category-unread", [], {"category": get(env, context, "c")});
          block(env, morph2, context, "if", [get(env, context, "c.logo_url")], {}, child0, null);
          content(env, morph3, context, "c.description_excerpt");
          block(env, morph4, context, "if", [get(env, context, "c.subcategories")], {}, child1, null);
          attribute(env, attrMorph2, element5, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "c.archived"), "archived"], {}), " latest"]));
          block(env, morph5, context, "each", [get(env, context, "c.featuredTopics")], {}, child2, null);
          element(env, element6, context, "bind-attr", [], {"title": "c.topicStatsTitle"});
          block(env, morph6, context, "each", [get(env, context, "c.topicCountStats")], {"keyword": "s"}, child3, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","contents");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("table");
        dom.setAttribute(el2,"class","topic-list categories");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("thead");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("th");
        dom.setAttribute(el5,"class","category");
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("th");
        dom.setAttribute(el5,"class","latest");
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("th");
        dom.setAttribute(el5,"class","stats topics");
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("tbody");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("footer");
        dom.setAttribute(el1,"class","topic-list-bottom");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1, 1]);
        var element8 = dom.childAt(element7, [1, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(element8, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element8, [5]),0,0);
        var morph3 = dom.createMorphAt(dom.childAt(element7, [3]),1,1);
        inline(env, morph0, context, "i18n", ["categories.category"], {});
        inline(env, morph1, context, "i18n", ["categories.latest"], {});
        inline(env, morph2, context, "i18n", ["categories.topics"], {});
        block(env, morph3, context, "each", [get(env, context, "model.categories")], {"keyword": "c"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model.categories")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery/topics"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-info");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "redirectedReason");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics-top");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element9 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element9,0,0);
          var attrMorph0 = dom.createAttrMorph(element9, 'title');
          attribute(env, attrMorph0, element9, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element9, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new-top");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element8,0,0);
          element(env, element8, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element10 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element10,1,1);
        var morph1 = dom.createMorphAt(element10,2,2);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","top-lists");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period"), "action": "changePeriod"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","alert alert-info clickable");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var element7 = dom.childAt(element6, [1]);
          var attrMorph0 = dom.createAttrMorph(element6, 'class');
          var morph0 = dom.createMorphAt(element7,1,1);
          var morph1 = dom.createMorphAt(element7,3,3);
          attribute(env, attrMorph0, element6, "class", concat(env, ["show-more ", subexpr(env, context, "if", [get(env, context, "hasTopics"), "has-topics"], {})]));
          element(env, element7, context, "action", ["showInserted"], {});
          inline(env, morph0, context, "count-i18n", [], {"key": "topic_count_", "suffix": get(env, context, "topicTrackingState.filter"), "count": get(env, context, "topicTrackingState.incomingCount")});
          inline(env, morph1, context, "i18n", ["click_to_show"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topicTrackingState.hasIncoming")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "topic-list", [], {"showTopicPostBadges": get(env, context, "showTopicPostBadges"), "showPosters": true, "currentUser": get(env, context, "currentUser"), "canBulkSelect": get(env, context, "canBulkSelect"), "changeSort": "changeSort", "toggleBulkSelect": "toggleBulkSelect", "hideCategory": get(env, context, "model.hideCategory"), "order": get(env, context, "order"), "ascending": get(env, context, "ascending"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "selected": get(env, context, "selected"), "expandGloballyPinned": get(env, context, "expandGloballyPinned"), "expandAllPinned": get(env, context, "expandAllPinned"), "topics": get(env, context, "model.topics")});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'title');
          attribute(env, attrMorph0, element5, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element5, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          element(env, element4, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [0]);
            var morph0 = dom.createMorphAt(element2,0,0);
            element(env, element2, context, "action", ["createTopic"], {});
            inline(env, morph0, context, "i18n", ["topic.suggest_create_topic"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","education");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(element3,1,1);
          var morph2 = dom.createMorphAt(element3,3,3);
          content(env, morph0, context, "footerEducation");
          content(env, morph1, context, "footerMessage");
          block(env, morph2, context, "if", [get(env, context, "canCreateTopicOnCategory")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(", ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            var morph2 = dom.createMorphAt(element1,5,5);
            var morph3 = dom.createMorphAt(element1,7,7);
            var morph4 = dom.createMorphAt(element1,9,9);
            block(env, morph0, context, "link-to", ["discovery.categories"], {}, child0, null);
            block(env, morph1, context, "link-to", ["discovery.latest"], {}, child1, null);
            inline(env, morph2, context, "i18n", ["or"], {});
            inline(env, morph3, context, "i18n", ["filters.top.other_periods"], {});
            inline(env, morph4, context, "top-period-buttons", [], {"period": get(env, context, "period"), "action": "changePeriod"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","education");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(element0,1,1);
            var morph2 = dom.createMorphAt(element0,2,2);
            var morph3 = dom.createMorphAt(element0,4,4);
            var morph4 = dom.createMorphAt(element0,6,6);
            content(env, morph0, context, "footerEducation");
            content(env, morph1, context, "footerMessage");
            block(env, morph2, context, "link-to", ["discovery.categories"], {}, child0, null);
            inline(env, morph3, context, "i18n", ["or"], {});
            block(env, morph4, context, "link-to", ["discovery.latest"], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "latest")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","contents");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("footer");
      dom.setAttribute(el1,"class","topic-list-bottom");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element11 = dom.childAt(fragment, [6]);
      var element12 = dom.childAt(fragment, [8]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(element11,1,1);
      var morph4 = dom.createMorphAt(element11,3,3);
      var morph5 = dom.createMorphAt(element12,1,1);
      var morph6 = dom.createMorphAt(element12,3,3);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "redirectedReason")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "showDismissAtTop")], {}, child1, null);
      inline(env, morph2, context, "bulk-select-button", [], {"selected": get(env, context, "selected"), "refreshTarget": get(env, context, "controller")});
      block(env, morph3, context, "if", [get(env, context, "top")], {}, child2, child3);
      block(env, morph4, context, "if", [get(env, context, "hasTopics")], {}, child4, null);
      inline(env, morph5, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
      block(env, morph6, context, "if", [get(env, context, "allLoaded")], {}, child5, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["embedded-post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","post-info arrow");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-arrow-up");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [0]);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var attrMorph1 = dom.createAttrMorph(element1, 'title');
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "url")], {})]));
        attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "i18n", ["topic.jump_reply_up"], {})]));
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","post-info arrow");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-arrow-down");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [0]);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "url")], {})]));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["topic.jump_reply_down"], {})]));
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","topic-avatar");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","topic-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","topic-meta-data");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","post-info post-date");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","cooked");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0]);
      var element3 = dom.childAt(element2, [3]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element4, [7]);
      var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),1,1);
      var morph1 = dom.createMorphAt(element4,1,1);
      var morph2 = dom.createMorphAt(element4,3,3);
      var morph3 = dom.createMorphAt(element4,5,5);
      var attrMorph0 = dom.createAttrMorph(element5, 'href');
      var morph4 = dom.createMorphAt(dom.childAt(element5, [0]),0,0);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element3, [3]),1,1);
      inline(env, morph0, context, "raw", ["post/poster-avatar"], {"post": get(env, context, "this"), "classNames": "main-avatar"});
      inline(env, morph1, context, "poster-name", [], {"post": get(env, context, "this")});
      block(env, morph2, context, "if", [get(env, context, "view.parentView.previousPost")], {}, child0, null);
      block(env, morph3, context, "unless", [get(env, context, "view.parentView.previousPost")], {}, child1, null);
      attribute(env, attrMorph0, element5, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "url")], {})]));
      inline(env, morph4, context, "age-with-tooltip", [get(env, context, "created_at")], {});
      inline(env, morph5, context, "unbound", [get(env, context, "cooked")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["emoji-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var stack1, buffer = "      <li>\n        <a href>\n";
  stack1 = helpers['if'].call(depth0, "option.src", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(2, data),"inverse":this.program(4, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "        </a>\n      </li>\n";
},"2":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "            <img src="
    + escapeExpression(helpers.get.call(depth0, "option.src", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + " class='emoji'> "
    + escapeExpression(helpers.get.call(depth0, "option.code", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\n";
},"4":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "            "
    + escapeExpression(helpers.get.call(depth0, "option.label", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='autocomplete'>\n  <ul>\n";
  stack1 = helpers.each.call(depth0, "option", "in", "options", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["emoji-toolbar.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var stack1, escapeExpression=this.escapeExpression, buffer = "<li><a title='"
    + escapeExpression(helpers.get.call(depth0, "item.title", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' ";
  stack1 = helpers['if'].call(depth0, "item.selected", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(2, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + " data-group-id='"
    + escapeExpression(helpers.get.call(depth0, "item.groupId", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'><img src='"
    + escapeExpression(helpers.get.call(depth0, "item.src", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='emoji'></a></li>";
},"2":function(depth0,helpers,partials,data) {
  return "class='selected'";
  },"4":function(depth0,helpers,partials,data) {
  var stack1, buffer = "      <tr>\n";
  stack1 = helpers.each.call(depth0, "item", "in", "row", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(5, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "      </tr>\n";
},"5":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "          <td><a title='"
    + escapeExpression(helpers.get.call(depth0, "item.title", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'><img src='"
    + escapeExpression(helpers.get.call(depth0, "item.src", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='emoji'></a></td>\n";
},"7":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        "
    + escapeExpression(((helpers['fa-icon'] || (depth0 && depth0['fa-icon']) || helperMissing).call(depth0, "fast-backward", {"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"9":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <a>"
    + escapeExpression(((helpers['fa-icon'] || (depth0 && depth0['fa-icon']) || helperMissing).call(depth0, "fast-backward", {"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"11":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        "
    + escapeExpression(((helpers['fa-icon'] || (depth0 && depth0['fa-icon']) || helperMissing).call(depth0, "fast-forward", {"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"13":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <a>"
    + escapeExpression(((helpers['fa-icon'] || (depth0 && depth0['fa-icon']) || helperMissing).call(depth0, "fast-forward", {"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='emoji-modal'>\n  <ul class='toolbar'>\n    ";
  stack1 = helpers.each.call(depth0, "item", "in", "toolbarItems", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n  </ul>\n  <div class='emoji-table-wrapper'>\n  <table class='emoji-page'>\n";
  stack1 = helpers.each.call(depth0, "row", "in", "rows", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(4, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "  </table>\n  </div>\n\n  <div class='info'></div>\n  <div class='nav'>\n    <span class='prev'>\n";
  stack1 = helpers['if'].call(depth0, "prevDisabled", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(7, data),"inverse":this.program(9, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "    </span>\n    <span class='next'>\n";
  stack1 = helpers['if'].call(depth0, "nextDisabled", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(11, data),"inverse":this.program(13, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "    </span>\n  </div>\n  <div class='clearfix'></div>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["exception"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-check-circle");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'class');
        attribute(env, attrMorph0, element0, "class", concat(env, ["btn ", subexpr(env, context, "unbound", [get(env, context, "buttonData.classes")], {})]));
        element(env, element0, context, "action", [get(env, context, "buttonData.action")], {});
        inline(env, morph0, context, "boundI18n", [get(env, context, "buttonData.key")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","error-page");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","face");
      var el4 = dom.createTextNode(":(");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","reason");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","url");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      dom.setAttribute(el4,"data-auto-route","true");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","desc");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","buttons");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline, get = hooks.get, element = hooks.element, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [5]);
      var element3 = dom.childAt(element2, [3]);
      var element4 = dom.childAt(element1, [7]);
      var element5 = dom.childAt(element1, [9]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph1 = dom.createMorphAt(element2,1,1);
      var morph2 = dom.createMorphAt(element3,0,0);
      var morph3 = dom.createMorphAt(element4,1,1);
      var morph4 = dom.createMorphAt(element4,3,3);
      var morph5 = dom.createMorphAt(element5,1,1);
      var morph6 = dom.createMorphAt(element5,3,3);
      content(env, morph0, context, "reason");
      inline(env, morph1, context, "i18n", ["errors.prev_page"], {});
      element(env, element3, context, "bind-attr", [], {"href": get(env, context, "requestUrl")});
      content(env, morph2, context, "requestUrl");
      block(env, morph3, context, "if", [get(env, context, "networkFixed")], {}, child0, null);
      content(env, morph4, context, "desc");
      block(env, morph5, context, "each", [get(env, context, "enabledButtons")], {"keyword": "buttonData"}, child1, null);
      inline(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["full-page-search"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "list", "class": "bulk-select", "title": "topics.bulk.toggle", "action": "toggleBulkSelect"});
          inline(env, morph1, context, "bulk-select-button", [], {"selected": get(env, context, "selected"), "refreshTarget": get(env, context, "controller")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.posts")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","fps-select");
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element13 = dom.childAt(fragment, [1]);
          var element14 = dom.childAt(element13, [1]);
          var element15 = dom.childAt(element13, [3]);
          var morph0 = dom.createMorphAt(element14,0,0);
          var morph1 = dom.createMorphAt(element15,0,0);
          element(env, element14, context, "action", ["selectAll"], {});
          inline(env, morph0, context, "i18n", ["search.select_all"], {});
          element(env, element15, context, "action", ["clearAll"], {});
          inline(env, morph1, context, "i18n", ["search.clear_all"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "bulkSelectEnabled")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","fps-search-context");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element12 = dom.childAt(fragment, [0, 1]);
        var morph0 = dom.createMorphAt(element12,1,1);
        var morph1 = dom.createMorphAt(element12,3,3);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "name": "searchContext", "checked": get(env, context, "searchContextEnabled")});
        content(env, morph1, context, "searchContextDescription");
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["search.no_results"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","show-help");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var element11 = dom.childAt(element10, [3]);
          var morph0 = dom.createMorphAt(element10,1,1);
          var morph1 = dom.createMorphAt(element11,0,0);
          block(env, morph0, context, "if", [get(env, context, "searchActive")], {}, child0, null);
          element(env, element11, context, "action", ["showSearchHelp"], {"bubbles": false});
          inline(env, morph1, context, "i18n", ["search.search_help"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","search-title clearfix");
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","result-count");
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n      ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n    ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","sort-by");
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","desc");
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n      ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n    ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var element9 = dom.childAt(element8, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(element8, [1, 1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element9, [1]),1,1);
          var morph2 = dom.createMorphAt(element9,3,3);
          inline(env, morph0, context, "i18n", ["search.result_count"], {"count": get(env, context, "resultCount"), "term": get(env, context, "noSortQ")});
          inline(env, morph1, context, "i18n", ["search.sort_by"], {});
          inline(env, morph2, context, "combo-box", [], {"value": get(env, context, "sortOrder"), "content": get(env, context, "sortOrders"), "castInteger": "true"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "track-selected", [], {"selectedList": get(env, context, "selected"), "selectedId": get(env, context, "result.topic")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "unbound", [get(env, context, "result.topic.fancyTitle")], {});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          -\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "unbound", [get(env, context, "result.blurb")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "highlight-text", [], {"highlight": get(env, context, "controller.q")}, child0, null);
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","like-count");
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode(" ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("i");
              dom.setAttribute(el2,"class","icon fa fa-heart");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              content(env, morph0, context, "result.like_count");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "result.like_count")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","fps-result");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","topic");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("a");
          dom.setAttribute(el3,"class","search-link");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("span");
          dom.setAttribute(el4,"class","topic-title");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","search-category");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","blurb container");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","date");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var element3 = dom.childAt(element2, [1]);
          var element4 = dom.childAt(element3, [5]);
          var element5 = dom.childAt(element3, [7]);
          var element6 = dom.childAt(element2, [3]);
          var element7 = dom.childAt(element6, [1]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(element3,3,3);
          var morph2 = dom.createMorphAt(element4,1,1);
          var attrMorph0 = dom.createAttrMorph(element4, 'href');
          var morph3 = dom.createMorphAt(dom.childAt(element4, [2]),0,0);
          var morph4 = dom.createMorphAt(element5,1,1);
          var morph5 = dom.createMorphAt(element5,3,3);
          var morph6 = dom.createMorphAt(element7,1,1);
          var morph7 = dom.createMorphAt(element7,3,3);
          var morph8 = dom.createMorphAt(element6,3,3);
          var morph9 = dom.createMorphAt(element2,5,5);
          set(env, context, "result", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "bulkSelectEnabled")], {}, child0, null);
          inline(env, morph1, context, "avatar", [get(env, context, "result")], {"imageSize": "tiny"});
          attribute(env, attrMorph0, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.url")], {})]));
          inline(env, morph2, context, "topic-status", [], {"topic": get(env, context, "result.topic"), "disableActions": true});
          block(env, morph3, context, "highlight-text", [], {"highlight": get(env, context, "controller.q")}, child1, null);
          inline(env, morph4, context, "category-link", [get(env, context, "result.topic.category")], {});
          inline(env, morph5, context, "plugin-outlet", ["full-page-search-category"], {});
          inline(env, morph6, context, "format-age", [get(env, context, "result.created_at")], {});
          block(env, morph7, context, "if", [get(env, context, "result.blurb")], {}, child2, null);
          block(env, morph8, context, "if", [get(env, context, "result.blurb")], {}, child3, null);
          block(env, morph9, context, "if", [get(env, context, "showLikeCount")], {}, child4, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          dom.setAttribute(el1,"class","search-footer");
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","show-help");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var element1 = dom.childAt(element0, [3]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createMorphAt(element1,0,0);
          inline(env, morph0, context, "i18n", ["search.no_more_results"], {});
          element(env, element1, context, "action", ["showSearchHelp"], {"bubbles": false});
          inline(env, morph1, context, "i18n", ["search.search_help"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
        block(env, morph0, context, "unless", [get(env, context, "model.posts")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.posts")], {}, child1, null);
        block(env, morph2, context, "each", [get(env, context, "model.posts")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.posts")], {}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","search row clearfix");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element16 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element16,1,1);
      var morph1 = dom.createMorphAt(element16,3,3);
      var morph2 = dom.createMorphAt(element16,5,5);
      var morph3 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph4 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph5 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "search-text-field", [], {"value": get(env, context, "searchTerm"), "class": "full-page-search input-xxlarge search no-blur", "action": "search", "hasAutofocus": get(env, context, "hasAutofocus")});
      inline(env, morph1, context, "d-button", [], {"action": "search", "icon": "search", "class": "btn-primary", "disabled": get(env, context, "searchButtonDisabled")});
      block(env, morph2, context, "if", [get(env, context, "canBulkSelect")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "model.posts")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "context")], {}, child2, null);
      block(env, morph5, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "      <li><a href>"
    + escapeExpression(helpers.get.call(depth0, "option.name", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</a></li>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='autocomplete'>\n  <ul>\n";
  stack1 = helpers.each.call(depth0, "option", "in", "options", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["group"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
            content(env, morph0, context, "tab.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "tab.name");
          block(env, morph1, context, "if", [get(env, context, "tab.count")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var attrMorph0 = dom.createAttrMorph(element0, 'class');
        set(env, context, "tab", blockArguments[0]);
        attribute(env, attrMorph0, element0, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "tab.active"), "active"], {})]));
        block(env, morph0, context, "link-to", [get(env, context, "tab.location"), get(env, context, "model")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","user-navigation");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("ul");
      dom.setAttribute(el3,"class","action-list nav-stacked");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","user-main");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","user-right groups");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("section");
      dom.setAttribute(el4,"class","about group");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","details");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("h1");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [3, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1, 1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element2, [1, 1, 1]),0,0);
      var morph2 = dom.createMorphAt(element2,3,3);
      block(env, morph0, context, "each", [get(env, context, "tabs")], {}, child0, null);
      content(env, morph1, context, "model.name");
      content(env, morph2, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group/index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "post", blockArguments[0]);
        inline(env, morph0, context, "group-post", [], {"post": get(env, context, "post")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.posts"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-stream");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "controller")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group/members"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","clearfix");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("form");
          dom.setAttribute(el2,"id","add-user-to-group");
          dom.setAttribute(el2,"autocomplete","off");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(element3,3,3);
          inline(env, morph0, context, "user-selector", [], {"usernames": get(env, context, "usernames"), "placeholderKey": "groups.selector_placeholder", "id": "user-search-selector", "name": "usernames"});
          inline(env, morph1, context, "d-button", [], {"action": "addMembers", "class": "add", "icon": "plus", "label": "groups.add"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("th");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","is-owner");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            inline(env, morph0, context, "i18n", ["groups.owner"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"class","remove-link");
              var el2 = dom.createElement("i");
              dom.setAttribute(el2,"class","fa fa-times");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, element = hooks.element;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1]);
              element(env, element0, context, "action", ["removeMember", get(env, context, "m")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("td");
            dom.setAttribute(el1,"class","remove-user");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "unless", [get(env, context, "m.owner")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","avatar");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","text");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","text");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var element2 = dom.childAt(element1, [1]);
          var morph0 = dom.createMorphAt(element2,1,1);
          var morph1 = dom.createMorphAt(element2,3,3);
          var morph2 = dom.createMorphAt(dom.childAt(element1, [3, 1]),0,0);
          var morph3 = dom.createMorphAt(dom.childAt(element1, [5, 1]),0,0);
          var morph4 = dom.createMorphAt(element1,7,7);
          set(env, context, "m", blockArguments[0]);
          inline(env, morph0, context, "user-small", [], {"user": get(env, context, "m")});
          block(env, morph1, context, "if", [get(env, context, "m.owner")], {}, child0, null);
          inline(env, morph2, context, "bound-date", [get(env, context, "m.last_posted_at")], {});
          inline(env, morph3, context, "bound-date", [get(env, context, "m.last_seen_at")], {});
          block(env, morph4, context, "if", [get(env, context, "isOwner")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("table");
        dom.setAttribute(el1,"class","group-members");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("tr");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("th");
        dom.setAttribute(el3,"colspan","2");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("th");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element4 = dom.childAt(fragment, [2]);
        var element5 = dom.childAt(element4, [1]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
        var morph3 = dom.createMorphAt(element5,5,5);
        var morph4 = dom.createMorphAt(element4,3,3);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isOwner")], {}, child0, null);
        inline(env, morph1, context, "i18n", ["last_post"], {});
        inline(env, morph2, context, "i18n", ["last_seen"], {});
        block(env, morph3, context, "if", [get(env, context, "isOwner")], {}, child1, null);
        block(env, morph4, context, "each", [get(env, context, "model.members")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.users"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group/mentions"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "post", blockArguments[0]);
        inline(env, morph0, context, "group-post", [], {"post": get(env, context, "post")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.mentions"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-stream");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "controller")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group/messages"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "post", blockArguments[0]);
        inline(env, morph0, context, "group-post", [], {"post": get(env, context, "post")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.messages"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-stream");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "controller")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group/topics"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "post", blockArguments[0]);
        inline(env, morph0, context, "group-post", [], {"post": get(env, context, "post")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.topics"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-stream");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "controller")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["header"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "showCreateAccount", "class": "btn-primary btn-small sign-up-button", "label": "sign_up"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showSignUpButton")], {}, child0, null);
        inline(env, morph1, context, "d-button", [], {"action": "showLogin", "class": "btn-primary btn-small login-button", "icon": "user", "label": "log_in"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "plugin-outlet", ["header-before-notifications"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","/admin/flags/active");
          dom.setAttribute(el1,"class","badge-notification flagged-posts");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,0,0);
          var attrMorph0 = dom.createAttrMorph(element2, 'title');
          attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["notifications.total_flagged"], {})]));
          content(env, morph0, context, "flaggedPostsCount");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "flaggedPostsCount")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            dom.setAttribute(el1,"class","badge-notification unread-notifications");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,0,0);
            element(env, element1, context, "action", ["showUserMenu"], {});
            content(env, morph0, context, "currentUser.unread_notifications");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            dom.setAttribute(el1,"class","badge-notification unread-private-messages");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            element(env, element0, context, "action", ["showUserMenu"], {});
            content(env, morph0, context, "currentUser.unread_private_messages");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "currentUser.unread_notifications")], {}, child0, null);
          block(env, morph1, context, "if", [get(env, context, "currentUser.unread_private_messages")], {}, child1, null);
          inline(env, morph2, context, "plugin-outlet", ["header-notifications"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "header-dropdown", [], {"iconId": "current-user", "class": "current-user", "showUser": "true", "toggleVisible": get(env, context, "userMenuVisible"), "loginAction": "showLogin", "title": "user.avatar.header_title"}, child0, null);
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "header-extra-info", [], {"topic": get(env, context, "topic")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","wrap");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","contents clearfix");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","panel clearfix");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      dom.setAttribute(el4,"class","icons clearfix");
      dom.setAttribute(el4,"role","navigation");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n        ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n        ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n        ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n        ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0, 1]);
      var element4 = dom.childAt(element3, [5]);
      var element5 = dom.childAt(element4, [3]);
      var morph0 = dom.createMorphAt(element3,1,1);
      var morph1 = dom.createMorphAt(element3,3,3);
      var morph2 = dom.createMorphAt(element4,1,1);
      var morph3 = dom.createMorphAt(element5,1,1);
      var morph4 = dom.createMorphAt(element5,3,3);
      var morph5 = dom.createMorphAt(element5,5,5);
      var morph6 = dom.createMorphAt(element5,7,7);
      var morph7 = dom.createMorphAt(element4,5,5);
      var morph8 = dom.createMorphAt(element4,7,7);
      var morph9 = dom.createMorphAt(element4,9,9);
      var morph10 = dom.createMorphAt(element4,11,11);
      var morph11 = dom.createMorphAt(element3,7,7);
      inline(env, morph0, context, "home-logo", [], {"minimized": get(env, context, "showExtraInfo")});
      inline(env, morph1, context, "plugin-outlet", ["header-after-home-logo"], {});
      block(env, morph2, context, "unless", [get(env, context, "currentUser")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "currentUser")], {}, child1, null);
      block(env, morph4, context, "header-dropdown", [], {"iconId": "search-button", "icon": "search", "action": "toggleSearch", "toggleVisible": get(env, context, "searchVisible"), "mobileAction": "fullPageSearch", "loginAction": "showLogin", "title": "search.title", "path": "/search"}, child2, null);
      block(env, morph5, context, "header-dropdown", [], {"iconId": "toggle-hamburger-menu", "icon": "bars", "toggleVisible": get(env, context, "hamburgerVisible"), "loginAction": "showLogin", "title": "hamburger_menu"}, child3, null);
      block(env, morph6, context, "if", [get(env, context, "currentUser")], {}, child4, null);
      inline(env, morph7, context, "plugin-outlet", ["header-before-dropdowns"], {});
      inline(env, morph8, context, "user-menu", [], {"visible": get(env, context, "userMenuVisible"), "logoutAction": "logout"});
      inline(env, morph9, context, "hamburger-menu", [], {"visible": get(env, context, "hamburgerVisible"), "showKeyboardAction": "showKeyboardShortcutsHelp"});
      inline(env, morph10, context, "search-menu", [], {"visible": get(env, context, "searchVisible")});
      block(env, morph11, context, "if", [get(env, context, "showExtraInfo")], {}, child5, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["list/action-list.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var stack1, escapeExpression=this.escapeExpression, buffer = "<div class='post-actions "
    + escapeExpression(helpers.get.call(depth0, "className", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>\n  <i class='fa fa-"
    + escapeExpression(helpers.get.call(depth0, "icon", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'></i>\n";
  stack1 = helpers.each.call(depth0, "postNumber", "in", "postNumbers", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(2, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</div>\n";
},"2":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "  <a href='"
    + escapeExpression(helpers.get.call(depth0, "topic.url", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "/"
    + escapeExpression(helpers.get.call(depth0, "postNumber", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>#"
    + escapeExpression(helpers.get.call(depth0, "postNumber", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, "postNumbers", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"useData":true});
Ember.TEMPLATES["list/activity-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<"
    + escapeExpression(helpers.get.call(depth0, "tagName", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + " class=\""
    + escapeExpression(helpers.get.call(depth0, "class", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + " "
    + escapeExpression(((helpers['cold-age-class'] || (depth0 && depth0['cold-age-class']) || helperMissing).call(depth0, "topic.createdAt", {"name":"cold-age-class","hash":{
    'class': (""),
    'startDate': ("topic.bumpedAt")
  },"hashTypes":{'class': "STRING",'startDate': "ID"},"hashContexts":{'class': depth0,'startDate': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + " activity\" title=\""
    + escapeExpression(helpers.get.call(depth0, "topic.bumpedAtTitle", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\"><a href=\""
    + escapeExpression(helpers.get.call(depth0, "topic.lastPostUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers['format-date'] || (depth0 && depth0['format-date']) || helperMissing).call(depth0, "topic.bumpedAt", {"name":"format-date","hash":{
    'noTitle': ("true"),
    'format': ("tiny")
  },"hashTypes":{'noTitle': "STRING",'format': "STRING"},"hashContexts":{'noTitle': depth0,'format': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a></"
    + escapeExpression(helpers.get.call(depth0, "tagName", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + ">\n";
},"useData":true});
Ember.TEMPLATES["list/category-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<td class='category'>"
    + escapeExpression(((helpers['category-link'] || (depth0 && depth0['category-link']) || helperMissing).call(depth0, "category", {"name":"category-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</td>\n";
},"useData":true});
Ember.TEMPLATES["list/post-count-or-badges.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-post-badges", {"name":"raw","hash":{
    'url': ("topic.lastUnreadUrl"),
    'unseen': ("topic.unseen"),
    'newPosts': ("topic.displayNewPosts"),
    'unread': ("topic.unread")
  },"hashTypes":{'url': "ID",'unseen': "ID",'newPosts': "ID",'unread': "ID"},"hashContexts":{'url': depth0,'unseen': depth0,'newPosts': depth0,'unread': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"3":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/posts-count-column", {"name":"raw","hash":{
    'tagName': ("div"),
    'topic': ("topic")
  },"hashTypes":{'tagName': "STRING",'topic': "ID"},"hashContexts":{'tagName': depth0,'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, "view.showBadges", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.program(3, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"useData":true});
Ember.TEMPLATES["list/posters-column.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<a href=\""
    + escapeExpression(helpers.get.call(depth0, "poster.user.path", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\" data-user-card=\""
    + escapeExpression(helpers.get.call(depth0, "poster.user.username", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\" class=\""
    + escapeExpression(helpers.get.call(depth0, "poster.extras", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers.avatar || (depth0 && depth0.avatar) || helperMissing).call(depth0, "poster", {"name":"avatar","hash":{
    'imageSize': ("small"),
    'usernamePath': ("user.username"),
    'avatarTemplatePath': ("user.avatar_template")
  },"hashTypes":{'imageSize': "STRING",'usernamePath': "STRING",'avatarTemplatePath': "STRING"},"hashContexts":{'imageSize': depth0,'usernamePath': depth0,'avatarTemplatePath': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<td class='posters'>\n";
  stack1 = helpers.each.call(depth0, "poster", "in", "posters", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</td>\n";
},"useData":true});
Ember.TEMPLATES["list/posts-count-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "<"
    + escapeExpression(helpers.get.call(depth0, "view.tagName", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + " class='num posts-map posts "
    + escapeExpression(helpers.get.call(depth0, "view.likesHeat", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' title='"
    + escapeExpression(helpers.get.call(depth0, "view.title", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>\n  <a href class='posts-map badge-posts "
    + escapeExpression(helpers.get.call(depth0, "view.likesHeat", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>"
    + escapeExpression(helpers.get.call(depth0, "topic.replyCount", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</a>\n</"
    + escapeExpression(helpers.get.call(depth0, "view.tagName", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + ">\n";
},"useData":true});
Ember.TEMPLATES["list/topic-excerpt.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var stack1, buffer = "  <div class=\"topic-excerpt\">\n    ";
  stack1 = helpers.get.call(depth0, "topic.excerpt", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, "topic.excerptTruncated", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(2, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "  </div>\n";
},"2":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "      <a href=\""
    + escapeExpression(helpers.get.call(depth0, "topic.url", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "read_more", {"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, "topic.hasExcerpt", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"useData":true});
Ember.TEMPLATES["list/topic-list-item.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  return "<td class='star'>\n  <input type=\"checkbox\" class=\"bulk-select\">\n</td>\n";
  },"3":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "    "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-post-badges", {"name":"raw","hash":{
    'url': ("topic.lastUnreadUrl"),
    'unseen': ("topic.unseen"),
    'newPosts': ("topic.displayNewPosts"),
    'unread': ("topic.unread")
  },"hashTypes":{'url': "ID",'unseen': "ID",'newPosts': "ID",'unread': "ID"},"hashContexts":{'url': depth0,'unseen': depth0,'newPosts': depth0,'unread': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"5":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "    "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/topic-excerpt", {"name":"raw","hash":{
    'topic': ("topic")
  },"hashTypes":{'topic': "ID"},"hashContexts":{'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"7":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers.unless.call(depth0, "topic.isPinnedUncategorized", {"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(8, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"8":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "    "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/category-column", {"name":"raw","hash":{
    'category': ("topic.category")
  },"hashTypes":{'category': "ID"},"hashContexts":{'category': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"10":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/posters-column", {"name":"raw","hash":{
    'posters': ("topic.posters")
  },"hashTypes":{'posters': "ID"},"hashContexts":{'posters': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"12":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/posters-column", {"name":"raw","hash":{
    'posters': ("topic.participants")
  },"hashTypes":{'posters': "ID"},"hashContexts":{'posters': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"14":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<td class=\"num likes\">\n";
  stack1 = helpers['if'].call(depth0, "hasLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(15, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"15":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "  <a href='"
    + escapeExpression(helpers.get.call(depth0, "topic.summaryUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>\n    "
    + escapeExpression(((helpers.number || (depth0 && depth0.number) || helperMissing).call(depth0, "topic.like_count", {"name":"number","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + " <i class='fa fa-heart'></i></td>\n  </a>\n";
},"17":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<td class=\"num likes\">\n";
  stack1 = helpers['if'].call(depth0, "hasOpLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(18, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"18":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "  <a href='"
    + escapeExpression(helpers.get.call(depth0, "topic.summaryUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>\n    "
    + escapeExpression(((helpers.number || (depth0 && depth0.number) || helperMissing).call(depth0, "topic.op_like_count", {"name":"number","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + " <i class='fa fa-heart'></i></td>\n  </a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, buffer = "";
  stack1 = helpers['if'].call(depth0, "controller.bulkSelectEnabled", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n<td class='main-link clearfix' colspan=\""
    + escapeExpression(helpers.get.call(depth0, "titleColSpan", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">\n  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-status", {"name":"raw","hash":{
    'topic': ("topic")
  },"hashTypes":{'topic': "ID"},"hashContexts":{'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n  "
    + escapeExpression(((helpers['topic-link'] || (depth0 && depth0['topic-link']) || helperMissing).call(depth0, "topic", {"name":"topic-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + "\n";
  stack1 = helpers['if'].call(depth0, "controller.showTopicPostBadges", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "  "
    + escapeExpression(((helpers['plugin-outlet'] || (depth0 && depth0['plugin-outlet']) || helperMissing).call(depth0, "topic-list-tags", {"name":"plugin-outlet","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
  stack1 = helpers['if'].call(depth0, "expandPinned", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(5, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/action-list", {"name":"raw","hash":{
    'icon': ("heart"),
    'className': ("likes"),
    'postNumbers': ("topic.liked_post_numbers"),
    'topic': ("topic")
  },"hashTypes":{'icon': "STRING",'className': "STRING",'postNumbers': "ID",'topic': "ID"},"hashContexts":{'icon': depth0,'className': depth0,'postNumbers': depth0,'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n</td>\n\n";
  stack1 = helpers.unless.call(depth0, "controller.hideCategory", {"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(7, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, "controller.showPosters", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(10, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n"
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/posts-count-column", {"name":"raw","hash":{
    'topic': ("topic")
  },"hashTypes":{'topic': "ID"},"hashContexts":{'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n\n";
  stack1 = helpers['if'].call(depth0, "controller.showParticipants", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(12, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, "controller.showLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(14, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, "controller.showOpLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(17, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n<td class=\"num views "
    + escapeExpression(helpers.get.call(depth0, "topic.viewsHeat", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers.number || (depth0 && depth0.number) || helperMissing).call(depth0, "topic.views", {"name":"number","hash":{
    'numberKey': ("views_long")
  },"hashTypes":{'numberKey': "STRING"},"hashContexts":{'numberKey': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</td>\n\n"
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/activity-column", {"name":"raw","hash":{
    'tagName': ("td"),
    'class': ("num"),
    'topic': ("topic")
  },"hashTypes":{'tagName': "STRING",'class': "STRING",'topic': "ID"},"hashContexts":{'tagName': depth0,'class': depth0,'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"useData":true});
Ember.TEMPLATES["login-preferences"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showForgotPassword", "label": "login.forgot"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h2");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      dom.setAttribute(el2,"style","margin-top: 1em");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(element0,7,7);
      inline(env, morph0, context, "i18n", ["login.to_continue"], {});
      inline(env, morph1, context, "i18n", ["login.preferences"], {});
      inline(env, morph2, context, "d-button", [], {"class": "btn-primary", "action": "showLogin", "label": "log_in"});
      block(env, morph3, context, "unless", [get(env, context, "siteSettings.enable_sso")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/basic-topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","badge-notification new-topic");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.1",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createElement("a");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var element2 = dom.childAt(fragment, [0]);
                  var morph0 = dom.createMorphAt(element2,0,0);
                  var attrMorph0 = dom.createAttrMorph(element2, 'href');
                  attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "t.url")], {})]));
                  inline(env, morph0, context, "i18n", ["read_more"], {});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                block(env, morph0, context, "unless", [get(env, context, "t.canClearPin")], {}, child0, null);
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"href","");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, get = hooks.get, element = hooks.element, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element1,0,0);
                var attrMorph0 = dom.createAttrMorph(element1, 'title');
                attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["topic.clear_pin.help"], {})]));
                element(env, element1, context, "action", ["clearPin", get(env, context, "t")], {});
                inline(env, morph0, context, "i18n", ["topic.clear_pin.title"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","topic-excerpt");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element3 = dom.childAt(fragment, [1]);
              var morph0 = dom.createUnsafeMorphAt(element3,1,1);
              var morph1 = dom.createMorphAt(element3,3,3);
              var morph2 = dom.createMorphAt(element3,4,4);
              content(env, morph0, context, "t.excerpt");
              block(env, morph1, context, "if", [get(env, context, "t.excerptTruncated")], {}, child0, null);
              block(env, morph2, context, "if", [get(env, context, "t.canClearPin")], {}, child1, null);
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","category");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "category-link", [get(env, context, "t.category")], {});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element0 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element0,0,0);
                var attrMorph0 = dom.createAttrMorph(element0, 'href');
                var attrMorph1 = dom.createAttrMorph(element0, 'class');
                attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.user.path")], {})]));
                attribute(env, attrMorph1, element0, "class", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.extras")], {})]));
                inline(env, morph0, context, "avatar", [get(env, context, "p")], {"usernamePath": "user.username", "imageSize": "small"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","participants");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "each", [get(env, context, "participants")], {"keyword": "p"}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","main-link");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","pull-right");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","clearfix");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","topic-item-stats clearfix");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","pull-right");
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            var el5 = dom.createComment("");
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("a");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n              ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","clearfix");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline, block = hooks.block, concat = hooks.concat, attribute = hooks.attribute, subexpr = hooks.subexpr, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element4 = dom.childAt(fragment, [1]);
            var element5 = dom.childAt(element4, [1]);
            var element6 = dom.childAt(element5, [1]);
            var element7 = dom.childAt(element5, [7]);
            var element8 = dom.childAt(element7, [1]);
            var element9 = dom.childAt(element8, [3]);
            var morph0 = dom.createMorphAt(element6,1,1);
            var morph1 = dom.createMorphAt(element6,3,3);
            var morph2 = dom.createMorphAt(element6,5,5);
            var morph3 = dom.createMorphAt(element6,6,6);
            var morph4 = dom.createMorphAt(dom.childAt(element5, [3]),1,1);
            var morph5 = dom.createMorphAt(element8,1,1);
            var morph6 = dom.createMorphAt(element9,0,0);
            var attrMorph0 = dom.createAttrMorph(element9, 'href');
            var attrMorph1 = dom.createAttrMorph(element9, 'title');
            var morph7 = dom.createMorphAt(element7,3,3);
            var morph8 = dom.createMorphAt(element7,4,4);
            element(env, element4, context, "bind-attr", [], {"class": "t.archived"});
            inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "t")});
            inline(env, morph1, context, "topic-link", [get(env, context, "t")], {});
            block(env, morph2, context, "if", [get(env, context, "t.unseen")], {}, child0, null);
            block(env, morph3, context, "if", [get(env, context, "t.hasExcerpt")], {}, child1, null);
            inline(env, morph4, context, "raw", ["list/post-count-or-badges"], {"topic": get(env, context, "t"), "postBadgesEnabled": "true"});
            inline(env, morph5, context, "raw", ["list/activity-column"], {"topic": get(env, context, "t"), "tagName": "div", "class": "num activity last"});
            attribute(env, attrMorph0, element9, "href", concat(env, [get(env, context, "t.lastPostUrl")]));
            attribute(env, attrMorph1, element9, "title", concat(env, [subexpr(env, context, "i18n", ["last_post"], {}), ": ", subexpr(env, context, "raw-date", [get(env, context, "t.bumped_at")], {})]));
            content(env, morph6, context, "t.last_poster_username");
            block(env, morph7, context, "unless", [get(env, context, "controller.hideCategory")], {}, child2, null);
            block(env, morph8, context, "if", [get(env, context, "controller.showParticipants")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","topic-list");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tbody");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),1,1);
          block(env, morph0, context, "each", [get(env, context, "topics")], {"keyword": "t"}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","alert alert-info");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topics")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/navigation-bar"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "navigation-item", [], {"content": get(env, context, "navItem"), "filterMode": get(env, context, "filterMode")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("ul");
        dom.setAttribute(el1,"class","drop");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
        block(env, morph0, context, "each", [get(env, context, "navItems")], {"keyword": "navItem"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("li");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("i");
      dom.setAttribute(el3,"class","fa fa-caret-down");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      element(env, element0, context, "action", ["toggleDrop"], {});
      content(env, morph0, context, "selectedNavItem.displayName");
      block(env, morph1, context, "if", [get(env, context, "expanded")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/discovery/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          dom.setAttribute(el1,"class","category-description");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"colspan","3");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1, 1]),1,1);
          content(env, morph0, context, "c.description_excerpt");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","badge-notification new-topic");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createElement("a");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element2 = dom.childAt(fragment, [0]);
                var morph0 = dom.createMorphAt(element2,0,0);
                var attrMorph0 = dom.createAttrMorph(element2, 'href');
                attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "t.url")], {})]));
                inline(env, morph0, context, "i18n", ["read_more"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              block(env, morph0, context, "unless", [get(env, context, "t.canClearPin")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"href","");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element1,0,0);
              var attrMorph0 = dom.createAttrMorph(element1, 'title');
              attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "i18n"), get(env, context, "topic.clear_pin.help")], {})]));
              element(env, element1, context, "action", ["clearPin", get(env, context, "t")], {});
              inline(env, morph0, context, "i18n", ["topic.clear_pin.title"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","topic-excerpt");
            var el2 = dom.createTextNode("\n                  ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("                ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element3 = dom.childAt(fragment, [1]);
            var morph0 = dom.createUnsafeMorphAt(element3,1,1);
            var morph1 = dom.createMorphAt(element3,3,3);
            var morph2 = dom.createMorphAt(element3,4,4);
            content(env, morph0, context, "t.excerpt");
            block(env, morph1, context, "if", [get(env, context, "t.excerptTruncated")], {}, child0, null);
            block(env, morph2, context, "if", [get(env, context, "t.canClearPin")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","main-link");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","topic-inset");
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("span");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("            ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","num posts");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var element5 = dom.childAt(element4, [1, 1]);
          var element6 = dom.childAt(element5, [7]);
          var morph0 = dom.createMorphAt(element5,1,1);
          var morph1 = dom.createMorphAt(element5,3,3);
          var morph2 = dom.createMorphAt(element5,5,5);
          var morph3 = dom.createUnsafeMorphAt(element6,0,0);
          var attrMorph0 = dom.createAttrMorph(element6, 'class');
          var attrMorph1 = dom.createAttrMorph(element6, 'title');
          var morph4 = dom.createMorphAt(element5,9,9);
          var morph5 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
          element(env, element4, context, "bind-attr", [], {"class": "t.archived :category-topic-link"});
          inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "t")});
          inline(env, morph1, context, "topic-link", [get(env, context, "t")], {});
          block(env, morph2, context, "if", [get(env, context, "t.unseen")], {}, child0, null);
          attribute(env, attrMorph0, element6, "class", concat(env, [subexpr(env, context, "cold-age-class", [get(env, context, "t.last_posted_at")], {})]));
          attribute(env, attrMorph1, element6, "title", concat(env, [subexpr(env, context, "raw-date", [get(env, context, "t.last_posted_at")], {})]));
          inline(env, morph3, context, "format-age", [get(env, context, "t.last_posted_at")], {});
          block(env, morph4, context, "if", [get(env, context, "t.hasExcerpt")], {}, child1, null);
          inline(env, morph5, context, "raw", ["list/post-count-or-badges"], {"topic": get(env, context, "t"), "postBadgesEnabled": "true"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "category-link", [get(env, context, "subcategory")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          dom.setAttribute(el1,"class","subcategories-list");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","subcategories");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("            ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),1,1);
          block(env, morph0, context, "each", [get(env, context, "c.subcategories")], {"keyword": "subcategory"}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","btn btn-small");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["editCategory", get(env, context, "c")], {});
          inline(env, morph0, context, "i18n", ["category.edit"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","category-list-item category");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("table");
        dom.setAttribute(el2,"class","topic-list");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("tr");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("th");
        dom.setAttribute(el4,"class","main-link");
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("footer");
        dom.setAttribute(el2,"class","clearfix");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var element8 = dom.childAt(element7, [1]);
        var element9 = dom.childAt(element7, [3]);
        var element10 = dom.childAt(element9, [1]);
        var element11 = dom.childAt(element9, [3]);
        var element12 = dom.childAt(element9, [5]);
        var attrMorph0 = dom.createAttrMorph(element7, 'style');
        var morph0 = dom.createMorphAt(dom.childAt(element8, [1, 1]),1,1);
        var morph1 = dom.createMorphAt(element8,3,3);
        var morph2 = dom.createMorphAt(element8,5,5);
        var morph3 = dom.createMorphAt(element8,6,6);
        var morph4 = dom.createMorphAt(element10,0,0);
        var attrMorph1 = dom.createAttrMorph(element10, 'title');
        var morph5 = dom.createMorphAt(dom.childAt(element10, [2]),0,0);
        var morph6 = dom.createMorphAt(element11,0,0);
        var attrMorph2 = dom.createAttrMorph(element11, 'title');
        var morph7 = dom.createMorphAt(dom.childAt(element11, [2]),0,0);
        var morph8 = dom.createMorphAt(element12,0,0);
        var attrMorph3 = dom.createAttrMorph(element12, 'title');
        var morph9 = dom.createMorphAt(dom.childAt(element12, [2]),0,0);
        var morph10 = dom.createMorphAt(element9,7,7);
        set(env, context, "c", blockArguments[0]);
        attribute(env, attrMorph0, element7, "style", concat(env, ["border-color: #", subexpr(env, context, "unbound", [get(env, context, "c.color")], {})]));
        inline(env, morph0, context, "category-title-link", [], {"category": get(env, context, "c")});
        block(env, morph1, context, "if", [get(env, context, "c.description_excerpt")], {}, child0, null);
        block(env, morph2, context, "each", [get(env, context, "c.topics")], {"keyword": "t"}, child1, null);
        block(env, morph3, context, "if", [get(env, context, "c.subcategories")], {}, child2, null);
        attribute(env, attrMorph1, element10, "title", concat(env, [subexpr(env, context, "i18n", ["year_desc"], {})]));
        inline(env, morph4, context, "number", [get(env, context, "c.topics_year")], {});
        inline(env, morph5, context, "i18n", ["category.this_year"], {});
        attribute(env, attrMorph2, element11, "title", concat(env, [subexpr(env, context, "i18n", ["month_desc"], {})]));
        inline(env, morph6, context, "number", [get(env, context, "c.topics_month")], {});
        inline(env, morph7, context, "i18n", ["month"], {});
        attribute(env, attrMorph3, element12, "title", concat(env, [subexpr(env, context, "i18n", ["week_desc"], {})]));
        inline(env, morph8, context, "number", [get(env, context, "c.topics_week")], {});
        inline(env, morph9, context, "i18n", ["week"], {});
        block(env, morph10, context, "if", [get(env, context, "controller.canEdit")], {}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "model.categories")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/discovery/topics"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","top-lists");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period"), "action": "changePeriod"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","alert alert-info");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element6,1,1);
          var morph1 = dom.createMorphAt(element6,3,3);
          element(env, element6, context, "action", ["showInserted"], {});
          inline(env, morph0, context, "count-i18n", [], {"key": "topic_count_", "suffix": get(env, context, "topicTrackingState.filter"), "count": get(env, context, "topicTrackingState.incomingCount")});
          inline(env, morph1, context, "i18n", ["click_to_show"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topicTrackingState.hasIncoming")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "topic-list", [], {"showPosters": true, "currentUser": get(env, context, "currentUser"), "hideCategory": get(env, context, "model.hideCategory"), "topics": get(env, context, "model.topics")});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'title');
          attribute(env, attrMorph0, element5, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element5, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          element(env, element4, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [0]);
            var morph0 = dom.createMorphAt(element2,0,0);
            element(env, element2, context, "action", ["createTopic"], {});
            inline(env, morph0, context, "i18n", ["topic.suggest_create_topic"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","education");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(element3,1,1);
          var morph2 = dom.createMorphAt(element3,3,3);
          content(env, morph0, context, "footerEducation");
          content(env, morph1, context, "footerMessage");
          block(env, morph2, context, "if", [get(env, context, "model.can_create_topic")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(", ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("br");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            var morph2 = dom.createMorphAt(element1,5,5);
            var morph3 = dom.createMorphAt(element1,7,7);
            var morph4 = dom.createMorphAt(element1,11,11);
            block(env, morph0, context, "link-to", ["discovery.categories"], {}, child0, null);
            block(env, morph1, context, "link-to", ["discovery.latest"], {}, child1, null);
            inline(env, morph2, context, "i18n", ["or"], {});
            inline(env, morph3, context, "i18n", ["filters.top.other_periods"], {});
            inline(env, morph4, context, "top-period-buttons", [], {"period": get(env, context, "period"), "action": "changePeriod"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","education");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(element0,1,1);
            var morph2 = dom.createMorphAt(element0,2,2);
            var morph3 = dom.createMorphAt(element0,4,4);
            var morph4 = dom.createMorphAt(element0,6,6);
            content(env, morph0, context, "footerEducation");
            content(env, morph1, context, "footerMessage");
            block(env, morph2, context, "link-to", ["discovery.categories"], {}, child0, null);
            inline(env, morph3, context, "i18n", ["or"], {});
            block(env, morph4, context, "link-to", ["discovery.latest"], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "latest")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","contents");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("footer");
      dom.setAttribute(el1,"class","topic-list-bottom");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element7 = dom.childAt(fragment, [0]);
      var element8 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element7,1,1);
      var morph1 = dom.createMorphAt(element7,3,3);
      var morph2 = dom.createMorphAt(element8,1,1);
      var morph3 = dom.createMorphAt(element8,3,3);
      block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
      block(env, morph1, context, "if", [get(env, context, "hasTopics")], {}, child2, null);
      inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
      block(env, morph3, context, "if", [get(env, context, "allLoaded")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/list/topic_list_item.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "  <div class='pull-left'>\n    <a href=\""
    + escapeExpression(helpers.get.call(depth0, "content.lastPostUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers.avatar || (depth0 && depth0.avatar) || helperMissing).call(depth0, "content.lastPoster", {"name":"avatar","hash":{
    'imageSize': ("large")
  },"hashTypes":{'imageSize': "STRING"},"hashContexts":{'imageSize': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a>\n  </div>\n  <div class='right'>\n";
},"3":function(depth0,helpers,partials,data) {
  return "  <div>\n";
  },"5":function(depth0,helpers,partials,data) {
  return "        <span class=\"badge-notification new-topic\"></span>\n";
  },"7":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "        <div class='category'>\n          "
    + escapeExpression(((helpers['category-link'] || (depth0 && depth0['category-link']) || helperMissing).call(depth0, "content.category", {"name":"category-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + "\n        </div>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<td>";
  stack1 = helpers.unless.call(depth0, "content.hasExcerpt", {"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.program(3, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "<div class='main-link'>\n      "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-status", {"name":"raw","hash":{
    'topic': ("content")
  },"hashTypes":{'topic': "ID"},"hashContexts":{'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n      "
    + escapeExpression(((helpers['topic-link'] || (depth0 && depth0['topic-link']) || helperMissing).call(depth0, "content", {"name":"topic-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data})))
    + "\n";
  stack1 = helpers['if'].call(depth0, "content.unseen", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(5, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "      "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/topic-excerpt", {"name":"raw","hash":{
    'topic': ("content")
  },"hashTypes":{'topic': "ID"},"hashContexts":{'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n    </div>\n\n    <div class='pull-right'>\n      "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "list/post-count-or-badges", {"name":"raw","hash":{
    'postBadgesEnabled': ("controller.showTopicPostBadges"),
    'topic': ("content")
  },"hashTypes":{'postBadgesEnabled': "ID",'topic': "ID"},"hashContexts":{'postBadgesEnabled': depth0,'topic': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n    </div>\n\n    <div class=\"topic-item-stats clearfix\">\n";
  stack1 = helpers.unless.call(depth0, "controller.hideCategory", {"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(7, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\n      "
    + escapeExpression(((helpers['plugin-outlet'] || (depth0 && depth0['plugin-outlet']) || helperMissing).call(depth0, "topic-list-tags", {"name":"plugin-outlet","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n\n      <div class=\"pull-right\">\n        <div class='num activity last'>\n          <span class=\"age activity\" title=\""
    + escapeExpression(helpers.get.call(depth0, "content.bumpedAtTitle", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\"><a href=\""
    + escapeExpression(helpers.get.call(depth0, "content.lastPostUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers['format-date'] || (depth0 && depth0['format-date']) || helperMissing).call(depth0, "content.bumpedAt", {"name":"format-date","hash":{
    'noTitle': ("true"),
    'format': ("tiny")
  },"hashTypes":{'noTitle': "STRING",'format': "STRING"},"hashContexts":{'noTitle': depth0,'format': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a></span>\n        </div>\n      </div>\n\n      <div class=\"clearfix\"></div>\n    </div>\n  </div>\n</td>\n";
},"useData":true});
Ember.TEMPLATES["mobile/modal/login"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("form");
        dom.setAttribute(el1,"id","login-form");
        dom.setAttribute(el1,"method","post");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("table");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-name");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-password");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("  \n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("a");
        dom.setAttribute(el6,"id","forgot-password-link");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1, 1]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [3]);
        var element5 = dom.childAt(element2, [5, 3, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [1, 1]),0,0);
        var morph3 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
        var morph4 = dom.createMorphAt(element5,0,0);
        inline(env, morph0, context, "i18n", ["login.username"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "loginName"), "placeholderKey": "login.email_placeholder", "id": "login-account-name", "autocorrect": "off", "autocapitalize": "off"});
        inline(env, morph2, context, "i18n", ["login.password"], {});
        inline(env, morph3, context, "text-field", [], {"value": get(env, context, "loginPassword"), "type": "password", "id": "login-account-password", "maxlength": "200"});
        element(env, element5, context, "action", ["showForgotPassword"], {});
        inline(env, morph4, context, "i18n", ["forgot_password.action"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.authenticating"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-large");
          dom.setAttribute(el1,"id","new-account-link");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          element(env, element0, context, "action", ["showCreateAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-large btn-primary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-unlock");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,3,3);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        element(env, element1, context, "bind-attr", [], {"disabled": "loginDisabled"});
        element(env, element1, context, "action", ["login"], {});
        content(env, morph0, context, "loginButtonText");
        block(env, morph1, context, "if", [get(env, context, "showSignupLink")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","login-alert");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element6 = dom.childAt(fragment, [0]);
      var element7 = dom.childAt(element6, [7]);
      var element8 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element6,1,1);
      var morph1 = dom.createMorphAt(element6,3,3);
      var morph2 = dom.createMorphAt(element6,5,5);
      var morph3 = dom.createMorphAt(element7,0,0);
      var morph4 = dom.createMorphAt(element8,1,1);
      var morph5 = dom.createMorphAt(element8,2,2);
      inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
      block(env, morph1, context, "if", [get(env, context, "canLoginLocal")], {}, child0, null);
      content(env, morph2, context, "authMessage");
      element(env, element7, context, "bind-attr", [], {"class": "alertClass"});
      content(env, morph3, context, "alert");
      block(env, morph4, context, "if", [get(env, context, "authenticate")], {}, child1, null);
      block(env, morph5, context, "if", [get(env, context, "canLoginLocal")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/users"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("div");
                dom.setAttribute(el1,"class","time-read");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                inline(env, morph0, context, "unbound", [get(env, context, "it.time_read")], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
              var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
              var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
              var morph5 = dom.createMorphAt(fragment,11,11,contextualElement);
              var morph6 = dom.createMorphAt(fragment,13,13,contextualElement);
              var morph7 = dom.createMorphAt(fragment,15,15,contextualElement);
              var morph8 = dom.createMorphAt(fragment,17,17,contextualElement);
              dom.insertBoundary(fragment, null);
              set(env, context, "it", blockArguments[0]);
              inline(env, morph0, context, "user-small", [], {"user": get(env, context, "it.user")});
              inline(env, morph1, context, "user-stat", [], {"value": get(env, context, "it.likes_received"), "label": "directory.likes_received", "icon": "heart"});
              inline(env, morph2, context, "user-stat", [], {"value": get(env, context, "it.likes_given"), "label": "directory.likes_given", "icon": "heart"});
              inline(env, morph3, context, "user-stat", [], {"value": get(env, context, "it.topic_count"), "label": "directory.topic_count"});
              inline(env, morph4, context, "user-stat", [], {"value": get(env, context, "it.post_count"), "label": "directory.post_count"});
              inline(env, morph5, context, "user-stat", [], {"value": get(env, context, "it.topics_entered"), "label": "directory.topics_entered"});
              inline(env, morph6, context, "user-stat", [], {"value": get(env, context, "it.posts_read"), "label": "directory.posts_read"});
              inline(env, morph7, context, "user-stat", [], {"value": get(env, context, "it.days_visited"), "label": "directory.days_visited"});
              block(env, morph8, context, "if", [get(env, context, "showTimeRead")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,1,1);
            var attrMorph0 = dom.createAttrMorph(element0, 'class');
            attribute(env, attrMorph0, element0, "class", concat(env, ["user ", subexpr(env, context, "if", [get(env, context, "ic.me"), "me"], {})]));
            block(env, morph0, context, "with", [get(env, context, "ic.model")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","total-rows");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          inline(env, morph0, context, "i18n", ["directory.total_rows"], {"count": get(env, context, "model.totalRows")});
          block(env, morph1, context, "each", [get(env, context, "model")], {"itemController": "directory-item", "keyword": "ic"}, child0, null);
          inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","clearfix");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          inline(env, morph0, context, "i18n", ["directory.no_results"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.length")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","directory");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix user-controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(element2,1,1);
      var morph1 = dom.createMorphAt(element2,3,3);
      var morph2 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period")});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "nameInput"), "placeholderKey": "directory.filter_name", "class": "filter-name"});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/archetype_options"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n   ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1]),1,1);
      var morph1 = dom.createMorphAt(element0,0,0);
      inline(env, morph0, context, "view", ["archetype-options"], {"archetype": get(env, context, "view.archetype")});
      element(env, element0, context, "action", ["closeModal"], {});
      inline(env, morph1, context, "i18n", ["post.archetypes.save"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/avatar_selector"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "custom_avatar_template"), "large"], {});
          inline(env, morph1, context, "i18n", ["user.change_avatar.uploaded_avatar"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_avatar.uploaded_avatar_empty"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","radio");
        dom.setAttribute(el2,"id","uploaded_avatar");
        dom.setAttribute(el2,"name","avatar");
        dom.setAttribute(el2,"value","uploaded");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        dom.setAttribute(el2,"for","uploaded_avatar");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph1 = dom.createMorphAt(element0,5,5);
        element(env, element1, context, "action", ["useUploadedAvatar"], {});
        block(env, morph0, context, "if", [get(env, context, "custom_avatar_template")], {}, child0, child1);
        inline(env, morph1, context, "avatar-uploader", [], {"user_id": get(env, context, "id"), "uploadedAvatarTemplate": get(env, context, "custom_avatar_template"), "uploadedAvatarId": get(env, context, "custom_avatar_upload_id"), "uploading": get(env, context, "uploading"), "done": "useUploadedAvatar"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","radio");
      dom.setAttribute(el4,"id","system-avatar");
      dom.setAttribute(el4,"name","avatar");
      dom.setAttribute(el4,"value","system");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","radio");
      dom.setAttribute(el4,"for","system-avatar");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","radio");
      dom.setAttribute(el4,"id","gravatar");
      dom.setAttribute(el4,"name","avatar");
      dom.setAttribute(el4,"value","gravatar");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","radio");
      dom.setAttribute(el4,"for","gravatar");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element3, [3]);
      var element6 = dom.childAt(element2, [3]);
      var element7 = dom.childAt(element6, [1]);
      var element8 = dom.childAt(element6, [3]);
      var element9 = dom.childAt(fragment, [2]);
      var element10 = dom.childAt(element9, [3]);
      var morph0 = dom.createMorphAt(element5,0,0);
      var morph1 = dom.createUnsafeMorphAt(element5,2,2);
      var morph2 = dom.createMorphAt(element8,0,0);
      var morph3 = dom.createUnsafeMorphAt(element8,2,2);
      var morph4 = dom.createMorphAt(element8,4,4);
      var morph5 = dom.createMorphAt(element6,5,5);
      var morph6 = dom.createMorphAt(element2,5,5);
      var morph7 = dom.createMorphAt(element9,1,1);
      var morph8 = dom.createMorphAt(element10,0,0);
      element(env, element4, context, "action", ["useSystem"], {});
      inline(env, morph0, context, "bound-avatar-template", [get(env, context, "system_avatar_template"), "large"], {});
      inline(env, morph1, context, "i18n", ["user.change_avatar.letter_based"], {});
      element(env, element7, context, "action", ["useGravatar"], {});
      inline(env, morph2, context, "bound-avatar-template", [get(env, context, "gravatar_avatar_template"), "large"], {});
      inline(env, morph3, context, "i18n", ["user.change_avatar.gravatar"], {});
      content(env, morph4, context, "email");
      inline(env, morph5, context, "d-button", [], {"action": "refreshGravatar", "title": "user.change_avatar.refresh_gravatar_title", "disabled": get(env, context, "gravatarRefreshDisabled"), "icon": "refresh"});
      block(env, morph6, context, "if", [get(env, context, "allowAvatarUpload")], {}, child0, null);
      inline(env, morph7, context, "d-button", [], {"action": "saveAvatarSelection", "class": "btn-primary", "disabled": get(env, context, "uploading"), "label": "save"});
      element(env, element10, context, "action", ["closeModal"], {});
      inline(env, morph8, context, "i18n", ["cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_actions_buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "button", blockArguments[0]);
          inline(env, morph0, context, "d-button", [], {"action": get(env, context, "button.action"), "label": get(env, context, "button.label")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        set(env, context, "row", blockArguments[0]);
        block(env, morph0, context, "each", [get(env, context, "row")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "buttonRows")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_change_category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "changeCategory", "label": "topics.bulk.change_category"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "i18n", ["topics.bulk.choose_new_category"], {});
      inline(env, morph1, context, "category-chooser", [], {"value": get(env, context, "newCategoryId")});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_notification_level"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","controls");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("strong");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","description");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        var morph2 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
        inline(env, morph0, context, "radio-button", [], {"value": get(env, context, "level.id"), "name": "notification_level", "selection": get(env, context, "controller.notificationLevelId")});
        inline(env, morph1, context, "unbound", [get(env, context, "level.name")], {});
        inline(env, morph2, context, "unbound", [get(env, context, "level.description")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("button");
      dom.setAttribute(el1,"class","btn");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element1,0,0);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "notificationLevels")], {"keyword": "level"}, child0, null);
      element(env, element1, context, "bind-attr", [], {"disabled": "disabled"});
      element(env, element1, context, "action", ["changeNotificationLevel"], {});
      inline(env, morph1, context, "i18n", ["topics.bulk.notification_level"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/change-owner"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      var morph4 = dom.createMorphAt(element2,0,0);
      inline(env, morph0, context, "i18n", ["topic.change_owner.instructions"], {"count": get(env, context, "selectedPostsCount"), "old_user": get(env, context, "selectedPostsUsername")});
      inline(env, morph1, context, "i18n", ["topic.change_owner.instructions_warn"], {});
      inline(env, morph2, context, "i18n", ["topic.change_owner.label"], {});
      inline(env, morph3, context, "user-selector", [], {"single": "true", "usernames": get(env, context, "new_user"), "placeholderKey": "topic.change_owner.placeholder"});
      element(env, element2, context, "bind-attr", [], {"disabled": "buttonDisabled"});
      element(env, element2, context, "action", ["changeOwnershipOfPosts"], {});
      content(env, morph4, context, "buttonTitle");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/change-timestamp"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, element = hooks.element, get = hooks.get, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var element2 = dom.childAt(element0, [5]);
      var element3 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element2,1,1);
      var morph3 = dom.createMorphAt(element2,3,3);
      var morph4 = dom.createMorphAt(element3,0,0);
      inline(env, morph0, context, "i18n", ["topic.change_timestamp.instructions"], {});
      element(env, element1, context, "bind-attr", [], {"class": ":alert :alert-error validTimestamp::hidden"});
      inline(env, morph1, context, "i18n", ["topic.change_timestamp.invalid_timestamp"], {});
      inline(env, morph2, context, "input", [], {"type": "date", "value": get(env, context, "date")});
      inline(env, morph3, context, "input", [], {"type": "time", "value": get(env, context, "time")});
      element(env, element3, context, "bind-attr", [], {"disabled": "buttonDisabled"});
      element(env, element3, context, "action", ["changeTimestamp"], {});
      content(env, morph4, context, "buttonTitle");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/create-account"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-username");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n                ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n                 ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n                ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element9 = dom.childAt(fragment, [1]);
            var element10 = dom.childAt(element9, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element9, [1, 0]),0,0);
            var morph1 = dom.createMorphAt(element10,1,1);
            var morph2 = dom.createMorphAt(element10,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(fragment, [3, 3, 0]),0,0);
            inline(env, morph0, context, "i18n", ["user.username.title"], {});
            inline(env, morph1, context, "input", [], {"value": get(env, context, "accountUsername"), "id": "new-account-username", "name": "username", "maxlength": get(env, context, "maxUsernameLength")});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "usernameValidation"), "id": "username-validation"});
            inline(env, morph3, context, "i18n", ["user.username.instructions"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"style","width:80px");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-name");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"style","width:496px");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode(" ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element7 = dom.childAt(fragment, [1]);
            var element8 = dom.childAt(element7, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element7, [1, 1]),0,0);
            var morph1 = dom.createMorphAt(element8,1,1);
            var morph2 = dom.createMorphAt(element8,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(fragment, [3, 3, 0]),0,0);
            inline(env, morph0, context, "i18n", ["user.name.title"], {});
            inline(env, morph1, context, "text-field", [], {"value": get(env, context, "accountName"), "id": "new-account-name"});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "nameValidation")});
            content(env, morph3, context, "nameInstructions");
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-password");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n               ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            var el4 = dom.createElement("i");
            dom.setAttribute(el4,"class","fa fa-exclamation-triangle");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode(" ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content, element = hooks.element;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element3 = dom.childAt(fragment, [1]);
            var element4 = dom.childAt(element3, [3]);
            var element5 = dom.childAt(fragment, [3, 3]);
            var element6 = dom.childAt(element5, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 0]),0,0);
            var morph1 = dom.createMorphAt(element4,1,1);
            var morph2 = dom.createMorphAt(element4,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
            var morph4 = dom.createMorphAt(element6,2,2);
            inline(env, morph0, context, "i18n", ["user.password.title"], {});
            inline(env, morph1, context, "password-field", [], {"value": get(env, context, "accountPassword"), "type": "password", "id": "new-account-password", "capsLockOn": get(env, context, "capsLockOn")});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "passwordValidation")});
            content(env, morph3, context, "passwordInstructions");
            element(env, element6, context, "bind-attr", [], {"class": ":caps-lock-warning capsLockOn::invisible"});
            inline(env, morph4, context, "i18n", ["login.caps_lock_warning"], {});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "user-field", [], {"field": get(env, context, "f.field"), "value": get(env, context, "f.value")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","user-fields");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "each", [get(env, context, "userFields")], {"keyword": "f"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("form");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("table");
          var el4 = dom.createTextNode("\n\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","input");
          var el5 = dom.createTextNode("\n              ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          dom.setAttribute(el5,"class","label");
          var el6 = dom.createElement("label");
          dom.setAttribute(el6,"for","new-account-email");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n              ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createTextNode("\n              ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n               ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n              ");
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","instructions");
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createElement("label");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","password-confirmation");
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createElement("label");
          dom.setAttribute(el6,"for","new-account-password-confirmation");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createTextNode("\n            ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n            ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n          ");
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element11 = dom.childAt(fragment, [1, 1]);
          var element12 = dom.childAt(element11, [1]);
          var element13 = dom.childAt(element12, [1]);
          var element14 = dom.childAt(element13, [3]);
          var element15 = dom.childAt(element12, [13]);
          var element16 = dom.childAt(element15, [3]);
          var morph0 = dom.createMorphAt(dom.childAt(element13, [1, 0]),0,0);
          var morph1 = dom.createMorphAt(element14,1,1);
          var morph2 = dom.createMorphAt(element14,3,3);
          var morph3 = dom.createMorphAt(dom.childAt(element12, [3, 3, 0]),0,0);
          var morph4 = dom.createMorphAt(element12,5,5);
          var morph5 = dom.createMorphAt(element12,7,7);
          var morph6 = dom.createMorphAt(element12,9,9);
          var morph7 = dom.createMorphAt(element12,11,11);
          var morph8 = dom.createMorphAt(dom.childAt(element15, [1, 0]),0,0);
          var morph9 = dom.createMorphAt(element16,1,1);
          var morph10 = dom.createMorphAt(element16,3,3);
          var morph11 = dom.createMorphAt(element11,3,3);
          inline(env, morph0, context, "i18n", ["user.email.title"], {});
          inline(env, morph1, context, "input", [], {"type": "email", "value": get(env, context, "accountEmail"), "id": "new-account-email", "disabled": get(env, context, "emailValidated"), "name": "email", "autofocus": "autofocus"});
          inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "emailValidation")});
          inline(env, morph3, context, "i18n", ["user.email.instructions"], {});
          block(env, morph4, context, "if", [get(env, context, "usernameRequired")], {}, child0, null);
          block(env, morph5, context, "if", [get(env, context, "siteSettings.enable_names")], {}, child1, null);
          inline(env, morph6, context, "plugin-outlet", ["create-account-before-password"], {});
          block(env, morph7, context, "if", [get(env, context, "passwordRequired")], {}, child2, null);
          inline(env, morph8, context, "i18n", ["user.password_confirmation.title"], {});
          inline(env, morph9, context, "input", [], {"type": "password", "value": get(env, context, "accountPasswordConfirm"), "id": "new-account-confirmation"});
          inline(env, morph10, context, "input", [], {"value": get(env, context, "accountChallenge"), "id": "new-account-challenge"});
          block(env, morph11, context, "if", [get(env, context, "userFields")], {}, child3, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("button");
            dom.setAttribute(el1,"class","btn btn-large");
            dom.setAttribute(el1,"id","login-link");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,1,1);
            element(env, element0, context, "action", ["showLogin"], {});
            inline(env, morph0, context, "i18n", ["log_in"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","modal-footer");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("button");
          dom.setAttribute(el2,"class","btn btn-large btn-primary");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var element2 = dom.childAt(element1, [1]);
          var morph0 = dom.createMorphAt(element2,0,0);
          var morph1 = dom.createMorphAt(element1,3,3);
          element(env, element2, context, "bind-attr", [], {"disabled": "submitDisabled"});
          element(env, element2, context, "action", ["createAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          block(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "formSubmitted"), "size": "small"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","modal-body");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element17 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element17,1,1);
        var morph1 = dom.createMorphAt(element17,3,3);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "unless", [get(env, context, "hasAuthOptions")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showCreateForm")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "showCreateForm")], {}, child2, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "complete")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/dismiss-read"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1]),1,1);
      var morph1 = dom.createMorphAt(element0,0,0);
      inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "topics.bulk.also_dismiss_topics", "checked": get(env, context, "dismissTopics")});
      element(env, element0, context, "action", ["dismissReadTopics", get(env, context, "dismissTopics")], {});
      inline(env, morph1, context, "i18n", ["topics.bulk.dismiss"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/edit-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "security"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "tab", blockArguments[0]);
        inline(env, morph0, context, "component", [get(env, context, "tab")], {"selectedTab": get(env, context, "selectedTab"), "category": get(env, context, "model")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-danger pull-right", "disabled": get(env, context, "deleteDisabled"), "action": "deleteCategory", "icon": "trash-o", "label": "category.delete"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","cannot_delete_reason");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
        content(env, morph0, context, "model.cannot_delete_reason");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","nav nav-pills");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element0, [5]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element1,5,5);
      var morph3 = dom.createMorphAt(element1,7,7);
      var morph4 = dom.createMorphAt(element1,9,9);
      var morph5 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph6 = dom.createMorphAt(element2,1,1);
      var morph7 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "general"});
      block(env, morph1, context, "unless", [get(env, context, "model.isUncategorizedCategory")], {}, child0, null);
      inline(env, morph2, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "settings"});
      inline(env, morph3, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "images"});
      inline(env, morph4, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "topic-template"});
      block(env, morph5, context, "each", [get(env, context, "panels")], {}, child1, null);
      inline(env, morph6, context, "d-button", [], {"id": "save-category", "class": "btn-primary", "disabled": get(env, context, "disabled"), "action": "saveCategory", "label": get(env, context, "saveLabel")});
      block(env, morph7, context, "if", [get(env, context, "model.can_delete")], {}, child2, child3);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/edit-topic-auto-close"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        inline(env, morph0, context, "fa-icon", ["warning"], {});
        content(env, morph1, context, "willCloseI18n");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [3]);
      var element4 = dom.childAt(element3, [3]);
      var morph0 = dom.createMorphAt(element2,1,1);
      var morph1 = dom.createMorphAt(element2,3,3);
      var morph2 = dom.createMorphAt(element3,1,1);
      var morph3 = dom.createMorphAt(element4,0,0);
      var morph4 = dom.createMorphAt(element3,5,5);
      var morph5 = dom.createMorphAt(element3,7,7);
      inline(env, morph0, context, "auto-close-form", [], {"autoCloseTime": get(env, context, "model.auto_close_time"), "autoCloseValid": get(env, context, "auto_close_valid"), "autoCloseBasedOnLastPost": get(env, context, "model.details.auto_close_based_on_last_post"), "limited": get(env, context, "model.details.auto_close_based_on_last_post")});
      block(env, morph1, context, "if", [get(env, context, "willCloseImmediately")], {}, child0, null);
      inline(env, morph2, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "disable_submit"), "label": "topic.auto_close_save", "action": "saveAutoClose"});
      element(env, element4, context, "action", ["closeModal"], {});
      inline(env, morph3, context, "i18n", ["cancel"], {});
      inline(env, morph4, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")});
      inline(env, morph5, context, "d-button", [], {"class": "pull-right", "action": "removeAutoClose", "label": "topic.auto_close_remove"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/feature-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["topic.feature_topic.already_pinned_globally"], {"count": get(env, context, "pinnedGloballyCount")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["topic.feature_topic.not_pinned_globally"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "pinnedGloballyCount")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
          inline(env, morph1, context, "i18n", ["topic.feature_topic.global_pin_note"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            content(env, morph0, context, "alreadyPinnedMessage");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
          inline(env, morph1, context, "i18n", ["topic.feature_topic.pin_note"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element4 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element4,1,1);
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element4, [3]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [5]),0,0);
        block(env, morph0, context, "if", [get(env, context, "model.pinned_globally")], {}, child0, child1);
        content(env, morph1, context, "unPinMessage");
        inline(env, morph2, context, "d-button", [], {"action": "unpin", "icon": "thumb-tack", "label": "topic.feature.unpin", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "alreadyPinnedMessage");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["topic.feature_topic.already_pinned_globally"], {"count": get(env, context, "pinnedGloballyCount")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["topic.feature_topic.not_pinned_globally"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "pinnedGloballyCount")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        dom.setAttribute(el3,"class","with-validation");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("hr");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        dom.setAttribute(el3,"class","with-validation");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var element1 = dom.childAt(element0, [5]);
        var element2 = dom.childAt(fragment, [5, 1]);
        var element3 = dom.childAt(element2, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph2 = dom.createUnsafeMorphAt(element1,1,1);
        var morph3 = dom.createMorphAt(element1,3,3);
        var morph4 = dom.createMorphAt(element1,5,5);
        var morph5 = dom.createMorphAt(element1,7,7);
        var morph6 = dom.createMorphAt(dom.childAt(element0, [7]),1,1);
        var morph7 = dom.createMorphAt(dom.childAt(element2, [1]),1,1);
        var morph8 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
        var morph9 = dom.createMorphAt(element3,1,1);
        var morph10 = dom.createMorphAt(element3,3,3);
        var morph11 = dom.createMorphAt(element3,5,5);
        var morph12 = dom.createMorphAt(element3,7,7);
        var morph13 = dom.createMorphAt(dom.childAt(element2, [7]),1,1);
        block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
        inline(env, morph1, context, "i18n", ["topic.feature_topic.pin_note"], {});
        content(env, morph2, context, "pinMessage");
        inline(env, morph3, context, "fa-icon", ["clock-o"], {});
        inline(env, morph4, context, "date-picker", [], {"value": get(env, context, "model.pinnedInCategoryUntil")});
        inline(env, morph5, context, "popup-input-tip", [], {"validation": get(env, context, "pinInCategoryValidation"), "shownAt": get(env, context, "pinInCategoryTipShownAt")});
        inline(env, morph6, context, "d-button", [], {"action": "pin", "icon": "thumb-tack", "label": "topic.feature.pin", "class": "btn-primary"});
        block(env, morph7, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child1, null);
        inline(env, morph8, context, "i18n", ["topic.feature_topic.global_pin_note"], {});
        inline(env, morph9, context, "i18n", ["topic.feature_topic.pin_globally"], {});
        inline(env, morph10, context, "fa-icon", ["clock-o"], {});
        inline(env, morph11, context, "date-picker", [], {"value": get(env, context, "model.pinnedGloballyUntil")});
        inline(env, morph12, context, "popup-input-tip", [], {"validation": get(env, context, "pinGloballyValidation"), "shownAt": get(env, context, "pinGloballyTipShownAt")});
        inline(env, morph13, context, "d-button", [], {"action": "pinGlobally", "icon": "thumb-tack", "label": "topic.feature.pin_globally", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["topic.feature_topic.banner_exists"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["topic.feature_topic.no_banner_exists"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "bannerCount")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["topic.feature_topic.remove_banner"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["topic.feature_topic.make_banner"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "removeBanner", "icon": "thumb-tack", "label": "topic.feature.remove_banner", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "makeBanner", "icon": "thumb-tack", "label": "topic.feature.make_banner", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body feature-topic");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("hr");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","feature-section");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","desc");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"class","pull-right");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element5 = dom.childAt(fragment, [0]);
      var element6 = dom.childAt(element5, [5, 1]);
      var element7 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(element5,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element6, [1]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element6, [3]),1,1);
      var morph3 = dom.createMorphAt(dom.childAt(element6, [5]),1,1);
      var morph4 = dom.createMorphAt(dom.childAt(element6, [7]),1,1);
      var morph5 = dom.createMorphAt(element7,0,0);
      block(env, morph0, context, "if", [get(env, context, "model.pinned_at")], {}, child0, child1);
      block(env, morph1, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child2, null);
      inline(env, morph2, context, "i18n", ["topic.feature_topic.banner_note"], {});
      block(env, morph3, context, "if", [get(env, context, "model.isBanner")], {}, child3, child4);
      block(env, morph4, context, "if", [get(env, context, "model.isBanner")], {}, child5, child6);
      element(env, element7, context, "action", ["closeModal"], {});
      inline(env, morph5, context, "i18n", ["cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/flag"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element6 = dom.childAt(fragment, [3]);
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(element6,0,0);
            inline(env, morph0, context, "textarea", [], {"name": "message", "class": "flag-message", "placeholder": get(env, context, "f.customPlaceholder"), "value": get(env, context, "f.message")});
            element(env, element6, context, "bind-attr", [], {"class": ":custom-message-length f.customMessageLengthClasses"});
            content(env, morph1, context, "f.customMessageLength");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("hr");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["flagging.notify_staff"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("label");
          dom.setAttribute(el2,"class","radio");
          var el3 = dom.createElement("input");
          dom.setAttribute(el3,"type","radio");
          dom.setAttribute(el3,"name","post_action_type_index");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode(" ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","description");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [3]);
          var element8 = dom.childAt(element7, [1]);
          var element9 = dom.childAt(element8, [0]);
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var attrMorph0 = dom.createAttrMorph(element9, 'id');
          var morph1 = dom.createUnsafeMorphAt(dom.childAt(element8, [2]),0,0);
          var morph2 = dom.createMorphAt(element7,3,3);
          var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
          dom.insertBoundary(fragment, null);
          content(env, morph0, context, "f.formattedName");
          attribute(env, attrMorph0, element9, "id", concat(env, ["radio_", subexpr(env, context, "unbound", [get(env, context, "f.model.name_key")], {})]));
          element(env, element9, context, "action", ["changePostActionType", get(env, context, "f")], {});
          content(env, morph1, context, "f.model.description");
          block(env, morph2, context, "if", [get(env, context, "f.showMessageInput")], {}, child0, null);
          block(env, morph3, context, "if", [get(env, context, "staffFlagsAvailable")], {}, child1, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","description");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
            content(env, morph0, context, "f.model.description");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [3]);
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(element2,0,0);
            inline(env, morph0, context, "textarea", [], {"name": "message", "class": "flag-message", "placeholder": get(env, context, "f.customPlaceholder"), "value": get(env, context, "f.message")});
            element(env, element2, context, "bind-attr", [], {"class": ":custom-message-length f.customMessageLengthClasses"});
            content(env, morph1, context, "f.customMessageLength");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("label");
          dom.setAttribute(el2,"class","radio");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("input");
          dom.setAttribute(el3,"type","radio");
          dom.setAttribute(el3,"name","post_action_type_index");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode(" ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("strong");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var element4 = dom.childAt(element3, [1]);
          var element5 = dom.childAt(element4, [1]);
          var attrMorph0 = dom.createAttrMorph(element5, 'id');
          var morph0 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
          var morph1 = dom.createMorphAt(element4,5,5);
          var morph2 = dom.createMorphAt(element3,3,3);
          attribute(env, attrMorph0, element5, "id", concat(env, ["radio_", subexpr(env, context, "unbound", [get(env, context, "f.model.name_key")], {})]));
          element(env, element5, context, "action", ["changePostActionType", get(env, context, "f")], {});
          content(env, morph0, context, "f.formattedName");
          block(env, morph1, context, "if", [get(env, context, "f.showDescription")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "f.showMessageInput")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "f.isNotifyUser")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["flagging.cant"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-gavel");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element1, 'title');
        var morph0 = dom.createMorphAt(element1,1,1);
        attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.take_action_tooltip"], {})]));
        element(env, element1, context, "action", ["takeAction"], {});
        element(env, element1, context, "bind-attr", [], {"disabled": "submitDisabled"});
        inline(env, morph0, context, "i18n", ["flagging.take_action"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-exclamation-triangle");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'title');
        var morph0 = dom.createMorphAt(element0,2,2);
        attribute(env, attrMorph0, element0, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.delete_spammer"], {})]));
        element(env, element0, context, "action", ["deleteSpammer", get(env, context, "userDetails")], {});
        element(env, element0, context, "bind-attr", [], {"disabled": "submitDisabled"});
        inline(env, morph0, context, "i18n", ["flagging.delete_spammer"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body flag-modal");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("span");
      dom.setAttribute(el2,"class","hint");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element10 = dom.childAt(fragment, [2]);
      var element11 = dom.childAt(element10, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1]),1,1);
      var morph1 = dom.createUnsafeMorphAt(element11,0,0);
      var attrMorph0 = dom.createAttrMorph(element11, 'title');
      var morph2 = dom.createMorphAt(element10,3,3);
      var morph3 = dom.createMorphAt(element10,5,5);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element10, [7]),0,0);
      block(env, morph0, context, "each", [get(env, context, "flagsAvailable")], {"itemController": "flag-action-type", "keyword": "f"}, child0, child1);
      attribute(env, attrMorph0, element11, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.submit_tooltip"], {})]));
      element(env, element11, context, "action", ["createFlag"], {});
      element(env, element11, context, "bind-attr", [], {"disabled": "submitDisabled"});
      content(env, morph1, context, "submitText");
      block(env, morph2, context, "if", [get(env, context, "canTakeAction")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "canDeleteSpammer")], {}, child3, null);
      inline(env, morph4, context, "i18n", ["flagging.private_reminder"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/forgot-password"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"for","username-or-email");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("button");
      dom.setAttribute(el3,"class","btn btn-large btn-primary");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element0, [3, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element2,0,0);
      inline(env, morph0, context, "i18n", ["forgot_password.invite"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "accountEmailOrUsername"), "placeholderKey": "login.email_placeholder", "id": "username-or-email", "autocorrect": "off", "autocapitalize": "off"});
      element(env, element2, context, "bind-attr", [], {"disabled": "submitDisabled"});
      element(env, element2, context, "action", ["submit"], {});
      inline(env, morph2, context, "i18n", ["forgot_password.reset"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/history"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "boundI18n", [get(env, context, "revisionsTextKey")], {"previousBinding": "previousVersion", "currentBinding": "model.current_version", "totalBinding": "model.version_count"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "hideVersion", "icon": "trash-o", "title": "post.revisions.controls.hide", "class": "btn-danger", "disabled": get(env, context, "loading")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showVersion", "icon": "undo", "title": "post.revisions.controls.show", "disabled": get(env, context, "loading")});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "displaySideBySide", "label": "post.revisions.displays.side_by_side.button", "title": "post.revisions.displays.side_by_side.title", "class": get(env, context, "sideBySideClass")});
        inline(env, morph1, context, "d-button", [], {"action": "displaySideBySideMarkdown", "label": "post.revisions.displays.side_by_side_markdown.button", "title": "post.revisions.displays.side_by_side_markdown.title", "class": get(env, context, "sideBySideMarkdownClass")});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.avatar_template"), "small"], {});
        content(env, morph1, context, "model.username");
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      — ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","edit-reason");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "model.edit_reason");
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        → ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.user_changes.previous.avatar_template"), "small"], {});
          content(env, morph1, context, "model.user_changes.previous.username");
          inline(env, morph2, context, "bound-avatar-template", [get(env, context, "model.user_changes.current.avatar_template"), "small"], {});
          content(env, morph3, context, "model.user_changes.current.username");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "pencil-square-o", "secondary": get(env, context, "wikiDisabled")});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "shield", "disabled": get(env, context, "postTypeDisabled")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" → ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createUnsafeMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "previousCategory");
          content(env, morph1, context, "currentCategory");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.user_changes")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.wiki_changes")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.post_type_changes")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.category_id_changes")], {}, child3, null);
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h2");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1, 1]),0,0);
        content(env, morph0, context, "titleDiff");
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          → ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element1,1,1);
          var morph1 = dom.createMorphAt(element1,3,3);
          var morph2 = dom.createMorphAt(element1,5,5);
          var morph3 = dom.createMorphAt(element1,7,7);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.user_changes.previous.avatar_template"), "small"], {});
          content(env, morph1, context, "model.user_changes.previous.username");
          inline(env, morph2, context, "bound-avatar-template", [get(env, context, "model.user_changes.current.avatar_template"), "small"], {});
          content(env, morph3, context, "model.user_changes.current.username");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "pencil-square-o", "secondary": get(env, context, "wikiDisabled")});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "shield", "disabled": get(env, context, "postTypeDisabled")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" → ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createUnsafeMorphAt(element0,1,1);
          var morph1 = dom.createUnsafeMorphAt(element0,3,3);
          content(env, morph0, context, "previousCategory");
          content(env, morph1, context, "currentCategory");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "user_changes")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.wiki_changes")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.post_type_changes")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.category_id_changes")], {}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","revision-controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","revision-numbers");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","display-modes");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","revision-details");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","date");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","revisions");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","row");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element4, [5]);
      var element6 = dom.childAt(element3, [3]);
      var element7 = dom.childAt(element2, [3]);
      var element8 = dom.childAt(element2, [5]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(element5,1,1);
      var morph3 = dom.createMorphAt(element4,7,7);
      var morph4 = dom.createMorphAt(element4,9,9);
      var morph5 = dom.createMorphAt(element4,11,11);
      var morph6 = dom.createMorphAt(element4,12,12);
      var morph7 = dom.createMorphAt(element6,1,1);
      var morph8 = dom.createMorphAt(element6,3,3);
      var morph9 = dom.createMorphAt(element7,1,1);
      var morph10 = dom.createMorphAt(element7,3,3);
      var morph11 = dom.createMorphAt(dom.childAt(element7, [5]),0,0);
      var morph12 = dom.createMorphAt(element7,7,7);
      var morph13 = dom.createMorphAt(element7,8,8);
      var morph14 = dom.createMorphAt(element8,1,1);
      var morph15 = dom.createMorphAt(element8,2,2);
      var morph16 = dom.createMorphAt(element8,4,4);
      var morph17 = dom.createUnsafeMorphAt(dom.childAt(element8, [6]),1,1);
      inline(env, morph0, context, "d-button", [], {"action": "loadFirstVersion", "icon": "fast-backward", "title": "post.revisions.controls.first", "disabled": get(env, context, "loadFirstDisabled")});
      inline(env, morph1, context, "d-button", [], {"action": "loadPreviousVersion", "icon": "backward", "title": "post.revisions.controls.previous", "disabled": get(env, context, "loadPreviousDisabled")});
      element(env, element5, context, "bind-attr", [], {"class": "displayRevisions::invisible"});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading"), "size": "small"}, child0, null);
      inline(env, morph3, context, "d-button", [], {"action": "loadNextVersion", "icon": "forward", "title": "post.revisions.controls.next", "disabled": get(env, context, "loadNextDisabled")});
      inline(env, morph4, context, "d-button", [], {"action": "loadLastVersion", "icon": "fast-forward", "title": "post.revisions.controls.last", "disabled": get(env, context, "loadLastDisabled")});
      block(env, morph5, context, "if", [get(env, context, "displayHide")], {}, child1, null);
      block(env, morph6, context, "if", [get(env, context, "displayShow")], {}, child2, null);
      inline(env, morph7, context, "d-button", [], {"action": "displayInline", "label": "post.revisions.displays.inline.button", "title": "post.revisions.displays.inline.title", "class": get(env, context, "inlineClass")});
      block(env, morph8, context, "unless", [get(env, context, "site.mobileView")], {}, child3, null);
      inline(env, morph9, context, "fa-icon", ["pencil"], {});
      block(env, morph10, context, "link-to", ["user", get(env, context, "model.username")], {}, child4, null);
      inline(env, morph11, context, "bound-date", [get(env, context, "model.created_at")], {});
      block(env, morph12, context, "if", [get(env, context, "model.edit_reason")], {}, child5, null);
      block(env, morph13, context, "unless", [get(env, context, "site.mobileView")], {}, child6, null);
      element(env, element8, context, "bind-attr", [], {"class": "hiddenClasses"});
      block(env, morph14, context, "if", [get(env, context, "model.title_changes")], {}, child7, null);
      block(env, morph15, context, "if", [get(env, context, "site.mobileView")], {}, child8, null);
      inline(env, morph16, context, "plugin-outlet", ["post-revisions"], {});
      content(env, morph17, context, "bodyDiff");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/invite"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-error");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"class","close");
        dom.setAttribute(el2,"data-dismiss","alert");
        var el3 = dom.createTextNode("×");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),3,3);
        content(env, morph0, context, "errorMessage");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "successMessage");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "user-selector", [], {"single": "true", "allowAny": true, "excludeCurrentUser": "true", "usernames": get(env, context, "emailOrUsername"), "allowedUsers": "true", "topicId": get(env, context, "topicId"), "placeholderKey": get(env, context, "placeholderKey")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "user-selector", [], {"single": "true", "allowAny": true, "excludeCurrentUser": "true", "usernames": get(env, context, "emailOrUsername"), "placeholderKey": get(env, context, "placeholderKey")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "isPrivateTopic")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "emailOrUsername"), "placeholderKey": "topic.invite_reply.email_placeholder"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "groupInstructions");
          inline(env, morph1, context, "group-selector", [], {"groupFinder": get(env, context, "groupFinder"), "groupNames": get(env, context, "model.groupNames"), "placeholderKey": "topic.invite_private.group_name"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("label");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
        dom.insertBoundary(fragment, null);
        content(env, morph0, context, "inviteInstructions");
        block(env, morph1, context, "if", [get(env, context, "allowExistingMembers")], {}, child0, child1);
        block(env, morph2, context, "if", [get(env, context, "showGroups")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-primary", "action": "closeModal", "label": "close"});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "link", "action": "generateInvitelink", "class": "btn-primary", "disabled": get(env, context, "disabledCopyLink"), "label": "user.invited.generate_link"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "d-button", [], {"icon": "envelope", "action": "createInvite", "class": "btn-primary", "disabled": get(env, context, "disabled"), "label": get(env, context, "buttonTitle")});
        block(env, morph1, context, "if", [get(env, context, "showCopyInviteButton")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body invite-modal");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,2,2);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      block(env, morph0, context, "if", [get(env, context, "model.error")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "model.finished")], {}, child1, child2);
      block(env, morph2, context, "if", [get(env, context, "model.finished")], {}, child3, child4);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/keyboard-shortcuts-help"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","keyboard-shortcuts-help");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element1, [7]);
      var element4 = dom.childAt(element0, [3]);
      var element5 = dom.childAt(element4, [3]);
      var element6 = dom.childAt(element0, [5]);
      var element7 = dom.childAt(element6, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element2, [1]),0,0);
      var morph2 = dom.createUnsafeMorphAt(dom.childAt(element2, [3]),0,0);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element2, [5]),0,0);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element2, [7]),0,0);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element2, [9]),0,0);
      var morph6 = dom.createUnsafeMorphAt(dom.childAt(element2, [11]),0,0);
      var morph7 = dom.createUnsafeMorphAt(dom.childAt(element2, [13]),0,0);
      var morph8 = dom.createUnsafeMorphAt(dom.childAt(element2, [15]),0,0);
      var morph9 = dom.createUnsafeMorphAt(dom.childAt(element2, [17]),0,0);
      var morph10 = dom.createMorphAt(dom.childAt(element1, [5]),0,0);
      var morph11 = dom.createUnsafeMorphAt(dom.childAt(element3, [1]),0,0);
      var morph12 = dom.createUnsafeMorphAt(dom.childAt(element3, [3]),0,0);
      var morph13 = dom.createUnsafeMorphAt(dom.childAt(element3, [5]),0,0);
      var morph14 = dom.createUnsafeMorphAt(dom.childAt(element3, [7]),0,0);
      var morph15 = dom.createUnsafeMorphAt(dom.childAt(element3, [9]),0,0);
      var morph16 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph17 = dom.createUnsafeMorphAt(dom.childAt(element5, [1]),0,0);
      var morph18 = dom.createUnsafeMorphAt(dom.childAt(element5, [3]),0,0);
      var morph19 = dom.createUnsafeMorphAt(dom.childAt(element5, [5]),0,0);
      var morph20 = dom.createUnsafeMorphAt(dom.childAt(element5, [7]),0,0);
      var morph21 = dom.createUnsafeMorphAt(dom.childAt(element5, [9]),0,0);
      var morph22 = dom.createUnsafeMorphAt(dom.childAt(element5, [11]),0,0);
      var morph23 = dom.createUnsafeMorphAt(dom.childAt(element5, [13]),0,0);
      var morph24 = dom.createUnsafeMorphAt(dom.childAt(element5, [15]),0,0);
      var morph25 = dom.createUnsafeMorphAt(dom.childAt(element5, [17]),0,0);
      var morph26 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
      var morph27 = dom.createUnsafeMorphAt(dom.childAt(element7, [1]),0,0);
      var morph28 = dom.createUnsafeMorphAt(dom.childAt(element7, [3]),0,0);
      var morph29 = dom.createUnsafeMorphAt(dom.childAt(element7, [5]),0,0);
      var morph30 = dom.createUnsafeMorphAt(dom.childAt(element7, [7]),0,0);
      var morph31 = dom.createUnsafeMorphAt(dom.childAt(element7, [9]),0,0);
      var morph32 = dom.createUnsafeMorphAt(dom.childAt(element7, [11]),0,0);
      var morph33 = dom.createUnsafeMorphAt(dom.childAt(element7, [13]),0,0);
      var morph34 = dom.createUnsafeMorphAt(dom.childAt(element7, [15]),0,0);
      var morph35 = dom.createUnsafeMorphAt(dom.childAt(element7, [17]),0,0);
      var morph36 = dom.createUnsafeMorphAt(dom.childAt(element7, [19]),0,0);
      var morph37 = dom.createUnsafeMorphAt(dom.childAt(element7, [21]),0,0);
      var morph38 = dom.createUnsafeMorphAt(dom.childAt(element7, [23]),0,0);
      var morph39 = dom.createUnsafeMorphAt(dom.childAt(element7, [25]),0,0);
      var morph40 = dom.createUnsafeMorphAt(dom.childAt(element7, [27]),0,0);
      var morph41 = dom.createUnsafeMorphAt(dom.childAt(element7, [29]),0,0);
      var morph42 = dom.createUnsafeMorphAt(dom.childAt(element7, [31]),0,0);
      var morph43 = dom.createUnsafeMorphAt(dom.childAt(element7, [33]),0,0);
      inline(env, morph0, context, "i18n", ["keyboard_shortcuts_help.jump_to.title"], {});
      inline(env, morph1, context, "i18n", ["keyboard_shortcuts_help.jump_to.home"], {});
      inline(env, morph2, context, "i18n", ["keyboard_shortcuts_help.jump_to.latest"], {});
      inline(env, morph3, context, "i18n", ["keyboard_shortcuts_help.jump_to.new"], {});
      inline(env, morph4, context, "i18n", ["keyboard_shortcuts_help.jump_to.unread"], {});
      inline(env, morph5, context, "i18n", ["keyboard_shortcuts_help.jump_to.categories"], {});
      inline(env, morph6, context, "i18n", ["keyboard_shortcuts_help.jump_to.top"], {});
      inline(env, morph7, context, "i18n", ["keyboard_shortcuts_help.jump_to.bookmarks"], {});
      inline(env, morph8, context, "i18n", ["keyboard_shortcuts_help.jump_to.profile"], {});
      inline(env, morph9, context, "i18n", ["keyboard_shortcuts_help.jump_to.messages"], {});
      inline(env, morph10, context, "i18n", ["keyboard_shortcuts_help.navigation.title"], {});
      inline(env, morph11, context, "i18n", ["keyboard_shortcuts_help.navigation.back"], {});
      inline(env, morph12, context, "i18n", ["keyboard_shortcuts_help.navigation.jump"], {});
      inline(env, morph13, context, "i18n", ["keyboard_shortcuts_help.navigation.up_down"], {});
      inline(env, morph14, context, "i18n", ["keyboard_shortcuts_help.navigation.open"], {});
      inline(env, morph15, context, "i18n", ["keyboard_shortcuts_help.navigation.next_prev"], {});
      inline(env, morph16, context, "i18n", ["keyboard_shortcuts_help.application.title"], {});
      inline(env, morph17, context, "i18n", ["keyboard_shortcuts_help.application.create"], {});
      inline(env, morph18, context, "i18n", ["keyboard_shortcuts_help.application.hamburger_menu"], {});
      inline(env, morph19, context, "i18n", ["keyboard_shortcuts_help.application.user_profile_menu"], {});
      inline(env, morph20, context, "i18n", ["keyboard_shortcuts_help.application.show_incoming_updated_topics"], {});
      inline(env, morph21, context, "i18n", ["keyboard_shortcuts_help.application.search"], {});
      inline(env, morph22, context, "i18n", ["keyboard_shortcuts_help.application.help"], {});
      inline(env, morph23, context, "i18n", ["keyboard_shortcuts_help.application.dismiss_new_posts"], {});
      inline(env, morph24, context, "i18n", ["keyboard_shortcuts_help.application.dismiss_topics"], {});
      inline(env, morph25, context, "i18n", ["keyboard_shortcuts_help.application.log_out"], {});
      inline(env, morph26, context, "i18n", ["keyboard_shortcuts_help.actions.title"], {});
      inline(env, morph27, context, "i18n", ["keyboard_shortcuts_help.actions.bookmark_topic"], {});
      inline(env, morph28, context, "i18n", ["keyboard_shortcuts_help.actions.pin_unpin_topic"], {});
      inline(env, morph29, context, "i18n", ["keyboard_shortcuts_help.actions.share_topic"], {});
      inline(env, morph30, context, "i18n", ["keyboard_shortcuts_help.actions.share_post"], {});
      inline(env, morph31, context, "i18n", ["keyboard_shortcuts_help.actions.reply_as_new_topic"], {});
      inline(env, morph32, context, "i18n", ["keyboard_shortcuts_help.actions.reply_topic"], {});
      inline(env, morph33, context, "i18n", ["keyboard_shortcuts_help.actions.reply_post"], {});
      inline(env, morph34, context, "i18n", ["keyboard_shortcuts_help.actions.quote_post"], {});
      inline(env, morph35, context, "i18n", ["keyboard_shortcuts_help.actions.like"], {});
      inline(env, morph36, context, "i18n", ["keyboard_shortcuts_help.actions.flag"], {});
      inline(env, morph37, context, "i18n", ["keyboard_shortcuts_help.actions.bookmark"], {});
      inline(env, morph38, context, "i18n", ["keyboard_shortcuts_help.actions.edit"], {});
      inline(env, morph39, context, "i18n", ["keyboard_shortcuts_help.actions.delete"], {});
      inline(env, morph40, context, "i18n", ["keyboard_shortcuts_help.actions.mark_muted"], {});
      inline(env, morph41, context, "i18n", ["keyboard_shortcuts_help.actions.mark_regular"], {});
      inline(env, morph42, context, "i18n", ["keyboard_shortcuts_help.actions.mark_tracking"], {});
      inline(env, morph43, context, "i18n", ["keyboard_shortcuts_help.actions.mark_watching"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/login"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("form");
        dom.setAttribute(el1,"id","login-form");
        dom.setAttribute(el1,"method","post");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("table");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-name");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-password");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("  \n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("a");
        dom.setAttribute(el6,"id","forgot-password-link");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createElement("div");
        var el7 = dom.createElement("i");
        dom.setAttribute(el7,"class","fa fa-exclamation-triangle");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1, 1]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [3]);
        var element5 = dom.childAt(element4, [5, 1]);
        var element6 = dom.childAt(element2, [5, 3, 0]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [1, 1]),0,0);
        var morph3 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
        var morph4 = dom.createMorphAt(element5,0,0);
        var morph5 = dom.createMorphAt(element6,2,2);
        inline(env, morph0, context, "i18n", ["login.username"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "loginName"), "placeholderKey": "login.email_placeholder", "id": "login-account-name", "autocorrect": "off", "autocapitalize": "off", "autofocus": "autofocus"});
        inline(env, morph2, context, "i18n", ["login.password"], {});
        inline(env, morph3, context, "password-field", [], {"value": get(env, context, "loginPassword"), "type": "password", "id": "login-account-password", "maxlength": "200", "capsLockOn": get(env, context, "capsLockOn")});
        element(env, element5, context, "action", ["forgotPassword"], {});
        inline(env, morph4, context, "i18n", ["forgot_password.action"], {});
        element(env, element6, context, "bind-attr", [], {"class": ":caps-lock-warning capsLockOn::invisible"});
        inline(env, morph5, context, "i18n", ["login.caps_lock_warning"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("       \n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-large");
          dom.setAttribute(el1,"id","new-account-link");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          element(env, element0, context, "action", ["createAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-large btn-primary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-unlock");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,3,3);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        element(env, element1, context, "bind-attr", [], {"disabled": "loginDisabled"});
        element(env, element1, context, "action", ["login"], {});
        content(env, morph0, context, "loginButtonText");
        block(env, morph1, context, "if", [get(env, context, "showSignupLink")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.authenticating"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","login-alert");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element7 = dom.childAt(fragment, [0]);
      var element8 = dom.childAt(element7, [7]);
      var element9 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element7,1,1);
      var morph1 = dom.createMorphAt(element7,3,3);
      var morph2 = dom.createMorphAt(element7,5,5);
      var morph3 = dom.createMorphAt(element8,0,0);
      var morph4 = dom.createMorphAt(element9,1,1);
      var morph5 = dom.createMorphAt(element9,3,3);
      var morph6 = dom.createMorphAt(element9,5,5);
      inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
      block(env, morph1, context, "if", [get(env, context, "canLoginLocal")], {}, child0, null);
      content(env, morph2, context, "authMessage");
      element(env, element8, context, "bind-attr", [], {"class": "alertClass"});
      content(env, morph3, context, "alert");
      block(env, morph4, context, "if", [get(env, context, "canLoginLocal")], {}, child1, null);
      block(env, morph5, context, "if", [get(env, context, "authenticate")], {}, child2, null);
      inline(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "showSpinner"), "size": "small"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/merge-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["sign-out"], {});
        content(env, morph1, context, "buttonTitle");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","move-selected");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", ["topic.merge_topic.instructions"], {"count": get(env, context, "selectedPostsCount")});
      inline(env, morph1, context, "view", ["choose-topic"], {"currentTopicId": get(env, context, "model.id"), "selectedTopicId": get(env, context, "selectedTopicId")});
      block(env, morph2, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "buttonDisabled"), "action": "movePostsToExistingTopic"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/modal"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-error");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"class","close");
        dom.setAttribute(el2,"data-dismiss","alert");
        var el3 = dom.createTextNode("×");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),3,3);
        content(env, morph0, context, "error");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-outer-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-middle-container");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","modal-inner-container");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","modal-header");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("a");
      dom.setAttribute(el5,"class","close");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","clearfix");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","modal-alert");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1, 1]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(element2,0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(element0,7,7);
      element(env, element2, context, "action", ["closeModal"], {});
      inline(env, morph0, context, "fa-icon", ["times"], {});
      content(env, morph1, context, "title");
      inline(env, morph2, context, "outlet", ["modalBody"], {});
      block(env, morph3, context, "each", [get(env, context, "errors")], {"keyword": "error"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/not-activated"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.sent_activation_email_again"], {"currentEmail": get(env, context, "currentEmail")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [3]);
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(element0,0,0);
        inline(env, morph0, context, "i18n", ["login.not_activated"], {"sentTo": get(env, context, "sentTo")});
        element(env, element0, context, "action", ["sendActivationEmail"], {});
        inline(env, morph1, context, "i18n", ["login.resend_activation_email"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(element1,0,0);
      block(env, morph0, context, "if", [get(env, context, "emailSent")], {}, child0, child1);
      element(env, element1, context, "action", ["closeModal"], {});
      inline(env, morph1, context, "i18n", ["close"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/option_boolean"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "view.checked")});
      content(env, morph1, context, "title");
      content(env, morph2, context, "description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/post-enqueued"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      content(env, morph0, context, "description");
      inline(env, morph1, context, "i18n", ["queue.approval.pending_posts"], {"count": get(env, context, "model.pending_count")});
      inline(env, morph2, context, "d-button", [], {"action": "closeModal", "class": "btn-primary", "label": "queue.approval.ok"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/raw_email"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "textarea", [], {"value": get(env, context, "rawEmail"), "class": "raw-email-textarea"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["raw_email.not_available"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "if", [get(env, context, "rawEmail")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/reorder-categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "no-text", "action": "commit", "icon": "check"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("tr");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'data-category-id');
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element1,5,5);
        var morph3 = dom.createMorphAt(element1,7,7);
        var morph4 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        set(env, context, "cat", blockArguments[0]);
        attribute(env, attrMorph0, element0, "data-category-id", concat(env, [get(env, context, "cat.id")]));
        inline(env, morph0, context, "number-field", [], {"number": get(env, context, "cat.position")});
        inline(env, morph1, context, "d-button", [], {"class": "no-text", "action": "moveUp", "actionParam": get(env, context, "cat"), "icon": "arrow-up"});
        inline(env, morph2, context, "d-button", [], {"class": "no-text", "action": "moveDown", "actionParam": get(env, context, "cat"), "icon": "arrow-down"});
        block(env, morph3, context, "if", [get(env, context, "cat.hasBufferedChanges")], {}, child0, null);
        inline(env, morph4, context, "category-badge", [get(env, context, "cat")], {"allowUncategorized": "true"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "fixIndices", "icon": "random", "label": "categories.reorder.fix_order", "title": "categories.reorder.fix_order_tooltip"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "commit", "icon": "check", "label": "categories.reorder.apply_all"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body reorder-categories full-height-modal");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","rc-scroll-anchor");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("table");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("thead");
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("th");
      dom.setAttribute(el4,"class","th-pos");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("th");
      dom.setAttribute(el4,"class","th-cat");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","rc-scroll-bottom");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 3]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
      var morph2 = dom.createMorphAt(element2,3,3);
      var morph3 = dom.createMorphAt(element4,1,1);
      var morph4 = dom.createMorphAt(element4,2,2);
      var morph5 = dom.createMorphAt(element4,4,4);
      inline(env, morph0, context, "i18n", ["categories.reorder.position"], {});
      inline(env, morph1, context, "i18n", ["categories.category"], {});
      block(env, morph2, context, "each", [get(env, context, "categoriesOrdered")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "showFixIndices")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "showApplyAll")], {}, child2, null);
      inline(env, morph5, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "saveDisabled"), "action": "saveOrder", "label": "categories.reorder.save"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/search_help"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["google_search"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","search-help");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      content(env, morph0, context, "model");
      block(env, morph1, context, "if", [get(env, context, "showGoogleSearch")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/split-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["sign-out"], {});
        content(env, morph1, context, "buttonTitle");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","move-selected");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph2 = dom.createMorphAt(element1,3,3);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [5]),0,0);
      var morph4 = dom.createMorphAt(element1,7,7);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", ["topic.split_topic.instructions"], {"count": get(env, context, "selectedPostsCount")});
      inline(env, morph1, context, "i18n", ["topic.split_topic.topic_name"], {});
      inline(env, morph2, context, "text-field", [], {"value": get(env, context, "topicName"), "placeholderKey": "composer.title_placeholder", "elementId": "split-topic-name"});
      inline(env, morph3, context, "i18n", ["categories.category"], {});
      inline(env, morph4, context, "category-chooser", [], {"value": get(env, context, "categoryId")});
      block(env, morph5, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "buttonDisabled"), "action": "movePostsToNewTopic"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/topic-bulk-actions"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      inline(env, morph0, context, "i18n", ["topics.bulk.selected"], {"count": get(env, context, "length")});
      inline(env, morph1, context, "outlet", ["bulkOutlet"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/upload-customization"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      inline(env, morph0, context, "json-file-uploader", [], {"value": get(env, context, "customizationFile"), "extension": ".dcstyle.json"});
      inline(env, morph1, context, "d-button", [], {"class": "btn-primary", "action": "createCustomization", "type": "submit", "disabled": get(env, context, "notReady"), "icon": "plus", "label": "admin.customize.import"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/upload-selector"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","inputs");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","file");
        dom.setAttribute(el2,"id","filename-input");
        dom.setAttribute(el2,"multiple","");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("br");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","description");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 4]),0,0);
        content(env, morph0, context, "tip");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","inputs");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","description");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
        inline(env, morph0, context, "input", [], {"value": get(env, context, "imageUrl"), "placeholder": "http://example.com/image.png"});
        content(env, morph1, context, "tip");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","radios");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","inputs");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","description");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
        inline(env, morph0, context, "input", [], {"value": get(env, context, "imageLink"), "laceholder": "http://example.com"});
        inline(env, morph1, context, "i18n", ["upload_selector.image_link"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["upload_selector.hint"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["upload_selector.hint_for_supported_browsers"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","pull-right");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["toggleShowMore"], {});
        inline(env, morph0, context, "i18n", ["show_more"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","radio");
      dom.setAttribute(el3,"id","local");
      dom.setAttribute(el3,"value","local");
      dom.setAttribute(el3,"name","upload");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","radio");
      dom.setAttribute(el3,"for","local");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","radio");
      dom.setAttribute(el3,"id","remote");
      dom.setAttribute(el3,"value","remote");
      dom.setAttribute(el3,"name","upload");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","radio");
      dom.setAttribute(el3,"for","remote");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","inputs");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      dom.setAttribute(el4,"class","hint");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"href","");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element3, [3]);
      var element7 = dom.childAt(element6, [1]);
      var element8 = dom.childAt(fragment, [2]);
      var element9 = dom.childAt(element8, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var morph1 = dom.createMorphAt(element4,5,5);
      var morph2 = dom.createMorphAt(dom.childAt(element6, [3]),0,0);
      var morph3 = dom.createMorphAt(element6,5,5);
      var morph4 = dom.createMorphAt(element3,5,5);
      var morph5 = dom.createMorphAt(dom.childAt(element3, [7, 1, 1]),1,1);
      var morph6 = dom.createMorphAt(element8,1,1);
      var morph7 = dom.createMorphAt(element9,0,0);
      var morph8 = dom.createMorphAt(element8,5,5);
      element(env, element5, context, "action", ["useLocal"], {});
      inline(env, morph0, context, "i18n", ["upload_selector.from_my_computer"], {});
      block(env, morph1, context, "if", [get(env, context, "local")], {}, child0, null);
      element(env, element7, context, "action", ["useRemote"], {});
      inline(env, morph2, context, "i18n", ["upload_selector.from_the_web"], {});
      block(env, morph3, context, "if", [get(env, context, "remote")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "showMore")], {}, child2, null);
      block(env, morph5, context, "if", [get(env, context, "capabilities.canPasteImages")], {}, child3, child4);
      inline(env, morph6, context, "d-button", [], {"action": "upload", "class": "btn-primary", "icon": get(env, context, "uploadIcon"), "label": "upload"});
      element(env, element9, context, "action", ["closeModal"], {});
      inline(env, morph7, context, "i18n", ["cancel"], {});
      block(env, morph8, context, "if", [get(env, context, "remote")], {}, child5, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "categories-admin-dropdown");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"id","create-topic");
        dom.setAttribute(el1,"class","btn btn-default");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-plus");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["createTopic"], {});
        inline(env, morph0, context, "i18n", ["topic.create"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "canCreateCategory")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "canCreateTopic")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "category-notifications-button", [], {"category": get(env, context, "category")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"id": "create-topic", "class": "btn-default", "action": "createTopic", "icon": "plus", "label": "topic.create", "disabled": get(env, context, "cannotCreateTopicOnCategory")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-default edit-category", "action": "editCategory", "actionParam": get(env, context, "category"), "icon": "wrench", "label": "category.edit_long"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "category.description");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "cdn-img", [], {"src": get(env, context, "category.logo_url"), "class": "category-logo"});
        block(env, morph1, context, "if", [get(env, context, "category.description")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","category-heading");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [10]),1,1);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories"), "category": get(env, context, "category"), "noSubcategories": get(env, context, "noSubcategories"), "hideSubcategories": get(env, context, "showingSubcategoryList")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "currentUser")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "canCreateTopic")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "canEditCategory")], {}, child2, null);
      block(env, morph5, context, "if", [get(env, context, "category.logo_url")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/default"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"id","create-topic");
        dom.setAttribute(el1,"class","btn btn-default");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-plus");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["createTopic"], {});
        inline(env, morph0, context, "i18n", ["topic.create"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "canCreateTopic")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["post-placeholder"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("article");
      dom.setAttribute(el1,"class","placeholder");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","topic-avatar");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","placeholder-avatar");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","topic-body");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","placeholder-text");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","placeholder-text");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","placeholder-text");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["post-small-action"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "post-gap", [], {"post": get(env, context, "this"), "postStream": get(env, context, "controller.model.postStream"), "before": "true"});
      inline(env, morph1, context, "small-action", [], {"actionCode": get(env, context, "action_code"), "post": get(env, context, "this"), "daysAgo": get(env, context, "view.daysAgo"), "editPost": "editPost", "deletePost": "deletePost"});
      inline(env, morph2, context, "post-gap", [], {"post": get(env, context, "this"), "postStream": get(env, context, "controller.model.postStream"), "before": "false"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "time-gap", [], {"daysAgo": get(env, context, "daysSincePrevious"), "postStream": get(env, context, "controller.model.postStream")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-trash-o deleted-user-avatar");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "raw", ["post/poster-avatar"], {"post": get(env, context, "this"), "classNames": "main-avatar"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createTextNode("\n                ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n                ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n              ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element8,1,1);
          var morph1 = dom.createMorphAt(element8,3,3);
          var attrMorph0 = dom.createAttrMorph(element8, 'class');
          var attrMorph1 = dom.createAttrMorph(element8, 'title');
          attribute(env, attrMorph0, element8, "class", concat(env, [subexpr(env, context, "unbound", [get(env, context, "view.historyHeat")], {})]));
          attribute(env, attrMorph1, element8, "title", concat(env, [subexpr(env, context, "i18n", ["post.last_edited_on"], {}), " ", subexpr(env, context, "raw-date", [get(env, context, "updated_at")], {})]));
          element(env, element8, context, "action", ["showHistory", get(env, context, "this")], {});
          content(env, morph0, context, "editCount");
          inline(env, morph1, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          var el2 = dom.createTextNode("\n                ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n                ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n              ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element7,1,1);
          var morph1 = dom.createMorphAt(element7,3,3);
          var attrMorph0 = dom.createAttrMorph(element7, 'class');
          var attrMorph1 = dom.createAttrMorph(element7, 'title');
          attribute(env, attrMorph0, element7, "class", concat(env, [subexpr(env, context, "unbound", [get(env, context, "view.historyHeat")], {})]));
          attribute(env, attrMorph1, element7, "title", concat(env, [subexpr(env, context, "i18n", ["post.last_edited_on"], {}), " ", subexpr(env, context, "raw-date", [get(env, context, "updated_at")], {})]));
          content(env, morph0, context, "editCount");
          inline(env, morph1, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","post-info edits");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("          ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "can_view_edit_history")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","post-info wiki");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element6 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element6,0,0);
        var attrMorph0 = dom.createAttrMorph(element6, 'title');
        attribute(env, attrMorph0, element6, "title", subexpr(env, context, "i18n", ["post.wiki.about"], {}));
        element(env, element6, context, "action", ["editPost", get(env, context, "this")], {});
        inline(env, morph0, context, "fa-icon", ["pencil-square-o"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","post-info via-email raw-email");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'title');
          attribute(env, attrMorph0, element5, "title", subexpr(env, context, "i18n", ["post.via_email"], {}));
          element(env, element5, context, "action", ["showRawEmail", get(env, context, "this")], {});
          inline(env, morph0, context, "fa-icon", ["envelope-o"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","post-info via-email");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          var attrMorph0 = dom.createAttrMorph(element4, 'title');
          attribute(env, attrMorph0, element4, "title", subexpr(env, context, "i18n", ["post.via_email"], {}));
          inline(env, morph0, context, "fa-icon", ["envelope-o"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "canViewRawEmail")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","post-info whisper");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element3,0,0);
        var attrMorph0 = dom.createAttrMorph(element3, 'title');
        attribute(env, attrMorph0, element3, "title", subexpr(env, context, "i18n", ["post.whisper"], {}));
        inline(env, morph0, context, "fa-icon", ["eye-slash"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["loading"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
          inline(env, morph0, context, "fa-icon", ["mail-forward"], {});
          inline(env, morph1, context, "avatar", [get(env, context, "reply_to_user")], {"imageSize": "tiny"});
          content(env, morph2, context, "reply_to_user.username");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","reply-to-tab");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("          ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, element = hooks.element, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        element(env, element2, context, "action", ["toggleReplyHistory", get(env, context, "this")], {"target": "view"});
        block(env, morph0, context, "if", [get(env, context, "loadingReplyHistory")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "plugin-outlet", ["topic-after-cooked"], {});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,0,0);
        element(env, element1, context, "action", ["expandHidden", get(env, context, "this")], {});
        inline(env, morph0, context, "i18n", ["post.show_hidden"], {});
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn expand-post");
          dom.setAttribute(el1,"disabled","");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", ["loading"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn expand-post");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("…");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["expandFirstPost", get(env, context, "this")], {});
          inline(env, morph0, context, "i18n", ["post.show_full"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "controller.loadingExpanded")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child11 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "view", ["embedded-post"], {"content": get(env, context, "reply")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","embedded-posts bottom");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "replies")], {"keyword": "reply"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("article");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","topic-avatar");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","poster-avatar-extra");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","topic-body");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","topic-meta-data");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","post-info");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("a");
      dom.setAttribute(el6,"class","post-date");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","select-post");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment(" keep the classes here in sync with composer.hbs ");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","cooked");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element9 = dom.childAt(fragment, [6]);
      var element10 = dom.childAt(element9, [1]);
      var element11 = dom.childAt(element10, [1]);
      var element12 = dom.childAt(element10, [3]);
      var element13 = dom.childAt(element12, [1]);
      var element14 = dom.childAt(element13, [5, 1]);
      var element15 = dom.childAt(element13, [15]);
      var element16 = dom.childAt(element12, [3]);
      var element17 = dom.childAt(element16, [1]);
      var element18 = dom.childAt(element16, [3]);
      var element19 = dom.childAt(element12, [7]);
      var element20 = dom.childAt(element19, [1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
      var attrMorph0 = dom.createAttrMorph(element9, 'class');
      var attrMorph1 = dom.createAttrMorph(element9, 'id');
      var attrMorph2 = dom.createAttrMorph(element9, 'data-post-id');
      var attrMorph3 = dom.createAttrMorph(element9, 'data-user-id');
      var morph3 = dom.createMorphAt(element11,1,1);
      var morph4 = dom.createMorphAt(element11,5,5);
      var morph5 = dom.createMorphAt(element13,1,1);
      var morph6 = dom.createMorphAt(element13,3,3);
      var morph7 = dom.createMorphAt(element14,0,0);
      var morph8 = dom.createMorphAt(element13,7,7);
      var morph9 = dom.createMorphAt(element13,8,8);
      var morph10 = dom.createMorphAt(element13,9,9);
      var morph11 = dom.createMorphAt(element13,11,11);
      var morph12 = dom.createMorphAt(element13,13,13);
      var morph13 = dom.createMorphAt(element15,0,0);
      var attrMorph4 = dom.createAttrMorph(element15, 'title');
      var attrMorph5 = dom.createAttrMorph(element16, 'class');
      var morph14 = dom.createMorphAt(element17,0,0);
      var attrMorph6 = dom.createAttrMorph(element17, 'class');
      var morph15 = dom.createMorphAt(element18,0,0);
      var morph16 = dom.createUnsafeMorphAt(element20,1,1);
      var morph17 = dom.createMorphAt(element20,3,3);
      var morph18 = dom.createMorphAt(element20,5,5);
      var morph19 = dom.createMorphAt(element19,3,3);
      var morph20 = dom.createMorphAt(element19,4,4);
      var morph21 = dom.createMorphAt(element19,6,6);
      var morph22 = dom.createMorphAt(element12,9,9);
      var morph23 = dom.createMorphAt(element12,11,11);
      var morph24 = dom.createMorphAt(element12,13,13);
      var morph25 = dom.createMorphAt(element12,15,15);
      var morph26 = dom.createMorphAt(element10,5,5);
      var morph27 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph28 = dom.createMorphAt(fragment,10,10,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "post-gap", [], {"post": get(env, context, "this"), "postStream": get(env, context, "controller.model.postStream"), "before": "true"});
      block(env, morph1, context, "if", [get(env, context, "hasTimeGap")], {}, child0, null);
      inline(env, morph2, context, "view", ["reply-history"], {"content": get(env, context, "replyHistory")});
      attribute(env, attrMorph0, element9, "class", concat(env, ["boxed ", subexpr(env, context, "if", [get(env, context, "via_email"), "via-email"], {})]));
      attribute(env, attrMorph1, element9, "id", get(env, context, "view.postElementId"));
      attribute(env, attrMorph2, element9, "data-post-id", get(env, context, "id"));
      attribute(env, attrMorph3, element9, "data-user-id", get(env, context, "user_id"));
      block(env, morph3, context, "if", [get(env, context, "userDeleted")], {}, child1, child2);
      inline(env, morph4, context, "plugin-outlet", ["poster-avatar-bottom"], {});
      inline(env, morph5, context, "poster-name", [], {"post": get(env, context, "this")});
      inline(env, morph6, context, "plugin-outlet", ["poster-name-right"], {});
      element(env, element14, context, "bind-attr", [], {"href": "shareUrl", "data-share-url": "shareUrl", "data-post-number": "post_number"});
      inline(env, morph7, context, "age-with-tooltip", [get(env, context, "created_at")], {});
      block(env, morph8, context, "if", [get(env, context, "hasHistory")], {}, child3, null);
      block(env, morph9, context, "if", [get(env, context, "wiki")], {}, child4, null);
      block(env, morph10, context, "if", [get(env, context, "via_email")], {}, child5, null);
      block(env, morph11, context, "if", [get(env, context, "view.whisper")], {}, child6, null);
      block(env, morph12, context, "if", [get(env, context, "showUserReplyTab")], {}, child7, null);
      attribute(env, attrMorph4, element15, "title", concat(env, [subexpr(env, context, "i18n", ["post.unread"], {})]));
      element(env, element15, context, "bind-attr", [], {"class": ":read-state read"});
      inline(env, morph13, context, "fa-icon", ["circle"], {});
      attribute(env, attrMorph5, element16, "class", concat(env, ["select-posts ", subexpr(env, context, "unless", [get(env, context, "controller.multiSelect"), "hidden"], {})]));
      attribute(env, attrMorph6, element17, "class", concat(env, [subexpr(env, context, "unless", [get(env, context, "view.canSelectReplies"), "hidden"], {})]));
      element(env, element17, context, "action", ["toggledSelectedPostReplies", get(env, context, "this")], {});
      inline(env, morph14, context, "i18n", ["topic.multi_select.select_replies"], {});
      element(env, element18, context, "action", ["toggledSelectedPost", get(env, context, "this")], {});
      content(env, morph15, context, "view.selectPostText");
      element(env, element19, context, "bind-attr", [], {"class": "showUserReplyTab:avoid-tab view.repliesShown::contents :regular view.extraClass"});
      content(env, morph16, context, "cooked");
      inline(env, morph17, context, "plugin-outlet", ["post-after-cooked"], {});
      block(env, morph18, context, "if", [get(env, context, "firstPost")], {}, child8, null);
      block(env, morph19, context, "if", [get(env, context, "cooked_hidden")], {}, child9, null);
      block(env, morph20, context, "if", [get(env, context, "view.showExpandButton")], {}, child10, null);
      inline(env, morph21, context, "post-menu", [], {"post": get(env, context, "this"), "canCreatePost": get(env, context, "controller.model.details.can_create_post"), "replyToPost": "replyToPost", "recoverPost": "recoverPost", "deletePost": "deletePost", "toggleLike": "toggleLike", "toggleLikeTarget": get(env, context, "view"), "showFlags": "showFlags", "editPost": "editPost", "toggleBookmark": "toggleBookmark", "toggleWiki": "toggleWiki", "togglePostType": "togglePostType", "rebakePost": "rebakePost", "unhidePost": "unhidePost", "changePostOwner": "changePostOwner", "toggleWhoLiked": "toggleWhoLiked", "toggleWhoLikedTarget": get(env, context, "view")});
      inline(env, morph22, context, "who-liked", [], {"users": get(env, context, "view.likedUsers")});
      block(env, morph23, context, "if", [get(env, context, "replies")], {}, child11, null);
      inline(env, morph24, context, "actions-summary", [], {"post": get(env, context, "this")});
      inline(env, morph25, context, "view", ["topic-map-container"], {"post": get(env, context, "this"), "topic": get(env, context, "controller.model")});
      inline(env, morph26, context, "post-gutter", [], {"post": get(env, context, "this"), "links": get(env, context, "internalLinks"), "canReplyAsNewTopic": get(env, context, "topic.details.can_reply_as_new_topic"), "newTopicAction": "replyAsNewTopic"});
      inline(env, morph27, context, "post-gap", [], {"post": get(env, context, "this"), "postStream": get(env, context, "controller.model.postStream"), "before": "false"});
      inline(env, morph28, context, "plugin-outlet", ["post-bottom"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["post/poster-avatar.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<a href=\""
    + escapeExpression(helpers.get.call(depth0, "post.usernameUrl", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\" classNames=\"trigger-user-card "
    + escapeExpression(helpers.get.call(depth0, "classNames", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\" data-user-card=\""
    + escapeExpression(helpers.get.call(depth0, "post.username", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "\">"
    + escapeExpression(((helpers.avatar || (depth0 && depth0.avatar) || helperMissing).call(depth0, "post", {"name":"avatar","hash":{
    'imageSize': ("large")
  },"hashTypes":{'imageSize': "STRING"},"hashContexts":{'imageSize': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"useData":true});
Ember.TEMPLATES["preferences/card-badge"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5, 1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3, 3]),1,1);
      var morph2 = dom.createMorphAt(element2,0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["user.card_badge.title"], {});
      inline(env, morph1, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "selectedUserBadgeId"), "nameProperty": "badge.displayName", "content": get(env, context, "selectableUserBadges")});
      element(env, element2, context, "bind-attr", [], {"disabled": get(env, context, "disableSave")});
      element(env, element2, context, "action", ["save"], {});
      content(env, morph2, context, "savingStatus");
      block(env, morph3, context, "if", [get(env, context, "saved")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["queued-posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "avatar", [get(env, context, "ctrl.post.user")], {"imageSize": "large"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "ctrl.post.user.username");
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","fa fa-ban");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var attrMorph0 = dom.createAttrMorph(element0, 'title');
          attribute(env, attrMorph0, element0, "title", concat(env, [subexpr(env, context, "i18n", ["user.blocked_tooltip"], {})]));
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "topic-link", [get(env, context, "ctrl.post.topic")], {});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "ctrl.post.post_options.title");
          return fragment;
        }
      };
    }());
    var child5 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-editor", [], {"value": get(env, context, "ctrl.buffered.raw")});
          return fragment;
        }
      };
    }());
    var child6 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "cook-text", [get(env, context, "ctrl.post.raw")], {});
          return fragment;
        }
      };
    }());
    var child7 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "confirmEdit", "label": "queue.confirm", "disabled": get(env, context, "ctrl.post.isSaving"), "class": "btn-primary confirm"});
          inline(env, morph1, context, "d-button", [], {"action": "cancelEdit", "label": "queue.cancel", "icon": "times", "disabled": get(env, context, "ctrl.post.isSaving"), "class": "btn-danger cancel"});
          return fragment;
        }
      };
    }());
    var child8 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "deleteUser", "disabled": get(env, context, "ctrl.post.isSaving"), "label": "queue.delete_user", "icon": "trash", "class": "btn-danger delete-user"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "approve", "disabled": get(env, context, "ctrl.post.isSaving"), "label": "queue.approve", "icon": "check", "class": "btn-primary approve"});
          inline(env, morph1, context, "d-button", [], {"action": "reject", "disabled": get(env, context, "ctrl.post.isSaving"), "label": "queue.reject", "icon": "times", "class": "btn-danger reject"});
          block(env, morph2, context, "if", [get(env, context, "ctrl.post.can_delete_user")], {}, child0, null);
          inline(env, morph3, context, "d-button", [], {"action": "edit", "disabled": get(env, context, "ctrl.post.isSaving"), "label": "queue.edit", "icon": "pencil", "class": "edit"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","queued-post");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","poster");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","cooked");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","names");
        var el4 = dom.createTextNode("\n            ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","username");
        var el5 = dom.createTextNode("\n");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("            ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","post-info");
        var el4 = dom.createTextNode("\n            ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","post-date");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","clearfix");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","post-title");
        var el4 = dom.createTextNode("\n            ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("            ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","body");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("          ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","queue-controls");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("          ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [3]);
        var element3 = dom.childAt(element2, [1, 1]);
        var element4 = dom.childAt(element2, [7]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
        var morph1 = dom.createMorphAt(element3,1,1);
        var morph2 = dom.createMorphAt(element3,2,2);
        var morph3 = dom.createMorphAt(dom.childAt(element2, [3, 1]),0,0);
        var morph4 = dom.createMorphAt(element4,1,1);
        var morph5 = dom.createMorphAt(element4,3,3);
        var morph6 = dom.createMorphAt(element4,5,5);
        var morph7 = dom.createMorphAt(dom.childAt(element2, [9]),1,1);
        var morph8 = dom.createMorphAt(dom.childAt(element2, [11]),1,1);
        block(env, morph0, context, "user-link", [], {"user": get(env, context, "ctrl.post.user")}, child0, null);
        block(env, morph1, context, "user-link", [], {"user": get(env, context, "ctrl.post.user")}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "ctrl.post.user.blocked")], {}, child2, null);
        inline(env, morph3, context, "age-with-tooltip", [get(env, context, "ctrl.post.created_at")], {});
        inline(env, morph4, context, "i18n", ["queue.topic"], {});
        block(env, morph5, context, "if", [get(env, context, "ctrl.post.topic")], {}, child3, child4);
        inline(env, morph6, context, "category-badge", [get(env, context, "ctrl.post.category")], {});
        block(env, morph7, context, "if", [get(env, context, "ctrl.editing")], {}, child5, child6);
        block(env, morph8, context, "if", [get(env, context, "ctrl.editing")], {}, child7, child8);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["queue.none"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","queued-posts");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element5 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element5,1,1);
      var morph1 = dom.createMorphAt(element5,3,3);
      block(env, morph0, context, "each", [get(env, context, "model")], {"itemController": "queued-post", "keyword": "ctrl"}, child0, child1);
      inline(env, morph1, context, "d-button", [], {"action": "refresh", "label": "refresh", "icon": "refresh", "disabled": get(env, context, "model.refreshing"), "id": "refresh-queued"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["selected-posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element1,0,0);
        element(env, element1, context, "action", ["selectAll"], {});
        inline(env, morph0, context, "i18n", ["topic.multi_select.select_all"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["deselectAll"], {});
        inline(env, morph0, context, "i18n", ["topic.multi_select.deselect_all"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "deleteSelected", "icon": "trash-o", "label": "topic.multi_select.delete"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "splitTopic", "icon": "sign-out", "label": "topic.split_topic.action"});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "mergeTopic", "icon": "sign-out", "label": "topic.merge_topic.action"});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "changeOwner", "icon": "user", "label": "topic.change_owner.action"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      dom.setAttribute(el1,"class","cancel");
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"href","");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [14, 0]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
      var morph6 = dom.createMorphAt(fragment,12,12,contextualElement);
      var morph7 = dom.createMorphAt(element2,0,0);
      inline(env, morph0, context, "count-i18n", [], {"key": "topic.multi_select.description", "count": get(env, context, "selectedPostsCount")});
      block(env, morph1, context, "if", [get(env, context, "canSelectAll")], {}, child0, null);
      block(env, morph2, context, "if", [get(env, context, "canDeselectAll")], {}, child1, null);
      block(env, morph3, context, "if", [get(env, context, "canDeleteSelected")], {}, child2, null);
      block(env, morph4, context, "if", [get(env, context, "canSplitTopic")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "canMergeTopic")], {}, child4, null);
      block(env, morph6, context, "if", [get(env, context, "canChangeOwner")], {}, child5, null);
      element(env, element2, context, "action", ["toggleMultiSelect"], {});
      inline(env, morph7, context, "i18n", ["topic.multi_select.cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["share"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","date");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "displayDate");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "share-source", [], {"source": get(env, context, "s"), "title": get(env, context, "view.title"), "action": "share"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","text");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","share-for-touch");
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","overflow-ellipsis");
        var el4 = dom.createElement("a");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","link");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [9, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,7,7,contextualElement);
        var morph3 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'aria-label');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        content(env, morph0, context, "view.title");
        block(env, morph1, context, "if", [get(env, context, "date")], {}, child0, null);
        block(env, morph2, context, "each", [get(env, context, "sources")], {"keyword": "s"}, child1, null);
        attribute(env, attrMorph0, element0, "aria-label", concat(env, [subexpr(env, context, "i18n", ["share.close"], {})]));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["share.close"], {})]));
        element(env, element0, context, "action", ["close"], {});
        inline(env, morph3, context, "fa-icon", ["times-circle"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "controller.link")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["static"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-primary");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["showLogin"], {});
        inline(env, morph0, context, "fa-icon", ["user"], {});
        inline(env, morph1, context, "i18n", ["log_in"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","contents clearfix body-page");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createUnsafeMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element1,5,5);
      inline(env, morph0, context, "plugin-outlet", ["above-static"], {});
      content(env, morph1, context, "model.html");
      block(env, morph2, context, "if", [get(env, context, "showLoginButton")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-entrance"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createUnsafeMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["caret-up"], {});
        content(env, morph1, context, "topDate");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        content(env, morph0, context, "bottomDate");
        inline(env, morph1, context, "fa-icon", ["caret-down"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "d-button", [], {"action": "enterTop", "class": "full jump-top"}, child0, null);
      block(env, morph1, context, "d-button", [], {"action": "enterBottom", "class": "full jump-button"}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-list-header-column.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "      <button class='btn bulk-select' title='"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "topics.bulk.toggle", {"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "'><i class='fa fa-list'></i></button>\n";
},"3":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "    <i class='"
    + escapeExpression(helpers.get.call(depth0, "view.sortClass", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'></i>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, escapeExpression=this.escapeExpression, buffer = "<th data-sort-order='"
    + escapeExpression(helpers.get.call(depth0, "order", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='"
    + escapeExpression(helpers.get.call(depth0, "view.className", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'>";
  stack1 = helpers['if'].call(depth0, "showBulkToggle", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += escapeExpression(helpers.get.call(depth0, "view.localizedName", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}));
  stack1 = helpers['if'].call(depth0, "view.isSorting", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</th>\n";
},"useData":true});
Ember.TEMPLATES["topic-list-header.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<th class='star'>\n  <button class='btn bulk-select' title='"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "topics.bulk.toggle", {"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "'><i class='fa fa-list'></i></button>\n</th>\n";
},"3":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("category_title"),
    'order': ("category"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"5":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("users"),
    'order': ("posters")
  },"hashTypes":{'name': "STRING",'order': "STRING"},"hashContexts":{'name': depth0,'order': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"7":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("users"),
    'order': ("participants")
  },"hashTypes":{'name': "STRING",'order': "STRING"},"hashContexts":{'name': depth0,'order': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"9":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("likes"),
    'order': ("likes"),
    'number': ("true"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'number': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'number': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"11":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "  "
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("likes"),
    'order': ("op_likes"),
    'number': ("true"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'number': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'number': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "";
  stack1 = helpers['if'].call(depth0, "bulkSelectEnabled", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'showBulkToggle': ("toggleInTitle"),
    'name': ("topic.title"),
    'order': ("default")
  },"hashTypes":{'showBulkToggle': "ID",'name': "STRING",'order': "STRING"},"hashContexts":{'showBulkToggle': depth0,'name': depth0,'order': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
  stack1 = helpers.unless.call(depth0, "hideCategory", {"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "showPosters", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(5, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("replies"),
    'order': ("posts"),
    'number': ("true"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'number': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'number': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
  stack1 = helpers['if'].call(depth0, "showParticipants", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(7, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "showLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(9, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "showOpLikes", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(11, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("views"),
    'order': ("views"),
    'number': ("true"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'number': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'number': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n"
    + escapeExpression(((helpers.raw || (depth0 && depth0.raw) || helperMissing).call(depth0, "topic-list-header-column", {"name":"raw","hash":{
    'name': ("activity"),
    'order': ("activity"),
    'number': ("true"),
    'sortable': ("sortable")
  },"hashTypes":{'name': "STRING",'order': "STRING",'number': "STRING",'sortable': "ID"},"hashContexts":{'name': depth0,'order': depth0,'number': depth0,'sortable': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "\n";
},"useData":true});
Ember.TEMPLATES["topic-post-badges.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<a href='"
    + escapeExpression(helpers.get.call(depth0, "url", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification unread' title='"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "topic.unread_posts", {"name":"i18n","hash":{
    'count': ("unread")
  },"hashTypes":{'count': "ID"},"hashContexts":{'count': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "'>"
    + escapeExpression(helpers.get.call(depth0, "unread", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"3":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<a href='"
    + escapeExpression(helpers.get.call(depth0, "url", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification new-posts' title='"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "topic.total_unread_posts", {"name":"i18n","hash":{
    'count': ("newPosts")
  },"hashTypes":{'count': "ID"},"hashContexts":{'count': depth0},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "'>"
    + escapeExpression(helpers.get.call(depth0, "newPosts", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"5":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "<a href='"
    + escapeExpression(helpers.get.call(depth0, "url", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification new-topic' title='"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "topic.new", {"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "'>"
    + escapeExpression(((helpers.i18n || (depth0 && depth0.i18n) || helperMissing).call(depth0, "filters.new.lower_title", {"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["STRING"],"contexts":[depth0],"data":data})))
    + "</a>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<span class='topic-post-badges'>\n";
  stack1 = helpers['if'].call(depth0, "unread", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "newPosts", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "unseen", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(5, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</span>\n";
},"useData":true});
Ember.TEMPLATES["topic-progress"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("nav");
        dom.setAttribute(el1,"id","topic-progress-expanded");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","jump-form");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [3]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element1,1,1);
        var morph2 = dom.createMorphAt(element1,3,3);
        var morph3 = dom.createMorphAt(element0,5,5);
        inline(env, morph0, context, "d-button", [], {"action": "jumpTop", "disabled": get(env, context, "jumpTopDisabled"), "class": "full no-text", "icon": "caret-up", "label": "topic.progress.go_top"});
        inline(env, morph1, context, "input", [], {"value": get(env, context, "toPostIndex")});
        inline(env, morph2, context, "d-button", [], {"action": "jumpPost", "label": "topic.progress.go"});
        inline(env, morph3, context, "d-button", [], {"action": "jumpBottom", "disabled": get(env, context, "jumpBottomDisabled"), "class": "full no-text jump-bottom", "icon": "caret-down", "label": "topic.progress.go_bottom"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("nav");
      dom.setAttribute(el1,"id","topic-progress");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","nums");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h4");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      var el5 = dom.createTextNode("/");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("i");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","bg");
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [2]);
      var element5 = dom.childAt(element2, [3]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var attrMorph0 = dom.createAttrMorph(element2, 'title');
      var attrMorph1 = dom.createAttrMorph(element2, 'class');
      var morph1 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var attrMorph2 = dom.createAttrMorph(element4, 'class');
      var morph2 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var attrMorph3 = dom.createAttrMorph(element5, 'class');
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "expanded")], {}, child0, null);
      attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["topic.progress.title"], {})]));
      attribute(env, attrMorph1, element2, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "hideProgress"), "hidden"], {})]));
      content(env, morph1, context, "progressPosition");
      attribute(env, attrMorph2, element4, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "hugeNumberOfPosts"), "hidden"], {})]));
      content(env, morph2, context, "model.postStream.filteredPostsCount");
      attribute(env, attrMorph3, element5, "class", concat(env, ["fa ", subexpr(env, context, "unless", [get(env, context, "expanded"), "fa-sort"], {})]));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-status.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  return "<div class='topic-statuses'>\n";
  },"3":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, "status.href", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(4, data),"inverse":this.program(6, data),"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"4":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "<a href='"
    + escapeExpression(helpers.get.call(depth0, "status.href", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' title='"
    + escapeExpression(helpers.get.call(depth0, "status.title", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='topic-status "
    + escapeExpression(helpers.get.call(depth0, "status.extraClasses", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'><i class='fa fa-"
    + escapeExpression(helpers.get.call(depth0, "status.icon", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'></i></a>";
},"6":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression;
  return "<"
    + escapeExpression(helpers.get.call(depth0, "status.openTag", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + " title='"
    + escapeExpression(helpers.get.call(depth0, "status.title", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "' class='topic-status'><i class='fa fa-"
    + escapeExpression(helpers.get.call(depth0, "status.icon", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "'></i></"
    + escapeExpression(helpers.get.call(depth0, "status.closeTag", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + ">";
},"8":function(depth0,helpers,partials,data) {
  return "</div>\n";
  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers['if'].call(depth0, "view.renderDiv", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers.each.call(depth0, "status", "in", "view.statuses", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "view.renderDiv", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(8, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"useData":true});
Ember.TEMPLATES["topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner"), "overlay": get(env, context, "view.hasScrolled"), "hide": get(env, context, "model.errorLoading")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","private-message-glyph");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              inline(env, morph0, context, "fa-icon", ["envelope"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("br");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
              inline(env, morph0, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "buffered.category_id"), "source": get(env, context, "buffered.category_id")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
            var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
            var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
            var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
            var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "model.isPrivateMessage")], {}, child0, null);
            inline(env, morph1, context, "text-field", [], {"id": "edit-title", "value": get(env, context, "buffered.title"), "maxlength": get(env, context, "siteSettings.max_topic_title_length"), "autofocus": "true"});
            block(env, morph2, context, "if", [get(env, context, "showCategoryChooser")], {}, child1, null);
            inline(env, morph3, context, "plugin-outlet", ["edit-topic"], {});
            inline(env, morph4, context, "d-button", [], {"action": "finishedEditingTopic", "class": "btn-primary btn-small submit-edit", "icon": "check"});
            inline(env, morph5, context, "d-button", [], {"action": "cancelEditingTopic", "class": "btn-small cancel-edit", "icon": "times"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","private-message-glyph");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              inline(env, morph0, context, "fa-icon", ["envelope"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"class","fancy-title");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element4 = dom.childAt(fragment, [3]);
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createUnsafeMorphAt(element4,1,1);
              var attrMorph0 = dom.createAttrMorph(element4, 'href');
              inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "model")});
              attribute(env, attrMorph0, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.url")], {})]));
              element(env, element4, context, "action", ["jumpTop"], {});
              content(env, morph1, context, "model.fancyTitle");
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"href","");
              dom.setAttribute(el1,"class","edit-topic");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element3 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element3,0,0);
              var attrMorph0 = dom.createAttrMorph(element3, 'title');
              attribute(env, attrMorph0, element3, "title", concat(env, [subexpr(env, context, "i18n", ["edit"], {})]));
              element(env, element3, context, "action", ["editTopic"], {});
              inline(env, morph0, context, "fa-icon", ["pencil"], {});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "topic-category", [], {"topic": get(env, context, "model")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h1");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element5 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element5,1,1);
            var morph1 = dom.createMorphAt(element5,3,3);
            var morph2 = dom.createMorphAt(element5,5,5);
            var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
            dom.insertBoundary(fragment, null);
            block(env, morph0, context, "unless", [get(env, context, "model.is_warning")], {}, child0, null);
            block(env, morph1, context, "if", [get(env, context, "model.details.loaded")], {}, child1, null);
            block(env, morph2, context, "if", [get(env, context, "model.details.can_edit")], {}, child2, null);
            block(env, morph3, context, "unless", [get(env, context, "model.isPrivateMessage")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"id","topic-title");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","container");
          var el3 = dom.createTextNode("\n\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","title-wrapper");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(dom.childAt(element6, [1]),1,1);
          var morph1 = dom.createMorphAt(element6,3,3);
          block(env, morph0, context, "if", [get(env, context, "editingTopic")], {}, child0, child1);
          inline(env, morph1, context, "plugin-outlet", ["topic-title"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "cloaked-collection", [], {"itemViewClass": "post", "defaultHeight": "200", "content": get(env, context, "postsToRender"), "slackRatio": "15", "loadingHTML": "", "preservesContext": "true", "uncloakDefault": "true", "offsetFixedTop": "header", "offsetFixedBottom": "#reply-control"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              content(env, morph0, context, "signup-cta");
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "view", ["topic-footer-buttons"], {"topic": get(env, context, "model")});
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.1",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
                  inline(env, morph0, context, "fa-icon", ["check"], {});
                  inline(env, morph1, context, "i18n", ["queue.view_pending"], {});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                block(env, morph0, context, "link-to", ["queued-posts"], {}, child0, null);
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","has-pending-posts");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element2 = dom.childAt(fragment, [1]);
              var morph0 = dom.createUnsafeMorphAt(element2,1,1);
              var morph1 = dom.createMorphAt(element2,3,3);
              inline(env, morph0, context, "i18n", ["queue.has_pending_posts"], {"count": get(env, context, "model.pending_posts_count")});
              block(env, morph1, context, "if", [get(env, context, "currentUser.show_queued_posts")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"id","suggested-topics");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("h3");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","topics");
              var el3 = dom.createTextNode("\n                  ");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("\n                ");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("h3");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
              var morph2 = dom.createUnsafeMorphAt(dom.childAt(element1, [5]),0,0);
              inline(env, morph0, context, "i18n", ["suggested_topics.title"], {});
              inline(env, morph1, context, "basic-topic-list", [], {"topics": get(env, context, "model.details.suggested_topics"), "postsAction": "showTopicEntrance"});
              content(env, morph2, context, "view.browseMoreMessage");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
            var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
            var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
            inline(env, morph0, context, "view", ["topic-closing"], {"topic": get(env, context, "model")});
            block(env, morph1, context, "if", [get(env, context, "session.showSignupCta")], {}, child0, child1);
            block(env, morph2, context, "if", [get(env, context, "model.pending_posts_count")], {}, child2, null);
            inline(env, morph3, context, "plugin-outlet", ["topic-above-suggested"], {});
            block(env, morph4, context, "if", [get(env, context, "model.details.suggested_topics.length")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "loadedAllPosts")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container posts");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","row");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("section");
        dom.setAttribute(el3,"class","topic-area");
        dom.setAttribute(el3,"id","topic");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("div");
        dom.setAttribute(el4,"class","posts-wrapper");
        var el5 = dom.createTextNode("\n\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n\n");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("div");
        dom.setAttribute(el4,"id","topic-bottom");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [2]);
        var element8 = dom.childAt(element7, [3, 1]);
        var element9 = dom.childAt(element8, [1]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(element7,1,1);
        var attrMorph0 = dom.createAttrMorph(element8, 'data-topic-id');
        var morph2 = dom.createMorphAt(element9,1,1);
        var morph3 = dom.createMorphAt(element9,3,3);
        var morph4 = dom.createMorphAt(element9,5,5);
        var morph5 = dom.createMorphAt(element8,5,5);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.postStream.firstPostPresent")], {}, child0, null);
        inline(env, morph1, context, "view", ["selected-posts"], {});
        attribute(env, attrMorph0, element8, "data-topic-id", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.id")], {})]));
        inline(env, morph2, context, "render", ["topic-progress"], {});
        inline(env, morph3, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.postStream.loadingAbove")});
        block(env, morph4, context, "unless", [get(env, context, "model.postStream.loadingFilter")], {}, child1, null);
        block(env, morph5, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.postStream.loadingFilter")}, child2, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","not-found");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
            content(env, morph0, context, "model.notFoundHtml");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("              ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showLogin", "class": "btn-primary topic-retry", "icon": "user", "label": "log_in"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              block(env, morph0, context, "unless", [get(env, context, "currentUser")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "retryLoading", "class": "btn-primary topic-retry", "icon": "refresh", "label": "errors.buttons.again"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","topic-error");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("div");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
            var morph1 = dom.createMorphAt(element0,3,3);
            var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
            content(env, morph0, context, "model.message");
            block(env, morph1, context, "if", [get(env, context, "model.noRetry")], {}, child0, child1);
            inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "retrying")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "model.notFoundHtml")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "noErrorYet")}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "render", ["quote-button"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "deleteTopic", "icon": "trash-o", "label": "topic.actions.delete", "class": "btn-danger"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "recoverTopic", "icon": "undo", "label": "topic.actions.recover"});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleClosed", "icon": "unlock", "label": "topic.actions.open"});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleClosed", "icon": "lock", "label": "topic.actions.close"});
            inline(env, morph1, context, "d-button", [], {"action": "showAutoClose", "icon": "clock-o", "label": "topic.actions.auto_close"});
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showFeatureTopic", "icon": "thumb-tack", "label": "topic.actions.unpin"});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showFeatureTopic", "icon": "thumb-tack", "label": "topic.actions.pin"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("li");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "if", [get(env, context, "isFeatured")], {}, child0, child1);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "model.visible")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child5 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleArchived", "icon": "folder", "label": "topic.actions.unarchive"});
            return fragment;
          }
        };
      }());
      var child6 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleArchived", "icon": "folder", "label": "topic.actions.archive"});
            return fragment;
          }
        };
      }());
      var child7 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleVisibility", "icon": "eye-slash", "label": "topic.actions.invisible"});
            return fragment;
          }
        };
      }());
      var child8 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleVisibility", "icon": "eye", "label": "topic.actions.visible"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),1,1);
          var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
          var morph5 = dom.createMorphAt(dom.childAt(fragment, [11]),1,1);
          var morph6 = dom.createMorphAt(dom.childAt(fragment, [13]),1,1);
          var morph7 = dom.createMorphAt(dom.childAt(fragment, [15]),1,1);
          var morph8 = dom.createMorphAt(fragment,17,17,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "toggleMultiSelect", "icon": "tasks", "label": "topic.actions.multi_select"});
          block(env, morph1, context, "if", [get(env, context, "model.details.can_delete")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "showRecover")], {}, child1, null);
          block(env, morph3, context, "if", [get(env, context, "model.closed")], {}, child2, child3);
          block(env, morph4, context, "unless", [get(env, context, "model.isPrivateMessage")], {}, child4, null);
          inline(env, morph5, context, "d-button", [], {"action": "showChangeTimestamp", "icon": "calendar", "label": "topic.change_timestamp.title"});
          block(env, morph6, context, "if", [get(env, context, "model.archived")], {}, child5, child6);
          block(env, morph7, context, "if", [get(env, context, "model.visible")], {}, child7, child8);
          inline(env, morph8, context, "plugin-outlet", ["topic-admin-menu-buttons"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "show-popup-button", [], {"action": "showTopicAdminMenu", "class": "show-topic-admin", "title": "topic_admin_menu", "icon": "wrench"});
        block(env, morph1, context, "popup-menu", [], {"visible": get(env, context, "adminMenuVisible"), "hide": "hideTopicAdminMenu", "title": "admin_title"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model")], {}, child0, null);
      inline(env, morph1, context, "plugin-outlet", ["topic-above-post-stream"], {});
      block(env, morph2, context, "if", [get(env, context, "model.postStream.loaded")], {}, child1, child2);
      inline(env, morph3, context, "render", ["share"], {});
      block(env, morph4, context, "if", [get(env, context, "currentUser.enable_quoting")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "currentUser.canManageTopic")], {}, child4, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic/unsubscribe"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element1,3,3);
      content(env, morph0, context, "stopNotificiationsText");
      inline(env, morph1, context, "i18n", ["topic.unsubscribe.change_notification_state"], {});
      inline(env, morph2, context, "topic-notifications-button", [], {"topic": get(env, context, "model")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-card"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h2");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "user.name");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h2");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "user.title");
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn btn-primary");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element8,0,0);
          var morph1 = dom.createMorphAt(element8,1,1);
          element(env, element8, context, "action", ["composePrivateMessage", get(env, context, "user"), get(env, context, "post")], {});
          inline(env, morph0, context, "fa-icon", ["envelope"], {});
          inline(env, morph1, context, "i18n", ["user.private_message"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element7,0,0);
          var morph1 = dom.createMorphAt(element7,1,1);
          element(env, element7, context, "action", ["togglePosts", get(env, context, "user")], {});
          inline(env, morph0, context, "fa-icon", ["filter"], {});
          inline(env, morph1, context, "i18n", ["topic.filter_to"], {"username": get(env, context, "username"), "post_count": get(env, context, "topicPostCount")});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element6,0,0);
          var morph1 = dom.createMorphAt(element6,1,1);
          element(env, element6, context, "action", ["cancelFilter"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          inline(env, morph1, context, "i18n", ["topic.filters.cancel"], {});
          return fragment;
        }
      };
    }());
    var child5 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn btn-danger");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var morph1 = dom.createMorphAt(element5,1,1);
          element(env, element5, context, "action", ["deleteUser", get(env, context, "user")], {});
          inline(env, morph0, context, "fa-icon", ["exclamation-triangle"], {});
          inline(env, morph1, context, "i18n", ["admin.user.delete"], {});
          return fragment;
        }
      };
    }());
    var child6 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","suspended");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("b");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("br");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("b");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(element4, [6]),0,0);
          var morph3 = dom.createMorphAt(element4,8,8);
          inline(env, morph0, context, "fa-icon", ["ban"], {});
          inline(env, morph1, context, "i18n", ["user.suspended_notice"], {"date": get(env, context, "user.suspendedTillDate")});
          inline(env, morph2, context, "i18n", ["user.suspended_reason"], {});
          content(env, morph3, context, "user.suspend_reason");
          return fragment;
        }
      };
    }());
    var child7 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","bio");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            inline(env, morph0, context, "text-overflow", [], {"class": "overflow", "text": get(env, context, "user.bio_excerpt")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "if", [get(env, context, "user.bio_cooked")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child8 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "icon-or-image", [get(env, context, "user.card_badge.image")], {"title": get(env, context, "user.card_badge.name")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "link-to", ["badges.show", get(env, context, "user.card_badge")], {"class": "card-badge", "title": get(env, context, "user.card_badge.name")}, child0, null);
          return fragment;
        }
      };
    }());
    var child9 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","desc");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element1, [0]),0,0);
            var morph1 = dom.createMorphAt(element1,2,2);
            inline(env, morph0, context, "i18n", ["last_post"], {});
            inline(env, morph1, context, "format-date", [get(env, context, "user.last_posted_at")], {"leaveAgo": "true"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","metadata");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("h3");
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","desc");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode(" ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var element3 = dom.childAt(element2, [3]);
          var morph0 = dom.createMorphAt(element2,1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element3, [0]),0,0);
          var morph2 = dom.createMorphAt(element3,2,2);
          var morph3 = dom.createMorphAt(element2,5,5);
          block(env, morph0, context, "if", [get(env, context, "user.last_posted_at")], {}, child0, null);
          inline(env, morph1, context, "i18n", ["joined"], {});
          inline(env, morph2, context, "format-date", [get(env, context, "user.created_at")], {"leaveAgo": "true"});
          inline(env, morph3, context, "plugin-outlet", ["user-card-metadata"], {});
          return fragment;
        }
      };
    }());
    var child10 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "user-badge", [], {"badge": get(env, context, "ub.badge")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["badges.more_badges"], {"count": get(env, context, "moreBadgesCount")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "link-to", ["user.badges", get(env, context, "user")], {"class": "btn more-user-badges"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","badge-section");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createMorphAt(element0,2,2);
          block(env, morph0, context, "each", [get(env, context, "user.featured_user_badges")], {"keyword": "ub"}, child0, null);
          block(env, morph1, context, "if", [get(env, context, "showMoreBadges")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","card-content");
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","card-huge-avatar");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","names");
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("h1");
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("a");
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode(" ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n      ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n    ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("ul");
        dom.setAttribute(el2,"class","usercard-controls");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline, concat = hooks.concat, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [0]);
        var element10 = dom.childAt(element9, [1]);
        var element11 = dom.childAt(element9, [3, 1]);
        var element12 = dom.childAt(element11, [1]);
        var element13 = dom.childAt(element12, [1]);
        var element14 = dom.childAt(element9, [5]);
        var morph0 = dom.createMorphAt(element10,0,0);
        var attrMorph0 = dom.createAttrMorph(element10, 'href');
        var attrMorph1 = dom.createAttrMorph(element12, 'class');
        var morph1 = dom.createMorphAt(element13,0,0);
        var morph2 = dom.createMorphAt(element13,2,2);
        var attrMorph2 = dom.createAttrMorph(element13, 'href');
        var morph3 = dom.createMorphAt(element11,3,3);
        var morph4 = dom.createMorphAt(element11,5,5);
        var morph5 = dom.createMorphAt(element11,7,7);
        var morph6 = dom.createMorphAt(element14,1,1);
        var morph7 = dom.createMorphAt(element14,3,3);
        var morph8 = dom.createMorphAt(element14,5,5);
        var morph9 = dom.createMorphAt(element14,7,7);
        var morph10 = dom.createMorphAt(element9,7,7);
        var morph11 = dom.createMorphAt(element9,9,9);
        var morph12 = dom.createMorphAt(element9,11,11);
        var morph13 = dom.createMorphAt(element9,13,13);
        attribute(env, attrMorph0, element10, "href", get(env, context, "user.path"));
        element(env, element10, context, "action", ["showUser"], {});
        inline(env, morph0, context, "bound-avatar", [get(env, context, "avatar"), "huge"], {});
        attribute(env, attrMorph1, element12, "class", concat(env, [get(env, context, "staff"), " ", get(env, context, "new_user")]));
        attribute(env, attrMorph2, element13, "href", get(env, context, "user.path"));
        element(env, element13, context, "action", ["showUser"], {});
        content(env, morph1, context, "username");
        inline(env, morph2, context, "user-status", [get(env, context, "user")], {"currentUser": get(env, context, "currentUser")});
        block(env, morph3, context, "if", [get(env, context, "user.name")], {}, child0, null);
        block(env, morph4, context, "if", [get(env, context, "user.title")], {}, child1, null);
        inline(env, morph5, context, "plugin-outlet", ["user-card-post-names"], {});
        block(env, morph6, context, "if", [get(env, context, "user.can_send_private_message_to_user")], {}, child2, null);
        block(env, morph7, context, "if", [get(env, context, "showFilter")], {}, child3, null);
        block(env, morph8, context, "if", [get(env, context, "hasUserFilters")], {}, child4, null);
        block(env, morph9, context, "if", [get(env, context, "showDelete")], {}, child5, null);
        block(env, morph10, context, "if", [get(env, context, "isSuspended")], {}, child6, child7);
        block(env, morph11, context, "if", [get(env, context, "user.card_badge")], {}, child8, null);
        block(env, morph12, context, "if", [get(env, context, "user")], {}, child9, null);
        block(env, morph13, context, "if", [get(env, context, "showBadges")], {}, child10, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "controller.visible")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-invited-show"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "resumable-upload", [], {"target": "/invites/upload", "success": "uploadSuccess", "error": "uploadError", "uploadText": get(env, context, "uploadText")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","user-invite-controls");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","span15");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("ul");
          dom.setAttribute(el3,"class","nav nav-pills");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","pull-right");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var element7 = dom.childAt(element6, [1, 1]);
          var element8 = dom.childAt(element6, [3]);
          var morph0 = dom.createMorphAt(element7,1,1);
          var morph1 = dom.createMorphAt(element7,3,3);
          var morph2 = dom.createMorphAt(element8,1,1);
          var morph3 = dom.createMorphAt(element8,3,3);
          inline(env, morph0, context, "nav-item", [], {"route": "userInvited.show", "routeParam": "pending", "i18nLabel": get(env, context, "pendingLabel")});
          inline(env, morph1, context, "nav-item", [], {"route": "userInvited.show", "routeParam": "redeemed", "i18nLabel": get(env, context, "redeemedLabel")});
          inline(env, morph2, context, "d-button", [], {"icon": "plus", "action": "showInvite", "label": "user.invited.create", "class": "btn"});
          block(env, morph3, context, "if", [get(env, context, "canBulkInvite")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","user-invite-search");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("form");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),0,0);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "searchTerm"), "placeholderKey": "user.invited.search"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
              var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),0,0);
              var morph4 = dom.createMorphAt(dom.childAt(fragment, [9]),0,0);
              inline(env, morph0, context, "i18n", ["user.last_seen"], {});
              inline(env, morph1, context, "i18n", ["user.invited.topics_entered"], {});
              inline(env, morph2, context, "i18n", ["user.invited.posts_read_count"], {});
              inline(env, morph3, context, "i18n", ["user.invited.time_read"], {});
              inline(env, morph4, context, "i18n", ["user.invited.days_visited"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
            dom.insertBoundary(fragment, null);
            inline(env, morph0, context, "i18n", ["user.invited.user"], {});
            inline(env, morph1, context, "i18n", ["user.invited.redeemed_at"], {});
            block(env, morph2, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            dom.setAttribute(el1,"colspan","1");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            dom.setAttribute(el1,"colspan","6");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["user.invited.user"], {});
            inline(env, morph1, context, "i18n", ["user.invited.sent"], {});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                inline(env, morph0, context, "avatar", [get(env, context, "invite.user")], {"imageSize": "tiny"});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                content(env, morph0, context, "invite.user.username");
                return fragment;
              }
            };
          }());
          var child2 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createElement("span");
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("\n                    /\n                  ");
                dom.appendChild(el1, el2);
                var el2 = dom.createElement("span");
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [9]);
                var element2 = dom.childAt(element1, [0]);
                var element3 = dom.childAt(element1, [2]);
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
                var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
                var morph3 = dom.createUnsafeMorphAt(dom.childAt(fragment, [7]),0,0);
                var morph4 = dom.createUnsafeMorphAt(element2,0,0);
                var attrMorph0 = dom.createAttrMorph(element2, 'title');
                var morph5 = dom.createUnsafeMorphAt(element3,0,0);
                var attrMorph1 = dom.createAttrMorph(element3, 'title');
                inline(env, morph0, context, "format-date", [get(env, context, "invite.user.last_seen_at")], {});
                inline(env, morph1, context, "number", [get(env, context, "invite.user.topics_entered")], {});
                inline(env, morph2, context, "number", [get(env, context, "invite.user.posts_read_count")], {});
                inline(env, morph3, context, "unbound", [get(env, context, "invite.user.time_read")], {});
                attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["user.invited.days_visited"], {})]));
                inline(env, morph4, context, "unbound", [get(env, context, "invite.user.days_visited")], {});
                attribute(env, attrMorph1, element3, "title", concat(env, [subexpr(env, context, "i18n", ["user.invited.account_age_days"], {})]));
                inline(env, morph5, context, "unbound", [get(env, context, "invite.user.days_since_created")], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element4 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element4,1,1);
              var morph1 = dom.createMorphAt(element4,3,3);
              var morph2 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
              dom.insertBoundary(fragment, null);
              block(env, morph0, context, "link-to", ["user", get(env, context, "invite.user")], {}, child0, null);
              block(env, morph1, context, "link-to", ["user", get(env, context, "invite.user")], {}, child1, null);
              inline(env, morph2, context, "format-date", [get(env, context, "invite.redeemed_at")], {});
              block(env, morph3, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child2, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                      \n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "i18n", ["user.invited.expired"], {});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "i18n", ["user.invited.rescinded"], {});
                return fragment;
              }
            };
          }());
          var child2 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"icon": "times", "action": "rescind", "actionParam": get(env, context, "invite"), "class": "btn", "label": "user.invited.rescind"});
                return fragment;
              }
            };
          }());
          var child3 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "i18n", ["user.invited.reinvited"], {});
                return fragment;
              }
            };
          }());
          var child4 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"icon": "refresh", "action": "reinvite", "actionParam": get(env, context, "invite"), "class": "btn", "label": "user.invited.reinvite"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              dom.setAttribute(el1,"colspan","5");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                    \n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [5]);
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              var morph2 = dom.createMorphAt(element0,1,1);
              var morph3 = dom.createMorphAt(element0,2,2);
              var morph4 = dom.createMorphAt(element0,4,4);
              inline(env, morph0, context, "unbound", [get(env, context, "invite.email")], {});
              inline(env, morph1, context, "format-date", [get(env, context, "invite.created_at")], {});
              block(env, morph2, context, "if", [get(env, context, "invite.expired")], {}, child0, null);
              block(env, morph3, context, "if", [get(env, context, "invite.rescinded")], {}, child1, child2);
              block(env, morph4, context, "if", [get(env, context, "invite.reinvited")], {}, child3, child4);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "if", [get(env, context, "invite.user")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","table user-invite-list");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tr");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element5, [1]),1,1);
          var morph1 = dom.createMorphAt(element5,3,3);
          var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
          block(env, morph0, context, "if", [get(env, context, "inviteRedeemed")], {}, child0, child1);
          block(env, morph1, context, "each", [get(env, context, "model.invites")], {"keyword": "invite"}, child2, null);
          inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "invitesLoading")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["user.invited.bulk_invite.none"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["user.invited.none"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","user-invite-none");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "if", [get(env, context, "canBulkInvite")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","user-content");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h2");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
        var morph1 = dom.createMorphAt(element9,3,3);
        var morph2 = dom.createMorphAt(element9,5,5);
        var morph3 = dom.createMorphAt(element9,7,7);
        inline(env, morph0, context, "i18n", ["user.invited.title"], {});
        block(env, morph1, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child0, null);
        block(env, morph2, context, "if", [get(env, context, "showSearch")], {}, child1, null);
        block(env, morph3, context, "if", [get(env, context, "model.invites")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "canInviteToForum")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(depth0,helpers,partials,data) {
  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "      <li>\n        <a href>\n          "
    + escapeExpression(((helpers.avatar || (depth0 && depth0.avatar) || helperMissing).call(depth0, "user", {"name":"avatar","hash":{
    'imageSize': ("tiny")
  },"hashTypes":{'imageSize': "STRING"},"hashContexts":{'imageSize': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "\n          <span class='username'>"
    + escapeExpression(helpers.get.call(depth0, "user.username", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</span>\n          <span class='name'>"
    + escapeExpression(helpers.get.call(depth0, "user.name", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</span>\n        </a>\n      </li>\n";
},"3":function(depth0,helpers,partials,data) {
  var stack1, buffer = "";
  stack1 = helpers.each.call(depth0, "group", "in", "options.groups", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(4, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"4":function(depth0,helpers,partials,data) {
  var escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;
  return "        <li>\n          <a href>\n            <i class='fa fa-users'></i>\n            <span class='username'>"
    + escapeExpression(helpers.get.call(depth0, "group.name", {"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["ID"],"contexts":[depth0],"data":data}))
    + "</span>\n            <span class='name'>"
    + escapeExpression(((helpers['max-usernames'] || (depth0 && depth0['max-usernames']) || helperMissing).call(depth0, "group.usernames", {"name":"max-usernames","hash":{
    'max': ("3")
  },"hashTypes":{'max': "STRING"},"hashContexts":{'max': depth0},"types":["ID"],"contexts":[depth0],"data":data})))
    + "</span>\n          </a>\n        </li>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, buffer = "<div class='autocomplete'>\n  <ul>\n";
  stack1 = helpers.each.call(depth0, "user", "in", "options.users", {"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(1, data),"inverse":this.noop,"types":["ID","ID","ID"],"contexts":[depth0,depth0,depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  stack1 = helpers['if'].call(depth0, "options.groups", {"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":this.program(3, data),"inverse":this.noop,"types":["ID"],"contexts":[depth0],"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["user-topics-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","clearfix");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn btn-primary pull-right new-private-message");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["composePrivateMessage"], {});
        inline(env, morph0, context, "fa-icon", ["envelope"], {});
        inline(env, morph1, context, "i18n", ["user.new_private_message"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "showNewPM")], {}, child0, null);
      inline(env, morph1, context, "basic-topic-list", [], {"topicList": get(env, context, "model"), "hideCategory": get(env, context, "hideCategory"), "showParticipants": get(env, context, "showParticipants"), "postsAction": "showTopicEntrance"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/about"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      dom.setAttribute(el1,"class","form-horizontal");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h3");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","control-label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      var morph3 = dom.createMorphAt(dom.childAt(element0, [5, 1]),1,1);
      inline(env, morph0, context, "i18n", ["user.change_about.title"], {});
      inline(env, morph1, context, "i18n", ["user.bio"], {});
      inline(env, morph2, context, "d-editor", [], {"value": get(env, context, "model.bio_raw")});
      block(env, morph3, context, "d-button", [], {"action": "changeAbout", "class": "btn btn-primary"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/activity"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/badge-title"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5, 1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3, 3]),1,1);
      var morph2 = dom.createMorphAt(element2,0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["badges.select_badge_for_title"], {});
      inline(env, morph1, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "selectedUserBadgeId"), "nameProperty": "badge.displayName", "content": get(env, context, "selectableUserBadges")});
      element(env, element2, context, "bind-attr", [], {"disabled": get(env, context, "disableSave")});
      element(env, element2, context, "action", ["save"], {});
      content(env, morph2, context, "savingStatus");
      block(env, morph3, context, "if", [get(env, context, "saved")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/badges"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "user-badge", [], {"badge": get(env, context, "ub.badge"), "count": get(env, context, "ub.count")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content user-badges-list");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "controller")], {"keyword": "ub"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/email"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_email.success"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","control-group");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","instructions");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","alert alert-error");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
          content(env, morph0, context, "errorMessage");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_email.taken"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.email.instructions"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("button");
        dom.setAttribute(el3,"class","btn btn-primary");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [2]);
        var element1 = dom.childAt(fragment, [4, 1, 1]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
        var morph4 = dom.createMorphAt(element1,0,0);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "error")], {}, child0, null);
        inline(env, morph1, context, "i18n", ["user.email.title"], {});
        inline(env, morph2, context, "text-field", [], {"value": get(env, context, "newEmail"), "id": "change_email", "classNames": "input-xxlarge"});
        block(env, morph3, context, "if", [get(env, context, "taken")], {}, child1, child2);
        element(env, element1, context, "action", ["changeEmail"], {});
        element(env, element1, context, "bind-attr", [], {"disabled": "saveDisabled"});
        content(env, morph4, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element2, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "i18n", ["user.change_email.title"], {});
      block(env, morph1, context, "if", [get(env, context, "success")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/notifications"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["errors.reasons.forbidden"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["errors.desc.unknown"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","item error");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "model.forbidden")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","notification-buttons");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"id","dismiss-notifications-top");
        dom.setAttribute(el2,"class","btn notifications-read");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element2,0,0);
        var attrMorph0 = dom.createAttrMorph(element2, 'title');
        attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["user.dismiss_notifications_tooltip"], {})]));
        element(env, element2, context, "action", ["resetNew"], {});
        inline(env, morph0, context, "i18n", ["user.dismiss_notifications"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","time");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        element(env, element1, context, "bind-attr", [], {"class": ":item :notification n.read::unread"});
        inline(env, morph0, context, "notification-item", [], {"notification": get(env, context, "n")});
        inline(env, morph1, context, "format-date", [get(env, context, "n.created_at")], {"leaveAgo": "true"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","notification-buttons");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("button");
            dom.setAttribute(el2,"id","dismiss-notifications");
            dom.setAttribute(el2,"class","btn notifications-read");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'title');
            attribute(env, attrMorph0, element0, "title", concat(env, [subexpr(env, context, "i18n", ["user.dismiss_notifications_tooltip"], {})]));
            element(env, element0, context, "action", ["resetNew"], {});
            inline(env, morph0, context, "i18n", ["user.dismiss_notifications"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "showDismissButton")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "model.canLoadMore")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model.error")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "showDismissButton")], {}, child1, null);
      block(env, morph2, context, "each", [get(env, context, "model")], {"keyword": "n"}, child2, null);
      block(env, morph3, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","delete-info");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("i");
          dom.setAttribute(el2,"class","fa fa-trash-o");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,3,3);
          var morph1 = dom.createMorphAt(element0,5,5);
          inline(env, morph0, context, "avatar", [get(env, context, "p.deleted_by")], {"imageSize": "tiny", "extraClasses": "actor", "ignoreTitle": "true"});
          inline(env, morph1, context, "format-date", [get(env, context, "p.deleted_at")], {"leaveAgo": "true"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix info");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"class","avatar-link");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("div");
        dom.setAttribute(el4,"class","avatar-wrapper");
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","time");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","title");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("a");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","category");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("p");
        dom.setAttribute(el2,"class","excerpt");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [1]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [5, 1]);
        var attrMorph0 = dom.createAttrMorph(element3, 'href');
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
        var morph2 = dom.createMorphAt(element4,0,0);
        var attrMorph1 = dom.createAttrMorph(element4, 'href');
        var morph3 = dom.createMorphAt(dom.childAt(element2, [7]),1,1);
        var morph4 = dom.createMorphAt(element2,9,9);
        var morph5 = dom.createUnsafeMorphAt(dom.childAt(element1, [3]),1,1);
        element(env, element1, context, "bind-attr", [], {"class": ":item p.hidden p.deleted p.moderator_action"});
        attribute(env, attrMorph0, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.usernameUrl")], {})]));
        inline(env, morph0, context, "avatar", [get(env, context, "p")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
        inline(env, morph1, context, "format-date", [get(env, context, "p.created_at")], {"leaveAgo": "true"});
        attribute(env, attrMorph1, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.url")], {})]));
        inline(env, morph2, context, "unbound", [get(env, context, "p.topic_title")], {});
        inline(env, morph3, context, "category-link", [get(env, context, "p.category")], {});
        block(env, morph4, context, "if", [get(env, context, "p.deleted")], {}, child0, null);
        content(env, morph5, context, "p.excerpt");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "model.content")], {"keyword": "p"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/preferences"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","fa fa-pencil");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        block(env, morph0, context, "link-to", ["preferences.username"], {"class": "btn btn-small pad-left no-text"}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "newNameInput"), "classNames": "input-xxlarge"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","static");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "name");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-name");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element10 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element10, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element10, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element10, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.name.title"], {});
        block(env, morph1, context, "if", [get(env, context, "model.can_edit_name")], {}, child0, child1);
        content(env, morph2, context, "nameInstructions");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-title");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","static");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element8 = dom.childAt(fragment, [1]);
        var element9 = dom.childAt(element8, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(element8, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
        var morph2 = dom.createMorphAt(element9,3,3);
        inline(env, morph0, context, "i18n", ["user.title.title"], {});
        content(env, morph1, context, "model.title");
        block(env, morph2, context, "link-to", ["preferences.badgeTitle"], {"class": "btn btn-small pad-left no-text"}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "fa-icon", ["pencil"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            block(env, morph0, context, "link-to", ["preferences.email"], {"class": "btn btn-small pad-left no-text"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","static");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","instructions");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
          var morph1 = dom.createMorphAt(element6,3,3);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
          content(env, morph0, context, "model.email");
          block(env, morph1, context, "if", [get(env, context, "model.can_edit_email")], {}, child0, null);
          inline(env, morph2, context, "i18n", ["user.email.instructions"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "d-button", [], {"action": "checkEmail", "actionParam": get(env, context, "model"), "title": "admin.users.check_email.title", "icon": "envelope-o", "label": "admin.users.check_email.text"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-email");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
        var morph1 = dom.createMorphAt(element7,3,3);
        inline(env, morph0, context, "i18n", ["user.email.title"], {});
        block(env, morph1, context, "if", [get(env, context, "model.email")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_password.set_password"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_password.action"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-password");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"href","");
        dom.setAttribute(el3,"class","btn");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var element4 = dom.childAt(element3, [3]);
        var element5 = dom.childAt(element4, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
        var morph1 = dom.createMorphAt(element5,1,1);
        var morph2 = dom.createMorphAt(element5,3,3);
        var morph3 = dom.createMorphAt(element4,3,3);
        inline(env, morph0, context, "i18n", ["user.password.title"], {});
        element(env, element5, context, "action", ["changePassword"], {});
        inline(env, morph1, context, "fa-icon", ["envelope"], {});
        block(env, morph2, context, "if", [get(env, context, "model.no_password")], {}, child0, child1);
        content(env, morph3, context, "passwordProgress");
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showAvatarSelector", "class": "pad-left", "icon": "pencil"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-profile-bg");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-profile-bg");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element1, [5]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
        var morph4 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
        var morph5 = dom.createMorphAt(dom.childAt(element2, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.change_profile_background.title"], {});
        inline(env, morph1, context, "image-uploader", [], {"imageUrl": get(env, context, "model.profile_background"), "type": "profile_background"});
        inline(env, morph2, context, "i18n", ["user.change_profile_background.instructions"], {});
        inline(env, morph3, context, "i18n", ["user.change_card_background.title"], {});
        inline(env, morph4, context, "image-uploader", [], {"imageUrl": get(env, context, "model.card_background"), "type": "card_background"});
        inline(env, morph5, context, "i18n", ["user.change_card_background.instructions"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-locale");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.locale.title"], {});
        inline(env, morph1, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "availableLocales"), "value": get(env, context, "model.locale"), "none": "user.locale.default"});
        inline(env, morph2, context, "i18n", ["user.locale.instructions"], {});
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "user-field", [], {"field": get(env, context, "uf.field"), "value": get(env, context, "uf.value")});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "icon-or-image", [get(env, context, "model.card_image_badge")], {});
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", ["pencil"], {});
        return fragment;
      }
    };
  }());
  var child11 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls controls-dropdown");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "digestFrequencies"), "value": get(env, context, "model.digest_after_days")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "user.email_digests.title", "checked": get(env, context, "model.email_digests")});
        block(env, morph1, context, "if", [get(env, context, "model.email_digests")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child12 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["user.email.frequency"], {"count": get(env, context, "siteSettings.email_time_window_mins")});
        return fragment;
      }
    };
  }());
  var child13 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["user.email.frequency_immediately"], {});
        return fragment;
      }
    };
  }());
  var child14 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "user.edit_history_public", "checked": get(env, context, "model.edit_history_public")});
        return fragment;
      }
    };
  }());
  var child15 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "user.automatically_unpin_topics", "checked": get(env, context, "model.automatically_unpin_topics")});
        return fragment;
      }
    };
  }());
  var child16 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group delete-account");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("hr");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 3]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "delete", "disabled": get(env, context, "deleteDisabled"), "class": "btn-danger", "icon": "trash-o", "label": "user.delete_account"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content user-preferences");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group save-button");
      dom.setAttribute(el3,"id","save-button-top");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-username");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","static");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-avatar");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-bio");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls bio-composer");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-location");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-website");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-card-badge");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-email-settings");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group notifications");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group other");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group category");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-exclamation-circle watching");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-circle tracking");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-times-circle muted");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group topics");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls topic-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("a");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group muting");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-times-circle muted");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element11 = dom.childAt(fragment, [0, 1]);
      var element12 = dom.childAt(element11, [3]);
      var element13 = dom.childAt(element12, [3]);
      var element14 = dom.childAt(element11, [13]);
      var element15 = dom.childAt(element14, [3]);
      var element16 = dom.childAt(element11, [19]);
      var element17 = dom.childAt(element11, [25]);
      var element18 = dom.childAt(element11, [27]);
      var element19 = dom.childAt(element11, [29]);
      var element20 = dom.childAt(element19, [3]);
      var element21 = dom.childAt(element11, [31]);
      var element22 = dom.childAt(element11, [33]);
      var element23 = dom.childAt(element11, [35]);
      var element24 = dom.childAt(element23, [3]);
      var element25 = dom.childAt(element23, [5]);
      var element26 = dom.childAt(element11, [37]);
      var element27 = dom.childAt(element26, [3]);
      var element28 = dom.childAt(element26, [7]);
      var element29 = dom.childAt(element26, [11]);
      var element30 = dom.childAt(element11, [39]);
      var element31 = dom.childAt(element30, [5, 1]);
      var element32 = dom.childAt(element11, [41]);
      var element33 = dom.childAt(element32, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element11, [1, 1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element12, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element13, [1]),0,0);
      var morph3 = dom.createMorphAt(element13,3,3);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element12, [5]),1,1);
      var morph5 = dom.createMorphAt(element11,5,5);
      var morph6 = dom.createMorphAt(element11,7,7);
      var morph7 = dom.createMorphAt(element11,9,9);
      var morph8 = dom.createMorphAt(element11,11,11);
      var morph9 = dom.createMorphAt(dom.childAt(element14, [1]),0,0);
      var morph10 = dom.createMorphAt(element15,1,1);
      var morph11 = dom.createMorphAt(element15,3,3);
      var morph12 = dom.createMorphAt(element11,15,15);
      var morph13 = dom.createMorphAt(element11,17,17);
      var morph14 = dom.createMorphAt(dom.childAt(element16, [1]),0,0);
      var morph15 = dom.createMorphAt(dom.childAt(element16, [3]),1,1);
      var morph16 = dom.createMorphAt(element11,21,21);
      var morph17 = dom.createMorphAt(dom.childAt(element17, [1]),0,0);
      var morph18 = dom.createMorphAt(dom.childAt(element17, [3]),1,1);
      var morph19 = dom.createMorphAt(dom.childAt(element18, [1]),0,0);
      var morph20 = dom.createMorphAt(dom.childAt(element18, [3]),1,1);
      var morph21 = dom.createMorphAt(dom.childAt(element19, [1]),0,0);
      var morph22 = dom.createMorphAt(element20,1,1);
      var morph23 = dom.createMorphAt(element20,3,3);
      var morph24 = dom.createMorphAt(dom.childAt(element21, [1]),0,0);
      var morph25 = dom.createMorphAt(element21,3,3);
      var morph26 = dom.createMorphAt(element21,5,5);
      var morph27 = dom.createMorphAt(element21,7,7);
      var morph28 = dom.createMorphAt(element21,9,9);
      var morph29 = dom.createMorphAt(element21,11,11);
      var morph30 = dom.createMorphAt(dom.childAt(element21, [13]),1,1);
      var morph31 = dom.createMorphAt(dom.childAt(element22, [1]),0,0);
      var morph32 = dom.createMorphAt(element22,3,3);
      var morph33 = dom.createMorphAt(dom.childAt(element22, [5]),0,0);
      var morph34 = dom.createMorphAt(dom.childAt(element23, [1]),0,0);
      var morph35 = dom.createMorphAt(dom.childAt(element24, [1]),0,0);
      var morph36 = dom.createMorphAt(element24,3,3);
      var morph37 = dom.createMorphAt(dom.childAt(element25, [1]),0,0);
      var morph38 = dom.createMorphAt(element25,3,3);
      var morph39 = dom.createMorphAt(element23,7,7);
      var morph40 = dom.createMorphAt(element23,9,9);
      var morph41 = dom.createMorphAt(element23,11,11);
      var morph42 = dom.createMorphAt(element23,13,13);
      var morph43 = dom.createMorphAt(element23,15,15);
      var morph44 = dom.createMorphAt(element23,17,17);
      var morph45 = dom.createMorphAt(dom.childAt(element26, [1]),0,0);
      var morph46 = dom.createMorphAt(dom.childAt(element27, [1]),2,2);
      var morph47 = dom.createMorphAt(element27,3,3);
      var morph48 = dom.createMorphAt(dom.childAt(element26, [5]),0,0);
      var morph49 = dom.createMorphAt(dom.childAt(element28, [1]),2,2);
      var morph50 = dom.createMorphAt(element28,3,3);
      var morph51 = dom.createMorphAt(dom.childAt(element26, [9]),0,0);
      var morph52 = dom.createMorphAt(dom.childAt(element29, [1]),2,2);
      var morph53 = dom.createMorphAt(element29,3,3);
      var morph54 = dom.createMorphAt(dom.childAt(element26, [13]),0,0);
      var morph55 = dom.createMorphAt(dom.childAt(element30, [1]),0,0);
      var morph56 = dom.createMorphAt(element30,3,3);
      var morph57 = dom.createMorphAt(element31,0,0);
      var attrMorph0 = dom.createAttrMorph(element31, 'href');
      var morph58 = dom.createMorphAt(dom.childAt(element32, [1]),0,0);
      var morph59 = dom.createMorphAt(dom.childAt(element33, [1]),2,2);
      var morph60 = dom.createMorphAt(element33,3,3);
      var morph61 = dom.createMorphAt(dom.childAt(element32, [5]),0,0);
      var morph62 = dom.createMorphAt(element11,43,43);
      var morph63 = dom.createMorphAt(dom.childAt(element11, [45, 1]),1,1);
      var morph64 = dom.createMorphAt(element11,47,47);
      inline(env, morph0, context, "partial", ["user/preferences/save-button"], {});
      inline(env, morph1, context, "i18n", ["user.username.title"], {});
      content(env, morph2, context, "model.username");
      block(env, morph3, context, "if", [get(env, context, "model.can_edit_username")], {}, child0, null);
      inline(env, morph4, context, "i18n", ["user.username.short_instructions"], {"username": get(env, context, "model.username")});
      block(env, morph5, context, "if", [get(env, context, "canEditName")], {}, child1, null);
      block(env, morph6, context, "if", [get(env, context, "canSelectTitle")], {}, child2, null);
      block(env, morph7, context, "if", [get(env, context, "canCheckEmails")], {}, child3, null);
      block(env, morph8, context, "if", [get(env, context, "canChangePassword")], {}, child4, null);
      inline(env, morph9, context, "i18n", ["user.avatar.title"], {});
      inline(env, morph10, context, "bound-avatar", [get(env, context, "model"), "huge"], {});
      block(env, morph11, context, "unless", [get(env, context, "siteSettings.sso_overrides_avatar")], {}, child5, null);
      block(env, morph12, context, "if", [get(env, context, "siteSettings.allow_profile_backgrounds")], {}, child6, null);
      block(env, morph13, context, "if", [get(env, context, "siteSettings.allow_user_locale")], {}, child7, null);
      inline(env, morph14, context, "i18n", ["user.bio"], {});
      inline(env, morph15, context, "d-editor", [], {"value": get(env, context, "model.bio_raw")});
      block(env, morph16, context, "each", [get(env, context, "userFields")], {"keyword": "uf"}, child8, null);
      inline(env, morph17, context, "i18n", ["user.location"], {});
      inline(env, morph18, context, "input", [], {"type": "text", "value": get(env, context, "model.location"), "class": "input-xxlarge", "id": "edit-location"});
      inline(env, morph19, context, "i18n", ["user.website"], {});
      inline(env, morph20, context, "input", [], {"type": "text", "value": get(env, context, "model.website"), "class": "input-xxlarge"});
      inline(env, morph21, context, "i18n", ["user.card_badge.title"], {});
      block(env, morph22, context, "if", [get(env, context, "model.card_image_badge")], {}, child9, null);
      block(env, morph23, context, "link-to", ["preferences.card-badge"], {"class": "btn btn-small pad-left no-text"}, child10, null);
      inline(env, morph24, context, "i18n", ["user.email_settings"], {});
      block(env, morph25, context, "if", [get(env, context, "canReceiveDigest")], {}, child11, null);
      inline(env, morph26, context, "preference-checkbox", [], {"labelKey": "user.email_private_messages", "checked": get(env, context, "model.email_private_messages")});
      inline(env, morph27, context, "preference-checkbox", [], {"labelKey": "user.email_direct", "checked": get(env, context, "model.email_direct")});
      inline(env, morph28, context, "preference-checkbox", [], {"labelKey": "user.mailing_list_mode", "checked": get(env, context, "model.mailing_list_mode")});
      inline(env, morph29, context, "preference-checkbox", [], {"labelKey": "user.email_always", "checked": get(env, context, "model.email_always")});
      block(env, morph30, context, "if", [get(env, context, "siteSettings.email_time_window_mins")], {}, child12, child13);
      inline(env, morph31, context, "i18n", ["user.desktop_notifications.label"], {});
      content(env, morph32, context, "desktop-notification-config");
      inline(env, morph33, context, "i18n", ["user.desktop_notifications.each_browser_note"], {});
      inline(env, morph34, context, "i18n", ["user.other_settings"], {});
      inline(env, morph35, context, "i18n", ["user.new_topic_duration.label"], {});
      inline(env, morph36, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "considerNewTopicOptions"), "value": get(env, context, "model.new_topic_duration_minutes")});
      inline(env, morph37, context, "i18n", ["user.auto_track_topics"], {});
      inline(env, morph38, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "autoTrackDurations"), "value": get(env, context, "model.auto_track_topics_after_msecs")});
      inline(env, morph39, context, "preference-checkbox", [], {"labelKey": "user.external_links_in_new_tab", "checked": get(env, context, "model.external_links_in_new_tab")});
      inline(env, morph40, context, "preference-checkbox", [], {"labelKey": "user.enable_quoting", "checked": get(env, context, "model.enable_quoting")});
      inline(env, morph41, context, "preference-checkbox", [], {"labelKey": "user.dynamic_favicon", "checked": get(env, context, "model.dynamic_favicon")});
      inline(env, morph42, context, "preference-checkbox", [], {"labelKey": "user.disable_jump_reply", "checked": get(env, context, "model.disable_jump_reply")});
      block(env, morph43, context, "unless", [get(env, context, "siteSettings.edit_history_visible_to_public")], {}, child14, null);
      inline(env, morph44, context, "plugin-outlet", ["user-custom-preferences"], {});
      inline(env, morph45, context, "i18n", ["user.categories_settings"], {});
      inline(env, morph46, context, "i18n", ["user.watched_categories"], {});
      inline(env, morph47, context, "category-group", [], {"categories": get(env, context, "model.watchedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph48, context, "i18n", ["user.watched_categories_instructions"], {});
      inline(env, morph49, context, "i18n", ["user.tracked_categories"], {});
      inline(env, morph50, context, "category-group", [], {"categories": get(env, context, "model.trackedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph51, context, "i18n", ["user.tracked_categories_instructions"], {});
      inline(env, morph52, context, "i18n", ["user.muted_categories"], {});
      inline(env, morph53, context, "category-group", [], {"categories": get(env, context, "model.mutedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph54, context, "i18n", ["user.muted_categories_instructions"], {});
      inline(env, morph55, context, "i18n", ["categories.topics"], {});
      block(env, morph56, context, "if", [get(env, context, "siteSettings.automatically_unpin_topics")], {}, child15, null);
      attribute(env, attrMorph0, element31, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.mutedTopicsPath")], {})]));
      inline(env, morph57, context, "i18n", ["user.muted_topics_link"], {});
      inline(env, morph58, context, "i18n", ["user.users"], {});
      inline(env, morph59, context, "i18n", ["user.muted_users"], {});
      inline(env, morph60, context, "user-selector", [], {"excludeCurrentUser": true, "usernames": get(env, context, "model.muted_usernames"), "class": "user-selector"});
      inline(env, morph61, context, "i18n", ["user.muted_users_instructions"], {});
      inline(env, morph62, context, "plugin-outlet", ["user-custom-controls"], {});
      inline(env, morph63, context, "partial", ["user/preferences/save-button"], {});
      block(env, morph64, context, "if", [get(env, context, "model.canDeleteAccount")], {}, child16, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/preferences/_save-button"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","saved-user");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "d-button", [], {"action": "save", "disabled": get(env, context, "model.isSaving"), "class": "btn btn-primary save-user"}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "saved")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/stream"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "item", blockArguments[0]);
        inline(env, morph0, context, "stream-item", [], {"item": get(env, context, "item"), "removeBookmark": "removeBookmark"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "model.content")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/user"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","helpful-flags");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element17 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element17, [0]),0,0);
        var morph1 = dom.createMorphAt(element17,2,2);
        content(env, morph0, context, "model.number_of_flags_given");
        inline(env, morph1, context, "i18n", ["user.staff_counters.flags_given"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","flagged-posts");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "model.number_of_flagged_posts");
          inline(env, morph1, context, "i18n", ["user.staff_counters.flagged_posts"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "link-to", ["user.flaggedPosts", get(env, context, "model")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","deleted-posts");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "model.number_of_deleted_posts");
          inline(env, morph1, context, "i18n", ["user.staff_counters.deleted_posts"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "link-to", ["user.deletedPosts", get(env, context, "model")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","suspensions");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element16 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element16, [0]),0,0);
        var morph1 = dom.createMorphAt(element16,2,2);
        content(env, morph0, context, "model.number_of_suspensions");
        inline(env, morph1, context, "i18n", ["user.staff_counters.suspensions"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","warnings-received");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element15 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element15, [0]),0,0);
        var morph1 = dom.createMorphAt(element15,2,2);
        content(env, morph0, context, "model.number_of_warnings");
        inline(env, morph1, context, "i18n", ["user.staff_counters.warnings_received"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n                ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn btn-primary");
        var el3 = dom.createTextNode("\n                  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n                  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n                ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n              ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element14 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element14,1,1);
        var morph1 = dom.createMorphAt(element14,3,3);
        element(env, element14, context, "action", ["composePrivateMessage", get(env, context, "model")], {});
        inline(env, morph0, context, "fa-icon", ["envelope"], {});
        inline(env, morph1, context, "i18n", ["user.private_message"], {});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        dom.setAttribute(el2,"class","btn btn-danger");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element13 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element13,0,0);
        var morph1 = dom.createMorphAt(element13,1,1);
        element(env, element13, context, "action", ["logout"], {});
        inline(env, morph0, context, "fa-icon", ["sign-out"], {});
        inline(env, morph1, context, "i18n", ["user.log_out"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element12 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element12,0,0);
        var morph1 = dom.createMorphAt(element12,1,1);
        var attrMorph0 = dom.createAttrMorph(element12, 'href');
        attribute(env, attrMorph0, element12, "href", get(env, context, "model.adminPath"));
        inline(env, morph0, context, "fa-icon", ["wrench"], {});
        inline(env, morph1, context, "i18n", ["admin.user.show_admin_profile"], {});
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "fa-icon", ["cog"], {});
          inline(env, morph1, context, "i18n", ["user.preferences"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        block(env, morph0, context, "link-to", ["preferences"], {"class": "btn"}, child0, null);
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "fa-icon", ["user-plus"], {});
          inline(env, morph1, context, "i18n", ["user.invited.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        block(env, morph0, context, "link-to", ["userInvited"], {"class": "btn"}, child0, null);
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","btn");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element11 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element11,0,0);
          var morph1 = dom.createMorphAt(element11,1,1);
          element(env, element11, context, "action", ["expandProfile"], {});
          inline(env, morph0, context, "fa-icon", ["angle-double-down"], {});
          inline(env, morph1, context, "i18n", ["user.expand_profile"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "viewingSelf")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child11 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "model.title");
        return fragment;
      }
    };
  }());
  var child12 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", ["map-marker"], {});
        content(env, morph1, context, "model.location");
        return fragment;
      }
    };
  }());
  var child13 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"target","_blank");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element10,0,0);
          var attrMorph0 = dom.createAttrMorph(element10, 'href');
          var attrMorph1 = dom.createAttrMorph(element10, 'rel');
          attribute(env, attrMorph0, element10, "href", get(env, context, "model.website"));
          attribute(env, attrMorph1, element10, "rel", subexpr(env, context, "unless", [get(env, context, "removeNoFollow"), "nofollow"], {}));
          content(env, morph0, context, "model.website_name");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element9 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element9,0,0);
          var attrMorph0 = dom.createAttrMorph(element9, 'title');
          attribute(env, attrMorph0, element9, "title", get(env, context, "model.website"));
          content(env, morph0, context, "model.website_name");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "fa-icon", ["globe"], {});
        block(env, morph1, context, "if", [get(env, context, "linkWebsite")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child14 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","suspended");
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("b");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("br");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("b");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element8 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element8,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element8, [6]),0,0);
        var morph3 = dom.createMorphAt(element8,8,8);
        inline(env, morph0, context, "fa-icon", ["ban"], {});
        inline(env, morph1, context, "i18n", ["user.suspended_notice"], {"date": get(env, context, "model.suspendedTillDate")});
        inline(env, morph2, context, "i18n", ["user.suspended_reason"], {});
        content(env, morph3, context, "model.suspend_reason");
        return fragment;
      }
    };
  }());
  var child15 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                    ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","public-user-field");
            var el2 = dom.createTextNode("\n                      ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","user-field-name");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(":\n                      ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","user-field-value");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                    ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element7 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(element7, [3]),0,0);
            content(env, morph0, context, "uf.field.name");
            content(env, morph1, context, "uf.value");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "uf.value")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","public-user-fields");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("              ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "publicUserFields")], {"keyword": "uf"}, child0, null);
        return fragment;
      }
    };
  }());
  var child16 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
        inline(env, morph0, context, "i18n", ["user.created"], {});
        inline(env, morph1, context, "bound-date", [get(env, context, "model.created_at")], {});
        return fragment;
      }
    };
  }());
  var child17 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
        inline(env, morph0, context, "i18n", ["user.last_posted"], {});
        inline(env, morph1, context, "bound-date", [get(env, context, "model.last_posted_at")], {});
        return fragment;
      }
    };
  }());
  var child18 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
        inline(env, morph0, context, "i18n", ["user.last_seen"], {});
        inline(env, morph1, context, "bound-date", [get(env, context, "model.last_seen_at")], {});
        return fragment;
      }
    };
  }());
  var child19 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          content(env, morph0, context, "model.invited_by.username");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        dom.setAttribute(el1,"class","invited-by");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        dom.setAttribute(el1,"class","invited-by");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
        inline(env, morph0, context, "i18n", ["user.invited_by"], {});
        block(env, morph1, context, "link-to", ["user", get(env, context, "model.invited_by")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child20 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "model.email");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "checkEmail", "actionParam": get(env, context, "model"), "icon": "envelope-o", "label": "admin.users.check_email.text", "class": "btn-primary"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("            ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element6 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element6,1,1);
        var attrMorph0 = dom.createAttrMorph(element6, 'title');
        inline(env, morph0, context, "i18n", ["user.email.title"], {});
        attribute(env, attrMorph0, element6, "title", get(env, context, "model.email"));
        block(env, morph1, context, "if", [get(env, context, "model.email")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child21 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            content(env, morph0, context, "group.name");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["group", get(env, context, "group")], {"class": "group-link"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dd");
        dom.setAttribute(el1,"class","groups");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("            ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
        inline(env, morph0, context, "i18n", ["groups.title"], {"count": get(env, context, "model.custom_groups.length")});
        block(env, morph1, context, "each", [get(env, context, "model.custom_groups")], {"keyword": "group"}, child0, null);
        return fragment;
      }
    };
  }());
  var child22 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("            ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "adminDelete", "icon": "exclamation-triangle", "label": "user.admin_delete", "class": "btn-danger"});
        return fragment;
      }
    };
  }());
  var child23 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "activity-filter", [], {"content": get(env, context, "stat"), "user": get(env, context, "model"), "userActionType": get(env, context, "userActionType"), "indexStream": get(env, context, "indexStream")});
        return fragment;
      }
    };
  }());
  var child24 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("i");
            dom.setAttribute(el1,"class","glyph fa fa-certificate");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [5]),1,1);
            inline(env, morph0, context, "i18n", ["badges.title"], {});
            content(env, morph1, context, "model.badge_count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "link-to", ["user.badges"], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "link-to", ["user.badges"], {"tagName": "li"}, child0, null);
        return fragment;
      }
    };
  }());
  var child25 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "fa-icon", ["comment"], {"class": "glyph"});
            inline(env, morph1, context, "i18n", ["user.notifications"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "link-to", ["user.notifications"], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "link-to", ["user.notifications"], {"tagName": "li"}, child0, null);
        return fragment;
      }
    };
  }());
  var child26 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
            content(env, morph0, context, "model.private_messages_stats.all");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.all"], {});
          block(env, morph1, context, "if", [get(env, context, "model.hasPMs")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
            content(env, morph0, context, "model.private_messages_stats.mine");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.mine"], {});
          block(env, morph1, context, "if", [get(env, context, "model.hasStartedPMs")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","badge-notification unread-private-messages");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            content(env, morph0, context, "model.private_messages_stats.unread");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.unread"], {});
          block(env, morph1, context, "if", [get(env, context, "model.hasUnreadPMs")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("i");
            dom.setAttribute(el1,"class","glyph fa fa-group");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [5]),1,1);
            content(env, morph0, context, "group.name");
            content(env, morph1, context, "group.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var attrMorph0 = dom.createAttrMorph(element0, 'class');
          set(env, context, "group", blockArguments[0]);
          attribute(env, attrMorph0, element0, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "group.active"), "active"], {})]));
          block(env, morph0, context, "link-to", ["userPrivateMessages.group", get(env, context, "group.name")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        dom.setAttribute(el1,"class","action-list nav-stacked");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("li");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("li");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("li");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(fragment, [3]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [3]);
        var element5 = dom.childAt(element2, [5]);
        var morph0 = dom.createMorphAt(element1,0,0);
        var morph1 = dom.createMorphAt(element1,2,2);
        var morph2 = dom.createMorphAt(element3,1,1);
        var morph3 = dom.createMorphAt(element4,1,1);
        var morph4 = dom.createMorphAt(element5,1,1);
        var morph5 = dom.createMorphAt(element2,7,7);
        inline(env, morph0, context, "fa-icon", ["envelope"], {});
        inline(env, morph1, context, "i18n", ["user.private_messages"], {});
        element(env, element3, context, "bind-attr", [], {"class": ":noGlyph privateMessagesActive:active"});
        block(env, morph2, context, "link-to", ["userPrivateMessages.index", get(env, context, "model")], {}, child0, null);
        element(env, element4, context, "bind-attr", [], {"class": ":noGlyph privateMessagesMineActive:active"});
        block(env, morph3, context, "link-to", ["userPrivateMessages.mine", get(env, context, "model")], {}, child1, null);
        element(env, element5, context, "bind-attr", [], {"class": ":noGlyph privateMessagesUnreadActive:active"});
        block(env, morph4, context, "link-to", ["userPrivateMessages.unread", get(env, context, "model")], {}, child2, null);
        block(env, morph5, context, "each", [get(env, context, "groupPMStats")], {}, child3, null);
        return fragment;
      }
    };
  }());
  var child27 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user-archive");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "exportUserArchive", "label": "user.download_archive", "icon": "download"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","user-main");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","staff-counters");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("    ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","profile-image");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","details");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","primary");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("section");
      dom.setAttribute(el6,"class","controls");
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("ul");
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n          ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("div");
      dom.setAttribute(el6,"class","primary-textual");
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h1");
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode(" ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h2");
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h3");
      var el8 = dom.createTextNode("\n            ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("div");
      dom.setAttribute(el7,"class","bio");
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("              ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n          ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"style","clear: both");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","secondary");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("dl");
      var el6 = dom.createTextNode("\n");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("dt");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("dd");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("dt");
      dom.setAttribute(el6,"class","trust-level");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("dd");
      dom.setAttribute(el6,"class","trust-level");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","user-navigation");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      dom.setAttribute(el4,"class","action-list nav-stacked");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","user-right");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, block = hooks.block, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element18 = dom.childAt(fragment, [0]);
      var element19 = dom.childAt(element18, [1]);
      var element20 = dom.childAt(element19, [1]);
      var element21 = dom.childAt(element20, [1]);
      var element22 = dom.childAt(element20, [5, 1]);
      var element23 = dom.childAt(element22, [3, 1]);
      var element24 = dom.childAt(element22, [5]);
      var element25 = dom.childAt(element24, [1]);
      var element26 = dom.childAt(element24, [7]);
      var element27 = dom.childAt(element24, [9]);
      var element28 = dom.childAt(element20, [7]);
      var element29 = dom.childAt(element28, [1]);
      var element30 = dom.childAt(element19, [3]);
      var element31 = dom.childAt(element30, [1]);
      var attrMorph0 = dom.createAttrMorph(element18, 'class');
      var attrMorph1 = dom.createAttrMorph(element20, 'style');
      var morph0 = dom.createMorphAt(element21,1,1);
      var morph1 = dom.createMorphAt(element21,2,2);
      var morph2 = dom.createMorphAt(element21,3,3);
      var morph3 = dom.createMorphAt(element21,4,4);
      var morph4 = dom.createMorphAt(element21,5,5);
      var morph5 = dom.createMorphAt(element22,1,1);
      var morph6 = dom.createMorphAt(element23,1,1);
      var morph7 = dom.createMorphAt(element23,2,2);
      var morph8 = dom.createMorphAt(element23,3,3);
      var morph9 = dom.createMorphAt(element23,4,4);
      var morph10 = dom.createMorphAt(element23,5,5);
      var morph11 = dom.createMorphAt(element23,6,6);
      var morph12 = dom.createMorphAt(element25,0,0);
      var morph13 = dom.createMorphAt(element25,2,2);
      var morph14 = dom.createMorphAt(dom.childAt(element24, [3]),0,0);
      var morph15 = dom.createMorphAt(element24,5,5);
      var morph16 = dom.createMorphAt(element26,1,1);
      var morph17 = dom.createMorphAt(element26,3,3);
      var morph18 = dom.createMorphAt(element27,1,1);
      var morph19 = dom.createUnsafeMorphAt(element27,3,3);
      var morph20 = dom.createMorphAt(element24,11,11);
      var morph21 = dom.createMorphAt(element24,13,13);
      var morph22 = dom.createMorphAt(element29,1,1);
      var morph23 = dom.createMorphAt(element29,2,2);
      var morph24 = dom.createMorphAt(element29,3,3);
      var morph25 = dom.createMorphAt(dom.childAt(element29, [5]),0,0);
      var morph26 = dom.createMorphAt(dom.childAt(element29, [6]),0,0);
      var morph27 = dom.createMorphAt(element29,8,8);
      var morph28 = dom.createMorphAt(dom.childAt(element29, [10]),0,0);
      var morph29 = dom.createMorphAt(dom.childAt(element29, [11]),0,0);
      var morph30 = dom.createMorphAt(element29,13,13);
      var morph31 = dom.createMorphAt(element29,14,14);
      var morph32 = dom.createMorphAt(element29,15,15);
      var morph33 = dom.createMorphAt(element28,3,3);
      var morph34 = dom.createMorphAt(element31,1,1);
      var morph35 = dom.createMorphAt(element31,3,3);
      var morph36 = dom.createMorphAt(element31,4,4);
      var morph37 = dom.createMorphAt(element31,5,5);
      var morph38 = dom.createMorphAt(element30,3,3);
      var morph39 = dom.createMorphAt(element30,5,5);
      var morph40 = dom.createMorphAt(dom.childAt(element19, [5]),1,1);
      attribute(env, attrMorph0, element18, "class", concat(env, ["container", subexpr(env, context, "if", [get(env, context, "viewingSelf"), " viewing-self"], {})]));
      attribute(env, attrMorph1, element20, "style", get(env, context, "model.profileBackground"));
      element(env, element20, context, "bind-attr", [], {"class": "collapsedInfo :about model.profileBackground:has-background:no-background"});
      block(env, morph0, context, "if", [get(env, context, "model.number_of_flags_given")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "model.number_of_flagged_posts")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "model.number_of_deleted_posts")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "model.number_of_suspensions")], {}, child3, null);
      block(env, morph4, context, "if", [get(env, context, "model.number_of_warnings")], {}, child4, null);
      inline(env, morph5, context, "bound-avatar", [get(env, context, "model"), "huge"], {});
      block(env, morph6, context, "if", [get(env, context, "model.can_send_private_message_to_user")], {}, child5, null);
      block(env, morph7, context, "if", [get(env, context, "viewingSelf")], {}, child6, null);
      block(env, morph8, context, "if", [get(env, context, "currentUser.staff")], {}, child7, null);
      block(env, morph9, context, "if", [get(env, context, "model.can_edit")], {}, child8, null);
      block(env, morph10, context, "if", [get(env, context, "canInviteToForum")], {}, child9, null);
      block(env, morph11, context, "if", [get(env, context, "collapsedInfo")], {}, child10, null);
      content(env, morph12, context, "model.username");
      inline(env, morph13, context, "user-status", [get(env, context, "model")], {"currentUser": get(env, context, "currentUser")});
      content(env, morph14, context, "model.name");
      block(env, morph15, context, "if", [get(env, context, "model.title")], {}, child11, null);
      block(env, morph16, context, "if", [get(env, context, "model.location")], {}, child12, null);
      block(env, morph17, context, "if", [get(env, context, "model.website_name")], {}, child13, null);
      block(env, morph18, context, "if", [get(env, context, "model.isSuspended")], {}, child14, null);
      content(env, morph19, context, "model.bio_cooked");
      block(env, morph20, context, "if", [get(env, context, "publicUserFields")], {}, child15, null);
      inline(env, morph21, context, "plugin-outlet", ["user-profile-primary"], {});
      block(env, morph22, context, "if", [get(env, context, "model.created_at")], {}, child16, null);
      block(env, morph23, context, "if", [get(env, context, "model.last_posted_at")], {}, child17, null);
      block(env, morph24, context, "if", [get(env, context, "model.last_seen_at")], {}, child18, null);
      inline(env, morph25, context, "i18n", ["views"], {});
      content(env, morph26, context, "model.profile_view_count");
      block(env, morph27, context, "if", [get(env, context, "model.invited_by")], {}, child19, null);
      inline(env, morph28, context, "i18n", ["user.trust_level"], {});
      content(env, morph29, context, "model.trustLevel.name");
      block(env, morph30, context, "if", [get(env, context, "canCheckEmails")], {}, child20, null);
      block(env, morph31, context, "if", [get(env, context, "model.custom_groups")], {}, child21, null);
      block(env, morph32, context, "if", [get(env, context, "canDeleteUser")], {}, child22, null);
      inline(env, morph33, context, "plugin-outlet", ["user-profile-secondary"], {});
      inline(env, morph34, context, "activity-filter", [], {"count": get(env, context, "model.statsCountNonPM"), "user": get(env, context, "model"), "userActionType": get(env, context, "userActionType"), "indexStream": get(env, context, "indexStream")});
      block(env, morph35, context, "each", [get(env, context, "model.statsExcludingPms")], {"keyword": "stat"}, child23, null);
      block(env, morph36, context, "if", [get(env, context, "showBadges")], {}, child24, null);
      block(env, morph37, context, "if", [get(env, context, "canSeeNotificationHistory")], {}, child25, null);
      block(env, morph38, context, "if", [get(env, context, "canSeePrivateMessages")], {}, child26, null);
      block(env, morph39, context, "if", [get(env, context, "viewingSelf")], {}, child27, null);
      content(env, morph40, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/username"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","alert alert-error");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_username.error"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["user.change_username.taken"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n          ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n          ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element1, [5]);
      var element3 = dom.childAt(element0, [7, 1]);
      var element4 = dom.childAt(element3, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      var morph4 = dom.createMorphAt(element2,1,1);
      var morph5 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
      var morph6 = dom.createMorphAt(element4,0,0);
      var morph7 = dom.createMorphAt(element3,3,3);
      inline(env, morph0, context, "i18n", ["user.change_username.title"], {});
      block(env, morph1, context, "if", [get(env, context, "error")], {}, child0, null);
      inline(env, morph2, context, "i18n", ["user.username.title"], {});
      inline(env, morph3, context, "text-field", [], {"value": get(env, context, "newUsername"), "id": "change_username", "classNames": "input-xxlarge", "maxlength": get(env, context, "maxLength")});
      block(env, morph4, context, "if", [get(env, context, "taken")], {}, child1, null);
      content(env, morph5, context, "errorMessage");
      element(env, element4, context, "action", ["changeUsername"], {});
      element(env, element4, context, "bind-attr", [], {"disabled": "saveDisabled"});
      content(env, morph6, context, "saveButtonText");
      block(env, morph7, context, "if", [get(env, context, "saved")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["users"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            inline(env, morph0, context, "i18n", ["directory.time_read"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.1",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createElement("span");
                dom.setAttribute(el2,"class","time-read");
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 0]),0,0);
                inline(env, morph0, context, "unbound", [get(env, context, "it.time_read")], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.1",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
              var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),0,0);
              var morph4 = dom.createMorphAt(dom.childAt(fragment, [9]),0,0);
              var morph5 = dom.createMorphAt(dom.childAt(fragment, [11]),0,0);
              var morph6 = dom.createMorphAt(dom.childAt(fragment, [13]),0,0);
              var morph7 = dom.createMorphAt(dom.childAt(fragment, [15]),0,0);
              var morph8 = dom.createMorphAt(fragment,17,17,contextualElement);
              dom.insertBoundary(fragment, null);
              set(env, context, "it", blockArguments[0]);
              inline(env, morph0, context, "user-small", [], {"user": get(env, context, "it.user")});
              inline(env, morph1, context, "number", [get(env, context, "it.likes_received")], {});
              inline(env, morph2, context, "number", [get(env, context, "it.likes_given")], {});
              inline(env, morph3, context, "number", [get(env, context, "it.topic_count")], {});
              inline(env, morph4, context, "number", [get(env, context, "it.post_count")], {});
              inline(env, morph5, context, "number", [get(env, context, "it.topics_entered")], {});
              inline(env, morph6, context, "number", [get(env, context, "it.posts_read")], {});
              inline(env, morph7, context, "number", [get(env, context, "it.days_visited")], {});
              block(env, morph8, context, "if", [get(env, context, "controller.parentController.showTimeRead")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.1",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("              ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,1,1);
            var attrMorph0 = dom.createAttrMorph(element0, 'class');
            attribute(env, attrMorph0, element0, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "ic.me"), "me"], {})]));
            block(env, morph0, context, "with", [get(env, context, "ic.model")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","total-rows");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("thead");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createTextNode(" ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tbody");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [3]);
          var element2 = dom.childAt(element1, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(element2,3,3);
          var morph2 = dom.createMorphAt(element2,5,5);
          var morph3 = dom.createMorphAt(element2,7,7);
          var morph4 = dom.createMorphAt(element2,9,9);
          var morph5 = dom.createMorphAt(element2,11,11);
          var morph6 = dom.createMorphAt(element2,13,13);
          var morph7 = dom.createMorphAt(element2,15,15);
          var morph8 = dom.createMorphAt(element2,17,17);
          var morph9 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
          var morph10 = dom.createMorphAt(fragment,5,5,contextualElement);
          inline(env, morph0, context, "i18n", ["directory.total_rows"], {"count": get(env, context, "model.totalRows")});
          inline(env, morph1, context, "directory-toggle", [], {"field": "likes_received", "order": get(env, context, "order"), "asc": get(env, context, "asc"), "icon": "heart"});
          inline(env, morph2, context, "directory-toggle", [], {"field": "likes_given", "order": get(env, context, "order"), "asc": get(env, context, "asc"), "icon": "heart"});
          inline(env, morph3, context, "directory-toggle", [], {"field": "topic_count", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
          inline(env, morph4, context, "directory-toggle", [], {"field": "post_count", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
          inline(env, morph5, context, "directory-toggle", [], {"field": "topics_entered", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
          inline(env, morph6, context, "directory-toggle", [], {"field": "posts_read", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
          inline(env, morph7, context, "directory-toggle", [], {"field": "days_visited", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
          block(env, morph8, context, "if", [get(env, context, "showTimeRead")], {}, child0, null);
          block(env, morph9, context, "each", [get(env, context, "model")], {"itemController": "directory-item", "keyword": "ic"}, child1, null);
          inline(env, morph10, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","clearfix");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          inline(env, morph0, context, "i18n", ["directory.no_results"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.length")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","directory");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0, 1]);
      var element4 = dom.childAt(element3, [1]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(element3,3,3);
      inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period")});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "nameInput"), "placeholderKey": "directory.filter_name", "class": "filter-name"});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loading")}, child0, null);
      return fragment;
    }
  };
}()));
define("discourse/routes/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return Discourse.ajax("/about.json").then(function (result) {
          return result.about;
        });
      },

      titleToken: function () {
        return I18n.t('about.simple_title');
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });define("discourse/routes/app-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function () {
      // Error page
      this.route('exception', { path: '/exception' });

      this.resource('about', { path: '/about' });

      // Topic routes
      this.resource('topic', { path: '/t/:slug/:id' }, function () {
        this.route('fromParams', { path: '/' });
        this.route('fromParamsNear', { path: '/:nearPost' });
      });
      this.resource('topicBySlug', { path: '/t/:slug' });
      this.route('topicUnsubscribe', { path: '/t/:slug/:id/unsubscribe' });

      this.resource('discovery', { path: '/' }, function () {
        var _this = this;

        // top
        this.route('top');
        this.route('topParentCategory', { path: '/c/:slug/l/top' });
        this.route('topCategoryNone', { path: '/c/:slug/none/l/top' });
        this.route('topCategory', { path: '/c/:parentSlug/:slug/l/top' });

        // top by periods
        Discourse.Site.currentProp('periods').forEach(function (period) {
          var top = 'top' + period.capitalize();
          _this.route(top, { path: '/top/' + period });
          _this.route(top + 'ParentCategory', { path: '/c/:slug/l/top/' + period });
          _this.route(top + 'CategoryNone', { path: '/c/:slug/none/l/top/' + period });
          _this.route(top + 'Category', { path: '/c/:parentSlug/:slug/l/top/' + period });
        });

        // filters
        Discourse.Site.currentProp('filters').forEach(function (filter) {
          _this.route(filter, { path: '/' + filter });
          _this.route(filter + 'ParentCategory', { path: '/c/:slug/l/' + filter });
          _this.route(filter + 'CategoryNone', { path: '/c/:slug/none/l/' + filter });
          _this.route(filter + 'Category', { path: '/c/:parentSlug/:slug/l/' + filter });
        });

        this.route('categories');

        // default filter for a category
        this.route('parentCategory', { path: '/c/:slug' });
        this.route('categoryNone', { path: '/c/:slug/none' });
        this.route('category', { path: '/c/:parentSlug/:slug' });

        // homepage
        this.route(Discourse.Utilities.defaultHomepage(), { path: '/' });
      });

      this.resource('group', { path: '/groups/:name' }, function () {
        this.route('topics');
        this.route('mentions');
        this.route('members');
        this.route('messages');
      });

      // User routes
      this.resource('users');
      this.resource('user', { path: '/users/:username' }, function () {
        this.resource('userActivity', { path: '/activity' }, function () {
          var _this2 = this;

          _.map(Discourse.UserAction.TYPES, function (id, userAction) {
            _this2.route(userAction, { path: userAction.replace('_', '-') });
          });
        });

        this.route('badges');
        this.route('notifications');
        this.route('flaggedPosts', { path: '/flagged-posts' });
        this.route('deletedPosts', { path: '/deleted-posts' });

        this.resource('userPrivateMessages', { path: '/messages' }, function () {
          this.route('mine');
          this.route('unread');
          this.route('group', { path: 'group/:name' });
        });

        this.resource('preferences', function () {
          this.route('username');
          this.route('email');
          this.route('about', { path: '/about-me' });
          this.route('badgeTitle', { path: '/badge_title' });
          this.route('card-badge', { path: '/card-badge' });
        });

        this.resource('userInvited', { path: '/invited' }, function () {
          this.route('show', { path: '/:filter' });
        });
      });

      this.route('signup', { path: '/signup' });
      this.route('login', { path: '/login' });
      this.route('login-preferences');
      this.route('forgot-password', { path: '/password-reset' });
      this.route('faq', { path: '/faq' });
      this.route('tos', { path: '/tos' });
      this.route('privacy', { path: '/privacy' });
      this.route('guidelines', { path: '/guidelines' });

      this.route('new-topic', { path: '/new-topic' });
      this.route('new-message', { path: '/new-message' });

      this.resource('badges', function () {
        this.route('show', { path: '/:id/:slug' });
      });

      this.resource('queued-posts', { path: '/queued-posts' });

      this.route('full-page-search', { path: '/search' });
    }
  });define("discourse/routes/application", 
  ["discourse/lib/computed","discourse/lib/logout","discourse/lib/show-modal","discourse/mixins/open-composer","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var logout = __dependency2__["default"];
    var showModal = __dependency3__["default"];
    var OpenComposer = __dependency4__["default"];
    var Category = __dependency5__["default"];

    function unlessReadOnly(method) {
      return function () {
        if (this.site.get("isReadOnly")) {
          bootbox.alert(I18n.t("read_only_mode.login_disabled"));
        } else {
          this[method]();
        }
      };
    }

    var ApplicationRoute = Discourse.Route.extend(OpenComposer, {
      siteTitle: setting('title'),

      actions: {

        logout: function () {
          var _this = this;

          if (this.currentUser) {
            this.currentUser.destroySession().then(function () {
              return logout(_this.siteSettings, _this.keyValueStore);
            });
          }
        },

        _collectTitleTokens: function (tokens) {
          tokens.push(this.get('siteTitle'));
          Discourse.set('_docTitle', tokens.join(' - '));
        },

        // Ember doesn't provider a router `willTransition` event so let's make one
        willTransition: function () {
          var router = this.container.lookup('router:main');
          Ember.run.once(router, router.trigger, 'willTransition');
          return this._super();
        },

        // This is here as a bugfix for when an Ember Cloaked view triggers
        // a scroll after a controller has been torn down. The real fix
        // should be to fix ember cloaking to not do that, but this catches
        // it safely just in case.
        postChangedRoute: Ember.K,

        showTopicEntrance: function (data) {
          this.controllerFor('topic-entrance').send('show', data);
        },

        postWasEnqueued: function (details) {
          var title = details.reason ? 'queue_reason.' + details.reason + '.title' : 'queue.approval.title';
          showModal('post-enqueued', { model: details, title: title });
        },

        composePrivateMessage: function (user, post) {
          var self = this;
          this.transitionTo('userActivity', user).then(function () {
            self.controllerFor('user-activity').send('composePrivateMessage', user, post);
          });
        },

        error: function (err, transition) {
          var xhr = {};
          if (err.jqXHR) {
            xhr = err.jqXHR;
          }

          var xhrOrErr = err.jqXHR ? xhr : err;

          var exceptionController = this.controllerFor('exception');

          var c = window.console;
          if (c && c.error) {
            c.error(xhrOrErr);
          }

          exceptionController.setProperties({ lastTransition: transition, thrown: xhrOrErr });

          this.intermediateTransitionTo('exception');
          return true;
        },

        showLogin: unlessReadOnly('handleShowLogin'),

        showCreateAccount: unlessReadOnly('handleShowCreateAccount'),

        showForgotPassword: function () {
          showModal('forgotPassword', { title: 'forgot_password.title' });
        },

        showNotActivated: function (props) {
          showModal('not-activated', { title: 'log_in' }).setProperties(props);
        },

        showUploadSelector: function (toolbarEvent) {
          showModal('uploadSelector').setProperties({ toolbarEvent: toolbarEvent, imageUrl: null, imageLink: null });
        },

        showKeyboardShortcutsHelp: function () {
          showModal('keyboard-shortcuts-help', { title: 'keyboard_shortcuts_help.title' });
        },

        // Close the current modal, and destroy its state.
        closeModal: function () {
          this.render('hide-modal', { into: 'modal', outlet: 'modalBody' });
        },

        /**
          Hide the modal, but keep it with all its state so that it can be shown again later.
          This is useful if you want to prompt for confirmation. hideModal, ask "Are you sure?",
          user clicks "No", reopenModal. If user clicks "Yes", be sure to call closeModal.
        **/
        hideModal: function () {
          $('#discourse-modal').modal('hide');
        },

        reopenModal: function () {
          $('#discourse-modal').modal('show');
        },

        editCategory: function (category) {
          var _this2 = this;

          Category.reloadById(category.get('id')).then(function (atts) {
            var model = _this2.store.createRecord('category', atts.category);
            model.setupGroupsAndPermissions();
            _this2.site.updateCategory(model);
            showModal('editCategory', { model: model });
            _this2.controllerFor('editCategory').set('selectedTab', 'general');
          });
        },

        deleteSpammer: function (user) {
          this.send('closeModal');
          user.deleteAsSpammer(function () {
            window.location.reload();
          });
        },

        checkEmail: function (user) {
          user.checkEmail();
        },

        changeBulkTemplate: function (w) {
          var controllerName = w.replace('modal/', ''),
              factory = this.container.lookupFactory('controller:' + controllerName);

          this.render(w, { into: 'modal/topic-bulk-actions', outlet: 'bulkOutlet', controller: factory ? controllerName : 'topic-bulk-actions' });
        },

        createNewTopicViaParams: function (title, body, category_id, category) {
          this.openComposerWithTopicParams(this.controllerFor('discovery/topics'), title, body, category_id, category);
        },

        createNewMessageViaParams: function (username, title, body) {
          this.openComposerWithMessageParams(username, title, body);
        }
      },

      activate: function () {
        this._super();
        Em.run.next(function () {
          // Support for callbacks once the application has activated
          ApplicationRoute.trigger('activate');
        });
      },

      handleShowLogin: function () {
        var _this3 = this;

        if (this.siteSettings.enable_sso) {
          var returnPath = encodeURIComponent(window.location.pathname);
          window.location = Discourse.getURL('/session/sso?return_path=' + returnPath);
        } else {
          this._autoLogin('login', 'login-modal', function () {
            return _this3.controllerFor('login').resetForm();
          });
        }
      },

      handleShowCreateAccount: function () {
        if (this.siteSettings.enable_sso) {
          var returnPath = encodeURIComponent(window.location.pathname);
          window.location = Discourse.getURL('/session/sso?return_path=' + returnPath);
        } else {
          this._autoLogin('createAccount', 'create-account');
        }
      },

      _autoLogin: function (modal, modalClass, notAuto) {
        var methods = Em.get('Discourse.LoginMethod.all');
        if (!this.siteSettings.enable_local_logins && methods.length === 1) {
          this.controllerFor('login').send('externalLogin', methods[0]);
        } else {
          showModal(modal);
          this.controllerFor('modal').set('modalClass', modalClass);
          if (notAuto) {
            notAuto();
          }
        }
      }

    });

    RSVP.EventTarget.mixin(ApplicationRoute);
    __exports__["default"] = ApplicationRoute;
  });define("discourse/routes/badges-index", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        if (PreloadStore.get("badges")) {
          return PreloadStore.getAndRemove("badges").then(function (json) {
            return Badge.createFromJson(json);
          });
        } else {
          return Badge.findAll({ onlyListable: true });
        }
      },

      titleToken: function () {
        return I18n.t("badges.title");
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });define("discourse/routes/badges-show", 
  ["discourse/models/user-badge","discourse/models/badge","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var Badge = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({
      actions: {
        didTransition: function () {
          this.controllerFor("badges/show")._showFooter();
          return true;
        }
      },

      serialize: function (model) {
        return {
          id: model.get("id"),
          slug: model.get("slug")
        };
      },

      model: function (params) {
        if (PreloadStore.get("badge")) {
          return PreloadStore.getAndRemove("badge").then(function (json) {
            return Badge.createFromJson(json);
          });
        } else {
          return Badge.findById(params.id);
        }
      },

      afterModel: function (model) {
        var _this = this;

        return UserBadge.findByBadgeId(model.get("id")).then(function (userBadges) {
          _this.userBadges = userBadges;
        });
      },

      titleToken: function () {
        var model = this.modelFor("badges.show");
        if (model) {
          return model.get("displayName");
        }
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        controller.set("userBadges", this.userBadges);
      }
    });
  });define("discourse/routes/build-admin-user-posts-route", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (filter) {
      return Discourse.Route.extend({
        actions: {
          didTransition: function () {
            this.controllerFor("user").set("indexStream", true);
            this.controllerFor("user-posts")._showFooter();
            return true;
          }
        },

        model: function () {
          return this.modelFor("user").get("postsStream");
        },

        afterModel: function () {
          return this.modelFor("user").get("postsStream").filterBy(filter);
        },

        setupController: function (controller, model) {
          // initialize "canLoadMore"
          model.set("canLoadMore", model.get("itemsLoaded") === 60);

          this.controllerFor("user-posts").set("model", model);
        },

        renderTemplate: function () {
          this.render("user/posts", { into: "user" });
        }
      });
    }
  });define("discourse/routes/build-category-route", 
  ["discourse/routes/build-topic-route","discourse/controllers/discovery-sortable","discourse/models/topic-list","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var filterQueryParams = __dependency1__.filterQueryParams;
    var findTopicList = __dependency1__.findTopicList;
    var queryParams = __dependency2__.queryParams;
    var TopicList = __dependency3__["default"];
    var PermissionType = __dependency4__["default"];

    // A helper function to create a category route with parameters
    __exports__["default"] = function (filter, params) {
      return Discourse.Route.extend({
        queryParams: queryParams,

        model: function (modelParams) {
          return { category: Discourse.Category.findBySlug(modelParams.slug, modelParams.parentSlug) };
        },

        afterModel: function (model, transition) {
          if (!model) {
            this.replaceWith('/404');
            return;
          }

          this._setupNavigation(model.category);
          return Em.RSVP.all([this._createSubcategoryList(model.category), this._retrieveTopicList(model.category, transition)]);
        },

        _setupNavigation: function (category) {
          var noSubcategories = params && !!params.no_subcategories,
              filterMode = 'c/' + Discourse.Category.slugFor(category) + (noSubcategories ? "/none" : "") + '/l/' + filter;

          this.controllerFor('navigation/category').setProperties({
            category: category,
            filterMode: filterMode,
            noSubcategories: params && params.no_subcategories,
            canEditCategory: category.get('can_edit')
          });
        },

        _createSubcategoryList: function (category) {
          var _this = this;

          this._categoryList = null;
          if (Em.isNone(category.get('parentCategory')) && Discourse.SiteSettings.show_subcategory_list) {
            var CategoryList = require('discourse/models/category-list').default;
            return CategoryList.listForParent(this.store, category).then(function (list) {
              return _this._categoryList = list;
            });
          }

          // If we're not loading a subcategory list just resolve
          return Em.RSVP.resolve();
        },

        _retrieveTopicList: function (category, transition) {
          var _this2 = this;

          var listFilter = 'c/' + Discourse.Category.slugFor(category) + '/l/' + filter,
              findOpts = filterQueryParams(transition.queryParams, params),
              extras = { cached: this.isPoppedState(transition) };

          return findTopicList(this.store, this.topicTrackingState, listFilter, findOpts, extras).then(function (list) {
            TopicList.hideUniformCategory(list, category);
            _this2.set('topics', list);
            return list;
          });
        },

        titleToken: function () {
          var filterText = I18n.t('filters.' + filter.replace('/', '.') + '.title'),
              category = this.currentModel.category;

          return I18n.t('filters.with_category', { filter: filterText, category: category.get('name') });
        },

        setupController: function (controller, model) {
          var topics = this.get('topics'),
              category = model.category,
              canCreateTopic = topics.get('can_create_topic'),
              canCreateTopicOnCategory = category.get('permission') === PermissionType.FULL;

          this.controllerFor('navigation/category').setProperties({
            canCreateTopicOnCategory: canCreateTopicOnCategory,
            cannotCreateTopicOnCategory: !canCreateTopicOnCategory,
            canCreateTopic: canCreateTopic
          });

          var topicOpts = {
            model: topics,
            category: category,
            period: topics.get('for_period') || (filter.indexOf('/') > 0 ? filter.split('/')[1] : ''),
            selected: [],
            noSubcategories: params && !!params.no_subcategories,
            expandAllPinned: true,
            canCreateTopic: canCreateTopic,
            canCreateTopicOnCategory: canCreateTopicOnCategory
          };

          var p = category.get('params');
          if (p && Object.keys(p).length) {
            if (p.order !== undefined) {
              topicOpts.order = p.order;
            }
            if (p.ascending !== undefined) {
              topicOpts.ascending = p.ascending;
            }
          }

          this.controllerFor('discovery/topics').setProperties(topicOpts);
          this.searchService.set('searchContext', category.get('searchContext'));
          this.set('topics', null);

          this.openTopicDraft(topics);
        },

        renderTemplate: function () {
          this.render('navigation/category', { outlet: 'navigation-bar' });

          if (this._categoryList) {
            this.render('discovery/categories', { outlet: 'header-list-container', model: this._categoryList });
          }
          this.render('discovery/topics', { controller: 'discovery/topics', outlet: 'list-container' });
        },

        resetController: function (controller, isExiting) {
          if (isExiting) {
            controller.setProperties({ order: "default", ascending: false });
          }
        },

        deactivate: function () {
          this._super();
          this.searchService.set('searchContext', null);
        },

        actions: {
          setNotification: function (notification_level) {
            this.currentModel.setNotification(notification_level);
          }
        }
      });
    }
  });define("discourse/routes/build-static-route", 
  ["discourse/routes/discourse","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseRoute = __dependency1__["default"];

    __exports__["default"] = function (pageName) {
      var route = {
        model: function () {
          return Discourse.StaticPage.find(pageName);
        },

        renderTemplate: function () {
          this.render('static');
        },

        setupController: function (controller, model) {
          this.controllerFor('static').set('model', model);
        }
      };
      return DiscourseRoute.extend(route);
    }
  });define("discourse/routes/build-user-topic-list-route", 
  ["discourse/routes/user-topic-list","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserTopicListRoute = __dependency1__["default"];

    // A helper to build a user topic list route
    __exports__["default"] = function (viewName, path) {
      return UserTopicListRoute.extend({
        userActionType: Discourse.UserAction.TYPES.messages_received,

        actions: {
          didTransition: function () {
            this.controllerFor("user-topics-list")._showFooter();
            return true;
          }
        },

        model: function () {
          return this.store.findFiltered("topicList", { filter: "topics/" + path + "/" + this.modelFor("user").get("username_lower") });
        },

        setupController: function () {
          this._super.apply(this, arguments);

          this.controllerFor("user-topics-list").setProperties({
            hideCategory: true,
            showParticipants: true
          });

          this.controllerFor("user").set("pmView", viewName);
          this.searchService.set('contextType', 'private_messages');
        },

        deactivate: function () {
          this.searchService.set('contextType', 'private_messages');
        }
      });
    }
  });define("discourse/routes/discovery-categories", 
  ["discourse/lib/show-modal","discourse/mixins/open-composer","discourse/models/category-list","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];
    var OpenComposer = __dependency2__["default"];
    var CategoryList = __dependency3__["default"];

    var DiscoveryCategoriesRoute = Discourse.Route.extend(OpenComposer, {
      renderTemplate: function () {
        this.render("navigation/categories", { outlet: "navigation-bar" });
        this.render("discovery/categories", { outlet: "list-container" });
      },

      beforeModel: function () {
        this.controllerFor("navigation/categories").set("filterMode", "categories");
      },

      model: function () {
        var _this = this;

        // TODO: Remove this and ensure server side does not supply `topic_list`
        // if default page is categories
        PreloadStore.remove("topic_list");

        return CategoryList.list(this.store, 'categories').then(function (list) {
          var tracking = _this.topicTrackingState;
          if (tracking) {
            tracking.sync(list, "categories");
            tracking.trackIncoming("categories");
          }
          return list;
        });
      },

      titleToken: function () {
        if (Discourse.Utilities.defaultHomepage() === "categories") {
          return;
        }
        return I18n.t("filters.categories.title");
      },

      setupController: function (controller, model) {
        controller.set("model", model);

        this.controllerFor("navigation/categories").setProperties({
          canCreateCategory: model.get("can_create_category"),
          canCreateTopic: model.get("can_create_topic")
        });

        this.openTopicDraft(model);
      },

      actions: {
        createCategory: function () {
          var groups = this.site.groups,
              everyoneName = groups.findBy("id", 0).name;

          var model = this.store.createRecord('category', {
            color: "AB9364", text_color: "FFFFFF", group_permissions: [{ group_name: everyoneName, permission_type: 1 }],
            available_groups: groups.map(function (g) {
              return g.name;
            }),
            allow_badges: true
          });

          showModal("editCategory", { model: model });
          this.controllerFor("editCategory").set("selectedTab", "general");
        },

        reorderCategories: function () {
          showModal("reorderCategories");
        },

        createTopic: function () {
          this.openComposer(this.controllerFor("discovery/categories"));
        },

        didTransition: function () {
          var _this2 = this;

          Ember.run.next(function () {
            return _this2.controllerFor("application").set("showFooter", true);
          });
          return true;
        }
      }
    });

    __exports__["default"] = DiscoveryCategoriesRoute;
  });define("discourse/routes/discovery", 
  ["discourse/mixins/open-composer","discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    /**
      The parent route for all discovery routes.
      Handles the logic for showing the loading spinners.
    **/

    var OpenComposer = __dependency1__["default"];
    var scrollTop = __dependency2__.scrollTop;

    __exports__["default"] = Discourse.Route.extend(OpenComposer, {
      redirect: function () {
        return this.redirectIfLoginRequired();
      },

      beforeModel: function (transition) {
        if (transition.intent.url === "/" && transition.targetName.indexOf("discovery.top") === -1 && Discourse.User.currentProp("should_be_redirected_to_top")) {
          Discourse.User.currentProp("should_be_redirected_to_top", false);
          var period = Discourse.User.currentProp("redirect_to_top.period") || "all";
          this.replaceWith("discovery.top" + period.capitalize());
        }
      },

      actions: {
        loading: function () {
          this.controllerFor("discovery").set("loading", true);
          return true;
        },

        loadingComplete: function () {
          this.controllerFor("discovery").set("loading", false);
          if (!this.session.get("topicListScrollPosition")) {
            scrollTop();
          }
        },

        didTransition: function () {
          this.controllerFor("discovery")._showFooter();
          this.send("loadingComplete");
          return true;
        },

        // clear a pinned topic
        clearPin: function (topic) {
          topic.clearPin();
        },

        createTopic: function () {
          this.openComposer(this.controllerFor("discovery/topics"));
        },

        dismissReadTopics: function (dismissTopics) {
          var operationType = dismissTopics ? "topics" : "posts";
          this.controllerFor("discovery/topics").send('dismissRead', operationType);
        },

        dismissRead: function (operationType) {
          this.controllerFor("discovery/topics").send('dismissRead', operationType);
        }
      }

    });
  });define("discourse/routes/exception", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      serialize: function () {
        return "";
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });define("discourse/routes/faq", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('faq');
  });define("discourse/routes/forgot-password", 
  ["discourse/routes/build-static-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildStaticRoute = __dependency1__["default"];

    var ForgotPasswordRoute = buildStaticRoute('password-reset');

    ForgotPasswordRoute.reopen({
      beforeModel: function () {
        this.replaceWith(this.controllerFor('application').get('loginRequired') ? 'login' : 'discovery').then(function (e) {
          Ember.run.next(function () {
            return e.send('showForgotPassword');
          });
        });
      }
    });

    __exports__["default"] = ForgotPasswordRoute;
  });define("discourse/routes/full-page-search", 
  ["discourse/lib/search","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var translateResults = __dependency1__.translateResults;
    var getSearchKey = __dependency1__.getSearchKey;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;

    __exports__["default"] = Discourse.Route.extend({
      queryParams: { q: {}, context_id: {}, context: {}, skip_context: {} },

      model: function (params) {
        var router = Discourse.__container__.lookup('router:main');
        var cached = router.transientCache('lastSearch');
        var args = { q: params.q };
        if (params.context_id && !args.skip_context) {
          args.search_context = {
            type: params.context,
            id: params.context_id
          };
        }

        var searchKey = getSearchKey(args);

        if (cached && cached.data.searchKey === searchKey) {
          // extend expiry
          router.transientCache('lastSearch', { searchKey: searchKey, model: cached.data.model }, 5);
          return cached.data.model;
        }

        return PreloadStore.getAndRemove("search", function () {
          if (isValidSearchTerm(params.q)) {
            return Discourse.ajax("/search", { data: args });
          } else {
            return null;
          }
        }).then(function (results) {
          var model = results && translateResults(results) || {};
          router.transientCache('lastSearch', { searchKey: searchKey, model: model }, 5);
          return model;
        });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("full-page-search")._showFooter();
          return true;
        }
      }

    });
  });define("discourse/routes/group-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      actions: {
        didTransition: function () {
          return true;
        }
      },

      model: function () {
        return this.modelFor("group").findPosts();
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.controllerFor("group").set("showing", "posts");
      }
    });
  });define("discourse/routes/group-members", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.modelFor("group");
      },

      setupController: function (controller, model) {
        this.controllerFor("group").set("showing", "members");
        controller.set("model", model);
        model.findMembers();
      }

    });
  });define("discourse/routes/group-mentions", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({

      model: function () {
        return this.modelFor("group").findPosts({ type: 'mentions' });
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.controllerFor("group").set("showing", "mentions");
      }
    });
  });define("discourse/routes/group-messages", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({

      model: function () {
        return this.modelFor("group").findPosts({ type: 'messages' });
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.controllerFor("group").set("showing", "messages");
      }
    });
  });define("discourse/routes/group-topics", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({

      model: function () {
        return this.modelFor("group").findPosts({ type: 'topics' });
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.controllerFor("group").set("showing", "topics");
      }
    });
  });define("discourse/routes/group", 
  ["discourse/models/group","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Group = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({

      model: function (params) {
        return Group.find(params.name);
      },

      serialize: function (model) {
        return { name: model.get('name').toLowerCase() };
      },

      afterModel: function (model) {
        var self = this;
        return Group.findGroupCounts(model.get('name')).then(function (counts) {
          self.set('counts', counts);
        });
      },

      setupController: function (controller, model) {
        controller.setProperties({
          model: model,
          counts: this.get('counts')
        });
      }
    });
  });define("discourse/routes/guidelines", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('guidelines');
  });define("discourse/routes/loading", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Route.extend();
  });define("discourse/routes/login", 
  ["discourse/routes/build-static-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildStaticRoute = __dependency1__["default"];

    var LoginRoute = buildStaticRoute('login');

    LoginRoute.reopen({
      beforeModel: function () {
        if (!this.siteSettings.login_required) {
          this.replaceWith('discovery.latest').then(function (e) {
            Ember.run.next(function () {
              return e.send('showLogin');
            });
          });
        }
      }
    });

    __exports__["default"] = LoginRoute;
  });define("discourse/routes/new-message", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function (transition) {
        var self = this;
        if (Discourse.User.current()) {
          // User is logged in
          self.replaceWith('discovery.latest').then(function (e) {
            Discourse.User.findByUsername(transition.queryParams.username).then(function (user) {
              if (user.can_send_private_message_to_user) {
                Ember.run.next(function () {
                  e.send('createNewMessageViaParams', user.username, transition.queryParams.title, transition.queryParams.body);
                });
              } else {
                bootbox.alert(I18n.t("composer.cant_send_pm", { username: user.username }));
              }
            }).catch(function () {
              bootbox.alert(I18n.t("generic_error"));
            });
          });
        } else {
          // User is not logged in
          self.session.set("shouldRedirectToUrl", window.location.href);
          self.replaceWith('login');
        }
      }
    });
  });define("discourse/routes/new-topic", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function (transition) {
        var self = this;
        if (Discourse.User.current()) {
          // User is logged in
          self.replaceWith('discovery.latest').then(function (e) {
            if (self.controllerFor('navigation/default').get('canCreateTopic')) {
              // User can create topic
              Ember.run.next(function () {
                e.send('createNewTopicViaParams', transition.queryParams.title, transition.queryParams.body, transition.queryParams.category_id, transition.queryParams.category);
              });
            }
          });
        } else {
          // User is not logged in
          self.session.set("shouldRedirectToUrl", window.location.href);
          self.replaceWith('login');
        }
      }
    });
  });define("discourse/routes/preferences-about", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        this.render({ into: 'user' });
      },

      setupController: function (controller, model) {
        controller.setProperties({ model: model, newBio: model.get('bio_raw') });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      actions: {
        changeAbout: function () {
          var route = this;
          var controller = route.controllerFor('preferences/about');

          controller.setProperties({ saving: true });
          return controller.get('model').save().then(function () {
            controller.set('saving', false);
            route.transitionTo('user.index');
          }, function () {
            // model failed to save
            controller.set('saving', false);
            alert(I18n.t('generic_error'));
          });
        }
      }

    });
  });define("discourse/routes/preferences-badge-title", 
  ["discourse/models/user-badge","discourse/routes/restricted-user","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var RestrictedUserRoute = __dependency2__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return UserBadge.findByUsername(this.modelFor('user').get('username'));
      },

      renderTemplate: function () {
        return this.render('user/badge-title', { into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, model) {
        controller.set('model', model);
        controller.set('user', this.modelFor('user'));

        model.forEach(function (userBadge) {
          if (userBadge.get('badge.name') === controller.get('user.title')) {
            controller.set('selectedUserBadgeId', userBadge.get('id'));
          }
        });
        if (!controller.get('selectedUserBadgeId') && controller.get('selectableUserBadges.length') > 0) {
          controller.set('selectedUserBadgeId', controller.get('selectableUserBadges')[0].get('id'));
        }
      }
    });
  });define("discourse/routes/preferences-card-badge", 
  ["discourse/models/user-badge","discourse/routes/restricted-user","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var RestrictedUserRoute = __dependency2__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return UserBadge.findByUsername(this.modelFor('user').get('username'));
      },

      renderTemplate: function () {
        return this.render({ into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, model) {
        controller.set('model', model);
        controller.set('user', this.modelFor('user'));

        model.forEach(function (userBadge) {
          if (userBadge.get('badge.image') === controller.get('user.card_image_badge')) {
            controller.set('selectedUserBadgeId', userBadge.get('id'));
          }
        });
      }
    });
  });define("discourse/routes/preferences-email", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        this.render({ into: 'user' });
      },

      setupController: function (controller, model) {
        controller.setProperties({ model: model, newEmail: model.get('email') });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      }
    });
  });define("discourse/routes/preferences-index", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      renderTemplate: function () {
        this.render('preferences', { into: 'user', controller: 'preferences' });
      }
    });
  });define("discourse/routes/preferences-username", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        return this.render({ into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, user) {
        controller.setProperties({ model: user, newUsername: user.get('username') });
      }
    });
  });define("discourse/routes/preferences", 
  ["discourse/routes/restricted-user","discourse/lib/show-modal","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];
    var showModal = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      setupController: function (controller, user) {
        controller.setProperties({
          model: user,
          newNameInput: user.get('name')
        });
      },

      actions: {
        showAvatarSelector: function () {
          showModal('avatar-selector');

          // all the properties needed for displaying the avatar selector modal
          var props = this.modelFor('user').getProperties('id', 'email', 'username', 'avatar_template', 'system_avatar_template', 'gravatar_avatar_template', 'custom_avatar_template', 'system_avatar_upload_id', 'gravatar_avatar_upload_id', 'custom_avatar_upload_id');

          switch (props.avatar_template) {
            case props.system_avatar_template:
              props.selected = "system";
              break;
            case props.gravatar_avatar_template:
              props.selected = "gravatar";
              break;
            default:
              props.selected = "uploaded";
          }

          this.controllerFor('avatar-selector').setProperties(props);
        },

        saveAvatarSelection: function () {
          var user = this.modelFor('user'),
              controller = this.controllerFor('avatar-selector'),
              selectedUploadId = controller.get("selectedUploadId"),
              selectedAvatarTemplate = controller.get("selectedAvatarTemplate"),
              type = controller.get("selected");

          user.pickAvatar(selectedUploadId, type, selectedAvatarTemplate).then(function () {
            user.setProperties(controller.getProperties('system_avatar_template', 'gravatar_avatar_template', 'custom_avatar_template'));
            bootbox.alert(I18n.t("user.change_avatar.cache_notice"));
          }).catch(popupAjaxError);

          // saves the data back
          controller.send('closeModal');
        }

      }
    });
  });define("discourse/routes/privacy", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('privacy');
  });define("discourse/routes/queued-posts", 
  ["discourse/lib/load-script","discourse/routes/discourse","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];
    var DiscourseRoute = __dependency2__["default"];

    __exports__["default"] = DiscourseRoute.extend({

      // this route requires the sanitizer
      beforeModel: function () {
        loadScript('defer/html-sanitizer-bundle');
      },

      model: function () {
        return this.store.find('queuedPost', { status: 'new' });
      },

      actions: {
        refresh: function () {
          this.modelFor('queued-posts').refresh();
        }
      }
    });
  });define("discourse/routes/signup", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function () {
        this.replaceWith('discovery.latest').then(function (e) {
          Ember.run.next(function () {
            e.send('showCreateAccount');
          });
        });
      }
    });
  });define("discourse/routes/topic-by-slug", 
  ["discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Topic = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function (params) {
        return Topic.idForSlug(params.slug);
      },

      afterModel: function (result) {
        DiscourseURL.routeTo(result.url, { replaceURL: true });
      }
    });
  });define("discourse/routes/topic-from-params-near", 
  ["discourse/routes/topic-from-params","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var TopicFromParamsRoute = __dependency1__["default"];

    __exports__["default"] = TopicFromParamsRoute;
  });define("discourse/routes/topic-unsubscribe", 
  ["discourse/models/topic","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadTopicView = __dependency1__.loadTopicView;

    __exports__["default"] = Discourse.Route.extend({
      model: function (params) {
        var topic = this.store.createRecord("topic", { id: params.id });
        return loadTopicView(topic).then(function () {
          return topic;
        });
      },

      afterModel: function (topic) {
        topic.set("details.notificationReasonText", null);
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });define("discourse/routes/topic", 
  ["discourse/lib/screen-track","discourse/lib/url","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ScreenTrack = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    var showModal = __dependency3__["default"];

    var isTransitioning = false,
        scheduledReplace = null,
        lastScrollPos = null;

    var SCROLL_DELAY = 500;var TopicRoute = Discourse.Route.extend({
      redirect: function () {
        return this.redirectIfLoginRequired();
      },

      queryParams: {
        filter: { replace: true },
        username_filters: { replace: true },
        show_deleted: { replace: true }
      },

      titleToken: function () {
        var model = this.modelFor('topic');
        if (model) {
          var result = model.get('title'),
              cat = model.get('category');

          // Only display uncategorized in the title tag if it was renamed
          if (cat && !(cat.get('isUncategorizedCategory') && cat.get('name').toLowerCase() === "uncategorized")) {
            var catName = cat.get('name');

            var parentCategory = cat.get('parentCategory');
            if (parentCategory) {
              catName = parentCategory.get('name') + " / " + catName;
            }

            return [result, catName];
          }
          return result;
        }
      },

      actions: {

        showFlags: function (model) {
          showModal('flag', { model: model });
          this.controllerFor('flag').setProperties({ selected: null, flagTopic: false });
        },

        showFlagTopic: function (model) {
          showModal('flag', { model: model });
          this.controllerFor('flag').setProperties({ selected: null, flagTopic: true });
        },

        showAutoClose: function () {
          showModal('edit-topic-auto-close', { model: this.modelFor('topic') });
          this.controllerFor('modal').set('modalClass', 'edit-auto-close-modal');
        },

        showChangeTimestamp: function () {
          showModal('change-timestamp', { model: this.modelFor('topic'), title: 'topic.change_timestamp.title' });
        },

        showFeatureTopic: function () {
          showModal('featureTopic', { model: this.modelFor('topic'), title: 'topic.feature_topic.title' });
          this.controllerFor('modal').set('modalClass', 'feature-topic-modal');
          this.controllerFor('feature_topic').reset();
        },

        showInvite: function () {
          showModal('invite', { model: this.modelFor('topic') });
          this.controllerFor('invite').reset();
        },

        showHistory: function (model) {
          showModal('history', { model: model });
          this.controllerFor('history').refresh(model.get("id"), "latest");
          this.controllerFor('modal').set('modalClass', 'history-modal');
        },

        showRawEmail: function (model) {
          showModal('raw-email', { model: model });
          this.controllerFor('raw_email').loadRawEmail(model.get("id"));
        },

        mergeTopic: function () {
          showModal('merge-topic', { model: this.modelFor('topic'), title: 'topic.merge_topic.title' });
        },

        splitTopic: function () {
          showModal('split-topic', { model: this.modelFor('topic') });
        },

        changeOwner: function () {
          showModal('change-owner', { model: this.modelFor('topic'), title: 'topic.change_owner.title' });
        },

        // Use replaceState to update the URL once it changes
        postChangedRoute: function (currentPost) {
          // do nothing if we are transitioning to another route
          if (isTransitioning || TopicRoute.disableReplaceState) {
            return;
          }

          var topic = this.modelFor('topic');
          if (topic && currentPost) {
            var postUrl = topic.get('url');
            if (currentPost > 1) {
              postUrl += "/" + currentPost;
            }

            Em.run.cancel(scheduledReplace);
            lastScrollPos = parseInt($(document).scrollTop(), 10);
            scheduledReplace = Em.run.later(this, '_replaceUnlessScrolling', postUrl, SCROLL_DELAY);
          }
        },

        didTransition: function () {
          this.controllerFor("topic")._showFooter();
          return true;
        },

        willTransition: function () {
          this._super();
          this.controllerFor("quote-button").deselectText();
          Em.run.cancel(scheduledReplace);
          isTransitioning = true;
          return true;
        }
      },

      // replaceState can be very slow on Android Chrome. This function debounces replaceState
      // within a topic until scrolling stops
      _replaceUnlessScrolling: function (url) {
        var currentPos = parseInt($(document).scrollTop(), 10);
        if (currentPos === lastScrollPos) {
          DiscourseURL.replaceState(url);
          return;
        }
        lastScrollPos = currentPos;
        scheduledReplace = Em.run.later(this, '_replaceUnlessScrolling', url, SCROLL_DELAY);
      },

      setupParams: function (topic, params) {
        var postStream = topic.get('postStream');
        postStream.set('summary', Em.get(params, 'filter') === 'summary');
        postStream.set('show_deleted', !!Em.get(params, 'show_deleted'));

        var usernames = Em.get(params, 'username_filters'),
            userFilters = postStream.get('userFilters');

        userFilters.clear();
        if (!Em.isEmpty(usernames) && usernames !== 'undefined') {
          userFilters.addObjects(usernames.split(','));
        }

        return topic;
      },

      model: function (params, transition) {
        var queryParams = transition.queryParams;

        var topic = this.modelFor('topic');
        if (topic && topic.get('id') === parseInt(params.id, 10)) {
          this.setupParams(topic, queryParams);
          return topic;
        } else {
          topic = this.store.createRecord('topic', _.omit(params, 'username_filters', 'filter'));
          return this.setupParams(topic, queryParams);
        }
      },

      activate: function () {
        this._super();
        isTransitioning = false;

        var topic = this.modelFor('topic');
        this.session.set('lastTopicIdViewed', parseInt(topic.get('id'), 10));
      },

      deactivate: function () {
        this._super();

        this.searchService.set('searchContext', null);
        this.controllerFor('user-card').set('visible', false);

        var topicController = this.controllerFor('topic'),
            postStream = topicController.get('model.postStream');
        postStream.cancelFilter();

        topicController.set('multiSelect', false);
        topicController.unsubscribe();
        this.controllerFor('composer').set('topic', null);
        ScreenTrack.current().stop();

        var headerController = this.controllerFor('header');
        if (headerController) {
          headerController.set('topic', null);
          headerController.set('showExtraInfo', false);
        }
      },

      setupController: function (controller, model) {
        // In case we navigate from one topic directly to another
        isTransitioning = false;

        controller.setProperties({
          model: model,
          editingTopic: false,
          firstPostExpanded: false
        });

        TopicRoute.trigger('setupTopicController', this);

        this.controllerFor('header').setProperties({ topic: model, showExtraInfo: false });
        this.searchService.set('searchContext', model.get('searchContext'));

        this.controllerFor('composer').set('topic', model);
        this.topicTrackingState.trackIncoming('all');
        controller.subscribe();

        this.controllerFor('topic-progress').set('model', model);
        // We reset screen tracking every time a topic is entered
        ScreenTrack.current().start(model.get('id'), controller);
      }

    });

    RSVP.EventTarget.mixin(TopicRoute);
    __exports__["default"] = TopicRoute;
  });define("discourse/routes/tos", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('tos');
  });define("discourse/routes/unknown", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return Discourse.ajax("/404-body", { dataType: 'html' });
      }
    });
  });define("discourse/routes/user-activity-bookmarks", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["bookmarks"]
    });
  });define("discourse/routes/user-activity-edits", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["edits"]
    });
  });define("discourse/routes/user-activity-index", 
  ["discourse/routes/user-activity-stream","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: undefined,

      actions: {
        didTransition: function () {
          this._super();
          this.controllerFor("user").set("indexStream", true);
          return true;
        }
      }

    });
  });define("discourse/routes/user-activity-likes-given", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["likes_given"]
    });
  });define("discourse/routes/user-activity-likes-received", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["likes_received"]
    });
  });define("discourse/routes/user-activity-mentions", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["mentions"]
    });
  });define("discourse/routes/user-activity-pending", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES.pending
    });
  });define("discourse/routes/user-activity-posts", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["posts"]
    });
  });define("discourse/routes/user-activity-replies", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["replies"]
    });
  });define("discourse/routes/user-activity-topics", 
  ["discourse/routes/user-topic-list","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserTopicListRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserTopicListRoute.extend({
      userActionType: UserAction.TYPES.topics,

      model: function () {
        return this.store.findFiltered('topicList', { filter: 'topics/created-by/' + this.modelFor('user').get('username_lower') });
      }
    });
  });define("discourse/routes/user-activity", 
  ["discourse/models/draft","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Draft = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.modelFor("user");
      },

      setupController: function (controller, user) {
        this.controllerFor("user-activity").set("model", user);

        // Bring up a draft
        var composerController = this.controllerFor("composer");
        controller.set("model", user);
        if (this.currentUser) {
          Draft.get("new_private_message").then(function (data) {
            if (data.draft) {
              composerController.open({
                draft: data.draft,
                draftKey: "new_private_message",
                ignoreIfChanged: true,
                draftSequence: data.draft_sequence
              });
            }
          });
        }
      }
    });
  });define("discourse/routes/user-badges", 
  ["discourse/mixins/viewing-action-type","discourse/models/user-badge","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];
    var UserBadge = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      model: function () {
        return UserBadge.findByUsername(this.modelFor("user").get("username_lower"), { grouped: true });
      },

      setupController: function (controller, model) {
        this.viewingActionType(-1);
        controller.set("model", model);
      },

      renderTemplate: function () {
        this.render("user/badges", { into: "user" });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });define("discourse/routes/user-deleted-posts", 
  ["discourse/routes/build-admin-user-posts-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createAdminUserPostsRoute = __dependency1__["default"];

    __exports__["default"] = createAdminUserPostsRoute("deleted");
  });define("discourse/routes/user-flagged-posts", 
  ["discourse/routes/build-admin-user-posts-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createAdminUserPostsRoute = __dependency1__["default"];

    __exports__["default"] = createAdminUserPostsRoute("flagged");
  });define("discourse/routes/user-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({

      beforeModel: function () {
        // HACK: Something with the way the user card intercepts clicks seems to break how the
        // transition into a user's activity works. This makes the back button work on mobile
        // where there is no user card as well as desktop where there is.
        if (Discourse.Mobile.mobileView) {
          this.replaceWith('userActivity');
        } else {
          this.transitionTo('userActivity');
        }
      }

    });
  });define("discourse/routes/user-invited-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function () {
        this.replaceWith('userInvited.show', 'pending');
      }
    });
  });define("discourse/routes/user-invited-show", 
  ["discourse/models/invite","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Invite = __dependency1__["default"];
    var showModal = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({

      model: function (params) {
        var self = this;
        Invite.findInvitedCount(self.modelFor("user")).then(function (result) {
          self.set('invitesCount', result);
        });
        self.inviteFilter = params.filter;
        return Invite.findInvitedBy(self.modelFor("user"), params.filter);
      },

      afterModel: function (model) {
        if (!model.can_see_invite_details) {
          this.replaceWith("userInvited.show", "redeemed");
        }
      },

      setupController: function (controller, model) {
        controller.setProperties({
          model: model,
          user: this.controllerFor("user").get("model"),
          filter: this.inviteFilter,
          searchTerm: "",
          totalInvites: model.invites.length,
          invitesCount: this.get('invitesCount')
        });
      },

      actions: {
        showInvite: function () {
          showModal("invite", { model: this.currentUser });
          this.controllerFor("invite").reset();
        },

        uploadSuccess: function (filename) {
          bootbox.alert(I18n.t("user.invited.bulk_invite.success", { filename: filename }));
        },

        uploadError: function (filename, message) {
          bootbox.alert(I18n.t("user.invited.bulk_invite.error", { filename: filename, message: message }));
        }
      }
    });
  });define("discourse/routes/user-notifications", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      actions: {
        didTransition: function () {
          this.controllerFor("user-notifications")._showFooter();
          return true;
        }
      },

      model: function () {
        return this.store.find("notification", { username: this.modelFor("user").get("username") });
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        controller.set("user", this.modelFor("user"));
        this.viewingActionType(-1);
      }
    });
  });define("discourse/routes/user-private-messages-group", 
  ["discourse/routes/build-user-topic-list-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('groups', 'private-messages-groups').extend({
      model: function (params) {
        return this.store.findFiltered("topicList", { filter: "topics/private-messages-group/" + this.modelFor("user").get("username_lower") + "/" + params.name });
      },

      setupController: function (controller, model) {
        this._super.apply(this, arguments);
        var filter = _.last(model.get("filter").split('/'));
        this.controllerFor("user").set("groupFilter", filter);
      }
    });
  });define("discourse/routes/user-private-messages-index", 
  ["discourse/routes/build-user-topic-list-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('index', 'private-messages');
  });define("discourse/routes/user-private-messages-mine", 
  ["discourse/routes/build-user-topic-list-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('mine', 'private-messages-sent');
  });define("discourse/routes/user-private-messages-unread", 
  ["discourse/routes/build-user-topic-list-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('unread', 'private-messages-unread');
  });define("discourse/routes/user-private-messages", 
  ["discourse/routes/user-activity","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserActivityRoute = __dependency1__["default"];

    __exports__["default"] = UserActivityRoute.extend({
      actions: {
        willTransition: function () {
          this._super();
          this.controllerFor('user').set('pmView', null);
          return true;
        }
      }
    });
  });define("discourse/routes/user", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var INDEX_STREAM_ROUTES = ["user.deletedPosts", "user.flaggedPosts", "userActivity.index"];

    __exports__["default"] = Discourse.Route.extend({

      titleToken: function () {
        var model = this.modelFor('user');
        var username = model.get('username');
        if (username) {
          return [I18n.t("user.profile"), username];
        }
      },

      actions: {
        composePrivateMessage: function (user, post) {
          var recipient = user ? user.get('username') : '',
              reply = post ? window.location.protocol + "//" + window.location.host + post.get("url") : null;

          // used only once, one less dependency
          var Composer = require('discourse/models/composer').default;
          return this.controllerFor('composer').open({
            action: Composer.PRIVATE_MESSAGE,
            usernames: recipient,
            archetypeId: 'private_message',
            draftKey: 'new_private_message',
            reply: reply
          });
        },

        willTransition: function (transition) {
          // will reset the indexStream when transitioning to routes that aren't "indexStream"
          // otherwise the "header" will jump
          var isIndexStream = INDEX_STREAM_ROUTES.indexOf(transition.targetName) !== -1;
          this.controllerFor('user').set('indexStream', isIndexStream);
          return true;
        }
      },

      beforeModel: function () {
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          this.replaceWith("discovery");
        }
      },

      model: function (params) {
        // If we're viewing the currently logged in user, return that object instead
        var currentUser = this.currentUser;
        if (currentUser && params.username.toLowerCase() === currentUser.get('username_lower')) {
          return currentUser;
        }

        return Discourse.User.create({ username: params.username });
      },

      afterModel: function () {
        var user = this.modelFor('user');
        var self = this;

        return user.findDetails().then(function () {
          return user.findStaffInfo();
        }).catch(function () {
          return self.replaceWith('/404');
        });
      },

      serialize: function (model) {
        if (!model) return {};
        return { username: (Em.get(model, 'username') || '').toLowerCase() };
      },

      setupController: function (controller, user) {
        controller.set('model', user);
        this.searchService.set('searchContext', user.get('searchContext'));
      },

      activate: function () {
        this._super();
        var user = this.modelFor('user');
        this.messageBus.subscribe("/users/" + user.get('username_lower'), function (data) {
          user.loadUserAction(data);
        });
      },

      deactivate: function () {
        this._super();
        this.messageBus.unsubscribe("/users/" + this.modelFor('user').get('username_lower'));

        // Remove the search context
        this.searchService.set('searchContext', null);
      }

    });
  });define("discourse/routes/users", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      queryParams: {
        period: { refreshModel: true },
        order: { refreshModel: true },
        asc: { refreshModel: true },
        name: { refreshModel: true, replace: true }
      },

      refreshQueryWithoutTransition: true,

      titleToken: function () {
        return I18n.t("directory.title");
      },

      resetController: function (controller, isExiting) {
        if (isExiting) {
          controller.setProperties({
            period: "weekly",
            order: "likes_received",
            asc: null,
            name: ""
          });
        }
      },

      beforeModel: function () {
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          this.replaceWith("discovery");
        }
      },

      model: function (params) {
        // If we refresh via `refreshModel` set the old model to loading
        this._params = params;
        return this.store.find("directoryItem", params);
      },

      setupController: function (controller, model) {
        var params = this._params;
        controller.setProperties({ model: model, period: params.period, nameInput: params.name });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("users")._showFooter();
          return true;
        }
      }
    });
  });define("discourse/pre-initializers/dynamic-route-builders", 
  ["discourse/routes/build-category-route","discourse/routes/build-topic-route","discourse/controllers/discovery-sortable","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var buildCategoryRoute = __dependency1__["default"];
    var buildTopicRoute = __dependency2__["default"];
    var DiscoverySortableController = __dependency3__["default"];

    __exports__["default"] = {
      after: 'inject-discourse-objects',
      name: 'dynamic-route-builders',

      initialize: function (container, app) {
        app.DiscoveryCategoryController = DiscoverySortableController.extend();
        app.DiscoveryParentCategoryController = DiscoverySortableController.extend();
        app.DiscoveryCategoryNoneController = DiscoverySortableController.extend();

        app.DiscoveryCategoryRoute = buildCategoryRoute('latest');
        app.DiscoveryParentCategoryRoute = buildCategoryRoute('latest');
        app.DiscoveryCategoryNoneRoute = buildCategoryRoute('latest', { no_subcategories: true });

        var site = Discourse.Site.current();
        site.get('filters').forEach(function (filter) {
          var filterCapitalized = filter.capitalize();
          app['Discovery' + filterCapitalized + 'Controller'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'CategoryController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'ParentCategoryController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'CategoryNoneController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'Route'] = buildTopicRoute(filter);
          app['Discovery' + filterCapitalized + 'CategoryRoute'] = buildCategoryRoute(filter);
          app['Discovery' + filterCapitalized + 'ParentCategoryRoute'] = buildCategoryRoute(filter);
          app['Discovery' + filterCapitalized + 'CategoryNoneRoute'] = buildCategoryRoute(filter, { no_subcategories: true });
        });

        Discourse.DiscoveryTopController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopCategoryController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopParentCategoryController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopCategoryNoneController = DiscoverySortableController.extend();

        Discourse.DiscoveryTopRoute = buildTopicRoute('top', {
          actions: {
            willTransition: function () {
              Discourse.User.currentProp("should_be_redirected_to_top", false);
              Discourse.User.currentProp("redirected_to_top.reason", null);
              return this._super();
            }
          }
        });
        Discourse.DiscoveryTopCategoryRoute = buildCategoryRoute('top');
        Discourse.DiscoveryTopParentCategoryRoute = buildCategoryRoute('top');
        Discourse.DiscoveryTopCategoryNoneRoute = buildCategoryRoute('top', { no_subcategories: true });

        site.get('periods').forEach(function (period) {
          var periodCapitalized = period.capitalize();
          app['DiscoveryTop' + periodCapitalized + 'Controller'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'CategoryController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'ParentCategoryController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'CategoryNoneController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'Route'] = buildTopicRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'CategoryRoute'] = buildCategoryRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'ParentCategoryRoute'] = buildCategoryRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'CategoryNoneRoute'] = buildCategoryRoute('top/' + period, { no_subcategories: true });
        });
      }
    };
  });define("discourse/pre-initializers/inject-discourse-objects", 
  ["discourse/models/session","discourse/lib/key-value-store","discourse/lib/app-events","discourse/models/store","discourse/lib/url","discourse/lib/discourse-location","discourse/services/search","discourse/models/topic-tracking-state","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {
    "use strict";
    var Session = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];
    var AppEvents = __dependency3__["default"];
    var Store = __dependency4__["default"];
    var DiscourseURL = __dependency5__["default"];
    var DiscourseLocation = __dependency6__["default"];
    var SearchService = __dependency7__["default"];
    var startTracking = __dependency8__.startTracking;
    var TopicTrackingState = __dependency8__.default;

    function inject() {
      var app = arguments[0],
          name = arguments[1],
          singletonName = Ember.String.underscore(name).replace(/_/g, '-') + ':main';

      Array.prototype.slice.call(arguments, 2).forEach(function (dest) {
        return app.inject(dest, name, singletonName);
      });
    }

    function injectAll(app, name) {
      inject(app, name, 'controller', 'component', 'route', 'view', 'model', 'adapter');
    }

    __exports__["default"] = {
      name: "inject-discourse-objects",

      initialize: function (container, app) {
        var appEvents = AppEvents.create();
        app.register('app-events:main', appEvents, { instantiate: false });
        injectAll(app, 'appEvents');
        DiscourseURL.appEvents = appEvents;

        app.register('store:main', Store);
        inject(app, 'store', 'route', 'controller');

        var messageBus = window.MessageBus;
        app.register('message-bus:main', messageBus, { instantiate: false });
        injectAll(app, 'messageBus');

        var currentUser = Discourse.User.current();
        app.register('current-user:main', currentUser, { instantiate: false });

        var tracking = TopicTrackingState.create({ messageBus: messageBus, currentUser: currentUser });
        app.register('topic-tracking-state:main', tracking, { instantiate: false });
        injectAll(app, 'topicTrackingState');

        var site = Discourse.Site.current();
        app.register('site:main', site, { instantiate: false });
        injectAll(app, 'site');

        app.register('site-settings:main', Discourse.SiteSettings, { instantiate: false });
        injectAll(app, 'siteSettings');

        app.register('search-service:main', SearchService);
        injectAll(app, 'searchService');

        app.register('session:main', Session.current(), { instantiate: false });
        injectAll(app, 'session');

        inject(app, 'currentUser', 'component', 'route', 'controller');

        app.register('location:discourse-location', DiscourseLocation);

        var keyValueStore = new KeyValueStore("discourse_");
        app.register('key-value-store:main', keyValueStore, { instantiate: false });
        injectAll(app, 'keyValueStore');

        startTracking(tracking);
      }
    };
  });define("discourse/pre-initializers/map-routes", 
  ["discourse/router","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var mapRoutes = __dependency1__.mapRoutes;

    __exports__["default"] = {
      name: "map-routes",
      after: 'inject-discourse-objects',

      initialize: function (container, app) {
        app.register('router:main', mapRoutes());

        // HACK to fix: https://github.com/emberjs/ember.js/issues/10310
        var originalBuildInstance = originalBuildInstance || Ember.Application.prototype.buildInstance;
        Ember.Application.prototype.buildInstance = function () {
          this.registry = this.buildRegistry();
          return originalBuildInstance.apply(this);
        };
      }
    };
  });define("discourse/pre-initializers/register-dom-templates", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "register-discourse-dom-templates",
      before: 'domTemplates',

      initialize: function () {
        $('script[type="text/x-handlebars"]').each(function () {
          var $this = $(this);
          var name = $this.attr("name") || $this.data("template-name");

          if (window.console) {
            window.console.log("WARNING: you have a handlebars template named " + name + " this is an unsupported setup, precompile your templates");
          }
          $this.remove();
        });
      }
    };
  });define("discourse/pre-initializers/sniff-capabilities", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /*global Modernizr:true*/

    // Initializes an object that lets us know about our capabilities.
    __exports__["default"] = {
      name: "sniff-capabilities",
      initialize: function (container, application) {
        var $html = $('html'),
            touch = $html.hasClass('touch') || Modernizr.prefixed("MaxTouchPoints", navigator) > 1,
            caps = { touch: touch };

        // Store the touch ability in our capabilities object
        $html.addClass(touch ? 'discourse-touch' : 'discourse-no-touch');

        // Detect Devices
        if (navigator) {
          var ua = navigator.userAgent;
          if (ua) {
            caps.isAndroid = ua.indexOf('Android') !== -1;
            caps.isWinphone = ua.indexOf('Windows Phone') !== -1;

            caps.isOpera = !!window.opera || ua.indexOf(' OPR/') >= 0;
            caps.isFirefox = typeof InstallTrigger !== 'undefined';
            caps.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
            caps.isChrome = !!window.chrome && !caps.isOpera;
            caps.canPasteImages = caps.isChrome || caps.isFirefox;
          }

          caps.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // We consider high res a device with 1280 horizontal pixels. High DPI tablets like
        // iPads should report as 1024.
        caps.highRes = window.screen.width >= 1280;

        // Inject it
        application.register('capabilities:main', caps, { instantiate: false });
        application.inject('view', 'capabilities', 'capabilities:main');
        application.inject('controller', 'capabilities', 'capabilities:main');
        application.inject('component', 'capabilities', 'capabilities:main');
      }
    };
  });define("discourse/initializers/apply-flagged-properties", 
  ["discourse/controllers/header","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var applyFlaggedProperties = __dependency1__.applyFlaggedProperties;

    __exports__["default"] = {
      name: 'apply-flagged-properties',
      initialize: applyFlaggedProperties
    };
  });define("discourse/initializers/asset-version", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Subscribe to "asset-version" change events via the Message Bus
    __exports__["default"] = {
      name: "asset-version",
      after: "message-bus",

      initialize: function (container) {
        var timeoutIsSet = false;
        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        messageBus.subscribe("/global/asset-version", function (version) {
          Discourse.set("assetVersion", version);

          if (!timeoutIsSet && Discourse.get("requiresRefresh")) {
            // since we can do this transparently for people browsing the forum
            //  hold back the message a couple of hours
            setTimeout(function () {
              bootbox.confirm(I18n.lookup("assets_changed_confirm"), function (result) {
                if (result) {
                  document.location.reload();
                }
              });
            }, 1000 * 60 * 120);
            timeoutIsSet = true;
          }
        });
      }
    };
  });define("discourse/initializers/banner", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "banner",
      after: "message-bus",

      initialize: function (container) {

        var banner = Em.Object.create(PreloadStore.get("banner")),
            site = container.lookup('site:main');

        site.set("banner", banner);

        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        messageBus.subscribe("/site/banner", function (ban) {
          site.set("banner", Em.Object.create(ban));
        });
      }
    };
  });define("discourse/initializers/click-interceptor", 
  ["discourse/lib/intercept-click","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var interceptClick = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = {
      name: "click-interceptor",
      initialize: function () {
        $('#main').on('click.discourse', 'a', interceptClick);
        $(window).on('hashchange', function () {
          return DiscourseURL.routeTo(document.location.hash);
        });
      }
    };
  });define("discourse/initializers/csrf-token", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Append our CSRF token to AJAX requests when necessary.
    __exports__["default"] = {
      name: "csrf-token",
      initialize: function (container) {

        var session = container.lookup('session:main');

        // Add a CSRF token to all AJAX requests
        session.set('csrfToken', $('meta[name=csrf-token]').attr('content'));

        $.ajaxPrefilter(function (options, originalOptions, xhr) {
          if (!options.crossDomain) {
            xhr.setRequestHeader('X-CSRF-Token', session.get('csrfToken'));
          }
        });
      }
    };
  });define("discourse/initializers/ember-events", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "ember-events",

      initialize: function () {

        // By default Ember listens to too many events. This tells it the only events
        // we're interested in.
        Ember.EventDispatcher.reopen({
          events: {
            touchstart: 'touchStart',
            touchend: 'touchEnd',
            touchcancel: 'touchCancel',
            keydown: 'keyDown',
            keyup: 'keyUp',
            keypress: 'keyPress',
            mousedown: 'mouseDown',
            mouseup: 'mouseUp',
            contextmenu: 'contextMenu',
            click: 'click',
            dblclick: 'doubleClick',
            focusin: 'focusIn',
            focusout: 'focusOut',
            mouseenter: 'mouseEnter',
            mouseleave: 'mouseLeave',
            submit: 'submit',
            input: 'input',
            change: 'change',
            dragstart: 'dragStart',
            drag: 'drag',
            dragenter: 'dragEnter',
            dragleave: 'dragLeave',
            dragover: 'dragOver',
            drop: 'drop',
            dragend: 'dragEnd'
          }
        });
      }
    };
  });define("discourse/initializers/enable-emoji", 
  ["discourse/components/d-editor","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var onToolbarCreate = __dependency1__.onToolbarCreate;

    __exports__["default"] = {
      name: 'enable-emoji',

      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');

        if (siteSettings.enable_emoji) {
          onToolbarCreate(function (toolbar) {
            toolbar.addButton({
              id: 'emoji',
              group: 'extras',
              icon: 'smile-o',
              action: 'emoji',
              title: 'composer.emoji'
            });
          });

          // enable plugin emojis
          Discourse.Emoji.applyCustomEmojis();
        }
      }
    };
  });define("discourse/initializers/ensure-max-image-dimensions", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'ensure-image-dimensions',
      after: 'mobile',
      initialize: function () {
        if (!window) {
          return;
        }

        // This enforces maximum dimensions of images based on site settings
        // for mobile we use the window width as a safeguard
        // This rule should never really be at play unless for some reason images do not have dimensions

        var width = Discourse.SiteSettings.max_image_width;
        var height = Discourse.SiteSettings.max_image_height;

        if (Discourse.Mobile.mobileView) {
          width = $(window).width() - 20;
        }

        var style = 'max-width:' + width + 'px;' + 'max-height:' + height + 'px;';

        $('<style id="image-sizing-hack">#reply-control .d-editor-preview img:not(.thumbnail), .cooked img:not(.thumbnail) {' + style + '}</style>').appendTo('head');
      }
    };
  });define("discourse/initializers/focus-event", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Keep track of when the browser is in focus.
    **/

    __exports__["default"] = {
      name: 'focus-event',

      initialize: function () {
        var hidden = "hidden";

        // Default to true
        Discourse.set('hasFocus', true);

        var gotFocus = function () {
          if (!Discourse.get('hasFocus')) {
            Discourse.setProperties({ hasFocus: true, notify: false });
          }
        };

        var lostFocus = function () {
          if (Discourse.get('hasFocus')) {
            Discourse.set('hasFocus', false);
          }
        };

        var onchange = function (evt) {
          var v = 'visible',
              h = 'hidden',
              evtMap = {
            focus: v, focusin: v, pageshow: v, blur: h, focusout: h, pagehide: h
          };

          evt = evt || window.event;
          if (evt.type in evtMap) {
            if (evtMap[evt.type] === 'hidden') {
              lostFocus();
            } else {
              gotFocus();
            }
          } else {
            if (this[hidden]) {
              lostFocus();
            } else {
              gotFocus();
            }
          }
        };

        // from StackOverflow http://stackoverflow.com/a/1060034/17174
        if (hidden in document) {
          document.addEventListener('visibilitychange', onchange);
        } else if ((hidden = 'mozHidden') in document) {
          document.addEventListener('mozvisibilitychange', onchange);
        } else if ((hidden = 'webkitHidden') in document) {
          document.addEventListener('webkitvisibilitychange', onchange);
        } else if ((hidden = 'msHidden') in document) {
          document.addEventListener('msvisibilitychange', onchange);
        }
        // IE 9 and lower:
        else if ('onfocusin' in document) {
            document.onfocusin = document.onfocusout = onchange;
          }
          // All others (including iPad which is a bit weird and gives onpageshow / hide
          else {
              window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange;
            }
      }
    };
  });define("discourse/initializers/ie9-hax", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'ie9-hacks',
      initialize: function () {
        if (!window) {
          return;
        }

        // IE9 does not support a console object unless the developer tools are open
        if (!window.console) {
          window.console = {};
        }
        if (!window.console.log) {
          window.console.log = Ember.K;
        }
      }
    };
  });define("discourse/initializers/inject-objects", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // backwards compatibility for plugins that depend on this initializer

    __exports__["default"] = {
      name: "inject-objects",
      initialize: Ember.K
    };
  });define("discourse/initializers/jquery-plugins", 
  ["discourse/lib/autocomplete","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var autocomplete = __dependency1__["default"];

    __exports__["default"] = {
      name: "jquery-plugins",
      initialize: function () {

        // Settings for bootbox
        bootbox.animate(false);
        bootbox.backdrop(true);

        // Initialize the autocomplete tool
        $.fn.autocomplete = autocomplete;
      }
    };
  });define("discourse/initializers/keyboard-shortcuts", 
  ["discourse/lib/keyboard-shortcuts","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /*global Mousetrap:true*/

    var KeyboardShortcuts = __dependency1__["default"];

    __exports__["default"] = {
      name: "keyboard-shortcuts",

      initialize: function (container) {
        KeyboardShortcuts.bindEvents(Mousetrap, container);
      }
    };
  });define("discourse/initializers/live-development", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];

    //  Use the message bus for live reloading of components for faster development.
    __exports__["default"] = {
      name: "live-development",
      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');

        // subscribe to any site customizations that are loaded
        $('link.custom-css').each(function () {
          var split = this.href.split("/"),
              id = split[split.length - 1].split(".css")[0],
              self = this;

          return messageBus.subscribe("/file-change/" + id, function (data) {
            if (!$(self).data('orig')) {
              $(self).data('orig', self.href);
            }
            var orig = $(self).data('orig');

            self.href = orig.replace(/v=.*/, "v=" + data);
          });
        });

        // Custom header changes
        $('header.custom').each(function () {
          var header = $(this);
          return messageBus.subscribe("/header-change/" + $(this).data('key'), function (data) {
            return header.html(data);
          });
        });

        // Observe file changes
        messageBus.subscribe("/file-change", function (data) {
          if (Handlebars.compile && !Ember.TEMPLATES.empty) {
            // hbs notifications only happen in dev
            Ember.TEMPLATES.empty = Handlebars.compile("<div></div>");
          }
          _.each(data, function (me) {

            if (me === "refresh") {
              // Refresh if necessary
              document.location.reload(true);
            } else if (me.name.substr(-10) === "hbs") {
              (function () {

                // Reload handlebars
                var js = me.name.replace(".hbs", "").replace("app/assets/javascripts", "/assets");
                loadScript(js + "?hash=" + me.hash).then(function () {
                  var templateName = js.replace(".js", "").replace("/assets/", "");
                  return _.each(Ember.View.views, function (view) {
                    if (view.get('templateName') === templateName) {
                      view.set('templateName', 'empty');
                      view.rerender();
                      Em.run.schedule('afterRender', function () {
                        view.set('templateName', templateName);
                        view.rerender();
                      });
                    }
                  });
                });
              })();
            } else {
              $('link').each(function () {
                // TODO: stop bundling css in DEV please
                if (true || this.href.match(me.name) && me.hash) {
                  if (!$(this).data('orig')) {
                    $(this).data('orig', this.href);
                  }
                  var orig = $(this).data('orig');
                  if (!me.hash) {
                    window.__uniq = window.__uniq || 1;
                    me.hash = window.__uniq++;
                  }
                  this.href = orig + (orig.indexOf('?') >= 0 ? "&hash=" : "?hash=") + me.hash;
                }
              });
            }
          });
        });
      }
    };
  });define("discourse/initializers/load-all-helpers", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.loadAllHelpers = loadAllHelpers;

    function loadAllHelpers() {
      Ember.keys(requirejs.entries).forEach(function (entry) {
        if (/\/helpers\//.test(entry)) {
          require(entry, null, null, true);
        }
      });
    }

    __exports__["default"] = {
      name: 'load-all-helpers',
      initialize: loadAllHelpers
    };
  });define("discourse/initializers/localization", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'localization',
      after: 'inject-objects',

      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');
        if (siteSettings.verbose_localization) {
          I18n.enable_verbose_localization();
        }

        // Merge any overrides into our object
        var overrides = PreloadStore.get('translationOverrides') || {};
        Object.keys(overrides).forEach(function (k) {
          var v = overrides[k];
          k = k.replace('admin_js', 'js');

          var segs = k.split('.');
          var node = I18n.translations[I18n.locale];
          var i = 0;
          for (; node && i < segs.length - 1; i++) {
            node = node[segs[i]];
          }

          if (node && i === segs.length - 1) {
            node[segs[segs.length - 1]] = v;
          }
        });
      }
    };
  });define("discourse/initializers/logout", 
  ["discourse/lib/logout","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var logout = __dependency1__["default"];

    //  Subscribe to "logout" change events via the Message Bus
    __exports__["default"] = {
      name: "logout",
      after: "message-bus",

      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');
        var siteSettings = container.lookup('site-settings:main');
        var keyValueStore = container.lookup('key-value-store:main');

        if (!messageBus) {
          return;
        }
        var callback = function () {
          return logout(siteSettings, keyValueStore);
        };

        messageBus.subscribe("/logout", function () {
          bootbox.dialog(I18n.t("logout"), { label: I18n.t("refresh"), callback: callback }, { onEscape: callback, backdrop: 'static' });
        });
      }
    };
  });define("discourse/initializers/message-bus", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Initialize the message bus to receive messages.
    __exports__["default"] = {
      name: "message-bus",
      after: 'inject-objects',

      initialize: function (container) {
        // We don't use the message bus in testing
        if (Discourse.testing) {
          return;
        }

        var messageBus = container.lookup('message-bus:main'),
            user = container.lookup('current-user:main'),
            siteSettings = container.lookup('site-settings:main');

        messageBus.alwaysLongPoll = Discourse.Environment === "development";
        messageBus.start();

        messageBus.callbackInterval = siteSettings.anon_polling_interval;
        messageBus.backgroundCallbackInterval = siteSettings.background_polling_interval;
        messageBus.baseUrl = siteSettings.long_polling_base_url;

        if (messageBus.baseUrl !== '/') {
          // zepto compatible, 1 param only
          messageBus.ajax = function (opts) {
            opts.headers = opts.headers || {};
            opts.headers['X-Shared-Session-Key'] = $('meta[name=shared_session_key]').attr('content');
            return $.ajax(opts);
          };
        } else {
          messageBus.baseUrl = Discourse.getURL('/');
        }

        if (user) {
          messageBus.callbackInterval = siteSettings.polling_interval;
          messageBus.enableLongPolling = true;
        }
      }
    };
  });define("discourse/initializers/mobile", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Initializes the `Discourse.Mobile` helper object.
    **/

    __exports__["default"] = {
      name: 'mobile',
      after: 'inject-objects',

      initialize: function (container) {
        Discourse.Mobile.init();
        var site = container.lookup('site:main');
        site.set('mobileView', Discourse.Mobile.mobileView);
      }
    };
  });define("discourse/initializers/page-tracking", 
  ["discourse/routes/discourse","discourse/lib/page-tracker","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var cleanDOM = __dependency1__.cleanDOM;
    var PageTracker = __dependency2__["default"];

    __exports__["default"] = {
      name: "page-tracking",

      initialize: function (container) {

        var cache = {};
        var transitionCount = 0;

        // Tell our AJAX system to track a page transition
        var router = container.lookup('router:main');
        router.on('willTransition', function () {
          Discourse.viewTrackingRequired();
        });

        router.on('didTransition', function () {
          Em.run.scheduleOnce('afterRender', Ember.Route, cleanDOM);
          transitionCount++;
          _.each(cache, function (v, k) {
            if (v && v.target && v.target < transitionCount) {
              delete cache[k];
            }
          });
        });

        router.transientCache = function (key, data, count) {
          if (data === undefined) {
            return cache[key];
          } else {
            return cache[key] = { data: data, target: transitionCount + count };
          }
        };

        var pageTracker = PageTracker.current();
        pageTracker.start();

        // Out of the box, Discourse tries to track google analytics
        // if it is present
        if (typeof window._gaq !== 'undefined') {
          pageTracker.on('change', function (url, title) {
            window._gaq.push(["_set", "title", title]);
            window._gaq.push(['_trackPageview', url]);
          });
          return;
        }

        // Also use Universal Analytics if it is present
        if (typeof window.ga !== 'undefined') {
          pageTracker.on('change', function (url, title) {
            window.ga('send', 'pageview', { page: url, title: title });
          });
        }
      }
    };
  });define("discourse/initializers/post-decorations", 
  ["discourse/lib/plugin-api","discourse/lib/highlight-syntax","discourse/lib/lightbox","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var decorateCooked = __dependency1__.decorateCooked;
    var HighlightSyntax = __dependency2__["default"];
    var Lightbox = __dependency3__["default"];

    __exports__["default"] = {
      name: "post-decorations",
      initialize: function (container) {
        decorateCooked(container, HighlightSyntax);
        decorateCooked(container, Lightbox);
      }
    };
  });define("discourse/initializers/read-only", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Subscribe to "read-only" status change events via the Message Bus
    __exports__["default"] = {
      name: "read-only",
      after: "message-bus",

      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        var site = container.lookup('site:main');
        messageBus.subscribe("/site/read-only", function (enabled) {
          site.set('isReadOnly', enabled);
        });
      }
    };
  });define("discourse/initializers/register-discourse-location", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // backwards compatibility for plugins that depend on this initializer

    __exports__["default"] = {
      name: "register-discourse-location",
      initialize: Ember.K
    };
  });define("discourse/initializers/relative-ages", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var updateRelativeAge = __dependency1__.updateRelativeAge;

    // Updates the relative ages of dates on the screen.
    __exports__["default"] = {
      name: "relative-ages",
      initialize: function () {
        setInterval(function () {
          updateRelativeAge($('.relative-date'));
        }, 60 * 1000);
      }
    };
  });define("discourse/initializers/sharing-sources", 
  ["discourse/lib/sharing","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Sharing = __dependency1__["default"];

    __exports__["default"] = {
      name: 'sharing-sources',

      initialize: function () {
        Sharing.addSource({
          id: 'twitter',
          faIcon: 'fa-twitter-square',
          generateUrl: function (link, title) {
            return "http://twitter.com/intent/tweet?url=" + encodeURIComponent(link) + "&text=" + encodeURIComponent(title);
          },
          shouldOpenInPopup: true,
          title: I18n.t('share.twitter'),
          popupHeight: 265
        });

        Sharing.addSource({
          id: 'facebook',
          faIcon: 'fa-facebook-square',
          title: I18n.t('share.facebook'),
          generateUrl: function (link, title) {
            return "http://www.facebook.com/sharer.php?u=" + encodeURIComponent(link) + '&t=' + encodeURIComponent(title);
          },
          shouldOpenInPopup: true
        });

        Sharing.addSource({
          id: 'google+',
          faIcon: 'fa-google-plus-square',
          title: I18n.t('share.google+'),
          generateUrl: function (link) {
            return "https://plus.google.com/share?url=" + encodeURIComponent(link);
          },
          shouldOpenInPopup: true,
          popupHeight: 600
        });

        Sharing.addSource({
          id: 'email',
          faIcon: 'fa-envelope-square',
          title: I18n.t('share.email'),
          generateUrl: function (link, title) {
            return "mailto:?to=&subject=" + encodeURIComponent('[' + Discourse.SiteSettings.title + '] ' + title) + "&body=" + encodeURIComponent(link);
          }
        });
      }
    };
  });define("discourse/initializers/show-footer", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "show-footer",

      initialize: function (container) {
        var router = container.lookup("router:main");
        var application = container.lookup("controller:application");

        // only take care of hiding the footer here
        // controllers MUST take care of displaying it
        router.on("willTransition", function () {
          application.set("showFooter", false);
          return true;
        });
      }
    };
  });define("discourse/initializers/signup-cta", 
  ["discourse/lib/screen-track","discourse/models/session","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ScreenTrack = __dependency1__["default"];
    var Session = __dependency2__["default"];

    var ANON_TOPIC_IDS = 3,
        ANON_PROMPT_READ_TIME = 5 * 60 * 1000,
        ONE_DAY = 24 * 60 * 60 * 1000,
        PROMPT_HIDE_DURATION = ONE_DAY;

    __exports__["default"] = {
      name: "signup-cta",

      initialize: function (container) {
        var screenTrack = ScreenTrack.current(),
            session = Session.current(),
            siteSettings = container.lookup('site-settings:main'),
            keyValueStore = container.lookup('key-value-store:main'),
            user = container.lookup('current-user:main');

        screenTrack.set('keyValueStore', keyValueStore);

        // Preconditions

        if (user) return; // must not be logged in
        if (keyValueStore.get('anon-cta-never')) return; // "never show again"
        if (!siteSettings.allow_new_registrations) return;
        if (siteSettings.invite_only) return;
        if (siteSettings.must_approve_users) return;
        if (siteSettings.login_required) return;
        if (!siteSettings.enable_signup_cta) return;

        function checkSignupCtaRequirements() {
          if (session.get('showSignupCta')) {
            return; // already shown
          }

          if (session.get('hideSignupCta')) {
            return; // hidden for session
          }

          if (keyValueStore.get('anon-cta-never')) {
            return; // hidden forever
          }

          var now = new Date().getTime();
          var hiddenAt = keyValueStore.getInt('anon-cta-hidden', 0);
          if (hiddenAt > now - PROMPT_HIDE_DURATION) {
            return; // hidden in last 24 hours
          }

          var readTime = keyValueStore.getInt('anon-topic-time');
          if (readTime < ANON_PROMPT_READ_TIME) {
            return;
          }

          var topicIdsString = keyValueStore.get('anon-topic-ids');
          if (!topicIdsString) {
            return;
          }
          var topicIdsAry = topicIdsString.split(',');
          if (topicIdsAry.length < ANON_TOPIC_IDS) {
            return;
          }

          // Requirements met.
          session.set('showSignupCta', true);
        }

        screenTrack.set('anonFlushCallback', checkSignupCtaRequirements);

        checkSignupCtaRequirements();
      }
    };
  });define("discourse/initializers/subscribe-user-notifications", 
  ["discourse/lib/desktop-notifications","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // Subscribes to user events on the message bus
    var initDesktopNotifications = __dependency1__.init;
    var onNotification = __dependency1__.onNotification;

    __exports__["default"] = {
      name: 'subscribe-user-notifications',
      after: 'message-bus',
      initialize: function (container) {
        var user = container.lookup('current-user:main'),
            site = container.lookup('site:main'),
            siteSettings = container.lookup('site-settings:main'),
            bus = container.lookup('message-bus:main'),
            keyValueStore = container.lookup('key-value-store:main');

        // clear old cached notifications
        // they could be a week old for all we know
        keyValueStore.remove('recent-notifications');

        if (user) {

          if (user.get('staff')) {
            bus.subscribe('/flagged_counts', function (data) {
              user.set('site_flagged_posts_count', data.total);
            });
            bus.subscribe('/queue_counts', function (data) {
              user.set('post_queue_new_count', data.post_queue_new_count);
              if (data.post_queue_new_count > 0) {
                user.set('show_queued_posts', 1);
              }
            });
          }

          bus.subscribe("/notification/" + user.get('id'), function (data) {
            var oldUnread = user.get('unread_notifications');
            var oldPM = user.get('unread_private_messages');

            user.set('unread_notifications', data.unread_notifications);
            user.set('unread_private_messages', data.unread_private_messages);

            if (oldUnread !== data.unread_notifications || oldPM !== data.unread_private_messages) {
              user.set('lastNotificationChange', new Date());
            }

            var stale = keyValueStore.getObject('recent-notifications');
            var lastNotification = data.last_notification && data.last_notification.notification;

            if (stale && stale.notifications && lastNotification) {

              var oldNotifications = stale.notifications;
              var staleIndex = _.findIndex(oldNotifications, { id: lastNotification.id });

              if (staleIndex > -1) {
                oldNotifications.splice(staleIndex, 1);
              }

              // this gets a bit tricky, uread pms are bumped to front
              var insertPosition = 0;
              if (lastNotification.notification_type !== 6) {
                insertPosition = _.findIndex(oldNotifications, function (n) {
                  return n.notification_type !== 6 || n.read;
                });
                insertPosition = insertPosition === -1 ? oldNotifications.length - 1 : insertPosition;
              }

              oldNotifications.splice(insertPosition, 0, lastNotification);
              keyValueStore.setItem('recent-notifications', JSON.stringify(stale));
            }
          }, user.notification_channel_position);

          bus.subscribe("/categories", function (data) {
            _.each(data.categories, function (c) {
              site.updateCategory(c);
            });
            _.each(data.deleted_categories, function (id) {
              site.removeCategory(id);
            });
          });

          bus.subscribe("/client_settings", function (data) {
            siteSettings[data.name] = data.value;
          });

          if (!Ember.testing) {
            if (!Discourse.Mobile.mobileView) {
              bus.subscribe("/notification-alert/" + user.get('id'), function (data) {
                onNotification(data, user);
              });

              initDesktopNotifications(bus);
            }
          }
        }
      }
    };
  });define("discourse/initializers/url-redirects", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = {
      name: 'url-redirects',
      initialize: function () {

        // URL rewrites (usually due to refactoring)
        DiscourseURL.rewrite(/^\/category\//, "/c/");
        DiscourseURL.rewrite(/^\/group\//, "/groups/");
        DiscourseURL.rewrite(/\/private-messages\/$/, "/messages/");
        DiscourseURL.rewrite(/^\/users\/([^\/]+)\/?$/, "/users/$1/activity");
      }
    };
  });define("discourse/services/search", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Object.extend(_createDecoratedObject([{
      key: 'searchContextEnabled',
      initializer: function () {
        return false;
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return null;
      }
    }, {
      key: 'term',
      initializer: function () {
        return null;
      }
    }, {
      key: 'highlightTerm',
      initializer: function () {
        return null;
      }
    }, {
      key: '_sethighlightTerm',
      decorators: [observes('term')],
      value: function () {
        this.set('highlightTerm', this.get('term'));
      }
    }, {
      key: 'contextType',
      decorators: [computed('searchContext')],
      initializer: function () {
        return {
          get: function (searchContext) {
            if (searchContext) {
              return Ember.get(searchContext, 'type');
            }
          },
          set: function (value, searchContext) {
            // a bit hacky, consider cleaning this up, need to work through all observers though
            var context = $.extend({}, searchContext);
            context.type = value;
            this.set('searchContext', context);
            return this.get('searchContext.type');
          }
        };
      }
    }]));
  });


// Stuff we need to load first











































































































;
(function(document, $) {

  // cf. http://mths.be/details
  var hasNativeSupport = (function(doc) {
    var fake, el = doc.createElement("details");
    // fail-fast
    if (!("open" in el)) { return false; }
    // figure out a root node
    var root = doc.body || (function() {
      var de = doc.documentElement;
      fake = true;
      return de.insertBefore(doc.createElement("body"), de.firstElementChild || de.firstChild);
    })();
    // setup test element
    el.innerHTML = "<summary>a</summary>b";
    el.style.display = "block";
    // add test element to the root node
    root.appendChild(el);
    // can we open it?
    var diff = el.offsetHeight;
    el.open = true;
    diff = diff !== el.offsetHeight;
    // cleanup
    root.removeChild(el);
    if (fake) { root.parentNode.removeChild(root); }
    // return the result
    return diff;
  })(document);

  function toggleOpen($details) {
    $details.toggleClass("open");
  }

  $.fn.details = function() {
    if (hasNativeSupport) { return this; }

    return this.each(function() {
      var $details = $(this),
          $firstSummary = $("summary", $details).first();

      $firstSummary.prop("tabIndex", 0);

      $firstSummary.on("keydown", function(event) {
        if (event.keyCode === 32 /* SPACE */ || event.keyCode === 13 /* ENTER */) {
          toggleOpen($details);
          return false;
        }
      });

      $firstSummary.on("click", function() {
        $firstSummary.focus();
        toggleOpen($details);
      });

    });
  };

})(document, jQuery);
(function() {

  function insertDetails(_, summary, details) {
    return "<details><summary>" + summary + "</summary>" + details + "</details>";
  }

  // replace all [details] BBCode with HTML 5.1 equivalent
  function replaceDetails(text) {
    text = text || "";

    while (text !== (text = text.replace(/\[details=([^\]]+)\]((?:(?!\[details=[^\]]+\]|\[\/details\])[\S\s])*)\[\/details\]/ig, insertDetails)));

    // add new lines to make sure we *always* have a <p> element after </summary> and around </details>
    // otherwise we can't hide the content since we can't target text nodes via CSS
    return text.replace(/<\/summary>/ig, "</summary>\n\n")
               .replace(/<\/details>/ig, "\n\n</details>\n\n");
  }

  Discourse.Dialect.addPreProcessor(function(text) {
    if (Discourse.SiteSettings.details_enabled) {
      text = replaceDetails(text);
    }
    return text;
  });

})();
/*!
* lazyYT (lazy load YouTube videos)
* v1.0.1 - 2014-12-30
* (CC) This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
* http://creativecommons.org/licenses/by-sa/4.0/
* Contributors: https://github.com/tylerpearson/lazyYT/graphs/contributors || https://github.com/daugilas/lazyYT/graphs/contributors
*
* Usage: <div class="lazyYT" data-youtube-id="laknj093n" data-parameters="rel=0">loading...</div>
*/


;(function ($) {
  'use strict';

  function setUp($el, settings) {
    var width = $el.data('width'),
    height = $el.data('height'),
    ratio = ($el.data('ratio')) ? $el.data('ratio') : settings.default_ratio,
    id = $el.data('youtube-id'),
    title = $el.data('youtube-title'),
    padding_bottom,
    innerHtml = [],
    $thumb,
    thumb_img,
    youtube_parameters = $el.data('parameters') || '';

    ratio = ratio.split(":");

    // width and height might override default_ratio value
    if (typeof width === 'number' && typeof height === 'number') {
      $el.width(width);
      padding_bottom = height + 'px';
    } else if (typeof width === 'number') {
      $el.width(width);
      padding_bottom = (width * ratio[1] / ratio[0]) + 'px';
    } else {
      width = $el.width();

      // no width means that container is fluid and will be the size of its parent
      if (width === 0) {
        width = $el.parent().width();
      }

      padding_bottom = (ratio[1] / ratio[0] * 100) + '%';
    }

    //
    // This HTML will be placed inside 'lazyYT' container

    innerHtml.push('<div class="ytp-thumbnail">');

    // Play button from YouTube (exactly as it is in YouTube)
    innerHtml.push('<div class="ytp-large-play-button"');
    if (width <= 640) innerHtml.push(' style="transform: scale(0.563888888888889);"');
    innerHtml.push('>');
    innerHtml.push('<svg>');
    innerHtml.push('<path fill-rule="evenodd" clip-rule="evenodd" fill="#1F1F1F" class="ytp-large-play-button-svg" d="M84.15,26.4v6.35c0,2.833-0.15,5.967-0.45,9.4c-0.133,1.7-0.267,3.117-0.4,4.25l-0.15,0.95c-0.167,0.767-0.367,1.517-0.6,2.25c-0.667,2.367-1.533,4.083-2.6,5.15c-1.367,1.4-2.967,2.383-4.8,2.95c-0.633,0.2-1.316,0.333-2.05,0.4c-0.767,0.1-1.3,0.167-1.6,0.2c-4.9,0.367-11.283,0.617-19.15,0.75c-2.434,0.034-4.883,0.067-7.35,0.1h-2.95C38.417,59.117,34.5,59.067,30.3,59c-8.433-0.167-14.05-0.383-16.85-0.65c-0.067-0.033-0.667-0.117-1.8-0.25c-0.9-0.133-1.683-0.283-2.35-0.45c-2.066-0.533-3.783-1.5-5.15-2.9c-1.033-1.067-1.9-2.783-2.6-5.15C1.317,48.867,1.133,48.117,1,47.35L0.8,46.4c-0.133-1.133-0.267-2.55-0.4-4.25C0.133,38.717,0,35.583,0,32.75V26.4c0-2.833,0.133-5.95,0.4-9.35l0.4-4.25c0.167-0.966,0.417-2.05,0.75-3.25c0.7-2.333,1.567-4.033,2.6-5.1c1.367-1.434,2.967-2.434,4.8-3c0.633-0.167,1.333-0.3,2.1-0.4c0.4-0.066,0.917-0.133,1.55-0.2c4.9-0.333,11.283-0.567,19.15-0.7C35.65,0.05,39.083,0,42.05,0L45,0.05c2.467,0,4.933,0.034,7.4,0.1c7.833,0.133,14.2,0.367,19.1,0.7c0.3,0.033,0.833,0.1,1.6,0.2c0.733,0.1,1.417,0.233,2.05,0.4c1.833,0.566,3.434,1.566,4.8,3c1.066,1.066,1.933,2.767,2.6,5.1c0.367,1.2,0.617,2.284,0.75,3.25l0.4,4.25C84,20.45,84.15,23.567,84.15,26.4z M33.3,41.4L56,29.6L33.3,17.75V41.4z"></path>');
    innerHtml.push('<polygon fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" points="33.3,41.4 33.3,17.75 56,29.6"></polygon>');
    innerHtml.push('</svg>');
    innerHtml.push('</div>'); // end of .ytp-large-play-button

    innerHtml.push('</div>'); // end of .ytp-thumbnail

    // Video title (info bar)
    innerHtml.push('<div class="html5-info-bar">');
    innerHtml.push('<div class="html5-title">');
    innerHtml.push('<div class="html5-title-text-wrapper">');
    innerHtml.push('<a class="html5-title-text" target="_blank" tabindex="3100" href="https://www.youtube.com/watch?v=', id, '">');
    if (title === undefined || title === null || title === '') {
      innerHtml.push('youtube.com/watch?v=' + id);
    } else {
      innerHtml.push(title);
    }
    innerHtml.push('</a>');
    innerHtml.push('</div>'); // .html5-title
    innerHtml.push('</div>'); // .html5-title-text-wrapper
    innerHtml.push('</div>'); // end of Video title .html5-info-bar

    $el.css({
      'padding-bottom': padding_bottom
    })
    .html(innerHtml.join(''));

    if (width > 640) {
      thumb_img = 'maxresdefault.jpg';
    } else if (width > 480) {
      thumb_img = 'sddefault.jpg';
    } else if (width > 320) {
      thumb_img = 'hqdefault.jpg';
    } else if (width > 120) {
      thumb_img = 'mqdefault.jpg';
    } else if (width === 0) { // sometimes it fails on fluid layout
      thumb_img = 'hqdefault.jpg';
    } else {
      thumb_img = 'default.jpg';
    }

    $thumb = $el.find('.ytp-thumbnail').css({
      'background-image': ['url(//img.youtube.com/vi/', id, '/', thumb_img, ')'].join('')
    })
    .addClass('lazyYT-image-loaded')
    .on('click', function (e) {
      e.preventDefault();
      if (!$el.hasClass('lazyYT-video-loaded') && $thumb.hasClass('lazyYT-image-loaded')) {
        $el.html('<iframe src="//www.youtube.com/embed/' + id + '?autoplay=1&' + youtube_parameters + '" frameborder="0" allowfullscreen></iframe>')
        .addClass('lazyYT-video-loaded');
      }
    });

  }

  $.fn.lazyYT = function (newSettings) {
    var defaultSettings = {
      default_ratio: '16:9',
      callback: null, // ToDO execute callback if given
      container_class: 'lazyYT-container'
    };
    var settings = $.extend(defaultSettings, newSettings);

    return this.each(function () {
      var $el = $(this).addClass(settings.container_class);
      setUp($el, settings);
    });
  };

}(jQuery));
/*global md5 */


(function() {

  var DATA_PREFIX = "data-poll-";
  var DEFAULT_POLL_NAME = "poll";

  var WHITELISTED_ATTRIBUTES = ["type", "name", "min", "max", "step", "order", "status"];

  var ATTRIBUTES_REGEX = new RegExp("(" + WHITELISTED_ATTRIBUTES.join("|") + ")=['\"]?[^\\s\\]]+['\"]?", "g");

  Discourse.Dialect.replaceBlock({
    start: /\[poll((?:\s+\w+=[^\s\]]+)*)\]([\s\S]*)/igm,
    stop: /\[\/poll\]/igm,

    emitter: function(blockContents, matches) {
      var o, contents = [];

      // post-process inside block contents
      if (blockContents.length) {
        var self = this, b;

        var postProcess = function(bc) {
          if (typeof bc === "string" || bc instanceof String) {
            var processed = self.processInline(String(bc));
            if (processed.length) {
              contents.push(["p"].concat(processed));
            }
          } else {
            contents.push(bc);
          }
        };

        while ((b = blockContents.shift()) !== undefined) {
          this.processBlock(b, blockContents).forEach(postProcess);
        }
      }

      // Disable dialect when poll plugin is disabled
      if (!Discourse.SiteSettings.poll_enabled) { return ["div"].concat(contents); }

      // default poll attributes
      var attributes = { "class": "poll" };
      attributes[DATA_PREFIX + "status"] = "open";
      attributes[DATA_PREFIX + "name"] = DEFAULT_POLL_NAME;

      // extract poll attributes
      (matches[1].match(ATTRIBUTES_REGEX) || []).forEach(function(m) {
        var attr = m.split("="), name = attr[0], value = attr[1];
        value = Handlebars.Utils.escapeExpression(value.replace(/["']/g, ""));
        attributes[DATA_PREFIX + name] = value;
      });

      // we might need these values later...
      var min = parseInt(attributes[DATA_PREFIX + "min"], 10),
          max = parseInt(attributes[DATA_PREFIX + "max"], 10),
          step = parseInt(attributes[DATA_PREFIX + "step"], 10);

      // generate the options when the type is "number"
      if (attributes[DATA_PREFIX + "type"] === "number") {
        // default values
        if (isNaN(min)) { min = 1; }
        if (isNaN(max)) { max = Discourse.SiteSettings.poll_maximum_options; }
        if (isNaN(step)) { step = 1; }
        // dynamically generate options
        contents.push(["bulletlist"]);
        for (o = min; o <= max; o += step) {
          contents[0].push(["listitem", String(o)]);
        }
      }

      // make sure there's only 1 child and it's a list with at least 1 option
      if (contents.length !== 1 || contents[0].length <= 1 || (contents[0][0] !== "numberlist" && contents[0][0] !== "bulletlist")) {
        return ["div"].concat(contents);
      }

      // make sure there's only options in the list
      for (o = 1; o < contents[0].length; o++) {
        if (contents[0][o][0] !== "listitem") {
          return ["div"].concat(contents);
        }
      }

      // TODO: remove non whitelisted content

      // add option id (hash)
      for (o = 1; o < contents[0].length; o++) {
        var attr = {};
        // compute md5 hash of the content of the option
        attr[DATA_PREFIX + "option-id"] = md5(JSON.stringify(contents[0][o].slice(1)));
        // store options attributes
        contents[0][o].splice(1, 0, attr);
      }

      var result = ["div", attributes],
          poll = ["div"];

      // 1 - POLL CONTAINER
      var container = ["div", { "class": "poll-container" }].concat(contents);
      poll.push(container);

      // 2 - POLL INFO
      var info = ["div", { "class": "poll-info" }];

      // # of voters
      info.push(["p",
                  ["span", { "class": "info-number" }, "0"],
                  ["span", { "class": "info-text"}, I18n.t("poll.voters", { count: 0 })]
                ]);

      // multiple help text
      if (attributes[DATA_PREFIX + "type"] === "multiple") {
        var optionCount = contents[0].length - 1;

        // default values
        if (isNaN(min) || min < 1) { min = 1; }
        if (isNaN(max) || max > optionCount) { max = optionCount; }

        // add some help text
        var help;

        if (max > 0) {
          if (min === max) {
            if (min > 1) {
              help = I18n.t("poll.multiple.help.x_options", { count: min });
            }
          } else if (min > 1) {
            if (max < optionCount) {
              help = I18n.t("poll.multiple.help.between_min_and_max_options", { min: min, max: max });
            } else {
              help = I18n.t("poll.multiple.help.at_least_min_options", { count: min });
            }
          } else if (max <= optionCount) {
            help = I18n.t("poll.multiple.help.up_to_max_options", { count: max });
          }
        }

        if (help) { info.push(["p", help]); }
      }

      poll.push(info);

      // 3 - BUTTONS
      var buttons = ["div", { "class": "poll-buttons" }];

      // add "cast-votes" button
      if (attributes[DATA_PREFIX + "type"] === "multiple") {
        buttons.push(["a", { "class": "button cast-votes", "title": I18n.t("poll.cast-votes.title") }, I18n.t("poll.cast-votes.label")]);
      }

      // add "toggle-results" button
      buttons.push(["a", { "class": "button toggle-results", "title": I18n.t("poll.show-results.title") }, I18n.t("poll.show-results.label")]);

      // 4 - MIX IT ALL UP
      result.push(poll);
      result.push(buttons);

      return result;
    }
  });

  Discourse.Markdown.whiteListTag("div", "class", "poll");
  Discourse.Markdown.whiteListTag("div", "class", /^poll-(info|container|buttons)/);
  Discourse.Markdown.whiteListTag("div", "data-*");

  Discourse.Markdown.whiteListTag("span", "class", /^info-(number|text)/);

  Discourse.Markdown.whiteListTag("a", "class", /^button (cast-votes|toggle-results)/);

  Discourse.Markdown.whiteListTag("li", "data-*");
})();
Ember.TEMPLATES["javascripts/upgrade-header"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("tr");
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("th");
        dom.setAttribute(el2,"colspan","5");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"href","/admin/upgrade");
        dom.setAttribute(el3,"data-auto-route","true");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [0, 1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [2]),0,0);
        inline(env, morph0, context, "i18n", ["docker.upgrade"], {});
        inline(env, morph1, context, "i18n", ["docker.perform_upgrade"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "versionCheck.upToDate")], {}, child0, null);
      return fragment;
    }
  };
}()));
define("discourse/plugins/discourse-details/initializers/apply-details", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var decorateCooked = __dependency1__.decorateCooked;

    __exports__["default"] = {
      name: "apply-details",

      initialize: function (container) {
        decorateCooked(container, function ($elem) {
          return $("details", $elem).details();
        });
      }

    };
  });define("discourse/plugins/static-pages/admin/models/page", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      findAll: function () {
        return Discourse.ajax('/pages/admin/pages');
      },

      findById: function (id) {
        return Discourse.ajax('/pages/admin/pages/' + id);
      },

      create: function (model) {
        return Discourse.ajax('/pages/admin/pages', {
          method: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({ page: model })
        });
      },

      update: function (model) {
        return Discourse.ajax('/pages/admin/pages/' + model.id, {
          method: 'PATCH',
          contentType: 'application/json',
          data: JSON.stringify({ page: model })
        });
      },

      delete: function (model) {
        return Discourse.ajax('/pages/admin/pages/' + model.id, {
          method: 'DELETE'
        });
      }
    };
  });define("discourse/plugins/static-pages/discourse/models/page", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      findAll: function () {
        return Discourse.ajax('/pages');
      },

      findById: function (id) {
        return Discourse.ajax('/pages/' + id);
      }
    };
  });define("discourse/plugins/static-pages/discourse/admin-pages-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      resource: 'admin.adminPlugins',
      path: '/plugins',
      map: function () {
        this.route('pages', function () {
          this.route('new');
          this.route('edit', { path: ':id/edit' });
        });
      }
    };
  });define("discourse/plugins/static-pages/discourse/routes/admin-plugins-pages-edit", 
  ["../../admin/models/page","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Page = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      actions: {
        update: function () {
          var _this = this;

          var _controller$model = this.controller.model;
          var id = _controller$model.id;
          var title = _controller$model.title;
          var body = _controller$model.body;

          Page.update({ id: id, title: title, body: body }).then(function () {
            _this.transitionTo('adminPlugins.pages.index');
          }).catch(function () {
            alert('Error updating page.');
          });
        },

        cancel: function () {
          this.transitionTo('adminPlugins.pages.index');
        }
      },

      model: function (params) {
        return Page.findById(params.id).then(function (result) {
          return result.page;
        });
      }
    });
  });define("discourse/plugins/static-pages/discourse/routes/pages-show", 
  ["../models/page","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Page = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function (params) {
        return Page.findById(params.id).then(function (result) {
          return result.page;
        });
      },

      setupController: function (controller, model) {
        model.body = new Handlebars.SafeString(Discourse.Markdown.cook(model.body));
        controller.setProperties({ model: model });
      }
    });
  });define("discourse/plugins/static-pages/discourse/routes/admin-plugins-pages-new", 
  ["../../admin/models/page","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Page = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      actions: {
        create: function () {
          var _this = this;

          var _controller$model = this.controller.model;
          var title = _controller$model.title;
          var body = _controller$model.body;

          Page.create({ title: title, body: body }).then(function () {
            _this.transitionTo('adminPlugins.pages.index');
          }).catch(function () {
            alert('Error creating page.');
          });
        },

        cancel: function () {
          this.transitionTo('adminPlugins.pages.index');
        }
      },

      model: function () {
        return {};
      }
    });
  });define("discourse/plugins/static-pages/discourse/routes/admin-plugins-pages-index", 
  ["../../admin/models/page","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Page = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return Page.findAll().then(function (result) {
          return result.pages;
        });
      },

      setupController: function (controller, model) {
        controller.setProperties({ model: model });
      }
    });
  });define("discourse/plugins/static-pages/discourse/pages-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      resource: 'pages',
      path: '/pages',
      map: function () {
        this.route('show', { path: ':id' });
      }
    };
  });define("discourse/plugins/static-pages/discourse/controllers/admin-plugins-pages-index", 
  ["../../admin/models/page","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Page = __dependency1__["default"];

    __exports__["default"] = Ember.ArrayController.extend({
      sortProperties: ['updated_at'],
      sortAscending: false,

      actions: {
        refresh: function () {
          var _this = this;

          Page.findAll().then(function (result) {
            _this.set('model', result.pages);
          });
        },

        delete: function (model) {
          if (confirm('Are you sure?')) {
            this.set('model', this.get('model').filter(function (page) {
              return page !== model;
            }));
            Page.delete(model);
          }
        }
      }
    });
  });define("discourse/plugins/static-pages/discourse/initializers/static-pages-menu", 
  ["discourse/components/hamburger-menu","../../discourse/models/page","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var HamburgerMenuComponent = __dependency1__["default"];
    var Page = __dependency2__["default"];

    __exports__["default"] = {
      name: 'static-pages-menu',

      initialize: function () {
        HamburgerMenuComponent.reopen({
          didInsertElement: function () {
            var _this = this;

            Page.findAll().then(function (result) {
              _this.set('staticPages', result.pages);
            });

            this.set('staticPages', [{ title: 'Testing', id: 123 }]);
          }
        });
      }
    };
  });Ember.TEMPLATES["javascripts/admin/plugins-pages-edit"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("hr");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","btn-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","submit");
      dom.setAttribute(el3,"class","btn btn-large btn-primary");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("button");
      dom.setAttribute(el3,"class","btn btn-large btn-danger");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [3]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var attrMorph0 = dom.createAttrMorph(element2, 'value');
      var morph1 = dom.createMorphAt(element3,1,1);
      element(env, element0, context, "action", ["update"], {"on": "submit"});
      inline(env, morph0, context, "partial", ["admin/plugins-pages-form"], {});
      attribute(env, attrMorph0, element2, "value", concat(env, [subexpr(env, context, "i18n", ["static_pages.update"], {})]));
      element(env, element3, context, "action", ["cancel", get(env, context, "this")], {});
      inline(env, morph1, context, "i18n", ["static_pages.cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-pages-index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["static_pages.view"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["static_pages.edit"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("tr");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("button");
        dom.setAttribute(el3,"class","btn");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [7]);
        var element2 = dom.childAt(element1, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
        var morph3 = dom.createMorphAt(element1,1,1);
        var morph4 = dom.createMorphAt(element1,3,3);
        var morph5 = dom.createMorphAt(element2,0,0);
        content(env, morph0, context, "page.title");
        content(env, morph1, context, "page.created_at");
        content(env, morph2, context, "page.updated_at");
        block(env, morph3, context, "link-to", ["pages.show", get(env, context, "page.id")], {"class": "btn"}, child0, null);
        block(env, morph4, context, "link-to", ["adminPlugins.pages.edit", get(env, context, "page.id")], {"class": "btn btn-primary"}, child1, null);
        element(env, element2, context, "action", ["delete", get(env, context, "page")], {});
        inline(env, morph5, context, "i18n", ["static_pages.delete"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["static_pages.new"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("table");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("thead");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("tr");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("th");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("th");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("th");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("th");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("tbody");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0, 1]);
      var element4 = dom.childAt(element3, [1, 1]);
      var element5 = dom.childAt(fragment, [2]);
      var element6 = dom.childAt(element5, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element4, [5]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element4, [7]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
      var morph5 = dom.createMorphAt(element5,1,1);
      var morph6 = dom.createMorphAt(element6,0,0);
      inline(env, morph0, context, "i18n", ["static_pages.page"], {});
      inline(env, morph1, context, "i18n", ["static_pages.created"], {});
      inline(env, morph2, context, "i18n", ["static_pages.updated"], {});
      inline(env, morph3, context, "i18n", ["static_pages.actions"], {});
      block(env, morph4, context, "each", [get(env, context, "model")], {"keyword": "page"}, child0, null);
      block(env, morph5, context, "link-to", ["adminPlugins.pages.new"], {"class": "btn btn-primary"}, child1, null);
      element(env, element6, context, "action", ["refresh"], {});
      inline(env, morph6, context, "i18n", ["static_pages.refresh"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-pages"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-pages-new"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("hr");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","btn-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","submit");
      dom.setAttribute(el3,"class","btn btn-large btn-primary");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("button");
      dom.setAttribute(el3,"class","btn btn-large btn-danger");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [3]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var attrMorph0 = dom.createAttrMorph(element2, 'value');
      var morph1 = dom.createMorphAt(element3,1,1);
      element(env, element0, context, "action", ["create"], {"on": "submit"});
      inline(env, morph0, context, "partial", ["admin/plugins-pages-form"], {});
      attribute(env, attrMorph0, element2, "value", concat(env, [subexpr(env, context, "i18n", ["static_pages.create"], {})]));
      element(env, element3, context, "action", ["cancel", get(env, context, "this")], {});
      inline(env, morph1, context, "i18n", ["static_pages.cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-pages-form"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","form-group");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      dom.setAttribute(el2,"class","control-label col-lg-2");
      dom.setAttribute(el2,"for","title");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","col-lg-10");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","form-group");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      dom.setAttribute(el2,"class","control-label col-lg-2");
      dom.setAttribute(el2,"for","body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","col-lg-10");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"type","hidden");
      dom.setAttribute(el1,"name","id");
      dom.setAttribute(el1,"id","id");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(fragment, [2]);
      var element2 = dom.childAt(fragment, [4]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      inline(env, morph0, context, "i18n", ["static_pages.title"], {});
      inline(env, morph1, context, "input", [], {"type": "text", "name": "title", "value": get(env, context, "model.title"), "required": "true"});
      inline(env, morph2, context, "i18n", ["static_pages.body"], {});
      inline(env, morph3, context, "d-editor", [], {"name": "body", "value": get(env, context, "model.body"), "required": "true"});
      element(env, element2, context, "bind-attr", [], {"value": get(env, context, "model.id")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/pages/show"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","static-page");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h1");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      content(env, morph0, context, "model.title");
      content(env, morph1, context, "model.body");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/connectors/site-map-links/static-pages"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          content(env, morph0, context, "page.title");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        set(env, context, "page", blockArguments[0]);
        block(env, morph0, context, "link-to", ["pages.show", get(env, context, "page.id")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "staticPages")], {}, child0, null);
      return fragment;
    }
  };
}()));
define("discourse/plugins/lazyYT/initializers/lazyYT", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /**
      Apply lazyYT when the app boots
    **/

    var decorateCooked = __dependency1__.decorateCooked;

    __exports__["default"] = {
      name: "apply-lazyYT",
      initialize: function (container) {
        decorateCooked(container, function ($elem) {
          $('.lazyYT', $elem).lazyYT();
        });
      }
    };
  });define("discourse/plugins/poll/views/poll", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Em.View.extend(_createDecoratedObject([{
      key: "templateName",
      initializer: function () {
        return "poll";
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ["poll"];
      }
    }, {
      key: "attributeBindings",
      initializer: function () {
        return ["data-poll-type", "data-poll-name", "data-poll-status"];
      }
    }, {
      key: "poll",
      initializer: function () {
        return Em.computed.alias("controller.poll");
      }
    }, {
      key: "data-poll-type",
      initializer: function () {
        return Em.computed.alias("poll.type");
      }
    }, {
      key: "data-poll-name",
      initializer: function () {
        return Em.computed.alias("poll.name");
      }
    }, {
      key: "data-poll-status",
      initializer: function () {
        return Em.computed.alias("poll.status");
      }
    }, {
      key: "_fixPollContainerHeight",
      decorators: [on("didInsertElement")],
      value: function () {
        var pollContainer = this.$(".poll-container");
        pollContainer.height(pollContainer.height());
      }
    }]));
  });define("discourse/plugins/poll/lib/even-round", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // stolen from http://stackoverflow.com/a/13484088/11983
    function sumsUpTo100(percentages) {
      return percentages.map(function (p) {
        return Math.floor(p);
      }).reduce(function (a, b) {
        return a + b;
      }) === 100;
    }

    __exports__["default"] = function (percentages) {
      var sumOfDecimals = Math.ceil(percentages.map(function (a) {
        return a % 1;
      }).reduce(function (a, b) {
        return a + b;
      }));
      // compensate error by adding 1 to the first n items
      for (var i = 0; i < sumOfDecimals; i++) {
        percentages[i] = ++percentages[i];
        // quit early when there is a rounding issue
        if (sumsUpTo100(percentages)) break;
      }
      return percentages.map(function (p) {
        return Math.floor(p);
      });
    }
  });define("discourse/plugins/poll/controllers/poll", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: "isMultiple",
      initializer: function () {
        return Ember.computed.equal("poll.type", "multiple");
      }
    }, {
      key: "isNumber",
      initializer: function () {
        return Ember.computed.equal("poll.type", "number");
      }
    }, {
      key: "isRandom",
      initializer: function () {
        return Ember.computed.equal("poll.order", "random");
      }
    }, {
      key: "isClosed",
      initializer: function () {
        return Ember.computed.equal("poll.status", "closed");
      }
    }, {
      key: "showingResults",

      // shows the results when
      //   - poll is closed
      //   - topic is archived/closed
      //   - user wants to see the results
      initializer: function () {
        return Em.computed.or("isClosed", "post.topic.closed", "post.topic.archived", "showResults");
      }
    }, {
      key: "showResultsDisabled",
      initializer: function () {
        return Em.computed.equal("poll.voters", 0);
      }
    }, {
      key: "hideResultsDisabled",
      initializer: function () {
        return Em.computed.or("isClosed", "post.topic.closed", "post.topic.archived");
      }
    }, {
      key: "poll",
      decorators: [computed("model", "vote")],
      value: function (poll, vote) {
        if (poll) {
          var options = _.map(poll.get("options"), function (o) {
            return Em.Object.create(o);
          });

          if (vote) {
            options.forEach(function (o) {
              return o.set("selected", vote.indexOf(o.get("id")) >= 0);
            });
          }

          poll.set("options", options);
        }

        return poll;
      }
    }, {
      key: "selectedOptions",
      decorators: [computed("poll.options.@each.selected")],
      value: function () {
        return _.map(this.get("poll.options").filterBy("selected"), function (o) {
          return o.get("id");
        });
      }
    }, {
      key: "min",
      decorators: [computed("poll.min")],
      value: function (min) {
        min = parseInt(min, 10);
        if (isNaN(min) || min < 1) {
          min = 1;
        }
        return min;
      }
    }, {
      key: "max",
      decorators: [computed("poll.max", "poll.options.length")],
      value: function (max, options) {
        max = parseInt(max, 10);
        if (isNaN(max) || max > options) {
          max = options;
        }
        return max;
      }
    }, {
      key: "votersText",
      decorators: [computed("poll.voters")],
      value: function (count) {
        return I18n.t("poll.voters", { count: count });
      }
    }, {
      key: "totalVotes",
      decorators: [computed("poll.options.@each.votes")],
      value: function () {
        return _.reduce(this.get("poll.options"), function (total, o) {
          return total + parseInt(o.get("votes"), 10);
        }, 0);
      }
    }, {
      key: "totalVotesText",
      decorators: [computed("totalVotes")],
      value: function (count) {
        return I18n.t("poll.total_votes", { count: count });
      }
    }, {
      key: "multipleHelpText",
      decorators: [computed("min", "max", "poll.options.length")],
      value: function (min, max, options) {
        if (max > 0) {
          if (min === max) {
            if (min > 1) {
              return I18n.t("poll.multiple.help.x_options", { count: min });
            }
          } else if (min > 1) {
            if (max < options) {
              return I18n.t("poll.multiple.help.between_min_and_max_options", { min: min, max: max });
            } else {
              return I18n.t("poll.multiple.help.at_least_min_options", { count: min });
            }
          } else if (max <= options) {
            return I18n.t("poll.multiple.help.up_to_max_options", { count: max });
          }
        }
      }
    }, {
      key: "canCastVotes",
      decorators: [computed("isClosed", "showResults", "loading", "isMultiple", "selectedOptions.length", "min", "max")],
      value: function (isClosed, showResults, loading, isMultiple, selectedOptionCount, min, max) {
        if (isClosed || showResults || loading) {
          return false;
        }

        if (isMultiple) {
          return selectedOptionCount >= min && selectedOptionCount <= max;
        } else {
          return selectedOptionCount > 0;
        }
      }
    }, {
      key: "castVotesDisabled",
      initializer: function () {
        return Em.computed.not("canCastVotes");
      }
    }, {
      key: "canToggleStatus",
      decorators: [computed("loading", "post.user_id", "post.topic.closed", "post.topic.archived")],
      value: function (loading, userId, topicClosed, topicArchived) {
        return this.currentUser && (this.currentUser.get("id") === userId || this.currentUser.get("staff")) && !loading && !topicClosed && !topicArchived;
      }
    }, {
      key: "actions",
      initializer: function () {
        return {

          toggleOption: function (option) {
            if (this.get("isClosed")) {
              return;
            }
            if (!this.currentUser) {
              return this.send("showLogin");
            }

            var wasSelected = option.get("selected");

            if (!this.get("isMultiple")) {
              this.get("poll.options").forEach(function (o) {
                return o.set("selected", false);
              });
            }

            option.toggleProperty("selected");

            if (!this.get("isMultiple") && !wasSelected) {
              this.send("castVotes");
            }
          },

          castVotes: function () {
            var _this = this;

            if (!this.get("canCastVotes")) {
              return;
            }
            if (!this.currentUser) {
              return this.send("showLogin");
            }

            this.set("loading", true);

            Discourse.ajax("/polls/vote", {
              type: "PUT",
              data: {
                post_id: this.get("post.id"),
                poll_name: this.get("poll.name"),
                options: this.get("selectedOptions")
              }
            }).then(function (results) {
              _this.setProperties({ vote: results.vote, showResults: true });
              _this.set("model", Em.Object.create(results.poll));
            }).catch(function () {
              bootbox.alert(I18n.t("poll.error_while_casting_votes"));
            }).finally(function () {
              _this.set("loading", false);
            });
          },

          toggleResults: function () {
            this.toggleProperty("showResults");
          },

          toggleStatus: function () {
            if (!this.get("canToggleStatus")) {
              return;
            }

            var self = this,
                confirm = this.get("isClosed") ? "poll.open.confirm" : "poll.close.confirm";

            bootbox.confirm(I18n.t(confirm), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
              if (confirmed) {
                self.set("loading", true);

                Discourse.ajax("/polls/toggle_status", {
                  type: "PUT",
                  data: {
                    post_id: self.get("post.id"),
                    poll_name: self.get("poll.name"),
                    status: self.get("isClosed") ? "open" : "closed"
                  }
                }).then(function (results) {
                  self.set("model", Em.Object.create(results.poll));
                }).catch(function () {
                  bootbox.alert(I18n.t("poll.error_while_toggling_status"));
                }).finally(function () {
                  self.set("loading", false);
                });
              }
            });
          }
        };
      }
    }]));
  });define("discourse/plugins/poll/initializers/extend-for-poll", 
  ["discourse/views/post","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var PostView = __dependency1__["default"];
    var on = __dependency2__.on;

    function createPollView(container, post, poll, vote) {
      var controller = container.lookup("controller:poll", { singleton: false }),
          view = container.lookup("view:poll");

      controller.set("vote", vote);
      controller.setProperties({ model: Em.Object.create(poll), post: post });
      view.set("controller", controller);

      return view;
    }

    __exports__["default"] = {
      name: "extend-for-poll",

      initialize: function (container) {

        var messageBus = container.lookup("message-bus:main");

        // listen for back-end to tell us when a post has a poll
        messageBus.subscribe("/polls", function (data) {
          var post = container.lookup("controller:topic").get('model.postStream').findLoadedPost(data.post_id);
          // HACK to trigger the "postViewUpdated" event
          Em.run.next(function () {
            return post.set("cooked", post.get("cooked") + " ");
          });
        });

        // overwrite polls
        PostView.reopen(_createDecoratedObject([{
          key: "_createPollViews",
          decorators: [on("postViewInserted", "postViewUpdated")],
          value: function ($post) {
            var post = this.get("post"),
                polls = post.get("polls"),
                votes = post.get("polls_votes") || {};

            // don't even bother when there's no poll
            if (!polls) {
              return;
            }

            // clean-up if needed
            this._cleanUpPollViews();

            var pollViews = {};

            // iterate over all polls
            $(".poll", $post).each(function () {
              var $div = $("<div>"),
                  $poll = $(this),
                  pollName = $poll.data("poll-name"),
                  pollView = createPollView(container, post, polls[pollName], votes[pollName]);

              $poll.replaceWith($div);
              Em.run.next(function () {
                return pollView.renderer.replaceIn(pollView, $div[0]);
              });
              pollViews[pollName] = pollView;
            });

            messageBus.subscribe("/polls/" + this.get("post.id"), function (results) {
              if (results && results.polls) {
                _.forEach(results.polls, function (poll) {
                  if (pollViews[poll.name]) {
                    pollViews[poll.name].get("controller").set("model", Em.Object.create(poll));
                  }
                });
              }
            });

            this.set("pollViews", pollViews);
          }
        }, {
          key: "_cleanUpPollViews",
          decorators: [on("willClearRender")],
          value: function () {
            messageBus.unsubscribe("/polls/" + this.get("post.id"));

            if (this.get("pollViews")) {
              _.forEach(this.get("pollViews"), function (v) {
                return v.destroy();
              });
            }
          }
        }]));
      }
    };
  });define("discourse/plugins/poll/components/poll-results-number", 
  ["discourse/lib/round","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var round = __dependency1__["default"];

    __exports__["default"] = Em.Component.extend({
      tagName: "span",

      totalScore: (function () {
        return _.reduce(this.get("poll.options"), function (total, o) {
          var value = parseInt(o.get("html"), 10),
              votes = parseInt(o.get("votes"), 10);
          return total + value * votes;
        }, 0);
      }).property("poll.options.@each.{html,votes}"),

      average: (function () {
        var voters = this.get("poll.voters");
        return voters === 0 ? 0 : round(this.get("totalScore") / voters, -2);
      }).property("totalScore", "poll.voters"),

      averageRating: (function () {
        return I18n.t("poll.average_rating", { average: this.get("average") });
      }).property("average")

    });
  });define("discourse/plugins/poll/components/poll-option", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Component.extend({
      tagName: "li",
      attributeBindings: ["data-poll-option-id", "data-poll-selected"],

      "data-poll-option-id": Em.computed.alias("option.id"),

      "data-poll-selected": (function () {
        return this.get("option.selected") ? "selected" : false;
      }).property("option.selected"),

      render: function (buffer) {
        buffer.push(this.get("option.html"));
      },

      click: function (e) {
        // ensure we're not clicking on a link
        if ($(e.target).closest("a").length === 0) {
          this.sendAction("toggle", this.get("option"));
        }
      }
    });
  });define("discourse/plugins/poll/components/poll-results-standard", 
  ["discourse/plugins/poll/lib/even-round","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var evenRound = __dependency1__["default"];
    var computed = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(_createDecoratedObject([{
      key: "tagName",
      initializer: function () {
        return "ul";
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ["results"];
      }
    }, {
      key: "options",
      decorators: [computed("poll.voters", "poll.type", "poll.options.[]")],
      value: function (voters, type) {
        var options = this.get("poll.options");

        var percentages = voters === 0 ? Array(options.length).fill(0) : _.map(options, function (o) {
          return 100 * o.get("votes") / voters;
        });

        // properly round percentages
        if (type === "multiple") {
          // when the poll is multiple choices, just "round down"
          percentages = percentages.map(function (p) {
            return Math.floor(p);
          });
        } else {
          // when the poll is single choice, adds up to 100%
          percentages = evenRound(percentages);
        }

        options.forEach(function (option, i) {
          var percentage = percentages[i];
          var style = new Ember.Handlebars.SafeString("width: " + percentage + "%");

          option.setProperties({
            percentage: percentage,
            style: style,
            title: I18n.t("poll.option_title", { count: option.get("votes") })
          });
        });

        return options;
      }
    }]));
  });Ember.TEMPLATES["javascripts/components/poll-results-standard"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","option");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","percentage");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("%");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","bar-back");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","bar");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1, 1]);
        var element2 = dom.childAt(element0, [3, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createUnsafeMorphAt(element1,3,3);
        var attrMorph0 = dom.createAttrMorph(element2, 'style');
        content(env, morph0, context, "option.percentage");
        content(env, morph1, context, "option.html");
        attribute(env, attrMorph0, element2, "style", get(env, context, "option.style"));
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "options")], {"keyword": "option"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/poll-results-number"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createUnsafeMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "averageRating");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/poll"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "poll-results-number", [], {"poll": get(env, context, "poll")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "poll-results-standard", [], {"poll": get(env, context, "poll")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isNumber")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "poll-option", [], {"option": get(env, context, "option"), "toggle": "toggleOption"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "poll.options")], {"keyword": "option"}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","info-number");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","info-text");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
          content(env, morph0, context, "totalVotes");
          content(env, morph1, context, "totalVotesText");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "multipleHelpText");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showingResults")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "cast-votes", "title": "poll.cast-votes.title", "label": "poll.cast-votes.label", "disabled": get(env, context, "castVotesDisabled"), "action": "castVotes"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "hideResultsDisabled")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "toggle-results", "title": "poll.hide-results.title", "label": "poll.hide-results.label", "icon": "eye-slash", "disabled": get(env, context, "hideResultsDisabled"), "action": "toggleResults"});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "toggle-results", "title": "poll.show-results.title", "label": "poll.show-results.label", "icon": "eye", "disabled": get(env, context, "showResultsDisabled"), "action": "toggleResults"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "toggle-status", "title": "poll.open.title", "label": "poll.open.label", "icon": "unlock-alt", "action": "toggleStatus"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.1",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "toggle-status btn-danger", "title": "poll.close.title", "label": "poll.close.label", "icon": "lock", "action": "toggleStatus"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.1",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isClosed")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.1",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","poll-container");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","poll-info");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("p");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","info-number");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","info-text");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","poll-buttons");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
      var morph3 = dom.createMorphAt(element2,3,3);
      var morph4 = dom.createMorphAt(element4,1,1);
      var morph5 = dom.createMorphAt(element4,3,3);
      var morph6 = dom.createMorphAt(element4,5,5);
      block(env, morph0, context, "if", [get(env, context, "showingResults")], {}, child0, child1);
      content(env, morph1, context, "poll.voters");
      content(env, morph2, context, "votersText");
      block(env, morph3, context, "if", [get(env, context, "isMultiple")], {}, child2, null);
      block(env, morph4, context, "if", [get(env, context, "isMultiple")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "showingResults")], {}, child4, child5);
      block(env, morph6, context, "if", [get(env, context, "canToggleStatus")], {}, child6, null);
      return fragment;
    }
  };
}()));

